<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>GuardianConnector map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link rel="stylesheet" href="dist/lightbox.min.css" />
  <style>
    body {
      margin: 0;
      padding: 0;
    }

    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
    }

    .mapboxgl-popup-content {
      word-wrap: break-word;
    }

    .popup-media {
      width: 100%;
      display: block;
      margin-top: 5px;
    }
  </style>
</head>

<body>
  <div id="map"></div>
  <script src="dist/lightbox-plus-jquery.js"></script>
  <script type="text/javascript">
    mapboxgl.accessToken = "<%= mapboxAccessToken %>";
    const map = new mapboxgl.Map({
      container: "map",
      style: "<%= mapboxStyle %>",
      projection: "<%= mapboxProjection %>",
      center: ["<%= mapboxCenterLatitude %>", "<%= mapboxCenterLongitude %>"],
      zoom: "<%= mapboxZoom %>",
      bearing: "<%= mapboxBearing %>",
      pitch: "<%= mapboxPitch %>",
    });

    // Process different geometry types and extract coordinates
    const processGeolocation = (obj) => {
      if (
        obj &&
        obj.g__type &&
        obj.g__coordinates &&
        typeof obj.g__coordinates === "string"
      ) {
        try {
          const geometryType = obj.g__type;
          const coordinates = JSON.parse(obj.g__coordinates);

          if (
            geometryType === "Point" &&
            Array.isArray(coordinates) &&
            coordinates.length === 2
          ) {
            const [longitude, latitude] = coordinates;
            obj.latitude = latitude;
            obj.longitude = longitude;
          } else if (geometryType === "LineString") {
            obj.coordinates = coordinates;
          } else if (geometryType === "Polygon") {
            obj.coordinates = [coordinates];
          }
        } catch (error) {
          console.error("Error parsing coordinates:", error);
        }
      }
      return obj;
    };

    // Calculate the centroid of the polygon's coordinates
    const calculatePolygonCentroid = (coordinates) => {
      const numPoints = coordinates.length;
      let x = 0.0;
      let y = 0.0;

      for (const [lng, lat] of coordinates) {
        x += lng;
        y += lat;
      }

      return [x / numPoints, y / numPoints];
    };

    const addDataToMap = async () => {

      // Parse strings from EJS template into objects
      const dataString = `<%- JSON.stringify(data) %>`;
      const filteredSqlColumnsString = `<%- JSON.stringify(filteredSqlColumns) %>`;


      data = JSON.parse(dataString.replace(/^"|"$/g, ''));
      filteredSqlColumnsObj = JSON.parse(filteredSqlColumnsString.replace(/^"|"$/g, ''));
      const filteredSqlColumns = new Set(filteredSqlColumnsObj);

      console.log(data)
      console.log(filteredSqlColumns)

      // Ensure we are only rendering data with expected geo fields
      filteredData = data.filter(
        (feature) =>
          feature.hasOwnProperty("g__coordinates") &&
          feature.hasOwnProperty("g__type")
      );
      
      filteredData.forEach((feature) => {
        feature = processGeolocation(feature);

        const popupHTML = Object.keys(feature)
          // Filter only the keys that exist in our filtered columns set
          .filter(
            (key) =>
              feature[key] !== null &&
              feature[key] !== "" &&
              filteredSqlColumns.has(key)
          )
          .map((key) => {
            // Rewrite the keys to be more legible
            let transformedKey = key.replace(/^p__/, "").replace(/_/g, " ");
            transformedKey = transformedKey.replace(/\b\w/g, (c) =>
              c.toUpperCase()
            ); // Capitalize first letter of each word
            if (transformedKey === "Today") {
              transformedKey = "Data Collected On";
            } else if (transformedKey === "Categoryid") {
              transformedKey = "Category";
            }

            // Rewrite the values to be more legible
            let transformedValue = feature[key];
            if (typeof transformedValue === "string") {
              transformedValue = transformedValue
                .replace(/_/g, " ")
                .replace(/;/g, ", ");

              if (key.includes("Category")) {
                transformedValue = transformedValue.replace(/-/g, " ");
              }

              transformedValue =
                transformedValue.charAt(0).toUpperCase() +
                transformedValue.slice(1);
            }

            // Handle lists enclosed in square brackets
            if (transformedValue.match(/^\[.*\]$/)) {
              transformedValue = transformedValue
                .replace(/^\[|\]$/g, "")
                .split(", ")
                .map((item) => item.replace(/'/g, ""))
                .join(", ");
            }

            if ("<%= embedMedia %>" === "YES") {
              // Store uuid key to use for media attachment paths if it exists
              let uuid;
              for (let key in feature) {
                if (key.includes("uuid") && !key.includes("formhub")) {
                  uuid = feature[key];
                  break;
                }
              }

              const imageExtensions = ['jpg', 'jpeg', 'png', 'webp'];
              const audioExtensions = ['mp3', 'ogg', 'wav', 'm4a'];
              const videoExtensions = ['mov', 'mp4', 'avi', 'mkv'];
              const allExtensions = [...imageExtensions, ...audioExtensions, ...videoExtensions];

              // Render media content in accordance to the kind of file extension that it has
              const processFile = (file) => {
                file = file.replace(/ /g, '_');

                // If uuid exists, prepend it to the filepath. This is necessary for KoboToolbox attachments
                let filepath;
                if (uuid !== undefined) {
                  filepath = `${uuid}/${file}`
                } else {
                  filepath = `${file}`
                }

                const extensionMatch = file.match(new RegExp(`\\.(${allExtensions.join('|')})`, 'i'));
                if (!extensionMatch) return null;

                const extension = extensionMatch[1].toLowerCase();

                if (imageExtensions.includes(extension)) {
                  return `<a href="<%= mediaPath %>/${filepath}" data-lightbox="${transformedKey}" data-title="${transformedKey}">
                                            <img class="popup-media" src="<%= mediaPath %>/${filepath}" alt="${transformedKey}" /></a>`;
                } else if (audioExtensions.includes(extension)) {
                  return `<audio class="popup-media" controls>
                                            <source src="<%= mediaPath %>/${filepath}" type="audio/${extension}">
                                        Your browser does not support the audio element.
                                      </audio>`;
                } else if (videoExtensions.includes(extension)) {
                  return `<video class="popup-media" controls>
                                            <source src="<%= mediaPath %>/${filepath}" type="video/${extension}">
                                        Your browser does not support the video element.
                                      </video>`;
                }
                return null;
              }

              if (transformedValue.includes(", ")) {
                const fileList = transformedValue.split(", ");
                transformedValue = fileList.map(processFile)
                  .filter(Boolean)
                  .join("<br>");
              } else {
                transformedValue = processFile(transformedValue) || transformedValue;
              }
            }
            return `<strong>${transformedKey}:</strong> ${transformedValue}`;
          })
          .join("<br>");

        if (feature.latitude && feature.longitude) {
          // Process and render Point geometry
          const marker = new mapboxgl.Marker()
            .setLngLat([feature.longitude, feature.latitude])
            .setPopup(new mapboxgl.Popup().setHTML(popupHTML));
          marker.getElement().style.cursor = "pointer"; // Change cursor to pointer
          marker.addTo(map);
        }

        if (feature.coordinates) {
          // Process and render LineString or Polygon geometry
          const geoJsonFeature = {
            type: "Feature",
            geometry: {
              type: feature.g__type,
              coordinates: feature.coordinates,
            },
          };

          const geometryType = geoJsonFeature.geometry.type;

          const featureLayer = {
            id: `${geometryType}-${feature.id}`, // Unique ID for the layer
            type: geometryType === "Polygon" ? "fill" : "line",
            source: {
              type: "geojson",
              data: geoJsonFeature,
            },
            paint: {
              ...(geometryType === "Polygon" && {
                "fill-color": "#3FB1CE",
                "fill-opacity": 0.75,
              }),
              ...(geometryType === "LineString" && {
                "line-color": "#3FB1CE",
                "line-opacity": 0.75,
                "line-width": 8,
              }),
            },
          };

          // Add cursor styling for polygons and linestrings
          if (geometryType === "Polygon" || geometryType === "LineString") {
            map.on("mouseenter", `${geometryType}-${feature.id}`, () => {
              map.getCanvas().style.cursor = "pointer";
            });
            map.on("mouseleave", `${geometryType}-${feature.id}`, () => {
              map.getCanvas().style.cursor = "";
            });
          }

          // Add popup for polygons and linestrings triggered by click
          map.on("click", `${geometryType}-${feature.id}`, (e) => {
            let popupLocation;

            if (geometryType === "LineString") {
              // For LineString, use the middle point of the coordinates array
              popupLocation =
                geoJsonFeature.geometry.coordinates[
                Math.floor(geoJsonFeature.geometry.coordinates.length / 2)
                ];
            } else if (geometryType === "Polygon") {
              // For Polygon, calculate the centroid of the coordinates
              popupLocation = calculatePolygonCentroid(
                geoJsonFeature.geometry.coordinates[0]
              );
            }

            new mapboxgl.Popup()
              .setLngLat(popupLocation)
              .setHTML(popupHTML)
              .addTo(map);
          });

          map.addLayer(featureLayer);
        }
      });
    };

    map.on("load", () => {
      addDataToMap();
    });
  </script>
</body>

</html>