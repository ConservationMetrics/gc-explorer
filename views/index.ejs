<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>GuardianConnector map</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css"
      rel="stylesheet"
    />
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <link rel="stylesheet" href="dist/lightbox.min.css" />
    <style>
      body {
        margin: 0;
        padding: 0;
      }

      #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
      }

      .mapboxgl-popup-content {
        word-wrap: break-word;
      }

      .popup-media {
        width: 100%;
        display: block;
        margin-top: 5px;
      }
    </style>
  </head>

  <body>
    <div id="map"></div>
    <script src="dist/lightbox-plus-jquery.js"></script>
    <script type="text/javascript">
      mapboxgl.accessToken = "<%= mapboxAccessToken %>";
      const map = new mapboxgl.Map({
        container: "map",
        style: "<%= mapboxStyle %>",
        projection: "<%= mapboxProjection %>",
        center: ["<%= mapboxCenterLatitude %>", "<%= mapboxCenterLongitude %>"],
        zoom: "<%= mapboxZoom %>",
        bearing: "<%= mapboxBearing %>",
        pitch: "<%= mapboxPitch %>",
      });

      // Request db data
      const fetchData = async () => {
        try {
          const response = await fetch("/data");
          const data = await response.json();
          return data;
        } catch (error) {
          console.error("Error fetching data:", error);
          return [];
        }
      };

      // Process different geometry types and extract coordinates
      const processGeolocation = (obj) => {
        if (
          obj &&
          obj.g__type &&
          obj.g__coordinates &&
          typeof obj.g__coordinates === "string"
        ) {
          try {
            const geometryType = obj.g__type;
            const coordinates = JSON.parse(obj.g__coordinates);

            if (
              geometryType === "Point" &&
              Array.isArray(coordinates) &&
              coordinates.length === 2
            ) {
              const [longitude, latitude] = coordinates;
              obj.latitude = latitude;
              obj.longitude = longitude;
            } else if (geometryType === "LineString") {
              obj.coordinates = coordinates;
            } else if (geometryType === "Polygon") {
              obj.coordinates = [coordinates];
            }
          } catch (error) {
            console.error("Error parsing coordinates:", error);
          }
        }
        return obj;
      };

      // Calculate the centroid of the polygon's coordinates
      const calculatePolygonCentroid = (coordinates) => {
        const numPoints = coordinates.length;
        let x = 0.0;
        let y = 0.0;

        for (const [lng, lat] of coordinates) {
          x += lng;
          y += lat;
        }

        return [x / numPoints, y / numPoints];
      };

      const addDataToMap = async () => {
        const data = await fetchData();

        const filteredData = data.filter((feature) =>
          feature.hasOwnProperty("g__coordinates")
        );

        filteredData.forEach((feature) => {
          feature = processGeolocation(feature);

          const popupHTML = Object.keys(feature)
            // Filter out any metadata fields and null values
            .filter(
              (key) =>
                key !== "type" &&
                !key.includes("g__") &&
                !key.includes("meta") &&
                !key.includes("formhub") &&
                !key.includes("start") &&
                !key.includes("end") &&
                (!key.includes("___") || key.includes("photos")) &&
                !key.includes("location") &&
                key !== "latitude" &&
                key !== "longitude" &&
                key !== "coordinates" &&
                feature[key] !== null &&
                feature[key] !== ""
            )
            .map((key) => {
              // Rewrite the keys to be more legible
              let transformedKey = key.replace(/^p__/, "").replace(/_/g, " ");
              transformedKey = transformedKey.replace(/\b\w/g, (c) =>
                c.toUpperCase()
              ); // Capitalize first letter of each word
              if (transformedKey === "Today") {
                transformedKey = "Data Collected On";
              } else if (transformedKey === "CategoryId") {
                transformedKey = "Category";
              }

              // Rewrite the values to be more legible
              let transformedValue = feature[key];
              if (typeof transformedValue === "string") {
                transformedValue = transformedValue
                  .replace(/_/g, " ")
                  .replace(/;/g, ", ");

                if (key === "p__categoryId") {
                  transformedValue = transformedValue.replace(/-/g, " ");
                }

                transformedValue =
                  transformedValue.charAt(0).toUpperCase() +
                  transformedValue.slice(1);
              }

              // Handle lists enclosed in square brackets
              if (transformedValue.match(/^\[.*\]$/)) {
                transformedValue = transformedValue
                  .replace(/^\[|\]$/g, "")
                  .split(", ")
                  .map((item) => item.replace(/'/g, ""))
                  .join(", ");
              }

              if ("<%= embedMedia %>" === "YES") {
                // Check if the value is a list of files delimited by ' and a space
                if (transformedValue.includes(", ")) {
                  const fileList = transformedValue.split(", ");
                  transformedValue = fileList
                    .map((file) => {
                      // Process each file individually based on its extension
                      if (file.match(/\.(jpg|jpeg|png|webp)$/i)) {
                        return `<a href="<%= mediaPath %>/${file}" data-lightbox="${transformedKey}" data-title="${transformedKey}">
                                    <img class="popup-media" src="<%= mediaPath %>/${file}" alt="${transformedKey}" /></a>`;
                      } else if (file.match(/\.(mp3|ogg|wav)$/i)) {
                        return `<audio class="popup-media" controls>
                                      <source src="<%= mediaPath %>/${file}" type="audio/${file
                          .split(".")
                          .pop()}">
                                    Your browser does not support the audio element.
                                  </audio>`;
                      } else if (file.match(/\.(mov|mp4|avi|mkv|m4a)$/i)) {
                        return `<video class="popup-media" controls>
                                      <source src="<%= mediaPath %>/${file}" type="video/${file
                          .split(".")
                          .pop()}">
                                    Your browser does not support the video element.
                                  </video>`;
                      } else {
                        return null; // Skip unsupported files
                      }
                    })
                    .filter((html) => html !== null) // Remove null values
                    .join("<br>");
                } else {
                  // Process a single file based on its extension
                  if (transformedValue.match(/\.(jpg|jpeg|png|webp)$/i)) {
                    transformedValue = `<a href="<%= mediaPath %>/${transformedValue}" data-lightbox="${transformedKey}" data-title="${transformedKey}">
                                            <img class="popup-media" src="<%= mediaPath %>/${transformedValue}" alt="${transformedKey}" /></a>`;
                  } else if (transformedValue.match(/\.(mp3|ogg|wav)$/i)) {
                    transformedValue = `<audio class="popup-media" controls>
                                                <source src="<%= mediaPath %>/${transformedValue}" type="audio/${transformedValue
                      .split(".")
                      .pop()}">
                                              Your browser does not support the audio element.
                                            </audio>`;
                  } else if (
                    transformedValue.match(/\.(mov|mp4|avi|mkv|m4a)$/i)
                  ) {
                    transformedValue = `<video class="popup-media" controls>
                                                <source src="<%= mediaPath %>/${transformedValue}" type="video/${transformedValue
                      .split(".")
                      .pop()}">
                                              Your browser does not support the video element.
                                            </video>`;
                  }
                }
              }
              return `<strong>${transformedKey}:</strong> ${transformedValue}`;
            })
            .join("<br>");

          if (feature.latitude && feature.longitude) {
            // Process and render Point geometry
            const marker = new mapboxgl.Marker()
              .setLngLat([feature.longitude, feature.latitude])
              .setPopup(new mapboxgl.Popup().setHTML(popupHTML));
            marker.getElement().style.cursor = "pointer"; // Change cursor to pointer
            marker.addTo(map);
          }

          if (feature.coordinates) {
            // Process and render LineString or Polygon geometry
            const geoJsonFeature = {
              type: "Feature",
              geometry: {
                type: feature.g__type,
                coordinates: feature.coordinates,
              },
            };

            const geometryType = geoJsonFeature.geometry.type;

            const featureLayer = {
              id: `${geometryType}-${feature.id}`, // Unique ID for the layer
              type: geometryType === "Polygon" ? "fill" : "line",
              source: {
                type: "geojson",
                data: geoJsonFeature,
              },
              paint: {
                ...(geometryType === "Polygon" && {
                  "fill-color": "#3FB1CE",
                  "fill-opacity": 0.75,
                }),
                ...(geometryType === "LineString" && {
                  "line-color": "#3FB1CE",
                  "line-opacity": 0.75,
                  "line-width": 8,
                }),
              },
            };

            // Add cursor styling for polygons and linestrings
            if (geometryType === "Polygon" || geometryType === "LineString") {
              map.on("mouseenter", `${geometryType}-${feature.id}`, () => {
                map.getCanvas().style.cursor = "pointer";
              });
              map.on("mouseleave", `${geometryType}-${feature.id}`, () => {
                map.getCanvas().style.cursor = "";
              });
            }

            // Add popup for polygons and linestrings triggered by click
            map.on("click", `${geometryType}-${feature.id}`, (e) => {
              let popupLocation;

              if (geometryType === "LineString") {
                // For LineString, use the middle point of the coordinates array
                popupLocation =
                  geoJsonFeature.geometry.coordinates[
                    Math.floor(geoJsonFeature.geometry.coordinates.length / 2)
                  ];
              } else if (geometryType === "Polygon") {
                // For Polygon, calculate the centroid of the coordinates
                popupLocation = calculatePolygonCentroid(
                  geoJsonFeature.geometry.coordinates[0]
                );
              }

              new mapboxgl.Popup()
                .setLngLat(popupLocation)
                .setHTML(popupHTML)
                .addTo(map);
            });

            map.addLayer(featureLayer);
          }
        });
      };

      map.on("load", () => {
        addDataToMap();
      });
    </script>
  </body>
</html>
