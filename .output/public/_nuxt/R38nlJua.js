var xA = Object.defineProperty;
var vA = (m, l, f) =>
  l in m
    ? xA(m, l, { enumerable: !0, configurable: !0, writable: !0, value: f })
    : (m[l] = f);
var ln = (m, l, f) => vA(m, typeof l != "symbol" ? l + "" : l, f);
import { a as FT } from "./Bx2EM-6T.js";
import {
  e as aa,
  c as pn,
  o as Xi,
  a as ci,
  t as An,
  z as hw,
  h as Fr,
  F as Yf,
  j as Og,
  ae as bo,
  ai as sa,
  af as Ws,
  N as rp,
  w as mh,
  b as Lt,
  ah as ra,
  m as bh,
  r as $n,
  O as Yl,
  i as sr,
  R as Wu,
  s as Fx,
  y as dp,
  as as bA,
  at as BT,
  au as Tx,
  av as NT,
  ar as Sx,
  M as wA,
  g as us,
  d as na,
  v as TA,
  _ as Bx,
  P as Kf,
  Q as SA,
  aw as Xs,
  ax as EA,
  ay as Nx,
  az as IA,
  aA as AA,
  aB as Vx,
  aC as MA,
  aD as xg,
} from "./CSw5FfBj.js";
import { b as VT, _ as UT, D as CA } from "./E3LaZOar.js";
var Fg = { exports: {} },
  PA = Fg.exports,
  uw;
function DA() {
  return (
    uw ||
      ((uw = 1),
      (function (m, l) {
        (function (f, y) {
          m.exports = y();
        })(PA, function () {
          var f, y, T;
          function I(r, F) {
            if (!f) f = F;
            else if (!y) y = F;
            else {
              var B =
                  "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" +
                  f +
                  ")(sharedChunk); (" +
                  y +
                  ")(sharedChunk); self.onerror = null;",
                q = {};
              (f(q),
                (T = F(q)),
                typeof window < "u" &&
                  window &&
                  window.URL &&
                  window.URL.createObjectURL &&
                  (T.workerUrl = window.URL.createObjectURL(
                    new Blob([B], { type: "text/javascript" }),
                  )));
            }
          }
          (I(["exports"], function (r) {
            var F = 1e-6,
              B = typeof Float32Array < "u" ? Float32Array : Array;
            function q(n, e) {
              var i = e[0],
                o = e[1],
                a = e[2],
                u = e[3],
                d = i * u - a * o;
              return d
                ? ((n[0] = u * (d = 1 / d)),
                  (n[1] = -o * d),
                  (n[2] = -a * d),
                  (n[3] = i * d),
                  n)
                : null;
            }
            function ne() {
              var n = new B(9);
              return (
                B != Float32Array &&
                  ((n[1] = 0),
                  (n[2] = 0),
                  (n[3] = 0),
                  (n[5] = 0),
                  (n[6] = 0),
                  (n[7] = 0)),
                (n[0] = 1),
                (n[4] = 1),
                (n[8] = 1),
                n
              );
            }
            function fe(n, e) {
              var i = e[0],
                o = e[1],
                a = e[2],
                u = e[3],
                d = e[4],
                _ = e[5],
                v = e[6],
                b = e[7],
                E = e[8];
              return (
                (n[0] = d * E - _ * b),
                (n[1] = a * b - o * E),
                (n[2] = o * _ - a * d),
                (n[3] = _ * v - u * E),
                (n[4] = i * E - a * v),
                (n[5] = a * u - i * _),
                (n[6] = u * b - d * v),
                (n[7] = o * v - i * b),
                (n[8] = i * d - o * u),
                n
              );
            }
            function de(n, e, i) {
              var o = e[0],
                a = e[1],
                u = e[2],
                d = e[3],
                _ = e[4],
                v = e[5],
                b = e[6],
                E = e[7],
                A = e[8],
                M = i[0],
                R = i[1],
                k = i[2],
                N = i[3],
                j = i[4],
                H = i[5],
                J = i[6],
                Q = i[7],
                V = i[8];
              return (
                (n[0] = M * o + R * d + k * b),
                (n[1] = M * a + R * _ + k * E),
                (n[2] = M * u + R * v + k * A),
                (n[3] = N * o + j * d + H * b),
                (n[4] = N * a + j * _ + H * E),
                (n[5] = N * u + j * v + H * A),
                (n[6] = J * o + Q * d + V * b),
                (n[7] = J * a + Q * _ + V * E),
                (n[8] = J * u + Q * v + V * A),
                n
              );
            }
            function Ie() {
              var n = new B(16);
              return (
                B != Float32Array &&
                  ((n[1] = 0),
                  (n[2] = 0),
                  (n[3] = 0),
                  (n[4] = 0),
                  (n[6] = 0),
                  (n[7] = 0),
                  (n[8] = 0),
                  (n[9] = 0),
                  (n[11] = 0),
                  (n[12] = 0),
                  (n[13] = 0),
                  (n[14] = 0)),
                (n[0] = 1),
                (n[5] = 1),
                (n[10] = 1),
                (n[15] = 1),
                n
              );
            }
            function xe(n) {
              return (
                (n[0] = 1),
                (n[1] = 0),
                (n[2] = 0),
                (n[3] = 0),
                (n[4] = 0),
                (n[5] = 1),
                (n[6] = 0),
                (n[7] = 0),
                (n[8] = 0),
                (n[9] = 0),
                (n[10] = 1),
                (n[11] = 0),
                (n[12] = 0),
                (n[13] = 0),
                (n[14] = 0),
                (n[15] = 1),
                n
              );
            }
            function we(n, e) {
              var i = e[0],
                o = e[1],
                a = e[2],
                u = e[3],
                d = e[4],
                _ = e[5],
                v = e[6],
                b = e[7],
                E = e[8],
                A = e[9],
                M = e[10],
                R = e[11],
                k = e[12],
                N = e[13],
                j = e[14],
                H = e[15],
                J = i * _ - o * d,
                Q = i * v - a * d,
                V = i * b - u * d,
                X = o * v - a * _,
                ee = o * b - u * _,
                re = a * b - u * v,
                ve = E * N - A * k,
                ge = E * j - M * k,
                be = E * H - R * k,
                Me = A * j - M * N,
                Ue = A * H - R * N,
                it = M * H - R * j,
                Xe = J * it - Q * Ue + V * Me + X * be - ee * ge + re * ve;
              return Xe
                ? ((n[0] = (_ * it - v * Ue + b * Me) * (Xe = 1 / Xe)),
                  (n[1] = (a * Ue - o * it - u * Me) * Xe),
                  (n[2] = (N * re - j * ee + H * X) * Xe),
                  (n[3] = (M * ee - A * re - R * X) * Xe),
                  (n[4] = (v * be - d * it - b * ge) * Xe),
                  (n[5] = (i * it - a * be + u * ge) * Xe),
                  (n[6] = (j * V - k * re - H * Q) * Xe),
                  (n[7] = (E * re - M * V + R * Q) * Xe),
                  (n[8] = (d * Ue - _ * be + b * ve) * Xe),
                  (n[9] = (o * be - i * Ue - u * ve) * Xe),
                  (n[10] = (k * ee - N * V + H * J) * Xe),
                  (n[11] = (A * V - E * ee - R * J) * Xe),
                  (n[12] = (_ * ge - d * Me - v * ve) * Xe),
                  (n[13] = (i * Me - o * ge + a * ve) * Xe),
                  (n[14] = (N * Q - k * X - j * J) * Xe),
                  (n[15] = (E * X - A * Q + M * J) * Xe),
                  n)
                : null;
            }
            function Ae(n, e, i) {
              var o = e[0],
                a = e[1],
                u = e[2],
                d = e[3],
                _ = e[4],
                v = e[5],
                b = e[6],
                E = e[7],
                A = e[8],
                M = e[9],
                R = e[10],
                k = e[11],
                N = e[12],
                j = e[13],
                H = e[14],
                J = e[15],
                Q = i[0],
                V = i[1],
                X = i[2],
                ee = i[3];
              return (
                (n[0] = Q * o + V * _ + X * A + ee * N),
                (n[1] = Q * a + V * v + X * M + ee * j),
                (n[2] = Q * u + V * b + X * R + ee * H),
                (n[3] = Q * d + V * E + X * k + ee * J),
                (n[4] =
                  (Q = i[4]) * o +
                  (V = i[5]) * _ +
                  (X = i[6]) * A +
                  (ee = i[7]) * N),
                (n[5] = Q * a + V * v + X * M + ee * j),
                (n[6] = Q * u + V * b + X * R + ee * H),
                (n[7] = Q * d + V * E + X * k + ee * J),
                (n[8] =
                  (Q = i[8]) * o +
                  (V = i[9]) * _ +
                  (X = i[10]) * A +
                  (ee = i[11]) * N),
                (n[9] = Q * a + V * v + X * M + ee * j),
                (n[10] = Q * u + V * b + X * R + ee * H),
                (n[11] = Q * d + V * E + X * k + ee * J),
                (n[12] =
                  (Q = i[12]) * o +
                  (V = i[13]) * _ +
                  (X = i[14]) * A +
                  (ee = i[15]) * N),
                (n[13] = Q * a + V * v + X * M + ee * j),
                (n[14] = Q * u + V * b + X * R + ee * H),
                (n[15] = Q * d + V * E + X * k + ee * J),
                n
              );
            }
            function Qe(n, e, i) {
              var o,
                a,
                u,
                d,
                _,
                v,
                b,
                E,
                A,
                M,
                R,
                k,
                N = i[0],
                j = i[1],
                H = i[2];
              return (
                e === n
                  ? ((n[12] = e[0] * N + e[4] * j + e[8] * H + e[12]),
                    (n[13] = e[1] * N + e[5] * j + e[9] * H + e[13]),
                    (n[14] = e[2] * N + e[6] * j + e[10] * H + e[14]),
                    (n[15] = e[3] * N + e[7] * j + e[11] * H + e[15]))
                  : ((a = e[1]),
                    (u = e[2]),
                    (d = e[3]),
                    (_ = e[4]),
                    (v = e[5]),
                    (b = e[6]),
                    (E = e[7]),
                    (A = e[8]),
                    (M = e[9]),
                    (R = e[10]),
                    (k = e[11]),
                    (n[0] = o = e[0]),
                    (n[1] = a),
                    (n[2] = u),
                    (n[3] = d),
                    (n[4] = _),
                    (n[5] = v),
                    (n[6] = b),
                    (n[7] = E),
                    (n[8] = A),
                    (n[9] = M),
                    (n[10] = R),
                    (n[11] = k),
                    (n[12] = o * N + _ * j + A * H + e[12]),
                    (n[13] = a * N + v * j + M * H + e[13]),
                    (n[14] = u * N + b * j + R * H + e[14]),
                    (n[15] = d * N + E * j + k * H + e[15])),
                n
              );
            }
            function gt(n, e, i) {
              var o = i[0],
                a = i[1],
                u = i[2];
              return (
                (n[0] = e[0] * o),
                (n[1] = e[1] * o),
                (n[2] = e[2] * o),
                (n[3] = e[3] * o),
                (n[4] = e[4] * a),
                (n[5] = e[5] * a),
                (n[6] = e[6] * a),
                (n[7] = e[7] * a),
                (n[8] = e[8] * u),
                (n[9] = e[9] * u),
                (n[10] = e[10] * u),
                (n[11] = e[11] * u),
                (n[12] = e[12]),
                (n[13] = e[13]),
                (n[14] = e[14]),
                (n[15] = e[15]),
                n
              );
            }
            function Rt(n, e, i) {
              var o = Math.sin(i),
                a = Math.cos(i),
                u = e[4],
                d = e[5],
                _ = e[6],
                v = e[7],
                b = e[8],
                E = e[9],
                A = e[10],
                M = e[11];
              return (
                e !== n &&
                  ((n[0] = e[0]),
                  (n[1] = e[1]),
                  (n[2] = e[2]),
                  (n[3] = e[3]),
                  (n[12] = e[12]),
                  (n[13] = e[13]),
                  (n[14] = e[14]),
                  (n[15] = e[15])),
                (n[4] = u * a + b * o),
                (n[5] = d * a + E * o),
                (n[6] = _ * a + A * o),
                (n[7] = v * a + M * o),
                (n[8] = b * a - u * o),
                (n[9] = E * a - d * o),
                (n[10] = A * a - _ * o),
                (n[11] = M * a - v * o),
                n
              );
            }
            function Mt(n, e, i) {
              var o = Math.sin(i),
                a = Math.cos(i),
                u = e[0],
                d = e[1],
                _ = e[2],
                v = e[3],
                b = e[8],
                E = e[9],
                A = e[10],
                M = e[11];
              return (
                e !== n &&
                  ((n[4] = e[4]),
                  (n[5] = e[5]),
                  (n[6] = e[6]),
                  (n[7] = e[7]),
                  (n[12] = e[12]),
                  (n[13] = e[13]),
                  (n[14] = e[14]),
                  (n[15] = e[15])),
                (n[0] = u * a - b * o),
                (n[1] = d * a - E * o),
                (n[2] = _ * a - A * o),
                (n[3] = v * a - M * o),
                (n[8] = u * o + b * a),
                (n[9] = d * o + E * a),
                (n[10] = _ * o + A * a),
                (n[11] = v * o + M * a),
                n
              );
            }
            function pt(n, e, i) {
              var o = Math.sin(i),
                a = Math.cos(i),
                u = e[0],
                d = e[1],
                _ = e[2],
                v = e[3],
                b = e[4],
                E = e[5],
                A = e[6],
                M = e[7];
              return (
                e !== n &&
                  ((n[8] = e[8]),
                  (n[9] = e[9]),
                  (n[10] = e[10]),
                  (n[11] = e[11]),
                  (n[12] = e[12]),
                  (n[13] = e[13]),
                  (n[14] = e[14]),
                  (n[15] = e[15])),
                (n[0] = u * a + b * o),
                (n[1] = d * a + E * o),
                (n[2] = _ * a + A * o),
                (n[3] = v * a + M * o),
                (n[4] = b * a - u * o),
                (n[5] = E * a - d * o),
                (n[6] = A * a - _ * o),
                (n[7] = M * a - v * o),
                n
              );
            }
            function Re(n, e) {
              return (
                (n[0] = e[0]),
                (n[1] = 0),
                (n[2] = 0),
                (n[3] = 0),
                (n[4] = 0),
                (n[5] = e[1]),
                (n[6] = 0),
                (n[7] = 0),
                (n[8] = 0),
                (n[9] = 0),
                (n[10] = e[2]),
                (n[11] = 0),
                (n[12] = 0),
                (n[13] = 0),
                (n[14] = 0),
                (n[15] = 1),
                n
              );
            }
            function rt(n, e, i) {
              var o,
                a,
                u,
                d = i[0],
                _ = i[1],
                v = i[2],
                b = Math.hypot(d, _, v);
              return b < F
                ? null
                : ((d *= b = 1 / b),
                  (_ *= b),
                  (v *= b),
                  (o = Math.sin(e)),
                  (a = Math.cos(e)),
                  (n[0] = d * d * (u = 1 - a) + a),
                  (n[1] = _ * d * u + v * o),
                  (n[2] = v * d * u - _ * o),
                  (n[3] = 0),
                  (n[4] = d * _ * u - v * o),
                  (n[5] = _ * _ * u + a),
                  (n[6] = v * _ * u + d * o),
                  (n[7] = 0),
                  (n[8] = d * v * u + _ * o),
                  (n[9] = _ * v * u - d * o),
                  (n[10] = v * v * u + a),
                  (n[11] = 0),
                  (n[12] = 0),
                  (n[13] = 0),
                  (n[14] = 0),
                  (n[15] = 1),
                  n);
            }
            function Ot(n, e) {
              var i = e[0],
                o = e[1],
                a = e[2],
                u = e[3],
                d = i + i,
                _ = o + o,
                v = a + a,
                b = i * d,
                E = o * d,
                A = o * _,
                M = a * d,
                R = a * _,
                k = a * v,
                N = u * d,
                j = u * _,
                H = u * v;
              return (
                (n[0] = 1 - A - k),
                (n[1] = E + H),
                (n[2] = M - j),
                (n[3] = 0),
                (n[4] = E - H),
                (n[5] = 1 - b - k),
                (n[6] = R + N),
                (n[7] = 0),
                (n[8] = M + j),
                (n[9] = R - N),
                (n[10] = 1 - b - A),
                (n[11] = 0),
                (n[12] = 0),
                (n[13] = 0),
                (n[14] = 0),
                (n[15] = 1),
                n
              );
            }
            Math.hypot ||
              (Math.hypot = function () {
                for (var n = 0, e = arguments.length; e--; )
                  n += arguments[e] * arguments[e];
                return Math.sqrt(n);
              });
            var _i = Ae;
            function qt() {
              var n = new B(3);
              return (
                B != Float32Array && ((n[0] = 0), (n[1] = 0), (n[2] = 0)),
                n
              );
            }
            function pi(n) {
              var e = new B(3);
              return ((e[0] = n[0]), (e[1] = n[1]), (e[2] = n[2]), e);
            }
            function Ri(n) {
              return Math.hypot(n[0], n[1], n[2]);
            }
            function wi(n, e, i) {
              var o = new B(3);
              return ((o[0] = n), (o[1] = e), (o[2] = i), o);
            }
            function ei(n, e, i) {
              return (
                (n[0] = e[0] + i[0]),
                (n[1] = e[1] + i[1]),
                (n[2] = e[2] + i[2]),
                n
              );
            }
            function Ii(n, e, i) {
              return (
                (n[0] = e[0] - i[0]),
                (n[1] = e[1] - i[1]),
                (n[2] = e[2] - i[2]),
                n
              );
            }
            function Ln(n, e, i) {
              return (
                (n[0] = e[0] * i[0]),
                (n[1] = e[1] * i[1]),
                (n[2] = e[2] * i[2]),
                n
              );
            }
            function ir(n, e, i) {
              return (
                (n[0] = Math.min(e[0], i[0])),
                (n[1] = Math.min(e[1], i[1])),
                (n[2] = Math.min(e[2], i[2])),
                n
              );
            }
            function or(n, e, i) {
              return (
                (n[0] = Math.max(e[0], i[0])),
                (n[1] = Math.max(e[1], i[1])),
                (n[2] = Math.max(e[2], i[2])),
                n
              );
            }
            function Vi(n, e, i) {
              return (
                (n[0] = e[0] * i),
                (n[1] = e[1] * i),
                (n[2] = e[2] * i),
                n
              );
            }
            function _r(n, e, i, o) {
              return (
                (n[0] = e[0] + i[0] * o),
                (n[1] = e[1] + i[1] * o),
                (n[2] = e[2] + i[2] * o),
                n
              );
            }
            function yr(n, e) {
              var i = e[0] - n[0],
                o = e[1] - n[1],
                a = e[2] - n[2];
              return i * i + o * o + a * a;
            }
            function fs(n) {
              var e = n[0],
                i = n[1],
                o = n[2];
              return e * e + i * i + o * o;
            }
            function qr(n, e) {
              return ((n[0] = -e[0]), (n[1] = -e[1]), (n[2] = -e[2]), n);
            }
            function tn(n, e) {
              var i = e[0],
                o = e[1],
                a = e[2],
                u = i * i + o * o + a * a;
              return (
                u > 0 && (u = 1 / Math.sqrt(u)),
                (n[0] = e[0] * u),
                (n[1] = e[1] * u),
                (n[2] = e[2] * u),
                n
              );
            }
            function wn(n, e) {
              return n[0] * e[0] + n[1] * e[1] + n[2] * e[2];
            }
            function nr(n, e, i) {
              var o = e[0],
                a = e[1],
                u = e[2],
                d = i[0],
                _ = i[1],
                v = i[2];
              return (
                (n[0] = a * v - u * _),
                (n[1] = u * d - o * v),
                (n[2] = o * _ - a * d),
                n
              );
            }
            function ps(n, e, i, o) {
              var a = e[0],
                u = e[1],
                d = e[2];
              return (
                (n[0] = a + o * (i[0] - a)),
                (n[1] = u + o * (i[1] - u)),
                (n[2] = d + o * (i[2] - d)),
                n
              );
            }
            function mn(n, e, i) {
              var o = e[0],
                a = e[1],
                u = e[2],
                d = i[3] * o + i[7] * a + i[11] * u + i[15];
              return (
                (n[0] =
                  (i[0] * o + i[4] * a + i[8] * u + i[12]) / (d = d || 1)),
                (n[1] = (i[1] * o + i[5] * a + i[9] * u + i[13]) / d),
                (n[2] = (i[2] * o + i[6] * a + i[10] * u + i[14]) / d),
                n
              );
            }
            function Za(n, e, i) {
              var o = e[0],
                a = e[1],
                u = e[2];
              return (
                (n[0] = o * i[0] + a * i[3] + u * i[6]),
                (n[1] = o * i[1] + a * i[4] + u * i[7]),
                (n[2] = o * i[2] + a * i[5] + u * i[8]),
                n
              );
            }
            function Qs(n, e, i) {
              var o = i[0],
                a = i[1],
                u = i[2],
                d = e[0],
                _ = e[1],
                v = e[2],
                b = a * v - u * _,
                E = u * d - o * v,
                A = o * _ - a * d,
                M = a * A - u * E,
                R = u * b - o * A,
                k = o * E - a * b,
                N = 2 * i[3];
              return (
                (E *= N),
                (A *= N),
                (R *= 2),
                (k *= 2),
                (n[0] = d + (b *= N) + (M *= 2)),
                (n[1] = _ + E + R),
                (n[2] = v + A + k),
                n
              );
            }
            function Is(n, e) {
              return n[0] === e[0] && n[1] === e[1] && n[2] === e[2];
            }
            var Gn = Ii,
              Xa = Ln,
              To = Ri;
            function Mr() {
              var n = new B(4);
              return (
                B != Float32Array &&
                  ((n[0] = 0), (n[1] = 0), (n[2] = 0), (n[3] = 0)),
                n
              );
            }
            function la(n, e, i) {
              return (
                (n[0] = e[0] * i),
                (n[1] = e[1] * i),
                (n[2] = e[2] * i),
                (n[3] = e[3] * i),
                n
              );
            }
            function ic(n, e) {
              var i = e[0],
                o = e[1],
                a = e[2],
                u = e[3],
                d = i * i + o * o + a * a + u * u;
              return (
                d > 0 && (d = 1 / Math.sqrt(d)),
                (n[0] = i * d),
                (n[1] = o * d),
                (n[2] = a * d),
                (n[3] = u * d),
                n
              );
            }
            function Cr(n, e, i) {
              var o = e[0],
                a = e[1],
                u = e[2],
                d = e[3];
              return (
                (n[0] = i[0] * o + i[4] * a + i[8] * u + i[12] * d),
                (n[1] = i[1] * o + i[5] * a + i[9] * u + i[13] * d),
                (n[2] = i[2] * o + i[6] * a + i[10] * u + i[14] * d),
                (n[3] = i[3] * o + i[7] * a + i[11] * u + i[15] * d),
                n
              );
            }
            function Zr() {
              var n = new B(4);
              return (
                B != Float32Array && ((n[0] = 0), (n[1] = 0), (n[2] = 0)),
                (n[3] = 1),
                n
              );
            }
            function So(n) {
              return ((n[0] = 0), (n[1] = 0), (n[2] = 0), (n[3] = 1), n);
            }
            function Eo(n, e, i) {
              i *= 0.5;
              var o = e[0],
                a = e[1],
                u = e[2],
                d = e[3],
                _ = Math.sin(i),
                v = Math.cos(i);
              return (
                (n[0] = o * v + d * _),
                (n[1] = a * v + u * _),
                (n[2] = u * v - a * _),
                (n[3] = d * v - o * _),
                n
              );
            }
            function Io(n, e, i) {
              i *= 0.5;
              var o = e[0],
                a = e[1],
                u = e[2],
                d = e[3],
                _ = Math.sin(i),
                v = Math.cos(i);
              return (
                (n[0] = o * v - u * _),
                (n[1] = a * v + d * _),
                (n[2] = u * v + o * _),
                (n[3] = d * v - a * _),
                n
              );
            }
            (qt(), Mr());
            var Pr,
              Ya,
              Ka,
              Xr,
              nc,
              eo = ic,
              Ja =
                ((Pr = qt()),
                (Ya = wi(1, 0, 0)),
                (Ka = wi(0, 1, 0)),
                function (n, e, i) {
                  var o = wn(e, i);
                  return o < -0.999999
                    ? (nr(Pr, Ya, e),
                      To(Pr) < 1e-6 && nr(Pr, Ka, e),
                      tn(Pr, Pr),
                      (function (a, u, d) {
                        d *= 0.5;
                        var _ = Math.sin(d);
                        ((a[0] = _ * u[0]),
                          (a[1] = _ * u[1]),
                          (a[2] = _ * u[2]),
                          (a[3] = Math.cos(d)));
                      })(n, Pr, Math.PI),
                      n)
                    : o > 0.999999
                      ? ((n[0] = 0), (n[1] = 0), (n[2] = 0), (n[3] = 1), n)
                      : (nr(Pr, e, i),
                        (n[0] = Pr[0]),
                        (n[1] = Pr[1]),
                        (n[2] = Pr[2]),
                        (n[3] = 1 + o),
                        eo(n, n));
                });
            function wr() {
              var n = new B(2);
              return (B != Float32Array && ((n[0] = 0), (n[1] = 0)), n);
            }
            function ms(n, e) {
              var i = new B(2);
              return ((i[0] = n), (i[1] = e), i);
            }
            function ca(n, e, i) {
              return ((n[0] = e[0] + i[0]), (n[1] = e[1] + i[1]), n);
            }
            function Ao(n, e, i) {
              return ((n[0] = e[0] - i[0]), (n[1] = e[1] - i[1]), n);
            }
            function ha(n, e, i) {
              return ((n[0] = e[0] * i), (n[1] = e[1] * i), n);
            }
            function Mo(n) {
              return Math.hypot(n[0], n[1]);
            }
            function Qa(n, e) {
              var i = e[0],
                o = e[1],
                a = i * i + o * o;
              return (
                a > 0 && (a = 1 / Math.sqrt(a)),
                (n[0] = e[0] * a),
                (n[1] = e[1] * a),
                n
              );
            }
            function bn(n, e) {
              return n[0] * e[0] + n[1] * e[1];
            }
            function Co(n) {
              return n &&
                n.__esModule &&
                Object.prototype.hasOwnProperty.call(n, "default")
                ? n.default
                : n;
            }
            (Zr(), Zr(), ne(), wr());
            var el,
              Yr,
              td = (function () {
                if (nc) return Xr;
                function n(e, i, o, a) {
                  ((this.cx = 3 * e),
                    (this.bx = 3 * (o - e) - this.cx),
                    (this.ax = 1 - this.cx - this.bx),
                    (this.cy = 3 * i),
                    (this.by = 3 * (a - i) - this.cy),
                    (this.ay = 1 - this.cy - this.by),
                    (this.p1x = e),
                    (this.p1y = i),
                    (this.p2x = o),
                    (this.p2y = a));
                }
                return (
                  (nc = 1),
                  (Xr = n),
                  (n.prototype = {
                    sampleCurveX: function (e) {
                      return ((this.ax * e + this.bx) * e + this.cx) * e;
                    },
                    sampleCurveY: function (e) {
                      return ((this.ay * e + this.by) * e + this.cy) * e;
                    },
                    sampleCurveDerivativeX: function (e) {
                      return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
                    },
                    solveCurveX: function (e, i) {
                      if ((i === void 0 && (i = 1e-6), e < 0)) return 0;
                      if (e > 1) return 1;
                      for (var o = e, a = 0; a < 8; a++) {
                        var u = this.sampleCurveX(o) - e;
                        if (Math.abs(u) < i) return o;
                        var d = this.sampleCurveDerivativeX(o);
                        if (Math.abs(d) < 1e-6) break;
                        o -= u / d;
                      }
                      var _ = 0,
                        v = 1;
                      for (
                        o = e, a = 0;
                        a < 20 &&
                        ((u = this.sampleCurveX(o)), !(Math.abs(u - e) < i));
                        a++
                      )
                        (e > u ? (_ = o) : (v = o), (o = 0.5 * (v - _) + _));
                      return o;
                    },
                    solve: function (e, i) {
                      return this.sampleCurveY(this.solveCurveX(e, i));
                    },
                  }),
                  Xr
                );
              })(),
              Sh = Co(td);
            function ua() {
              if (Yr) return el;
              function n(e, i) {
                ((this.x = e), (this.y = i));
              }
              return (
                (Yr = 1),
                (el = n),
                (n.prototype = {
                  clone: function () {
                    return new n(this.x, this.y);
                  },
                  add: function (e) {
                    return this.clone()._add(e);
                  },
                  sub: function (e) {
                    return this.clone()._sub(e);
                  },
                  multByPoint: function (e) {
                    return this.clone()._multByPoint(e);
                  },
                  divByPoint: function (e) {
                    return this.clone()._divByPoint(e);
                  },
                  mult: function (e) {
                    return this.clone()._mult(e);
                  },
                  div: function (e) {
                    return this.clone()._div(e);
                  },
                  rotate: function (e) {
                    return this.clone()._rotate(e);
                  },
                  rotateAround: function (e, i) {
                    return this.clone()._rotateAround(e, i);
                  },
                  matMult: function (e) {
                    return this.clone()._matMult(e);
                  },
                  unit: function () {
                    return this.clone()._unit();
                  },
                  perp: function () {
                    return this.clone()._perp();
                  },
                  round: function () {
                    return this.clone()._round();
                  },
                  mag: function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y);
                  },
                  equals: function (e) {
                    return this.x === e.x && this.y === e.y;
                  },
                  dist: function (e) {
                    return Math.sqrt(this.distSqr(e));
                  },
                  distSqr: function (e) {
                    var i = e.x - this.x,
                      o = e.y - this.y;
                    return i * i + o * o;
                  },
                  angle: function () {
                    return Math.atan2(this.y, this.x);
                  },
                  angleTo: function (e) {
                    return Math.atan2(this.y - e.y, this.x - e.x);
                  },
                  angleWith: function (e) {
                    return this.angleWithSep(e.x, e.y);
                  },
                  angleWithSep: function (e, i) {
                    return Math.atan2(
                      this.x * i - this.y * e,
                      this.x * e + this.y * i,
                    );
                  },
                  _matMult: function (e) {
                    var i = e[2] * this.x + e[3] * this.y;
                    return (
                      (this.x = e[0] * this.x + e[1] * this.y),
                      (this.y = i),
                      this
                    );
                  },
                  _add: function (e) {
                    return ((this.x += e.x), (this.y += e.y), this);
                  },
                  _sub: function (e) {
                    return ((this.x -= e.x), (this.y -= e.y), this);
                  },
                  _mult: function (e) {
                    return ((this.x *= e), (this.y *= e), this);
                  },
                  _div: function (e) {
                    return ((this.x /= e), (this.y /= e), this);
                  },
                  _multByPoint: function (e) {
                    return ((this.x *= e.x), (this.y *= e.y), this);
                  },
                  _divByPoint: function (e) {
                    return ((this.x /= e.x), (this.y /= e.y), this);
                  },
                  _unit: function () {
                    return (this._div(this.mag()), this);
                  },
                  _perp: function () {
                    var e = this.y;
                    return ((this.y = this.x), (this.x = -e), this);
                  },
                  _rotate: function (e) {
                    var i = Math.cos(e),
                      o = Math.sin(e),
                      a = o * this.x + i * this.y;
                    return (
                      (this.x = i * this.x - o * this.y),
                      (this.y = a),
                      this
                    );
                  },
                  _rotateAround: function (e, i) {
                    var o = Math.cos(e),
                      a = Math.sin(e),
                      u = i.y + a * (this.x - i.x) + o * (this.y - i.y);
                    return (
                      (this.x = i.x + o * (this.x - i.x) - a * (this.y - i.y)),
                      (this.y = u),
                      this
                    );
                  },
                  _round: function () {
                    return (
                      (this.x = Math.round(this.x)),
                      (this.y = Math.round(this.y)),
                      this
                    );
                  },
                }),
                (n.convert = function (e) {
                  return e instanceof n
                    ? e
                    : Array.isArray(e)
                      ? new n(e[0], e[1])
                      : e;
                }),
                el
              );
            }
            var ft = Co(ua());
            function to(n, e) {
              if (Array.isArray(n)) {
                if (!Array.isArray(e) || n.length !== e.length) return !1;
                for (let i = 0; i < n.length; i++)
                  if (!to(n[i], e[i])) return !1;
                return !0;
              }
              if (typeof n == "object" && n !== null && e !== null) {
                if (
                  typeof e != "object" ||
                  Object.keys(n).length !== Object.keys(e).length
                )
                  return !1;
                for (const i in n) if (!to(n[i], e[i])) return !1;
                return !0;
              }
              return n === e;
            }
            const id = Math.PI / 180,
              rc = 180 / Math.PI;
            function Mi(n) {
              return n * id;
            }
            function Fe(n) {
              return n * rc;
            }
            const W = [
              [0, 0],
              [1, 0],
              [1, 1],
              [0, 1],
            ];
            function K(n) {
              if (n <= 0) return 0;
              if (n >= 1) return 1;
              const e = n * n,
                i = e * n;
              return 4 * (n < 0.5 ? i : 3 * (n - e) + i - 0.75);
            }
            function oe(n, e, i, o) {
              const a = new Sh(n, e, i, o);
              return function (u) {
                return a.solve(u);
              };
            }
            const ye = oe(0.25, 0.1, 0.25, 1);
            function he(n, e, i) {
              return Math.min(i, Math.max(e, n));
            }
            function Se(n, e, i) {
              return (i = he((i - n) / (e - n), 0, 1)) * i * (3 - 2 * i);
            }
            function ke(n, e, i) {
              const o = i - e,
                a = ((((n - e) % o) + o) % o) + e;
              return a === e ? i : a;
            }
            function Ee(n, e, i) {
              if (!n.length) return i(null, []);
              let o = n.length;
              const a = new Array(n.length);
              let u = null;
              n.forEach((d, _) => {
                e(d, (v, b) => {
                  (v && (u = v), (a[_] = b), --o == 0 && i(u, a));
                });
              });
            }
            function Le(n, ...e) {
              for (const i of e) for (const o in i) n[o] = i[o];
              return n;
            }
            let Ye = 1;
            function Be() {
              return Ye++;
            }
            function dt(n) {
              return n <= 1
                ? 1
                : Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
            }
            function Pt(n, e) {
              n.forEach((i) => {
                e[i] && (e[i] = e[i].bind(e));
              });
            }
            function zt(n, e, i) {
              const o = {};
              for (const a in n) o[a] = e.call(this, n[a], a, n);
              return o;
            }
            function Xt(n, e, i) {
              const o = {};
              for (const a in n) e.call(this, n[a], a, n) && (o[a] = n[a]);
              return o;
            }
            function Kt(n) {
              return Array.isArray(n)
                ? n.map(Kt)
                : typeof n == "object" && n
                  ? zt(n, Kt)
                  : n;
            }
            function Qt(n, e) {
              for (let i = 0; i < n.length; i++)
                if (e.indexOf(n[i]) >= 0) return !0;
              return !1;
            }
            const mi = {};
            function ri(n) {
              mi[n] || (typeof console < "u" && console.warn(n), (mi[n] = !0));
            }
            function Ki(n, e, i) {
              return (i.y - n.y) * (e.x - n.x) > (e.y - n.y) * (i.x - n.x);
            }
            function gn(n) {
              let e = 0;
              for (let i, o, a = 0, u = n.length, d = u - 1; a < u; d = a++)
                ((i = n[a]), (o = n[d]), (e += (o.x - i.x) * (i.y + o.y)));
              return e;
            }
            function _n([n, e, i]) {
              const o = Mi(e + 90),
                a = Mi(i);
              return {
                x: n * Math.cos(o) * Math.sin(a),
                y: n * Math.sin(o) * Math.sin(a),
                z: n * Math.cos(a),
                azimuthal: e,
                polar: i,
              };
            }
            function Ui(n) {
              return (
                (typeof self < "u" || n !== void 0) &&
                typeof WorkerGlobalScope < "u" &&
                (n !== void 0 ? n : self) instanceof WorkerGlobalScope
              );
            }
            function Pi(n) {
              const e = {};
              if (
                (n.replace(
                  /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g,
                  (i, o, a, u) => {
                    const d = a || u;
                    return ((e[o] = !d || d.toLowerCase()), "");
                  },
                ),
                e["max-age"])
              ) {
                const i = parseInt(e["max-age"], 10);
                isNaN(i) ? delete e["max-age"] : (e["max-age"] = i);
              }
              return e;
            }
            let On = null;
            function Mn(n, e) {
              return [n[4 * e], n[4 * e + 1], n[4 * e + 2], n[4 * e + 3]];
            }
            function Tn(n, e, i, o) {
              for (; e < i; ) {
                const a = (e + i) >> 1;
                n[a] < o ? (e = a + 1) : (i = a);
              }
              return e;
            }
            function ar(n, e, i, o) {
              for (; e < i; ) {
                const a = (e + i) >> 1;
                n[a] <= o ? (e = a + 1) : (i = a);
              }
              return e;
            }
            function Ur(n) {
              return n > 0 ? 1 / (1.001 - n) : 1 + n;
            }
            function Tr(n) {
              return n > 0 ? 1 - 1 / (1.001 - n) : -n;
            }
            function sc(n, e, i) {
              return ((n - e.min) * (i.max - i.min)) / (e.max - e.min) + i.min;
            }
            const hr = {
              API_URL: "https://api.mapbox.com",
              get API_URL_REGEX() {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
              },
              get API_TILEJSON_REGEX() {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
              },
              get API_SPRITE_REGEX() {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
              },
              get API_FONTS_REGEX() {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
              },
              get API_STYLE_REGEX() {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
              },
              get API_CDN_URL_REGEX() {
                return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
              },
              get EVENTS_URL() {
                if (!hr.API_URL) return null;
                try {
                  const n = new URL(hr.API_URL);
                  return n.hostname === "api.mapbox.cn"
                    ? "https://events.mapbox.cn/events/v2"
                    : n.hostname === "api.mapbox.com"
                      ? "https://events.mapbox.com/events/v2"
                      : null;
                } catch {
                  return null;
                }
              },
              SESSION_PATH: "/map-sessions/v1",
              FEEDBACK_URL: "https://apps.mapbox.com/feedback",
              TILE_URL_VERSION: "v4",
              RASTER_URL_PREFIX: "raster/v1",
              RASTERARRAYS_URL_PREFIX: "rasterarrays/v1",
              REQUIRE_ACCESS_TOKEN: !0,
              ACCESS_TOKEN: null,
              DEFAULT_STYLE: "mapbox://styles/mapbox/standard",
              MAX_PARALLEL_IMAGE_REQUESTS: 16,
              DRACO_URL:
                "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm",
              MESHOPT_URL:
                "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm",
              MESHOPT_SIMD_URL:
                "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm",
              BUILDING_GEN_URL:
                "https://api.mapbox.com/mapbox-gl-js/building-gen/building_gen_v0.3.0.wasm",
              GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf",
              TILES3D_URL_PREFIX: "3dtiles/v1",
            };
            function Po(n) {
              return hr.API_URL_REGEX.test(n);
            }
            function Eh(n) {
              return hr.API_SPRITE_REGEX.test(n);
            }
            let oc, ac, Ih, Ah, da, lc;
            function Mh() {
              return (
                oc == null &&
                  (oc =
                    self.OffscreenCanvas &&
                    new OffscreenCanvas(1, 1).getContext("2d") &&
                    typeof self.createImageBitmap == "function"),
                oc
              );
            }
            const As = {
              now: () => (Ah !== void 0 ? Ah : performance.now()),
              setNow(n) {
                Ah = n;
              },
              restoreNow() {
                Ah = void 0;
              },
              frame(n) {
                const e = requestAnimationFrame(n);
                return { cancel: () => cancelAnimationFrame(e) };
              },
              getImageData(n, e = 0) {
                const { width: i, height: o } = n;
                da || (da = document.createElement("canvas"));
                const a = da.getContext("2d", { willReadFrequently: !0 });
                if (!a) throw new Error("failed to create canvas 2d context");
                return (
                  (i > da.width || o > da.height) &&
                    ((da.width = i), (da.height = o)),
                  a.clearRect(-e, -e, i + 2 * e, o + 2 * e),
                  a.drawImage(n, 0, 0, i, o),
                  a.getImageData(-e, -e, i + 2 * e, o + 2 * e)
                );
              },
              resolveURL: (n) => (
                ac || (ac = document.createElement("a")),
                (ac.href = n),
                ac.href
              ),
              get devicePixelRatio() {
                return window.devicePixelRatio;
              },
              get prefersReducedMotion() {
                return (
                  !!window.matchMedia &&
                  (Ih == null &&
                    (Ih = window.matchMedia(
                      "(prefers-reduced-motion: reduce)",
                    )),
                  Ih.matches)
                );
              },
              hasCanvasFingerprintNoise() {
                if (lc !== void 0) return lc;
                if (!Mh()) return ((lc = !1), !1);
                const n = new OffscreenCanvas(85, 1),
                  e = n.getContext("2d", { willReadFrequently: !0 });
                let i = 0;
                for (let a = 0; a < n.width; ++a)
                  ((e.fillStyle = `rgba(${i++},${i++},${i++}, 255)`),
                    e.fillRect(a, 0, 1, 1));
                const o = e.getImageData(0, 0, n.width, n.height);
                i = 0;
                for (let a = 0; a < o.data.length; ++a)
                  if (a % 4 != 3 && i++ !== o.data[a]) return ((lc = !0), !0);
                return ((lc = !1), !1);
              },
            };
            function ss(n, e) {
              const i = n.indexOf("?");
              if (i < 0) return `${n}?${new URLSearchParams(e).toString()}`;
              const o = new URLSearchParams(n.slice(i));
              for (const a in e) o.set(a, e[a]);
              return `${n.slice(0, i)}?${o.toString()}`;
            }
            function gs(n, e = { persistentParams: [] }) {
              const i = n.indexOf("?");
              if (i < 0) return n;
              const o = new URLSearchParams(),
                a = new URLSearchParams(n.slice(i));
              for (const d of e.persistentParams) {
                const _ = a.get(d);
                _ && o.set(d, _);
              }
              const u = o.toString();
              return `${n.slice(0, i)}${u.length > 0 ? `?${u}` : ""}`;
            }
            const io = "mapbox-tiles";
            let Ms = 500,
              no = 50;
            const cc = ["language", "worldview", "jobid"];
            let Fs, hc;
            function fa() {
              try {
                return caches;
              } catch {}
            }
            function tl() {
              const n = fa();
              n && Fs == null && (Fs = n.open(io));
            }
            let nd = 1 / 0;
            const rd = {
              supported: !1,
              testSupport: function (n) {
                !uc && pa && (il ? Sp(n) : (jr = n));
              },
            };
            let jr,
              pa,
              uc = !1,
              il = !1;
            const Tp = typeof self < "u" ? self : {};
            function Sp(n) {
              const e = n.createTexture();
              n.bindTexture(n.TEXTURE_2D, e);
              try {
                if (
                  (n.texImage2D(
                    n.TEXTURE_2D,
                    0,
                    n.RGBA,
                    n.RGBA,
                    n.UNSIGNED_BYTE,
                    pa,
                  ),
                  n.isContextLost())
                )
                  return;
                rd.supported = !0;
              } catch {}
              (n.deleteTexture(e), (uc = !0));
            }
            Tp.document &&
              ((pa = Tp.document.createElement("img")),
              (pa.onload = function () {
                (jr && Sp(jr), (jr = null), (il = !0));
              }),
              (pa.onerror = function () {
                ((uc = !0), (jr = null));
              }),
              (pa.src =
                "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="));
            const dc = {
              Unknown: "Unknown",
              Style: "Style",
              Source: "Source",
              Tile: "Tile",
              Glyphs: "Glyphs",
              SpriteImage: "SpriteImage",
              SpriteJSON: "SpriteJSON",
              Iconset: "Iconset",
              Image: "Image",
              Model: "Model",
            };
            typeof Object.freeze == "function" && Object.freeze(dc);
            class Ei extends Error {
              constructor(e, i, o) {
                (i === 401 &&
                  Po(o) &&
                  (e +=
                    ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"),
                  super(e),
                  (this.status = i),
                  (this.url = o));
              }
              toString() {
                return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
              }
            }
            const Ch = Ui()
                ? () => self.worker.referrer
                : () =>
                    (location.protocol === "blob:" ? parent : self).location
                      .href,
              nl = function (n, e) {
                if (
                  !(
                    /^file:/.test((i = n.url)) ||
                    (/^file:/.test(Ch()) && !/^\w+:/.test(i))
                  )
                ) {
                  if (
                    self.fetch &&
                    self.Request &&
                    self.AbortController &&
                    Request.prototype.hasOwnProperty("signal")
                  )
                    return (function (o, a) {
                      const u = new AbortController(),
                        d = new Request(o.url, {
                          method: o.method || "GET",
                          body: o.body,
                          credentials: o.credentials,
                          headers: o.headers,
                          referrer: Ch(),
                          referrerPolicy: o.referrerPolicy,
                          signal: u.signal,
                        });
                      let _ = !1,
                        v = !1;
                      const b = (E = d.url).indexOf("sku=") > 0 && Po(E);
                      var E;
                      o.type === "json" &&
                        d.headers.set("Accept", "application/json");
                      const A = (R, k, N) => {
                          if (v) return;
                          if (
                            (R &&
                              R.message !== "SecurityError" &&
                              ri(R.toString()),
                            k && N)
                          )
                            return M(k);
                          const j = Date.now();
                          fetch(d)
                            .then((H) => {
                              if (H.ok) {
                                const J = b ? H.clone() : null;
                                return M(H, J, j);
                              }
                              return a(new Ei(H.statusText, H.status, o.url));
                            })
                            .catch((H) => {
                              H.name !== "AbortError" &&
                                a(new Error(`${H.message} ${o.url}`));
                            });
                        },
                        M = (R, k, N) => {
                          (o.type === "arrayBuffer"
                            ? R.arrayBuffer()
                            : o.type === "json"
                              ? R.json()
                              : R.text()
                          )
                            .then((j) => {
                              v ||
                                (k &&
                                  N &&
                                  (function (H, J, Q) {
                                    if ((tl(), Fs == null)) return;
                                    const V = Pi(
                                      J.headers.get("Cache-Control") || "",
                                    );
                                    if (V["no-store"]) return;
                                    const X = {
                                      status: J.status,
                                      statusText: J.statusText,
                                      headers: new Headers(),
                                    };
                                    (J.headers.forEach((ve, ge) =>
                                      X.headers.set(ge, ve),
                                    ),
                                      V["max-age"] &&
                                        X.headers.set(
                                          "Expires",
                                          new Date(
                                            Q + 1e3 * V["max-age"],
                                          ).toUTCString(),
                                        ));
                                    const ee = X.headers.get("Expires");
                                    if (
                                      !ee ||
                                      new Date(ee).getTime() - Q < 42e4
                                    )
                                      return;
                                    let re = gs(H.url, {
                                      persistentParams: cc,
                                    });
                                    if (J.status === 206) {
                                      const ve = H.headers.get("Range");
                                      if (!ve) return;
                                      ((X.status = 200),
                                        (re = ss(re, { range: ve })));
                                    }
                                    (function (ve, ge) {
                                      if (hc === void 0)
                                        try {
                                          (new Response(new ReadableStream()),
                                            (hc = !0));
                                        } catch {
                                          hc = !1;
                                        }
                                      hc
                                        ? ge(ve.body)
                                        : ve
                                            .blob()
                                            .then(ge)
                                            .catch((be) => ri(be.message));
                                    })(J, (ve) => {
                                      const ge = new Response(
                                        (be = J.status) !== 200 &&
                                        be !== 404 &&
                                        [101, 103, 204, 205, 304].includes(be)
                                          ? null
                                          : ve,
                                        X,
                                      );
                                      var be;
                                      (tl(),
                                        Fs != null &&
                                          Fs.then((Me) => Me.put(re, ge)).catch(
                                            (Me) => ri(Me.message),
                                          ));
                                    });
                                  })(d, k, N),
                                (_ = !0),
                                a(
                                  null,
                                  j,
                                  R.headers.get("Cache-Control"),
                                  R.headers.get("Expires"),
                                ));
                            })
                            .catch((j) => {
                              v || a(new Error(j.message));
                            });
                        };
                      return (
                        b
                          ? (function (R, k) {
                              if ((tl(), Fs == null)) return k(null);
                              Fs.then((N) => {
                                let j = gs(R.url, { persistentParams: cc });
                                const H = R.headers.get("Range");
                                (H && (j = ss(j, { range: H })),
                                  N.match(j)
                                    .then((J) => {
                                      const Q = (function (V) {
                                        if (!V) return !1;
                                        const X = new Date(
                                            V.headers.get("Expires") || 0,
                                          ),
                                          ee = Pi(
                                            V.headers.get("Cache-Control") ||
                                              "",
                                          );
                                        return (
                                          Number(X) > Date.now() &&
                                          !ee["no-cache"]
                                        );
                                      })(J);
                                      (N.delete(j).catch(k),
                                        Q && N.put(j, J.clone()).catch(k),
                                        k(null, J, Q));
                                    })
                                    .catch(k));
                              }).catch(k);
                            })(d, A)
                          : A(null, null),
                        {
                          cancel: () => {
                            ((v = !0), _ || u.abort());
                          },
                        }
                      );
                    })(n, e);
                  if (Ui(self) && self.worker.actor)
                    return self.worker.actor.send(
                      "getResource",
                      n,
                      e,
                      void 0,
                      !0,
                    );
                }
                var i;
                return (function (o, a) {
                  const u = new XMLHttpRequest();
                  (u.open(o.method || "GET", o.url, !0),
                    o.type === "arrayBuffer" &&
                      (u.responseType = "arraybuffer"));
                  for (const d in o.headers)
                    u.setRequestHeader(d, o.headers[d]);
                  return (
                    o.type === "json" &&
                      ((u.responseType = "text"),
                      u.setRequestHeader("Accept", "application/json")),
                    (u.withCredentials = o.credentials === "include"),
                    (u.onerror = () => {
                      a(new Error(u.statusText));
                    }),
                    (u.onload = () => {
                      if (
                        ((u.status >= 200 && u.status < 300) ||
                          u.status === 0) &&
                        u.response !== null
                      ) {
                        let d = u.response;
                        if (o.type === "json")
                          try {
                            d = JSON.parse(u.response);
                          } catch (_) {
                            return a(_);
                          }
                        a(
                          null,
                          d,
                          u.getResponseHeader("Cache-Control"),
                          u.getResponseHeader("Expires"),
                        );
                      } else a(new Ei(u.statusText, u.status, o.url));
                    }),
                    u.send(o.body),
                    { cancel: () => u.abort() }
                  );
                })(n, e);
              },
              fc = function (n, e) {
                return nl(Le(n, { type: "arrayBuffer" }), e);
              };
            function c_(n) {
              const e = document.createElement("a");
              return (
                (e.href = n),
                e.protocol === location.protocol && e.host === location.host
              );
            }
            const pc =
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
            let ma, Do;
            ((ma = []), (Do = 0));
            const sd = function (n, e) {
              if (
                (rd.supported &&
                  (n.headers || (n.headers = {}),
                  (n.headers.accept = "image/webp,*/*")),
                Do >= hr.MAX_PARALLEL_IMAGE_REQUESTS)
              ) {
                const u = {
                  requestParameters: n,
                  callback: e,
                  cancelled: !1,
                  cancel() {
                    this.cancelled = !0;
                  },
                };
                return (ma.push(u), u);
              }
              Do++;
              let i = !1;
              const o = () => {
                  if (!i)
                    for (
                      i = !0, Do--;
                      ma.length && Do < hr.MAX_PARALLEL_IMAGE_REQUESTS;

                    ) {
                      const u = ma.shift(),
                        { requestParameters: d, callback: _, cancelled: v } = u;
                      v || (u.cancel = sd(d, _).cancel);
                    }
                },
                a = fc(n, (u, d, _, v) => {
                  (o(),
                    u
                      ? e(u)
                      : d &&
                        (self.createImageBitmap
                          ? (function (b, E) {
                              const A = new Blob([new Uint8Array(b)], {
                                type: "image/png",
                              });
                              createImageBitmap(A)
                                .then((M) => {
                                  E(null, M);
                                })
                                .catch((M) => {
                                  E(
                                    new Error(
                                      `Could not load image because of ${M.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`,
                                    ),
                                  );
                                });
                            })(d, (b, E) => e(b, E, _, v))
                          : (function (b, E) {
                              const A = new Image();
                              ((A.onload = () => {
                                (E(null, A),
                                  URL.revokeObjectURL(A.src),
                                  (A.onload = null),
                                  requestAnimationFrame(() => {
                                    A.src = pc;
                                  }));
                              }),
                                (A.onerror = () =>
                                  E(
                                    new Error(
                                      "Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.",
                                    ),
                                  )));
                              const M = new Blob([new Uint8Array(b)], {
                                type: "image/png",
                              });
                              A.src = b.byteLength
                                ? URL.createObjectURL(M)
                                : pc;
                            })(d, (b, E) => e(b, E, _, v))));
                });
              return {
                cancel: () => {
                  (a.cancel(), o());
                },
              };
            };
            var od,
              ga,
              Ep,
              ro = { exports: {} },
              Ph = { exports: {} },
              Dh = { exports: {} },
              Cs = (function () {
                if (Ep) return ro.exports;
                Ep = 1;
                var n =
                    (od ||
                      ((od = 1),
                      (Ph.exports = function (i, o) {
                        var a, u, d, _, v, b, E, A;
                        for (
                          u = i.length - (a = 3 & i.length),
                            d = o,
                            v = 3432918353,
                            b = 461845907,
                            A = 0;
                          A < u;

                        )
                          ((E =
                            (255 & i.charCodeAt(A)) |
                            ((255 & i.charCodeAt(++A)) << 8) |
                            ((255 & i.charCodeAt(++A)) << 16) |
                            ((255 & i.charCodeAt(++A)) << 24)),
                            ++A,
                            (d =
                              27492 +
                              (65535 &
                                (_ =
                                  (5 *
                                    (65535 &
                                      (d =
                                        ((d ^= E =
                                          ((65535 &
                                            (E =
                                              ((E =
                                                ((65535 & E) * v +
                                                  ((((E >>> 16) * v) & 65535) <<
                                                    16)) &
                                                4294967295) <<
                                                15) |
                                              (E >>> 17))) *
                                            b +
                                            ((((E >>> 16) * b) & 65535) <<
                                              16)) &
                                          4294967295) <<
                                          13) |
                                        (d >>> 19))) +
                                    (((5 * (d >>> 16)) & 65535) << 16)) &
                                  4294967295)) +
                              (((58964 + (_ >>> 16)) & 65535) << 16)));
                        switch (((E = 0), a)) {
                          case 3:
                            E ^= (255 & i.charCodeAt(A + 2)) << 16;
                          case 2:
                            E ^= (255 & i.charCodeAt(A + 1)) << 8;
                          case 1:
                            d ^= E =
                              ((65535 &
                                (E =
                                  ((E =
                                    ((65535 & (E ^= 255 & i.charCodeAt(A))) *
                                      v +
                                      ((((E >>> 16) * v) & 65535) << 16)) &
                                    4294967295) <<
                                    15) |
                                  (E >>> 17))) *
                                b +
                                ((((E >>> 16) * b) & 65535) << 16)) &
                              4294967295;
                        }
                        return (
                          (d ^= i.length),
                          (d =
                            (2246822507 * (65535 & (d ^= d >>> 16)) +
                              (((2246822507 * (d >>> 16)) & 65535) << 16)) &
                            4294967295),
                          (d =
                            (3266489909 * (65535 & (d ^= d >>> 13)) +
                              (((3266489909 * (d >>> 16)) & 65535) << 16)) &
                            4294967295),
                          (d ^= d >>> 16) >>> 0
                        );
                      })),
                    Ph.exports),
                  e =
                    (ga ||
                      ((ga = 1),
                      (Dh.exports = function (i, o) {
                        for (var a, u = i.length, d = o ^ u, _ = 0; u >= 4; )
                          ((a =
                            1540483477 *
                              (65535 &
                                (a =
                                  (255 & i.charCodeAt(_)) |
                                  ((255 & i.charCodeAt(++_)) << 8) |
                                  ((255 & i.charCodeAt(++_)) << 16) |
                                  ((255 & i.charCodeAt(++_)) << 24))) +
                            (((1540483477 * (a >>> 16)) & 65535) << 16)),
                            (d =
                              (1540483477 * (65535 & d) +
                                (((1540483477 * (d >>> 16)) & 65535) << 16)) ^
                              (a =
                                1540483477 * (65535 & (a ^= a >>> 24)) +
                                (((1540483477 * (a >>> 16)) & 65535) << 16))),
                            (u -= 4),
                            ++_);
                        switch (u) {
                          case 3:
                            d ^= (255 & i.charCodeAt(_ + 2)) << 16;
                          case 2:
                            d ^= (255 & i.charCodeAt(_ + 1)) << 8;
                          case 1:
                            d =
                              1540483477 *
                                (65535 & (d ^= 255 & i.charCodeAt(_))) +
                              (((1540483477 * (d >>> 16)) & 65535) << 16);
                        }
                        return (
                          (d =
                            1540483477 * (65535 & (d ^= d >>> 13)) +
                            (((1540483477 * (d >>> 16)) & 65535) << 16)),
                          (d ^= d >>> 15) >>> 0
                        );
                      })),
                    Dh.exports);
                return (
                  (ro.exports = n),
                  (ro.exports.murmur3 = n),
                  (ro.exports.murmur2 = e),
                  ro.exports
                );
              })(),
              mc = Co(Cs);
            class _a {
              constructor(e, ...i) {
                (Le(this, i[0] || {}), (this.type = e));
              }
            }
            class Rh extends _a {
              constructor(e, i = {}) {
                super("error", Le({ error: e }, i));
              }
            }
            function ad(n, e, i) {
              (i[n] && i[n].indexOf(e) !== -1) ||
                ((i[n] = i[n] || []), i[n].push(e));
            }
            function zh(n, e, i) {
              if (i && i[n]) {
                const o = i[n].indexOf(e);
                o !== -1 && i[n].splice(o, 1);
              }
            }
            class ya {
              on(e, i) {
                return (
                  (this._listeners = this._listeners || {}),
                  ad(e, i, this._listeners),
                  this
                );
              }
              off(e, i) {
                return (
                  zh(e, i, this._listeners),
                  zh(e, i, this._oneTimeListeners),
                  this
                );
              }
              once(e, i) {
                return i
                  ? ((this._oneTimeListeners = this._oneTimeListeners || {}),
                    ad(e, i, this._oneTimeListeners),
                    this)
                  : new Promise((o) => {
                      this.once(e, o);
                    });
              }
              fire(e, i) {
                const o = typeof e == "string" ? new _a(e, i) : e,
                  a = o.type;
                if (this.listens(a)) {
                  o.target = this;
                  const u =
                    this._listeners && this._listeners[a]
                      ? this._listeners[a].slice()
                      : [];
                  for (const v of u) v.call(this, o);
                  const d =
                    this._oneTimeListeners && this._oneTimeListeners[a]
                      ? this._oneTimeListeners[a].slice()
                      : [];
                  for (const v of d)
                    (zh(a, v, this._oneTimeListeners), v.call(this, o));
                  const _ = this._eventedParent;
                  _ &&
                    (Le(
                      o,
                      typeof this._eventedParentData == "function"
                        ? this._eventedParentData()
                        : this._eventedParentData,
                    ),
                    _.fire(o));
                } else o instanceof Rh && console.error(o.error);
                return this;
              }
              listens(e) {
                return !!(
                  (this._listeners &&
                    this._listeners[e] &&
                    this._listeners[e].length > 0) ||
                  (this._oneTimeListeners &&
                    this._oneTimeListeners[e] &&
                    this._oneTimeListeners[e].length > 0) ||
                  (this._eventedParent && this._eventedParent.listens(e))
                );
              }
              setEventedParent(e, i) {
                return (
                  (this._eventedParent = e),
                  (this._eventedParentData = i),
                  this
                );
              }
            }
            class Kr {
              constructor(e) {
                typeof e == "string"
                  ? (this.name = e)
                  : ((this.name = e.name), (this.iconsetId = e.iconsetId));
              }
              static from(e) {
                return new Kr(e);
              }
              static toString(e) {
                return e.iconsetId ? `${e.name}${e.iconsetId}` : e.name;
              }
              static parse(e) {
                const [i, o] = e.split("");
                return new Kr({ name: i, iconsetId: o });
              }
              static isEqual(e, i) {
                return e.name === i.name && e.iconsetId === i.iconsetId;
              }
              toString() {
                return Kr.toString(this);
              }
              serialize() {
                return { name: this.name, iconsetId: this.iconsetId };
              }
            }
            var ld,
              rl = {},
              xa = (function () {
                if (ld) return rl;
                ld = 1;
                var n = {
                  transparent: [0, 0, 0, 0],
                  aliceblue: [240, 248, 255, 1],
                  antiquewhite: [250, 235, 215, 1],
                  aqua: [0, 255, 255, 1],
                  aquamarine: [127, 255, 212, 1],
                  azure: [240, 255, 255, 1],
                  beige: [245, 245, 220, 1],
                  bisque: [255, 228, 196, 1],
                  black: [0, 0, 0, 1],
                  blanchedalmond: [255, 235, 205, 1],
                  blue: [0, 0, 255, 1],
                  blueviolet: [138, 43, 226, 1],
                  brown: [165, 42, 42, 1],
                  burlywood: [222, 184, 135, 1],
                  cadetblue: [95, 158, 160, 1],
                  chartreuse: [127, 255, 0, 1],
                  chocolate: [210, 105, 30, 1],
                  coral: [255, 127, 80, 1],
                  cornflowerblue: [100, 149, 237, 1],
                  cornsilk: [255, 248, 220, 1],
                  crimson: [220, 20, 60, 1],
                  cyan: [0, 255, 255, 1],
                  darkblue: [0, 0, 139, 1],
                  darkcyan: [0, 139, 139, 1],
                  darkgoldenrod: [184, 134, 11, 1],
                  darkgray: [169, 169, 169, 1],
                  darkgreen: [0, 100, 0, 1],
                  darkgrey: [169, 169, 169, 1],
                  darkkhaki: [189, 183, 107, 1],
                  darkmagenta: [139, 0, 139, 1],
                  darkolivegreen: [85, 107, 47, 1],
                  darkorange: [255, 140, 0, 1],
                  darkorchid: [153, 50, 204, 1],
                  darkred: [139, 0, 0, 1],
                  darksalmon: [233, 150, 122, 1],
                  darkseagreen: [143, 188, 143, 1],
                  darkslateblue: [72, 61, 139, 1],
                  darkslategray: [47, 79, 79, 1],
                  darkslategrey: [47, 79, 79, 1],
                  darkturquoise: [0, 206, 209, 1],
                  darkviolet: [148, 0, 211, 1],
                  deeppink: [255, 20, 147, 1],
                  deepskyblue: [0, 191, 255, 1],
                  dimgray: [105, 105, 105, 1],
                  dimgrey: [105, 105, 105, 1],
                  dodgerblue: [30, 144, 255, 1],
                  firebrick: [178, 34, 34, 1],
                  floralwhite: [255, 250, 240, 1],
                  forestgreen: [34, 139, 34, 1],
                  fuchsia: [255, 0, 255, 1],
                  gainsboro: [220, 220, 220, 1],
                  ghostwhite: [248, 248, 255, 1],
                  gold: [255, 215, 0, 1],
                  goldenrod: [218, 165, 32, 1],
                  gray: [128, 128, 128, 1],
                  green: [0, 128, 0, 1],
                  greenyellow: [173, 255, 47, 1],
                  grey: [128, 128, 128, 1],
                  honeydew: [240, 255, 240, 1],
                  hotpink: [255, 105, 180, 1],
                  indianred: [205, 92, 92, 1],
                  indigo: [75, 0, 130, 1],
                  ivory: [255, 255, 240, 1],
                  khaki: [240, 230, 140, 1],
                  lavender: [230, 230, 250, 1],
                  lavenderblush: [255, 240, 245, 1],
                  lawngreen: [124, 252, 0, 1],
                  lemonchiffon: [255, 250, 205, 1],
                  lightblue: [173, 216, 230, 1],
                  lightcoral: [240, 128, 128, 1],
                  lightcyan: [224, 255, 255, 1],
                  lightgoldenrodyellow: [250, 250, 210, 1],
                  lightgray: [211, 211, 211, 1],
                  lightgreen: [144, 238, 144, 1],
                  lightgrey: [211, 211, 211, 1],
                  lightpink: [255, 182, 193, 1],
                  lightsalmon: [255, 160, 122, 1],
                  lightseagreen: [32, 178, 170, 1],
                  lightskyblue: [135, 206, 250, 1],
                  lightslategray: [119, 136, 153, 1],
                  lightslategrey: [119, 136, 153, 1],
                  lightsteelblue: [176, 196, 222, 1],
                  lightyellow: [255, 255, 224, 1],
                  lime: [0, 255, 0, 1],
                  limegreen: [50, 205, 50, 1],
                  linen: [250, 240, 230, 1],
                  magenta: [255, 0, 255, 1],
                  maroon: [128, 0, 0, 1],
                  mediumaquamarine: [102, 205, 170, 1],
                  mediumblue: [0, 0, 205, 1],
                  mediumorchid: [186, 85, 211, 1],
                  mediumpurple: [147, 112, 219, 1],
                  mediumseagreen: [60, 179, 113, 1],
                  mediumslateblue: [123, 104, 238, 1],
                  mediumspringgreen: [0, 250, 154, 1],
                  mediumturquoise: [72, 209, 204, 1],
                  mediumvioletred: [199, 21, 133, 1],
                  midnightblue: [25, 25, 112, 1],
                  mintcream: [245, 255, 250, 1],
                  mistyrose: [255, 228, 225, 1],
                  moccasin: [255, 228, 181, 1],
                  navajowhite: [255, 222, 173, 1],
                  navy: [0, 0, 128, 1],
                  oldlace: [253, 245, 230, 1],
                  olive: [128, 128, 0, 1],
                  olivedrab: [107, 142, 35, 1],
                  orange: [255, 165, 0, 1],
                  orangered: [255, 69, 0, 1],
                  orchid: [218, 112, 214, 1],
                  palegoldenrod: [238, 232, 170, 1],
                  palegreen: [152, 251, 152, 1],
                  paleturquoise: [175, 238, 238, 1],
                  palevioletred: [219, 112, 147, 1],
                  papayawhip: [255, 239, 213, 1],
                  peachpuff: [255, 218, 185, 1],
                  peru: [205, 133, 63, 1],
                  pink: [255, 192, 203, 1],
                  plum: [221, 160, 221, 1],
                  powderblue: [176, 224, 230, 1],
                  purple: [128, 0, 128, 1],
                  rebeccapurple: [102, 51, 153, 1],
                  red: [255, 0, 0, 1],
                  rosybrown: [188, 143, 143, 1],
                  royalblue: [65, 105, 225, 1],
                  saddlebrown: [139, 69, 19, 1],
                  salmon: [250, 128, 114, 1],
                  sandybrown: [244, 164, 96, 1],
                  seagreen: [46, 139, 87, 1],
                  seashell: [255, 245, 238, 1],
                  sienna: [160, 82, 45, 1],
                  silver: [192, 192, 192, 1],
                  skyblue: [135, 206, 235, 1],
                  slateblue: [106, 90, 205, 1],
                  slategray: [112, 128, 144, 1],
                  slategrey: [112, 128, 144, 1],
                  snow: [255, 250, 250, 1],
                  springgreen: [0, 255, 127, 1],
                  steelblue: [70, 130, 180, 1],
                  tan: [210, 180, 140, 1],
                  teal: [0, 128, 128, 1],
                  thistle: [216, 191, 216, 1],
                  tomato: [255, 99, 71, 1],
                  turquoise: [64, 224, 208, 1],
                  violet: [238, 130, 238, 1],
                  wheat: [245, 222, 179, 1],
                  white: [255, 255, 255, 1],
                  whitesmoke: [245, 245, 245, 1],
                  yellow: [255, 255, 0, 1],
                  yellowgreen: [154, 205, 50, 1],
                };
                function e(u) {
                  return (u = Math.round(u)) < 0 ? 0 : u > 255 ? 255 : u;
                }
                function i(u) {
                  return e(
                    u[u.length - 1] === "%"
                      ? (parseFloat(u) / 100) * 255
                      : parseInt(u),
                  );
                }
                function o(u) {
                  return (d =
                    u[u.length - 1] === "%"
                      ? parseFloat(u) / 100
                      : parseFloat(u)) < 0
                    ? 0
                    : d > 1
                      ? 1
                      : d;
                  var d;
                }
                function a(u, d, _) {
                  return (
                    _ < 0 ? (_ += 1) : _ > 1 && (_ -= 1),
                    6 * _ < 1
                      ? u + (d - u) * _ * 6
                      : 2 * _ < 1
                        ? d
                        : 3 * _ < 2
                          ? u + (d - u) * (2 / 3 - _) * 6
                          : u
                  );
                }
                try {
                  rl.parseCSSColor = function (u) {
                    var d,
                      _ = u.replace(/ /g, "").toLowerCase();
                    if (_ in n) return n[_].slice();
                    if (_[0] === "#")
                      return _.length === 4
                        ? (d = parseInt(_.substr(1), 16)) >= 0 && d <= 4095
                          ? [
                              ((3840 & d) >> 4) | ((3840 & d) >> 8),
                              (240 & d) | ((240 & d) >> 4),
                              (15 & d) | ((15 & d) << 4),
                              1,
                            ]
                          : null
                        : _.length === 7 &&
                            (d = parseInt(_.substr(1), 16)) >= 0 &&
                            d <= 16777215
                          ? [(16711680 & d) >> 16, (65280 & d) >> 8, 255 & d, 1]
                          : null;
                    var v = _.indexOf("("),
                      b = _.indexOf(")");
                    if (v !== -1 && b + 1 === _.length) {
                      var E = _.substr(0, v),
                        A = _.substr(v + 1, b - (v + 1)).split(","),
                        M = 1;
                      switch (E) {
                        case "rgba":
                          if (A.length !== 4) return null;
                          M = o(A.pop());
                        case "rgb":
                          return A.length !== 3
                            ? null
                            : [i(A[0]), i(A[1]), i(A[2]), M];
                        case "hsla":
                          if (A.length !== 4) return null;
                          M = o(A.pop());
                        case "hsl":
                          if (A.length !== 3) return null;
                          var R =
                              (((parseFloat(A[0]) % 360) + 360) % 360) / 360,
                            k = o(A[1]),
                            N = o(A[2]),
                            j = N <= 0.5 ? N * (k + 1) : N + k - N * k,
                            H = 2 * N - j;
                          return [
                            e(255 * a(H, j, R + 1 / 3)),
                            e(255 * a(H, j, R)),
                            e(255 * a(H, j, R - 1 / 3)),
                            M,
                          ];
                        default:
                          return null;
                      }
                    }
                    return null;
                  };
                } catch {}
                return rl;
              })();
            class Li {
              constructor(e, i, o, a = 1) {
                ((this.r = e), (this.g = i), (this.b = o), (this.a = a));
              }
              static parse(e) {
                if (!e) return;
                if (e instanceof Li) return e;
                if (typeof e != "string") return;
                const i = xa.parseCSSColor(e);
                return i
                  ? new Li(i[0] / 255, i[1] / 255, i[2] / 255, i[3])
                  : void 0;
              }
              toString() {
                const [e, i, o, a] = [this.r, this.g, this.b, this.a];
                return `rgba(${Math.round(255 * e)},${Math.round(255 * i)},${Math.round(255 * o)},${a})`;
              }
              toNonPremultipliedRenderColor(e) {
                const { r: i, g: o, b: a, a: u } = this;
                return new h_(e, i, o, a, u);
              }
              toPremultipliedRenderColor(e) {
                const { r: i, g: o, b: a, a: u } = this;
                return new cd(e, i * u, o * u, a * u, u);
              }
              clone() {
                return new Li(this.r, this.g, this.b, this.a);
              }
            }
            class Ps {
              constructor(e, i, o, a, u, d = !1) {
                if (((this.premultiplied = !1), (this.premultiplied = d), e)) {
                  const _ = e.image.height,
                    v = _ * _;
                  this.premultiplied
                    ? ((i = u === 0 ? 0 : (i / u) * (_ - 1)),
                      (o = u === 0 ? 0 : (o / u) * (_ - 1)),
                      (a = u === 0 ? 0 : (a / u) * (_ - 1)))
                    : ((i *= _ - 1), (o *= _ - 1), (a *= _ - 1));
                  const b = Math.floor(i),
                    E = Math.floor(o),
                    A = Math.floor(a),
                    M = Math.ceil(i),
                    R = Math.ceil(o),
                    k = Math.ceil(a),
                    N = i - b,
                    j = o - E,
                    H = a - A,
                    J = e.image.data,
                    Q = 4 * (b + E * v + A * _),
                    V = 4 * (b + E * v + k * _),
                    X = 4 * (b + R * v + A * _),
                    ee = 4 * (b + R * v + k * _),
                    re = 4 * (M + E * v + A * _),
                    ve = 4 * (M + E * v + k * _),
                    ge = 4 * (M + R * v + A * _),
                    be = 4 * (M + R * v + k * _);
                  if (Q < 0 || be >= J.length) throw new Error("out of range");
                  ((this.r =
                    (Ht(
                      Ht(Ht(J[Q], J[V], H), Ht(J[X], J[ee], H), j),
                      Ht(Ht(J[re], J[ve], H), Ht(J[ge], J[be], H), j),
                      N,
                    ) /
                      255) *
                    (this.premultiplied ? u : 1)),
                    (this.g =
                      (Ht(
                        Ht(
                          Ht(J[Q + 1], J[V + 1], H),
                          Ht(J[X + 1], J[ee + 1], H),
                          j,
                        ),
                        Ht(
                          Ht(J[re + 1], J[ve + 1], H),
                          Ht(J[ge + 1], J[be + 1], H),
                          j,
                        ),
                        N,
                      ) /
                        255) *
                      (this.premultiplied ? u : 1)),
                    (this.b =
                      (Ht(
                        Ht(
                          Ht(J[Q + 2], J[V + 2], H),
                          Ht(J[X + 2], J[ee + 2], H),
                          j,
                        ),
                        Ht(
                          Ht(J[re + 2], J[ve + 2], H),
                          Ht(J[ge + 2], J[be + 2], H),
                          j,
                        ),
                        N,
                      ) /
                        255) *
                      (this.premultiplied ? u : 1)),
                    (this.a = u));
                } else ((this.r = i), (this.g = o), (this.b = a), (this.a = u));
              }
              toArray() {
                const { r: e, g: i, b: o, a } = this;
                return [255 * e, 255 * i, 255 * o, a];
              }
              toHslaArray() {
                let { r: e, g: i, b: o, a } = this;
                if (this.premultiplied) {
                  if (a === 0) return [0, 0, 0, 0];
                  ((e /= a), (i /= a), (o /= a));
                }
                const u = Math.min(Math.max(e, 0), 1),
                  d = Math.min(Math.max(i, 0), 1),
                  _ = Math.min(Math.max(o, 0), 1),
                  v = Math.min(u, d, _),
                  b = Math.max(u, d, _),
                  E = (v + b) / 2;
                if (v === b) return [0, 0, 100 * E, a];
                const A = b - v,
                  M = E > 0.5 ? A / (2 - b - v) : A / (b + v);
                let R = 0;
                return (
                  b === u
                    ? (R = (d - _) / A + (d < _ ? 6 : 0))
                    : b === d
                      ? (R = (_ - u) / A + 2)
                      : b === _ && (R = (u - d) / A + 4),
                  (R *= 60),
                  [
                    Math.min(Math.max(R, 0), 360),
                    Math.min(Math.max(100 * M, 0), 100),
                    Math.min(Math.max(100 * E, 0), 100),
                    a,
                  ]
                );
              }
              toArray01() {
                const { r: e, g: i, b: o, a } = this;
                return [e, i, o, a];
              }
              toArray01Scaled(e) {
                const { r: i, g: o, b: a } = this;
                return [i * e, o * e, a * e];
              }
              toArray01Linear() {
                const { r: e, g: i, b: o, a } = this;
                return [
                  Math.pow(e, 2.2),
                  Math.pow(i, 2.2),
                  Math.pow(o, 2.2),
                  a,
                ];
              }
            }
            class h_ extends Ps {
              constructor(e, i, o, a, u) {
                super(e, i, o, a, u, !1);
              }
            }
            class cd extends Ps {
              constructor(e, i, o, a, u) {
                super(e, i, o, a, u, !0);
              }
            }
            function Ht(n, e, i) {
              return n * (1 - i) + e * i;
            }
            function kh(n, e, i) {
              return n.map((o, a) => Ht(o, e[a], i));
            }
            ((Li.black = new Li(0, 0, 0, 1)),
              (Li.white = new Li(1, 1, 1, 1)),
              (Li.transparent = new Li(0, 0, 0, 0)),
              (Li.red = new Li(1, 0, 0, 1)),
              (Li.blue = new Li(0, 0, 1, 1)));
            var gc = Object.freeze({
              __proto__: null,
              array: kh,
              color: function (n, e, i) {
                return new Li(
                  Ht(n.r, e.r, i),
                  Ht(n.g, e.g, i),
                  Ht(n.b, e.b, i),
                  Ht(n.a, e.a, i),
                );
              },
              number: Ht,
            });
            function va(n, ...e) {
              for (const i of e) for (const o in i) n[o] = i[o];
              return n;
            }
            class os extends Error {
              constructor(e, i) {
                (super(i), (this.message = i), (this.key = e));
              }
            }
            class hd {
              constructor(e, i = []) {
                ((this.parent = e), (this.bindings = {}));
                for (const [o, a] of i) this.bindings[o] = a;
              }
              concat(e) {
                return new hd(this, e);
              }
              get(e) {
                if (this.bindings[e]) return this.bindings[e];
                if (this.parent) return this.parent.get(e);
                throw new Error(`${e} not found in scope.`);
              }
              has(e) {
                return (
                  !!this.bindings[e] || (!!this.parent && this.parent.has(e))
                );
              }
            }
            const sl = { kind: "null" },
              Ft = { kind: "number" },
              $i = { kind: "string" },
              zi = { kind: "boolean" },
              Jr = { kind: "color" },
              so = { kind: "object" },
              Oi = { kind: "value" },
              Lh = { kind: "collator" },
              _c = { kind: "formatted" },
              yc = { kind: "resolvedImage" };
            function Dr(n, e) {
              return { kind: "array", itemType: n, N: e };
            }
            function Xn(n) {
              if (n.kind === "array") {
                const e = Xn(n.itemType);
                return typeof n.N == "number"
                  ? `array<${e}, ${n.N}>`
                  : n.itemType.kind === "value"
                    ? "array"
                    : `array<${e}>`;
              }
              return n.kind;
            }
            const u_ = [sl, Ft, $i, zi, Jr, _c, so, Dr(Oi), yc];
            function ol(n, e) {
              if (e.kind === "error") return null;
              if (n.kind === "array") {
                if (
                  e.kind === "array" &&
                  ((e.N === 0 && e.itemType.kind === "value") ||
                    !ol(n.itemType, e.itemType)) &&
                  (typeof n.N != "number" || n.N === e.N)
                )
                  return null;
              } else {
                if (n.kind === e.kind) return null;
                if (n.kind === "value") {
                  for (const i of u_) if (!ol(i, e)) return null;
                }
              }
              return `Expected ${Xn(n)} but found ${Xn(e)} instead.`;
            }
            function Ro(n, e) {
              return e.some((i) => i.kind === n.kind);
            }
            function xc(n, e) {
              return e.some((i) =>
                i === "null"
                  ? n === null
                  : i === "array"
                    ? Array.isArray(n)
                    : i === "object"
                      ? n && !Array.isArray(n) && typeof n == "object"
                      : i === typeof n,
              );
            }
            function Oh(n, e) {
              return n.kind === "array" && e.kind === "array"
                ? n.N === e.N && Oh(n.itemType, e.itemType)
                : n.kind === e.kind;
            }
            class vc {
              constructor(e, i, o) {
                ((this.sensitivity = e
                  ? i
                    ? "variant"
                    : "case"
                  : i
                    ? "accent"
                    : "base"),
                  (this.locale = o),
                  (this.collator = new Intl.Collator(
                    this.locale ? this.locale : [],
                    { sensitivity: this.sensitivity, usage: "search" },
                  )));
              }
              compare(e, i) {
                return this.collator.compare(e, i);
              }
              resolvedLocale() {
                return new Intl.Collator(
                  this.locale ? this.locale : [],
                ).resolvedOptions().locale;
              }
            }
            class Fh {
              constructor(e, i, o, a, u) {
                ((this.text = e.normalize ? e.normalize() : e),
                  (this.image = i),
                  (this.scale = o),
                  (this.fontStack = a),
                  (this.textColor = u));
              }
            }
            class Rr {
              constructor(e) {
                this.sections = e;
              }
              static fromString(e) {
                return new Rr([new Fh(e, null, null, null, null)]);
              }
              isEmpty() {
                return (
                  this.sections.length === 0 ||
                  !this.sections.some(
                    (e) =>
                      e.text.length !== 0 ||
                      (!!e.image && e.image.hasPrimary()),
                  )
                );
              }
              static factory(e) {
                return e instanceof Rr ? e : Rr.fromString(e);
              }
              toString() {
                return this.sections.length === 0
                  ? ""
                  : this.sections.map((e) => e.text).join("");
              }
              serialize() {
                const e = ["format"];
                for (const i of this.sections) {
                  if (i.image) {
                    const a = i.image.getPrimary().id.toString();
                    e.push(["image", a]);
                    continue;
                  }
                  e.push(i.text);
                  const o = {};
                  (i.fontStack &&
                    (o["text-font"] = ["literal", i.fontStack.split(",")]),
                    i.scale && (o["font-scale"] = i.scale),
                    i.textColor &&
                      (o["text-color"] = ["rgba"].concat(
                        i.textColor
                          .toNonPremultipliedRenderColor(null)
                          .toArray(),
                      )),
                    e.push(o));
                }
                return e;
              }
            }
            class oo {
              constructor(e, i = {}) {
                if (
                  ((this.id = Kr.from(e)),
                  (this.options = Object.assign({}, i)),
                  i.transform)
                ) {
                  const { a: o, b: a, c: u, d, e: _, f: v } = i.transform;
                  this.options.transform = new DOMMatrix([o, a, u, d, _, v]);
                } else
                  this.options.transform = new DOMMatrix([1, 0, 0, 1, 0, 0]);
              }
              toString() {
                const {
                  a: e,
                  b: i,
                  c: o,
                  d: a,
                  e: u,
                  f: d,
                } = this.options.transform;
                return JSON.stringify({
                  name: this.id.name,
                  iconsetId: this.id.iconsetId,
                  params: this.options.params,
                  transform: { a: e, b: i, c: o, d: a, e: u, f: d },
                });
              }
              static parse(e) {
                let i, o, a, u;
                try {
                  ({
                    name: i,
                    iconsetId: o,
                    params: a,
                    transform: u,
                  } = JSON.parse(e) || {});
                } catch {
                  return null;
                }
                if (!i) return null;
                const { a: d, b: _, c: v, d: b, e: E, f: A } = u || {};
                return new oo(
                  { name: i, iconsetId: o },
                  { params: a, transform: new DOMMatrix([d, _, v, b, E, A]) },
                );
              }
              scaleSelf(e, i) {
                return (this.options.transform.scaleSelf(e, i), this);
              }
            }
            class Gr {
              constructor(e, i, o, a, u = !1) {
                ((this.primaryId = Kr.from(e)),
                  (this.primaryOptions = i),
                  o && (this.secondaryId = Kr.from(o)),
                  (this.secondaryOptions = a),
                  (this.available = u));
              }
              toString() {
                return this.primaryId && this.secondaryId
                  ? `[${this.primaryId.name},${this.secondaryId.name}]`
                  : this.primaryId.name;
              }
              hasPrimary() {
                return !!this.primaryId;
              }
              getPrimary() {
                return new oo(this.primaryId, this.primaryOptions);
              }
              hasSecondary() {
                return !!this.secondaryId;
              }
              getSecondary() {
                return this.secondaryId
                  ? new oo(this.secondaryId, this.secondaryOptions)
                  : null;
              }
              static from(e) {
                return typeof e == "string" ? Gr.build({ name: e }) : e;
              }
              static build(e, i, o, a) {
                return !e || (typeof e == "object" && !("name" in e))
                  ? null
                  : new Gr(e, o, i, a);
              }
            }
            function ba(n, e, i, o) {
              return typeof n == "number" &&
                n >= 0 &&
                n <= 255 &&
                typeof e == "number" &&
                e >= 0 &&
                e <= 255 &&
                typeof i == "number" &&
                i >= 0 &&
                i <= 255
                ? o === void 0 || (typeof o == "number" && o >= 0 && o <= 1)
                  ? null
                  : `Invalid rgba value [${[n, e, i, o].join(", ")}]: 'a' must be between 0 and 1.`
                : `Invalid rgba value [${(typeof o == "number" ? [n, e, i, o] : [n, e, i]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
            }
            function ui(n) {
              if (
                n === null ||
                typeof n == "string" ||
                typeof n == "boolean" ||
                typeof n == "number" ||
                n instanceof Li ||
                n instanceof vc ||
                n instanceof Rr ||
                n instanceof Gr
              )
                return !0;
              if (Array.isArray(n)) {
                for (const e of n) if (!ui(e)) return !1;
                return !0;
              }
              if (typeof n == "object") {
                for (const e in n) if (!ui(n[e])) return !1;
                return !0;
              }
              return !1;
            }
            function wt(n) {
              if (n === null) return sl;
              if (typeof n == "string") return $i;
              if (typeof n == "boolean") return zi;
              if (typeof n == "number") return Ft;
              if (n instanceof Li) return Jr;
              if (n instanceof vc) return Lh;
              if (n instanceof Rr) return _c;
              if (n instanceof Gr) return yc;
              if (Array.isArray(n)) {
                const e = n.length;
                let i;
                for (const o of n) {
                  const a = wt(o);
                  if (i) {
                    if (i === a) continue;
                    i = Oi;
                    break;
                  }
                  i = a;
                }
                return Dr(i || Oi, e);
              }
              return so;
            }
            function _s(n) {
              const e = typeof n;
              return n === null
                ? ""
                : e === "string" || e === "number" || e === "boolean"
                  ? String(n)
                  : n instanceof Rr || n instanceof Gr || n instanceof Li
                    ? n.toString()
                    : JSON.stringify(n);
            }
            class Yt {
              constructor(e, i) {
                ((this.type = e), (this.value = i));
              }
              static parse(e, i) {
                if (e.length !== 2)
                  return i.error(
                    `'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`,
                  );
                if (!ui(e[1])) return i.error("invalid value");
                const o = e[1];
                let a = wt(o);
                const u = i.expectedType;
                return (
                  a.kind !== "array" ||
                    a.N !== 0 ||
                    !u ||
                    u.kind !== "array" ||
                    (typeof u.N == "number" && u.N !== 0) ||
                    (a = u),
                  new Yt(a, o)
                );
              }
              evaluate() {
                return this.value;
              }
              eachChild() {}
              outputDefined() {
                return !0;
              }
              serialize() {
                return this.type.kind === "array" || this.type.kind === "object"
                  ? ["literal", this.value]
                  : this.value instanceof Li
                    ? ["rgba"].concat(
                        this.value
                          .toNonPremultipliedRenderColor(null)
                          .toArray(),
                      )
                    : this.value instanceof Rr
                      ? this.value.serialize()
                      : this.value;
              }
            }
            class Wn {
              constructor(e) {
                ((this.name = "ExpressionEvaluationError"), (this.message = e));
              }
              toJSON() {
                return this.message;
              }
            }
            const bc = { string: $i, number: Ft, boolean: zi, object: so };
            class Gt {
              constructor(e, i) {
                ((this.type = e), (this.args = i));
              }
              static parse(e, i) {
                if (e.length < 2)
                  return i.error("Expected at least one argument.");
                let o,
                  a = 1;
                const u = e[0];
                if (u === "array") {
                  let _, v;
                  if (e.length > 2) {
                    const b = e[1];
                    if (typeof b != "string" || !(b in bc) || b === "object")
                      return i.error(
                        'The item type argument of "array" must be one of string, number, boolean',
                        1,
                      );
                    ((_ = bc[b]), a++);
                  } else _ = Oi;
                  if (e.length > 3) {
                    if (
                      e[2] !== null &&
                      (typeof e[2] != "number" ||
                        e[2] < 0 ||
                        e[2] !== Math.floor(e[2]))
                    )
                      return i.error(
                        'The length argument to "array" must be a positive integer literal',
                        2,
                      );
                    ((v = e[2]), a++);
                  }
                  o = Dr(_, v);
                } else o = bc[u];
                const d = [];
                for (; a < e.length; a++) {
                  const _ = i.parse(e[a], a, Oi);
                  if (!_) return null;
                  d.push(_);
                }
                return new Gt(o, d);
              }
              evaluate(e) {
                for (let i = 0; i < this.args.length; i++) {
                  const o = this.args[i].evaluate(e);
                  if (!ol(this.type, wt(o))) return o;
                  if (i === this.args.length - 1)
                    throw new Wn(
                      `The expression ${JSON.stringify(this.args[i].serialize())} evaluated to ${Xn(wt(o))} but was expected to be of type ${Xn(this.type)}.`,
                    );
                }
                return null;
              }
              eachChild(e) {
                this.args.forEach(e);
              }
              outputDefined() {
                return this.args.every((e) => e.outputDefined());
              }
              serialize() {
                const e = this.type,
                  i = [e.kind];
                if (e.kind === "array") {
                  const o = e.itemType;
                  if (
                    o.kind === "string" ||
                    o.kind === "number" ||
                    o.kind === "boolean"
                  ) {
                    i.push(o.kind);
                    const a = e.N;
                    (typeof a == "number" || this.args.length > 1) && i.push(a);
                  }
                }
                return i.concat(this.args.map((o) => o.serialize()));
              }
            }
            class al {
              constructor(e) {
                ((this.type = _c), (this.sections = e));
              }
              static parse(e, i) {
                if (e.length < 2)
                  return i.error("Expected at least one argument.");
                const o = e[1];
                if (!Array.isArray(o) && typeof o == "object")
                  return i.error(
                    "First argument must be an image or text section.",
                  );
                const a = [];
                let u = !1;
                for (let d = 1; d <= e.length - 1; ++d) {
                  const _ = e[d];
                  if (u && typeof _ == "object" && !Array.isArray(_)) {
                    u = !1;
                    let v = null;
                    if (
                      _["font-scale"] &&
                      ((v = i.parseObjectValue(
                        _["font-scale"],
                        d,
                        "font-scale",
                        Ft,
                      )),
                      !v)
                    )
                      return null;
                    let b = null;
                    if (
                      _["text-font"] &&
                      ((b = i.parseObjectValue(
                        _["text-font"],
                        d,
                        "text-font",
                        Dr($i),
                      )),
                      !b)
                    )
                      return null;
                    let E = null;
                    if (
                      _["text-color"] &&
                      ((E = i.parseObjectValue(
                        _["text-color"],
                        d,
                        "text-color",
                        Jr,
                      )),
                      !E)
                    )
                      return null;
                    const A = a[a.length - 1];
                    ((A.scale = v), (A.font = b), (A.textColor = E));
                  } else {
                    const v = i.parse(e[d], d, Oi);
                    if (!v) return null;
                    const b = v.type.kind;
                    if (
                      b !== "string" &&
                      b !== "value" &&
                      b !== "null" &&
                      b !== "resolvedImage"
                    )
                      return i.error(
                        "Formatted text type must be 'string', 'value', 'image' or 'null'.",
                      );
                    ((u = !0),
                      a.push({
                        content: v,
                        scale: null,
                        font: null,
                        textColor: null,
                      }));
                  }
                }
                return new al(a);
              }
              evaluate(e) {
                return new Rr(
                  this.sections.map((i) => {
                    const o = i.content.evaluate(e);
                    return Oh(wt(o), yc)
                      ? new Fh("", o, null, null, null)
                      : new Fh(
                          _s(o),
                          null,
                          i.scale ? i.scale.evaluate(e) : null,
                          i.font ? i.font.evaluate(e).join(",") : null,
                          i.textColor ? i.textColor.evaluate(e) : null,
                        );
                  }),
                );
              }
              eachChild(e) {
                for (const i of this.sections)
                  (e(i.content),
                    i.scale && e(i.scale),
                    i.font && e(i.font),
                    i.textColor && e(i.textColor));
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const e = ["format"];
                for (const i of this.sections) {
                  e.push(i.content.serialize());
                  const o = {};
                  (i.scale && (o["font-scale"] = i.scale.serialize()),
                    i.font && (o["text-font"] = i.font.serialize()),
                    i.textColor && (o["text-color"] = i.textColor.serialize()),
                    e.push(o));
                }
                return e;
              }
            }
            class ll {
              constructor(e, i, o, a) {
                ((this._imageWarnHistory = {}),
                  (this.type = yc),
                  (this.namePrimary = e),
                  (this.nameSecondary = i),
                  o &&
                    ((this.paramsPrimary = o.params),
                    (this.iconsetIdPrimary = o.iconset
                      ? o.iconset.id
                      : void 0)),
                  a &&
                    ((this.paramsSecondary = a.params),
                    (this.iconsetIdSecondary = a.iconset
                      ? a.iconset.id
                      : void 0)));
              }
              static parse(e, i) {
                if (e.length < 2)
                  return i.error("Expected two or more arguments.");
                let o = 1;
                const a = [];
                function u() {
                  if (o < e.length) {
                    const _ = i.parse(e[o], o++, $i);
                    return _
                      ? (a.push({ image: _, options: {} }), !0)
                      : (i.error(
                          a.length
                            ? "Secondary image variant is not a string."
                            : "No image name provided.",
                        ),
                        !1);
                  }
                  return !0;
                }
                function d() {
                  if (o < e.length) {
                    const v = e[o];
                    if (
                      (_ = v) === null ||
                      typeof _ != "object" ||
                      Array.isArray(_)
                    )
                      return !0;
                    const b = v.params,
                      E = v.iconset,
                      A = i.concat(o);
                    if (!b && !E) return (o++, !0);
                    if (b) {
                      if (typeof b != "object" || b.constructor !== Object)
                        return (
                          A.error('Image options "params" should be an object'),
                          !1
                        );
                      const M = {},
                        R = A.concat(void 0, "params");
                      for (const k in b) {
                        if (!k)
                          return (
                            R.error("Image parameter name should be non-empty"),
                            !1
                          );
                        const N = R.concat(void 0, k).parse(
                          b[k],
                          void 0,
                          Jr,
                          void 0,
                          { typeAnnotation: "coerce" },
                        );
                        if (!N) return !1;
                        M[k] = N;
                      }
                      a[a.length - 1].options.params = M;
                    }
                    if (E) {
                      if (typeof E != "object" || E.constructor !== Object)
                        return (
                          A.error(
                            'Image options "iconset" should be an object',
                          ),
                          !1
                        );
                      if (!E.id)
                        return (
                          A.error(
                            'Image options "iconset" should have an "id" property',
                          ),
                          !1
                        );
                      a[a.length - 1].options.iconset = E;
                    }
                    return (o++, !0);
                  }
                  var _;
                  return !0;
                }
                for (let _ = 0; _ < 2; _++) if (!u() || !d()) return;
                return new ll(
                  a[0].image,
                  a[1] ? a[1].image : void 0,
                  a[0].options,
                  a[1] ? a[1].options : void 0,
                );
              }
              evaluateParams(e, i) {
                const o = {};
                if (i) {
                  for (const a in i)
                    if (i[a])
                      try {
                        o[a] = i[a].evaluate(e);
                      } catch {
                        continue;
                      }
                  if (Object.keys(o).length !== 0) return { params: o };
                }
              }
              evaluate(e) {
                const i = {
                    name: this.namePrimary.evaluate(e),
                    iconsetId: this.iconsetIdPrimary,
                  },
                  o = this.nameSecondary
                    ? {
                        name: this.nameSecondary.evaluate(e),
                        iconsetId: this.iconsetIdSecondary,
                      }
                    : void 0,
                  a = Gr.build(
                    i,
                    o,
                    this.paramsPrimary
                      ? this.evaluateParams(e, this.paramsPrimary)
                      : void 0,
                    this.paramsSecondary
                      ? this.evaluateParams(e, this.paramsSecondary)
                      : void 0,
                  );
                if (a && e.availableImages) {
                  const u = a.getPrimary().id;
                  if (
                    ((a.available = e.availableImages.some((d) =>
                      Kr.isEqual(d, u),
                    )),
                    a.available)
                  ) {
                    const d = a.getSecondary() ? a.getSecondary().id : null;
                    d &&
                      (a.available = e.availableImages.some((_) =>
                        Kr.isEqual(_, d),
                      ));
                  }
                }
                return a;
              }
              eachChild(e) {
                if ((e(this.namePrimary), this.paramsPrimary))
                  for (const i in this.paramsPrimary)
                    this.paramsPrimary[i] && e(this.paramsPrimary[i]);
                if (
                  this.nameSecondary &&
                  (e(this.nameSecondary), this.paramsSecondary)
                )
                  for (const i in this.paramsSecondary)
                    this.paramsSecondary[i] && e(this.paramsSecondary[i]);
              }
              outputDefined() {
                return !1;
              }
              serializeOptions(e, i) {
                const o = {};
                if ((i && (o.iconset = { id: i }), e)) {
                  o.params = {};
                  for (const a in e) e[a] && (o.params[a] = e[a].serialize());
                }
                return Object.keys(o).length > 0 ? o : void 0;
              }
              serialize() {
                const e = ["image", this.namePrimary.serialize()];
                if (this.paramsPrimary || this.iconsetIdPrimary) {
                  const i = this.serializeOptions(
                    this.paramsPrimary,
                    this.iconsetIdPrimary,
                  );
                  i && e.push(i);
                }
                if (
                  this.nameSecondary &&
                  (e.push(this.nameSecondary.serialize()),
                  this.paramsSecondary || this.iconsetIdSecondary)
                ) {
                  const i = this.serializeOptions(
                    this.paramsSecondary,
                    this.iconsetIdSecondary,
                  );
                  i && e.push(i);
                }
                return e;
              }
            }
            function zo(n) {
              return n instanceof Number
                ? "number"
                : n instanceof String
                  ? "string"
                  : n instanceof Boolean
                    ? "boolean"
                    : Array.isArray(n)
                      ? "array"
                      : n === null
                        ? "null"
                        : typeof n;
            }
            const Ip = {
              "to-boolean": zi,
              "to-color": Jr,
              "to-number": Ft,
              "to-string": $i,
            };
            class ys {
              constructor(e, i) {
                ((this.type = e), (this.args = i));
              }
              static parse(e, i) {
                if (e.length < 2)
                  return i.error("Expected at least one argument.");
                const o = e[0],
                  a = [];
                let u = sl;
                if (o === "to-array") {
                  if (!Array.isArray(e[1])) return null;
                  const d = e[1].length;
                  if (i.expectedType) {
                    if (i.expectedType.kind !== "array")
                      return i.error(
                        `Expected ${i.expectedType.kind} but found array.`,
                      );
                    u = Dr(i.expectedType.itemType, d);
                  } else {
                    if (!(d > 0 && ui(e[1][0]))) return null;
                    u = Dr(wt(e[1][0]), d);
                  }
                  for (let _ = 0; _ < d; _++) {
                    const v = e[1][_];
                    let b;
                    if (zo(v) === "array") b = i.parse(v, void 0, u.itemType);
                    else {
                      const E = zo(v);
                      if (E !== u.itemType.kind)
                        return i.error(
                          `Expected ${u.itemType.kind} but found ${E}.`,
                        );
                      b = i.registry.literal.parse(
                        ["literal", v === void 0 ? null : v],
                        i,
                      );
                    }
                    if (!b) return null;
                    a.push(b);
                  }
                } else {
                  if (
                    (o === "to-boolean" || o === "to-string") &&
                    e.length !== 2
                  )
                    return i.error("Expected one argument.");
                  u = Ip[o];
                  for (let d = 1; d < e.length; d++) {
                    const _ = i.parse(e[d], d, Oi);
                    if (!_) return null;
                    a.push(_);
                  }
                }
                return new ys(u, a);
              }
              evaluate(e) {
                if (this.type.kind === "boolean")
                  return !!this.args[0].evaluate(e);
                if (this.type.kind === "color") {
                  let i, o;
                  for (const a of this.args) {
                    if (((i = a.evaluate(e)), (o = null), i instanceof Li))
                      return i;
                    if (typeof i == "string") {
                      const u = e.parseColor(i);
                      if (u) return u;
                    } else if (
                      Array.isArray(i) &&
                      ((o =
                        i.length < 3 || i.length > 4
                          ? `Invalid rbga value ${JSON.stringify(i)}: expected an array containing either three or four numeric values.`
                          : ba(i[0], i[1], i[2], i[3])),
                      !o)
                    )
                      return new Li(i[0] / 255, i[1] / 255, i[2] / 255, i[3]);
                  }
                  throw new Wn(
                    o ||
                      `Could not parse color from value '${typeof i == "string" ? i : String(JSON.stringify(i))}'`,
                  );
                }
                if (this.type.kind === "number") {
                  let i = null;
                  for (const o of this.args) {
                    if (((i = o.evaluate(e)), i === null)) return 0;
                    const a = Number(i);
                    if (!isNaN(a)) return a;
                  }
                  throw new Wn(
                    `Could not convert ${JSON.stringify(i)} to number.`,
                  );
                }
                return this.type.kind === "formatted"
                  ? Rr.fromString(_s(this.args[0].evaluate(e)))
                  : this.type.kind === "resolvedImage"
                    ? Gr.build(_s(this.args[0].evaluate(e)))
                    : this.type.kind === "array"
                      ? this.args.map((i) => i.evaluate(e))
                      : _s(this.args[0].evaluate(e));
              }
              eachChild(e) {
                this.args.forEach(e);
              }
              outputDefined() {
                return this.args.every((e) => e.outputDefined());
              }
              serialize() {
                if (this.type.kind === "formatted")
                  return new al([
                    {
                      content: this.args[0],
                      scale: null,
                      font: null,
                      textColor: null,
                    },
                  ]).serialize();
                if (this.type.kind === "resolvedImage")
                  return new ll(this.args[0]).serialize();
                const e =
                  this.type.kind === "array" ? [] : [`to-${this.type.kind}`];
                return (
                  this.eachChild((i) => {
                    e.push(i.serialize());
                  }),
                  e
                );
              }
            }
            const zr = ["Unknown", "Point", "LineString", "Polygon"];
            class wc {
              constructor(e, i) {
                ((this.globals = null),
                  (this.feature = null),
                  (this.featureState = null),
                  (this.formattedSection = null),
                  (this._parseColorCache = {}),
                  (this.availableImages = null),
                  (this.canonical = null),
                  (this.featureTileCoord = null),
                  (this.featureDistanceData = null),
                  (this.scope = e),
                  (this.options = i));
              }
              id() {
                return this.feature && this.feature.id !== void 0
                  ? this.feature.id
                  : null;
              }
              geometryType() {
                return this.feature
                  ? typeof this.feature.type == "number"
                    ? zr[this.feature.type]
                    : this.feature.type
                  : null;
              }
              geometry() {
                return this.feature && "geometry" in this.feature
                  ? this.feature.geometry
                  : null;
              }
              canonicalID() {
                return this.canonical;
              }
              properties() {
                return (this.feature && this.feature.properties) || {};
              }
              measureLight(e) {
                return this.globals.brightness || 0;
              }
              distanceFromCenter() {
                if (this.featureTileCoord && this.featureDistanceData) {
                  const e = this.featureDistanceData.center,
                    i = this.featureDistanceData.scale,
                    { x: o, y: a } = this.featureTileCoord;
                  return (
                    this.featureDistanceData.bearing[0] * (o * i - e[0]) +
                    this.featureDistanceData.bearing[1] * (a * i - e[1])
                  );
                }
                return 0;
              }
              parseColor(e) {
                let i = this._parseColorCache[e];
                return (i || (i = this._parseColorCache[e] = Li.parse(e)), i);
              }
              getConfig(e) {
                return this.options ? this.options.get(e) : null;
              }
            }
            class lr {
              constructor(e, i, o, a, u) {
                ((this.name = e),
                  (this.type = i),
                  (this._evaluate = o),
                  (this.args = a),
                  (this._overloadIndex = u));
              }
              evaluate(e) {
                if (!this._evaluate) {
                  const i = lr.definitions[this.name];
                  this._evaluate = Array.isArray(i)
                    ? i[2]
                    : i.overloads[this._overloadIndex][1];
                }
                return this._evaluate(e, this.args);
              }
              eachChild(e) {
                this.args.forEach(e);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return [this.name].concat(this.args.map((e) => e.serialize()));
              }
              static parse(e, i) {
                const o = e[0],
                  a = lr.definitions[o];
                if (!a)
                  return i.error(
                    `Unknown expression "${o}". If you wanted a literal array, use ["literal", [...]].`,
                    0,
                  );
                const u = Array.isArray(a) ? a[0] : a.type,
                  d = Array.isArray(a) ? [[a[1], a[2]]] : a.overloads,
                  _ = [];
                let v = null,
                  b = -1;
                for (const [E, A] of d) {
                  if (Array.isArray(E) && E.length !== e.length - 1) continue;
                  (_.push(E),
                    b++,
                    (v = new Xh(
                      i.registry,
                      i.path,
                      null,
                      i.scope,
                      void 0,
                      i._scope,
                      i.options,
                    )));
                  const M = [];
                  let R = !1;
                  for (let k = 1; k < e.length; k++) {
                    const N = e[k],
                      j = Array.isArray(E) ? E[k - 1] : E.type,
                      H = v.parse(N, 1 + M.length, j);
                    if (!H) {
                      R = !0;
                      break;
                    }
                    M.push(H);
                  }
                  if (!R)
                    if (Array.isArray(E) && E.length !== M.length)
                      v.error(
                        `Expected ${E.length} arguments, but found ${M.length} instead.`,
                      );
                    else {
                      for (let k = 0; k < M.length; k++) {
                        const N = Array.isArray(E) ? E[k] : E.type,
                          j = M[k];
                        v.concat(k + 1).checkSubtype(N, j.type);
                      }
                      if (v.errors.length === 0) return new lr(o, u, A, M, b);
                    }
                }
                if (_.length === 1) i.errors.push(...v.errors);
                else {
                  const E = (_.length ? _ : d.map(([M]) => M))
                      .map(ud)
                      .join(" | "),
                    A = [];
                  for (let M = 1; M < e.length; M++) {
                    const R = i.parse(e[M], 1 + A.length);
                    if (!R) return null;
                    A.push(Xn(R.type));
                  }
                  i.error(
                    `Expected arguments of type ${E}, but found (${A.join(", ")}) instead.`,
                  );
                }
                return null;
              }
              static register(e, i) {
                lr.definitions = i;
                for (const o in i) e[o] = lr;
              }
            }
            function ud(n) {
              return Array.isArray(n)
                ? `(${n.map(Xn).join(", ")})`
                : `(${Xn(n.type)}...)`;
            }
            class Bs {
              constructor(e, i, o) {
                ((this.type = Lh),
                  (this.locale = o),
                  (this.caseSensitive = e),
                  (this.diacriticSensitive = i));
              }
              static parse(e, i) {
                if (e.length !== 2) return i.error("Expected one argument.");
                const o = e[1];
                if (typeof o != "object" || Array.isArray(o))
                  return i.error(
                    "Collator options argument must be an object.",
                  );
                const a =
                  o["case-sensitive"] === void 0
                    ? i.parse(!1, 1, zi)
                    : i.parseObjectValue(
                        o["case-sensitive"],
                        1,
                        "case-sensitive",
                        zi,
                      );
                if (!a) return null;
                const u =
                  o["diacritic-sensitive"] === void 0
                    ? i.parse(!1, 1, zi)
                    : i.parseObjectValue(
                        o["diacritic-sensitive"],
                        1,
                        "diacritic-sensitive",
                        zi,
                      );
                if (!u) return null;
                let d = null;
                return o.locale &&
                  ((d = i.parseObjectValue(o.locale, 1, "locale", $i)), !d)
                  ? null
                  : new Bs(a, u, d);
              }
              evaluate(e) {
                return new vc(
                  this.caseSensitive.evaluate(e),
                  this.diacriticSensitive.evaluate(e),
                  this.locale ? this.locale.evaluate(e) : null,
                );
              }
              eachChild(e) {
                (e(this.caseSensitive),
                  e(this.diacriticSensitive),
                  this.locale && e(this.locale));
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const e = {};
                return (
                  (e["case-sensitive"] = this.caseSensitive.serialize()),
                  (e["diacritic-sensitive"] =
                    this.diacriticSensitive.serialize()),
                  this.locale && (e.locale = this.locale.serialize()),
                  ["collator", e]
                );
              }
            }
            function Sr(n, e, i = 0, o = n.length - 1, a = d_) {
              for (; o > i; ) {
                if (o - i > 600) {
                  const v = o - i + 1,
                    b = e - i + 1,
                    E = Math.log(v),
                    A = 0.5 * Math.exp((2 * E) / 3),
                    M =
                      0.5 *
                      Math.sqrt((E * A * (v - A)) / v) *
                      (b - v / 2 < 0 ? -1 : 1);
                  Sr(
                    n,
                    e,
                    Math.max(i, Math.floor(e - (b * A) / v + M)),
                    Math.min(o, Math.floor(e + ((v - b) * A) / v + M)),
                    a,
                  );
                }
                const u = n[e];
                let d = i,
                  _ = o;
                for (Tc(n, i, e), a(n[o], u) > 0 && Tc(n, i, o); d < _; ) {
                  for (Tc(n, d, _), d++, _--; a(n[d], u) < 0; ) d++;
                  for (; a(n[_], u) > 0; ) _--;
                }
                (a(n[i], u) === 0 ? Tc(n, i, _) : (_++, Tc(n, _, o)),
                  _ <= e && (i = _ + 1),
                  e <= _ && (o = _ - 1));
              }
            }
            function Tc(n, e, i) {
              const o = n[e];
              ((n[e] = n[i]), (n[i] = o));
            }
            function d_(n, e) {
              return n < e ? -1 : n > e ? 1 : 0;
            }
            function f_(n) {
              let e = 0;
              for (let i, o, a = 0, u = n.length, d = u - 1; a < u; d = a++)
                ((i = n[a]), (o = n[d]), (e += (o.x - i.x) * (i.y + o.y)));
              return e;
            }
            function ko(n, e) {
              ((n[0] = Math.min(n[0], e[0])),
                (n[1] = Math.min(n[1], e[1])),
                (n[2] = Math.max(n[2], e[0])),
                (n[3] = Math.max(n[3], e[1])));
            }
            function cl(n, e) {
              return !(
                n[0] <= e[0] ||
                n[2] >= e[2] ||
                n[1] <= e[1] ||
                n[3] >= e[3]
              );
            }
            function wa(n, e, i) {
              const o = n[0] - e[0],
                a = n[1] - e[1],
                u = n[0] - i[0],
                d = n[1] - i[1];
              return o * d - u * a == 0 && o * u <= 0 && a * d <= 0;
            }
            function hl(n, e, i = !1) {
              let o = !1;
              for (let _ = 0, v = e.length; _ < v; _++) {
                const b = e[_];
                for (let E = 0, A = b.length, M = A - 1; E < A; M = E++) {
                  const R = b[M],
                    k = b[E];
                  if (wa(n, R, k)) return i;
                  (u = R)[1] > (a = n)[1] != (d = k)[1] > a[1] &&
                    a[0] <
                      ((d[0] - u[0]) * (a[1] - u[1])) / (d[1] - u[1]) + u[0] &&
                    (o = !o);
                }
              }
              var a, u, d;
              return o;
            }
            function Ap(n, e, i, o) {
              const a = o[0] - i[0],
                u = o[1] - i[1],
                d = (n[0] - i[0]) * u - a * (n[1] - i[1]),
                _ = (e[0] - i[0]) * u - a * (e[1] - i[1]);
              return (d > 0 && _ < 0) || (d < 0 && _ > 0);
            }
            function Bh(n, e, i, o) {
              return (
                (a = [o[0] - i[0], o[1] - i[1]])[0] *
                  (u = [e[0] - n[0], e[1] - n[1]])[1] -
                  a[1] * u[0] !=
                  0 && !(!Ap(n, e, i, o) || !Ap(i, o, n, e))
              );
              var a, u;
            }
            function dd(n) {
              const e = new ft(
                  Number.POSITIVE_INFINITY,
                  Number.POSITIVE_INFINITY,
                ),
                i = new ft(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
              for (const o of n[0])
                (e.x > o.x && (e.x = o.x),
                  e.y > o.y && (e.y = o.y),
                  i.x < o.x && (i.x = o.x),
                  i.y < o.y && (i.y = o.y));
              return { min: e, max: i };
            }
            const ao = 8192;
            function p_(n, e) {
              const i = (180 + n[0]) / 360,
                o =
                  (180 -
                    (180 / Math.PI) *
                      Math.log(
                        Math.tan(Math.PI / 4 + (n[1] * Math.PI) / 360),
                      )) /
                  360,
                a = Math.pow(2, e.z);
              return [Math.round(i * a * ao), Math.round(o * a * ao)];
            }
            function m_(n, e) {
              for (let i = 0; i < e.length; i++) if (hl(n, e[i])) return !0;
              return !1;
            }
            function Mp(n, e, i) {
              for (const o of i)
                for (let a = 0, u = o.length, d = u - 1; a < u; d = a++)
                  if (Bh(n, e, o[d], o[a])) return !0;
              return !1;
            }
            function Cp(n, e) {
              for (let i = 0; i < n.length; ++i) if (!hl(n[i], e)) return !1;
              for (let i = 0; i < n.length - 1; ++i)
                if (Mp(n[i], n[i + 1], e)) return !1;
              return !0;
            }
            function Ta(n, e) {
              for (let i = 0; i < e.length; i++) if (Cp(n, e[i])) return !0;
              return !1;
            }
            function fd(n, e, i) {
              const o = [];
              for (let a = 0; a < n.length; a++) {
                const u = [];
                for (let d = 0; d < n[a].length; d++) {
                  const _ = p_(n[a][d], i);
                  (ko(e, _), u.push(_));
                }
                o.push(u);
              }
              return o;
            }
            function Pp(n, e, i) {
              const o = [];
              for (let a = 0; a < n.length; a++) {
                const u = fd(n[a], e, i);
                o.push(u);
              }
              return o;
            }
            function Nh(n, e, i, o) {
              if (n[0] < i[0] || n[0] > i[2]) {
                const a = 0.5 * o;
                let u = n[0] - i[0] > a ? -o : i[0] - n[0] > a ? o : 0;
                (u === 0 &&
                  (u = n[0] - i[2] > a ? -o : i[2] - n[0] > a ? o : 0),
                  (n[0] += u));
              }
              ko(e, n);
            }
            function pd(n, e, i, o) {
              const a = Math.pow(2, o.z) * ao,
                u = [o.x * ao, o.y * ao],
                d = [];
              if (!n) return d;
              for (const _ of n)
                for (const v of _) {
                  const b = [v.x + u[0], v.y + u[1]];
                  (Nh(b, e, i, a), d.push(b));
                }
              return d;
            }
            function md(n, e, i, o) {
              const a = Math.pow(2, o.z) * ao,
                u = [o.x * ao, o.y * ao],
                d = [];
              if (!n) return d;
              for (const v of n) {
                const b = [];
                for (const E of v) {
                  const A = [E.x + u[0], E.y + u[1]];
                  (ko(e, A), b.push(A));
                }
                d.push(b);
              }
              if (e[2] - e[0] <= a / 2) {
                (((_ = e)[0] = _[1] = 1 / 0), (_[2] = _[3] = -1 / 0));
                for (const v of d) for (const b of v) Nh(b, e, i, a);
              }
              var _;
              return d;
            }
            class Er {
              constructor(e, i) {
                ((this.type = zi), (this.geojson = e), (this.geometries = i));
              }
              static parse(e, i) {
                if (e.length !== 2)
                  return i.error(
                    `'within' expression requires exactly one argument, but found ${e.length - 1} instead.`,
                  );
                if (ui(e[1])) {
                  const o = e[1];
                  if (o.type === "FeatureCollection")
                    for (let a = 0; a < o.features.length; ++a) {
                      const u = o.features[a].geometry.type;
                      if (u === "Polygon" || u === "MultiPolygon")
                        return new Er(o, o.features[a].geometry);
                    }
                  else if (o.type === "Feature") {
                    const a = o.geometry.type;
                    if (a === "Polygon" || a === "MultiPolygon")
                      return new Er(o, o.geometry);
                  } else if (o.type === "Polygon" || o.type === "MultiPolygon")
                    return new Er(o, o);
                }
                return i.error(
                  "'within' expression requires valid geojson object that contains polygon geometry type.",
                );
              }
              evaluate(e) {
                if (e.geometry() != null && e.canonicalID() != null) {
                  if (e.geometryType() === "Point")
                    return (function (i, o) {
                      const a = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        u = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        d = i.canonicalID();
                      if (!d) return !1;
                      if (o.type === "Polygon") {
                        const _ = fd(o.coordinates, u, d),
                          v = pd(i.geometry(), a, u, d);
                        if (!cl(a, u)) return !1;
                        for (const b of v) if (!hl(b, _)) return !1;
                      }
                      if (o.type === "MultiPolygon") {
                        const _ = Pp(o.coordinates, u, d),
                          v = pd(i.geometry(), a, u, d);
                        if (!cl(a, u)) return !1;
                        for (const b of v) if (!m_(b, _)) return !1;
                      }
                      return !0;
                    })(e, this.geometries);
                  if (e.geometryType() === "LineString")
                    return (function (i, o) {
                      const a = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        u = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                        d = i.canonicalID();
                      if (!d) return !1;
                      if (o.type === "Polygon") {
                        const _ = fd(o.coordinates, u, d),
                          v = md(i.geometry(), a, u, d);
                        if (!cl(a, u)) return !1;
                        for (const b of v) if (!Cp(b, _)) return !1;
                      }
                      if (o.type === "MultiPolygon") {
                        const _ = Pp(o.coordinates, u, d),
                          v = md(i.geometry(), a, u, d);
                        if (!cl(a, u)) return !1;
                        for (const b of v) if (!Ta(b, _)) return !1;
                      }
                      return !0;
                    })(e, this.geometries);
                }
                return !1;
              }
              eachChild() {}
              outputDefined() {
                return !0;
              }
              serialize() {
                return ["within", this.geojson];
              }
            }
            const Sc = {
                kilometers: 1,
                miles: 1e3 / 1609.344,
                nauticalmiles: 1e3 / 1852,
                meters: 1e3,
                metres: 1e3,
                yards: 1e3 / 0.9144,
                feet: 1e3 / 0.3048,
                inches: 1e3 / 0.0254,
              },
              gd = 1 / 298.257223563,
              _d = gd * (2 - gd),
              ul = Math.PI / 180;
            class dl {
              static fromTile(e, i, o) {
                const a = Math.PI * (1 - (2 * (e + 0.5)) / Math.pow(2, i)),
                  u = Math.atan(0.5 * (Math.exp(a) - Math.exp(-a))) / ul;
                return new dl(u, o);
              }
              static get units() {
                return Sc;
              }
              constructor(e, i) {
                if (e === void 0) throw new Error("No latitude given.");
                if (i && !Sc[i])
                  throw new Error(
                    `Unknown unit ${i}. Use one of: ${Object.keys(Sc).join(", ")}`,
                  );
                const o = 6378.137 * ul * (i ? Sc[i] : 1),
                  a = Math.cos(e * ul),
                  u = 1 / (1 - _d * (1 - a * a)),
                  d = Math.sqrt(u);
                ((this.kx = o * d * a), (this.ky = o * d * u * (1 - _d)));
              }
              distance(e, i) {
                const o = as(e[0] - i[0]) * this.kx,
                  a = (e[1] - i[1]) * this.ky;
                return Math.sqrt(o * o + a * a);
              }
              bearing(e, i) {
                const o = as(i[0] - e[0]) * this.kx;
                return Math.atan2(o, (i[1] - e[1]) * this.ky) / ul;
              }
              destination(e, i, o) {
                const a = o * ul;
                return this.offset(e, Math.sin(a) * i, Math.cos(a) * i);
              }
              offset(e, i, o) {
                return [e[0] + i / this.kx, e[1] + o / this.ky];
              }
              lineDistance(e) {
                let i = 0;
                for (let o = 0; o < e.length - 1; o++)
                  i += this.distance(e[o], e[o + 1]);
                return i;
              }
              area(e) {
                let i = 0;
                for (let o = 0; o < e.length; o++) {
                  const a = e[o];
                  for (let u = 0, d = a.length, _ = d - 1; u < d; _ = u++)
                    i +=
                      as(a[u][0] - a[_][0]) *
                      (a[u][1] + a[_][1]) *
                      (o ? -1 : 1);
                }
                return (Math.abs(i) / 2) * this.kx * this.ky;
              }
              along(e, i) {
                let o = 0;
                if (i <= 0) return e[0];
                for (let a = 0; a < e.length - 1; a++) {
                  const u = e[a],
                    d = e[a + 1],
                    _ = this.distance(u, d);
                  if (((o += _), o > i)) return Vh(u, d, (i - (o - _)) / _);
                }
                return e[e.length - 1];
              }
              pointToSegmentDistance(e, i, o) {
                let [a, u] = i,
                  d = as(o[0] - a) * this.kx,
                  _ = (o[1] - u) * this.ky;
                if (d !== 0 || _ !== 0) {
                  const v =
                    (as(e[0] - a) * this.kx * d + (e[1] - u) * this.ky * _) /
                    (d * d + _ * _);
                  v > 1
                    ? ((a = o[0]), (u = o[1]))
                    : v > 0 &&
                      ((a += (d / this.kx) * v), (u += (_ / this.ky) * v));
                }
                return (
                  (d = as(e[0] - a) * this.kx),
                  (_ = (e[1] - u) * this.ky),
                  Math.sqrt(d * d + _ * _)
                );
              }
              pointOnLine(e, i) {
                let o = 1 / 0,
                  a = e[0][0],
                  u = e[0][1],
                  d = 0,
                  _ = 0;
                for (let v = 0; v < e.length - 1; v++) {
                  let b = e[v][0],
                    E = e[v][1],
                    A = as(e[v + 1][0] - b) * this.kx,
                    M = (e[v + 1][1] - E) * this.ky,
                    R = 0;
                  ((A === 0 && M === 0) ||
                    ((R =
                      (as(i[0] - b) * this.kx * A + (i[1] - E) * this.ky * M) /
                      (A * A + M * M)),
                    R > 1
                      ? ((b = e[v + 1][0]), (E = e[v + 1][1]))
                      : R > 0 &&
                        ((b += (A / this.kx) * R), (E += (M / this.ky) * R))),
                    (A = as(i[0] - b) * this.kx),
                    (M = (i[1] - E) * this.ky));
                  const k = A * A + M * M;
                  k < o && ((o = k), (a = b), (u = E), (d = v), (_ = R));
                }
                return {
                  point: [a, u],
                  index: d,
                  t: Math.max(0, Math.min(1, _)),
                };
              }
              lineSlice(e, i, o) {
                let a = this.pointOnLine(o, e),
                  u = this.pointOnLine(o, i);
                if (a.index > u.index || (a.index === u.index && a.t > u.t)) {
                  const b = a;
                  ((a = u), (u = b));
                }
                const d = [a.point],
                  _ = a.index + 1,
                  v = u.index;
                !yd(o[_], d[0]) && _ <= v && d.push(o[_]);
                for (let b = _ + 1; b <= v; b++) d.push(o[b]);
                return (yd(o[v], u.point) || d.push(u.point), d);
              }
              lineSliceAlong(e, i, o) {
                let a = 0;
                const u = [];
                for (let d = 0; d < o.length - 1; d++) {
                  const _ = o[d],
                    v = o[d + 1],
                    b = this.distance(_, v);
                  if (
                    ((a += b),
                    a > e &&
                      u.length === 0 &&
                      u.push(Vh(_, v, (e - (a - b)) / b)),
                    a >= i)
                  )
                    return (u.push(Vh(_, v, (i - (a - b)) / b)), u);
                  a > e && u.push(v);
                }
                return u;
              }
              bufferPoint(e, i) {
                const o = i / this.ky,
                  a = i / this.kx;
                return [e[0] - a, e[1] - o, e[0] + a, e[1] + o];
              }
              bufferBBox(e, i) {
                const o = i / this.ky,
                  a = i / this.kx;
                return [e[0] - a, e[1] - o, e[2] + a, e[3] + o];
              }
              insideBBox(e, i) {
                return (
                  as(e[0] - i[0]) >= 0 &&
                  as(e[0] - i[2]) <= 0 &&
                  e[1] >= i[1] &&
                  e[1] <= i[3]
                );
              }
            }
            function yd(n, e) {
              return n[0] === e[0] && n[1] === e[1];
            }
            function Vh(n, e, i) {
              const o = as(e[0] - n[0]);
              return [n[0] + o * i, n[1] + (e[1] - n[1]) * i];
            }
            function as(n) {
              for (; n < -180; ) n += 360;
              for (; n > 180; ) n -= 360;
              return n;
            }
            class Uh {
              constructor(e = [], i = (o, a) => (o < a ? -1 : o > a ? 1 : 0)) {
                if (
                  ((this.data = e),
                  (this.length = this.data.length),
                  (this.compare = i),
                  this.length > 0)
                )
                  for (let o = (this.length >> 1) - 1; o >= 0; o--)
                    this._down(o);
              }
              push(e) {
                (this.data.push(e), this._up(this.length++));
              }
              pop() {
                if (this.length === 0) return;
                const e = this.data[0],
                  i = this.data.pop();
                return (
                  --this.length > 0 && ((this.data[0] = i), this._down(0)),
                  e
                );
              }
              peek() {
                return this.data[0];
              }
              _up(e) {
                const { data: i, compare: o } = this,
                  a = i[e];
                for (; e > 0; ) {
                  const u = (e - 1) >> 1,
                    d = i[u];
                  if (o(a, d) >= 0) break;
                  ((i[e] = d), (e = u));
                }
                i[e] = a;
              }
              _down(e) {
                const { data: i, compare: o } = this,
                  a = this.length >> 1,
                  u = i[e];
                for (; e < a; ) {
                  let d = 1 + (e << 1);
                  const _ = d + 1;
                  if (
                    (_ < this.length && o(i[_], i[d]) < 0 && (d = _),
                    o(i[d], u) >= 0)
                  )
                    break;
                  ((i[e] = i[d]), (e = d));
                }
                i[e] = u;
              }
            }
            var mt = 8192;
            function xd(n, e) {
              return e.dist - n.dist;
            }
            const fl = 100,
              pl = 50;
            function Ec(n) {
              const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              if (e.length !== n.length) return !1;
              for (let i = 0; i < e.length; i++) if (e[i] !== n[i]) return !1;
              return !0;
            }
            function Ic(n) {
              return n[1] - n[0] + 1;
            }
            function Ns(n, e) {
              const i = n[1] >= n[0] && n[1] < e;
              return (
                i || console.warn("Distance Expression: Index is out of range"),
                i
              );
            }
            function jh(n, e) {
              if (n[0] > n[1]) return [null, null];
              const i = Ic(n);
              if (e) {
                if (i === 2) return [n, null];
                const o = Math.floor(i / 2);
                return [
                  [n[0], n[0] + o],
                  [n[0] + o, n[1]],
                ];
              }
              {
                if (i === 1) return [n, null];
                const o = Math.floor(i / 2) - 1;
                return [
                  [n[0], n[0] + o],
                  [n[0] + o + 1, n[1]],
                ];
              }
            }
            function xs(n, e) {
              const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              if (!Ns(e, n.length)) return i;
              for (let o = e[0]; o <= e[1]; ++o) ko(i, n[o]);
              return i;
            }
            function bi(n) {
              const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let i = 0; i < n.length; ++i)
                for (let o = 0; o < n[i].length; ++o) ko(e, n[i][o]);
              return e;
            }
            function ml(n, e, i) {
              if (Ec(n) || Ec(e)) return NaN;
              let o = 0,
                a = 0;
              return (
                n[2] < e[0] && (o = e[0] - n[2]),
                n[0] > e[2] && (o = n[0] - e[2]),
                n[1] > e[3] && (a = n[1] - e[3]),
                n[3] < e[1] && (a = e[1] - n[3]),
                i.distance([0, 0], [o, a])
              );
            }
            function g_(n) {
              return 360 * n - 180;
            }
            function __(n) {
              return (
                (360 / Math.PI) *
                  Math.atan(Math.exp(((180 - 360 * n) * Math.PI) / 180)) -
                90
              );
            }
            function Gh(n, e) {
              const i = Math.pow(2, e.z),
                o = (n.y / mt + e.y) / i;
              return [g_((n.x / mt + e.x) / i), __(o)];
            }
            function y_(n, e) {
              const i = [];
              for (let o = 0; o < n.length; ++o) i.push(Gh(n[o], e));
              return i;
            }
            function Sn(n, e, i) {
              const o = i.pointOnLine(e, n).point;
              return i.distance(n, o);
            }
            function Dp(n, e, i, o, a) {
              const u = i.slice(o[0], o[1] + 1);
              let d = 1 / 0;
              for (let _ = e[0]; _ <= e[1]; ++_)
                if ((d = Math.min(d, Sn(n[_], u, a))) === 0) return 0;
              return d;
            }
            function vd(n, e, i, o, a) {
              const u = Math.min(
                  a.pointToSegmentDistance(n, i, o),
                  a.pointToSegmentDistance(e, i, o),
                ),
                d = Math.min(
                  a.pointToSegmentDistance(i, n, e),
                  a.pointToSegmentDistance(o, n, e),
                );
              return Math.min(u, d);
            }
            function x_(n, e, i, o, a) {
              if (!Ns(e, n.length) || !Ns(o, i.length)) return NaN;
              let u = 1 / 0;
              for (let d = e[0]; d < e[1]; ++d)
                for (let _ = o[0]; _ < o[1]; ++_) {
                  if (Bh(n[d], n[d + 1], i[_], i[_ + 1])) return 0;
                  u = Math.min(u, vd(n[d], n[d + 1], i[_], i[_ + 1], a));
                }
              return u;
            }
            function v_(n, e, i, o, a) {
              if (!Ns(e, n.length) || !Ns(o, i.length)) return NaN;
              let u = 1 / 0;
              for (let d = e[0]; d <= e[1]; ++d)
                for (let _ = o[0]; _ <= o[1]; ++_)
                  if ((u = Math.min(u, a.distance(n[d], i[_]))) === 0) return u;
              return u;
            }
            function b_(n, e, i) {
              if (hl(n, e, !0)) return 0;
              let o = 1 / 0;
              for (const a of e) {
                const u = a.length;
                if (u < 2)
                  return (
                    console.warn("Distance Expression: Invalid polygon!"),
                    NaN
                  );
                if (
                  (a[0] !== a[u - 1] &&
                    (o = Math.min(
                      o,
                      i.pointToSegmentDistance(n, a[u - 1], a[0]),
                    )) === 0) ||
                  (o = Math.min(o, Sn(n, a, i))) === 0
                )
                  return o;
              }
              return o;
            }
            function w_(n, e, i, o) {
              if (!Ns(e, n.length)) return NaN;
              for (let u = e[0]; u <= e[1]; ++u) if (hl(n[u], i, !0)) return 0;
              let a = 1 / 0;
              for (let u = e[0]; u < e[1]; ++u)
                for (const d of i)
                  for (let _ = 0, v = d.length, b = v - 1; _ < v; b = _++) {
                    if (Bh(n[u], n[u + 1], d[b], d[_])) return 0;
                    a = Math.min(a, vd(n[u], n[u + 1], d[b], d[_], o));
                  }
              return a;
            }
            function Rp(n, e) {
              for (const i of n)
                for (let o = 0; o <= i.length - 1; ++o)
                  if (hl(i[o], e, !0)) return !0;
              return !1;
            }
            function T_(n, e, i, o = 1 / 0) {
              const a = bi(n),
                u = bi(e);
              if (o !== 1 / 0 && ml(a, u, i) >= o) return o;
              if (cl(a, u)) {
                if (Rp(n, e)) return 0;
              } else if (Rp(e, n)) return 0;
              let d = o;
              for (const _ of n)
                for (let v = 0, b = _.length, E = b - 1; v < b; E = v++)
                  for (const A of e)
                    for (let M = 0, R = A.length, k = R - 1; M < R; k = M++) {
                      if (Bh(_[E], _[v], A[k], A[M])) return 0;
                      d = Math.min(d, vd(_[E], _[v], A[k], A[M], i));
                    }
              return d;
            }
            function $h(n, e, i, o, a, u, d) {
              if (u === null || d === null) return;
              const _ = ml(xs(o, u), xs(a, d), i);
              _ < e && n.push({ dist: _, range1: u, range2: d });
            }
            function S_(n, e, i, o, a = 1 / 0) {
              let u = Math.min(o.distance(n[0], i[0][0]), a);
              if (u === 0) return u;
              const d = new Uh(
                  [{ dist: 0, range1: [0, n.length - 1], range2: [0, 0] }],
                  xd,
                ),
                _ = e ? pl : fl,
                v = bi(i);
              for (; d.length; ) {
                const b = d.pop();
                if (b.dist >= u) continue;
                const E = b.range1;
                if (Ic(E) <= _) {
                  if (!Ns(E, n.length)) return NaN;
                  if (e) {
                    const A = w_(n, E, i, o);
                    if ((u = Math.min(u, A)) === 0) return u;
                  } else
                    for (let A = E[0]; A <= E[1]; ++A) {
                      const M = b_(n[A], i, o);
                      if ((u = Math.min(u, M)) === 0) return u;
                    }
                } else {
                  const A = jh(E, e);
                  if (A[0] !== null) {
                    const M = ml(xs(n, A[0]), v, o);
                    M < u && d.push({ dist: M, range1: A[0], range2: [0, 0] });
                  }
                  if (A[1] !== null) {
                    const M = ml(xs(n, A[1]), v, o);
                    M < u && d.push({ dist: M, range1: A[1], range2: [0, 0] });
                  }
                }
              }
              return u;
            }
            function zp(n, e, i, o, a, u = 1 / 0) {
              let d = Math.min(u, a.distance(n[0], i[0]));
              if (d === 0) return d;
              const _ = new Uh(
                  [
                    {
                      dist: 0,
                      range1: [0, n.length - 1],
                      range2: [0, i.length - 1],
                    },
                  ],
                  xd,
                ),
                v = e ? pl : fl,
                b = o ? pl : fl;
              for (; _.length; ) {
                const E = _.pop();
                if (E.dist >= d) continue;
                const A = E.range1,
                  M = E.range2;
                if (Ic(A) <= v && Ic(M) <= b) {
                  if (!Ns(A, n.length) || !Ns(M, i.length)) return NaN;
                  if (
                    (e && o
                      ? (d = Math.min(d, x_(n, A, i, M, a)))
                      : e || o
                        ? e && !o
                          ? (d = Math.min(d, Dp(i, M, n, A, a)))
                          : !e && o && (d = Math.min(d, Dp(n, A, i, M, a)))
                        : (d = Math.min(d, v_(n, A, i, M, a))),
                    d === 0)
                  )
                    return d;
                } else {
                  const R = jh(A, e),
                    k = jh(M, o);
                  ($h(_, d, a, n, i, R[0], k[0]),
                    $h(_, d, a, n, i, R[0], k[1]),
                    $h(_, d, a, n, i, R[1], k[0]),
                    $h(_, d, a, n, i, R[1], k[1]));
                }
              }
              return d;
            }
            function bd(n, e, i, o, a = 1 / 0) {
              let u = a;
              const d = xs(n, [0, n.length - 1]);
              for (const _ of i)
                if (
                  !(u !== 1 / 0 && ml(d, xs(_, [0, _.length - 1]), o) >= u) &&
                  ((u = Math.min(u, zp(n, e, _, !0, o, u))), u === 0)
                )
                  return u;
              return u;
            }
            function Hh(n, e, i, o, a = 1 / 0) {
              let u = a;
              const d = xs(n, [0, n.length - 1]);
              for (const _ of i) {
                if (u !== 1 / 0 && ml(d, bi(_), o) >= u) continue;
                const v = S_(n, e, _, o, u);
                if (isNaN(v)) return v;
                if ((u = Math.min(u, v)) === 0) return u;
              }
              return u;
            }
            function wd(n) {
              return (
                n === "Point" ||
                n === "MultiPoint" ||
                n === "LineString" ||
                n === "MultiLineString" ||
                n === "Polygon" ||
                n === "MultiPolygon"
              );
            }
            class Sa {
              constructor(e, i) {
                ((this.type = Ft), (this.geojson = e), (this.geometries = i));
              }
              static parse(e, i) {
                if (e.length !== 2)
                  return i.error(
                    `'distance' expression requires either one argument, but found ' ${e.length - 1} instead.`,
                  );
                if (ui(e[1])) {
                  const o = e[1];
                  if (o.type === "FeatureCollection") {
                    for (let a = 0; a < o.features.length; ++a)
                      if (wd(o.features[a].geometry.type))
                        return new Sa(o, o.features[a].geometry);
                  } else if (o.type === "Feature") {
                    if (wd(o.geometry.type)) return new Sa(o, o.geometry);
                  } else if (wd(o.type)) return new Sa(o, o);
                }
                return i.error(
                  "'distance' expression needs to be an array with format ['Distance', GeoJSONObj].",
                );
              }
              evaluate(e) {
                const i = e.geometry(),
                  o = e.canonicalID();
                if (i != null && o != null) {
                  if (e.geometryType() === "Point")
                    return (function (a, u, d) {
                      const _ = [];
                      for (const b of a) for (const E of b) _.push(Gh(E, u));
                      const v = new dl(_[0][1], "meters");
                      return d.type === "Point" ||
                        d.type === "MultiPoint" ||
                        d.type === "LineString"
                        ? zp(
                            _,
                            !1,
                            d.type === "Point"
                              ? [d.coordinates]
                              : d.coordinates,
                            d.type === "LineString",
                            v,
                          )
                        : d.type === "MultiLineString"
                          ? bd(_, !1, d.coordinates, v)
                          : d.type === "Polygon" || d.type === "MultiPolygon"
                            ? Hh(
                                _,
                                !1,
                                d.type === "Polygon"
                                  ? [d.coordinates]
                                  : d.coordinates,
                                v,
                              )
                            : null;
                    })(i, o, this.geometries);
                  if (e.geometryType() === "LineString")
                    return (function (a, u, d) {
                      const _ = [];
                      for (const b of a) {
                        const E = [];
                        for (const A of b) E.push(Gh(A, u));
                        _.push(E);
                      }
                      const v = new dl(_[0][0][1], "meters");
                      if (
                        d.type === "Point" ||
                        d.type === "MultiPoint" ||
                        d.type === "LineString"
                      )
                        return bd(
                          d.type === "Point" ? [d.coordinates] : d.coordinates,
                          d.type === "LineString",
                          _,
                          v,
                        );
                      if (d.type === "MultiLineString") {
                        let b = 1 / 0;
                        for (let E = 0; E < d.coordinates.length; E++) {
                          const A = bd(d.coordinates[E], !0, _, v, b);
                          if (isNaN(A)) return A;
                          if ((b = Math.min(b, A)) === 0) return b;
                        }
                        return b;
                      }
                      if (d.type === "Polygon" || d.type === "MultiPolygon") {
                        let b = 1 / 0;
                        for (let E = 0; E < _.length; E++) {
                          const A = Hh(
                            _[E],
                            !0,
                            d.type === "Polygon"
                              ? [d.coordinates]
                              : d.coordinates,
                            v,
                            b,
                          );
                          if (isNaN(A)) return A;
                          if ((b = Math.min(b, A)) === 0) return b;
                        }
                        return b;
                      }
                      return null;
                    })(i, o, this.geometries);
                  if (e.geometryType() === "Polygon")
                    return (function (a, u, d) {
                      const _ = [];
                      for (const b of (function (E, A) {
                        const M = E.length;
                        if (M <= 1) return [E];
                        const R = [];
                        let k, N;
                        for (let j = 0; j < M; j++) {
                          const H = f_(E[j]);
                          H !== 0 &&
                            ((E[j].area = Math.abs(H)),
                            N === void 0 && (N = H < 0),
                            N === H < 0
                              ? (k && R.push(k), (k = [E[j]]))
                              : k.push(E[j]));
                        }
                        return (k && R.push(k), R);
                      })(a)) {
                        const E = [];
                        for (let A = 0; A < b.length; ++A) E.push(y_(b[A], u));
                        _.push(E);
                      }
                      const v = new dl(_[0][0][0][1], "meters");
                      if (
                        d.type === "Point" ||
                        d.type === "MultiPoint" ||
                        d.type === "LineString"
                      )
                        return Hh(
                          d.type === "Point" ? [d.coordinates] : d.coordinates,
                          d.type === "LineString",
                          _,
                          v,
                        );
                      if (d.type === "MultiLineString") {
                        let b = 1 / 0;
                        for (let E = 0; E < d.coordinates.length; E++) {
                          const A = Hh(d.coordinates[E], !0, _, v, b);
                          if (isNaN(A)) return A;
                          if ((b = Math.min(b, A)) === 0) return b;
                        }
                        return b;
                      }
                      return d.type === "Polygon" || d.type === "MultiPolygon"
                        ? (function (b, E, A) {
                            let M = 1 / 0;
                            for (const R of b)
                              for (const k of E) {
                                const N = T_(R, k, A, M);
                                if (isNaN(N)) return N;
                                if ((M = Math.min(M, N)) === 0) return M;
                              }
                            return M;
                          })(
                            d.type === "Polygon"
                              ? [d.coordinates]
                              : d.coordinates,
                            _,
                            v,
                          )
                        : null;
                    })(i, o, this.geometries);
                  console.warn(
                    "Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.",
                  );
                } else
                  console.warn(
                    "Distance Expression: requirs valid feature and canonical information.",
                  );
                return null;
              }
              eachChild() {}
              outputDefined() {
                return !0;
              }
              serialize() {
                return ["distance", this.geojson];
              }
            }
            function gl(n) {
              if (
                (n instanceof lr &&
                  ((n.name === "get" && n.args.length === 1) ||
                    n.name === "feature-state" ||
                    (n.name === "has" && n.args.length === 1) ||
                    n.name === "properties" ||
                    n.name === "geometry-type" ||
                    n.name === "id" ||
                    /^filter-/.test(n.name))) ||
                n instanceof Er ||
                n instanceof Sa
              )
                return !1;
              if (n instanceof yl) return n.featureConstant;
              let e = !0;
              return (
                n.eachChild((i) => {
                  e && !gl(i) && (e = !1);
                }),
                e
              );
            }
            function Wh(n) {
              if (n instanceof lr && n.name === "feature-state") return !1;
              let e = !0;
              return (
                n.eachChild((i) => {
                  e && !Wh(i) && (e = !1);
                }),
                e
              );
            }
            function qh(n) {
              if (n instanceof yl) return new Set([n.key]);
              let e = new Set();
              return (
                n.eachChild((i) => {
                  e = new Set([...e, ...qh(i)]);
                }),
                e
              );
            }
            function _l(n, e) {
              if (n instanceof lr && e.indexOf(n.name) >= 0) return !1;
              let i = !0;
              return (
                n.eachChild((o) => {
                  i && !_l(o, e) && (i = !1);
                }),
                i
              );
            }
            function kp(n, e, i) {
              return [n, e, i].filter(Boolean).join("");
            }
            function Td(n, e) {
              switch (n) {
                case "string":
                  return _s(e);
                case "number":
                  return +e;
                case "boolean":
                  return !!e;
                case "color":
                  return Li.parse(e);
                case "formatted":
                  return Rr.fromString(_s(e));
                case "resolvedImage":
                  return Gr.build(_s(e));
              }
              return e;
            }
            function Lp(n, e, i, o) {
              return (
                o !== void 0 && (n = o * Math.round(n / o)),
                e !== void 0 && n < e && (n = e),
                i !== void 0 && n > i && (n = i),
                n
              );
            }
            class yl {
              constructor(e, i, o, a = !1) {
                ((this.type = e),
                  (this.key = i),
                  (this.scope = o),
                  (this.featureConstant = a));
              }
              static parse(e, i) {
                let o = i.expectedType;
                if ((o == null && (o = Oi), e.length < 2 || e.length > 3))
                  return i.error(
                    "Invalid number of arguments for 'config' expression.",
                  );
                const a = i.parse(e[1], 1);
                if (!(a instanceof Yt))
                  return i.error(
                    "Key name of 'config' expression must be a string literal.",
                  );
                let u,
                  d = !0;
                const _ = _s(a.value);
                if (e.length >= 3) {
                  const v = i.parse(e[2], 2);
                  if (!(v instanceof Yt))
                    return i.error(
                      "Scope of 'config' expression must be a string literal.",
                    );
                  u = _s(v.value);
                }
                if (i.options) {
                  const v = kp(_, u, i._scope),
                    b = i.options.get(v);
                  b && (d = gl(b.value || b.default));
                }
                return new yl(o, _, u, d);
              }
              evaluate(e) {
                const i = kp(this.key, this.scope, e.scope),
                  o = e.getConfig(i);
                if (!o) return null;
                const {
                    type: a,
                    value: u,
                    values: d,
                    minValue: _,
                    maxValue: v,
                    stepValue: b,
                  } = o,
                  E = o.default.evaluate(e);
                let A = E;
                if (u) {
                  const M = e.scope;
                  ((e.scope = (M || "").split("").slice(1).join("")),
                    (A = u.evaluate(e)),
                    (e.scope = M));
                }
                return (
                  a && (A = Td(a, A)),
                  A === void 0 ||
                    (_ === void 0 && v === void 0 && b === void 0) ||
                    (typeof A == "number"
                      ? (A = Lp(A, _, v, b))
                      : Array.isArray(A) &&
                        (A = A.map((M) =>
                          typeof M == "number" ? Lp(M, _, v, b) : M,
                        ))),
                  u !== void 0 &&
                    A !== void 0 &&
                    d &&
                    !d.includes(A) &&
                    ((A = E), a && (A = Td(a, A))),
                  ((a && a !== this.type) ||
                    (A !== void 0 && !Oh(wt(A), this.type))) &&
                    (A = Td(this.type.kind, A)),
                  A
                );
              }
              eachChild() {}
              outputDefined() {
                return !1;
              }
              serialize() {
                const e = ["config", this.key];
                return (this.scope && e.concat(this.scope), e);
              }
            }
            class Zh {
              constructor(e, i) {
                ((this.type = i.type),
                  (this.name = e),
                  (this.boundExpression = i));
              }
              static parse(e, i) {
                if (e.length !== 2 || typeof e[1] != "string")
                  return i.error(
                    "'var' expression requires exactly one string literal argument.",
                  );
                const o = e[1];
                return i.scope.has(o)
                  ? new Zh(o, i.scope.get(o))
                  : i.error(
                      `Unknown variable "${o}". Make sure "${o}" has been bound in an enclosing "let" expression before using it.`,
                      1,
                    );
              }
              evaluate(e) {
                return this.boundExpression.evaluate(e);
              }
              eachChild() {}
              outputDefined() {
                return !1;
              }
              serialize() {
                return ["var", this.name];
              }
            }
            class Xh {
              constructor(e, i = [], o, a = new hd(), u = [], d, _) {
                ((this.registry = e),
                  (this.path = i),
                  (this.key = i
                    .map((v) => (typeof v == "string" ? `['${v}']` : `[${v}]`))
                    .join("")),
                  (this.scope = a),
                  (this.errors = u),
                  (this.expectedType = o),
                  (this._scope = d),
                  (this.options = _));
              }
              parse(e, i, o, a, u = {}) {
                return i || o
                  ? this.concat(i, null, o, a)._parse(e, u)
                  : this._parse(e, u);
              }
              parseObjectValue(e, i, o, a, u, d = {}) {
                return this.concat(i, o, a, u)._parse(e, d);
              }
              _parse(e, i) {
                function o(a, u, d) {
                  return d === "assert"
                    ? new Gt(u, [a])
                    : d === "coerce"
                      ? new ys(u, [a])
                      : a;
                }
                if (
                  ((e !== null &&
                    typeof e != "string" &&
                    typeof e != "boolean" &&
                    typeof e != "number") ||
                    (e = ["literal", e]),
                  Array.isArray(e))
                ) {
                  if (e.length === 0)
                    return this.error(
                      'Expected an array with at least one element. If you wanted a literal array, use ["literal", []].',
                    );
                  const a =
                    typeof e[0] == "string" ? this.registry[e[0]] : void 0;
                  if (a) {
                    let u = a.parse(e, this);
                    if (!u) return null;
                    if (this.expectedType) {
                      const d = this.expectedType,
                        _ = u.type;
                      if (
                        (d.kind !== "string" &&
                          d.kind !== "number" &&
                          d.kind !== "boolean" &&
                          d.kind !== "object" &&
                          d.kind !== "array") ||
                        _.kind !== "value"
                      )
                        if (
                          (d.kind !== "color" &&
                            d.kind !== "formatted" &&
                            d.kind !== "resolvedImage") ||
                          (_.kind !== "value" && _.kind !== "string")
                        ) {
                          if (this.checkSubtype(d, _)) return null;
                        } else u = o(u, d, i.typeAnnotation || "coerce");
                      else u = o(u, d, i.typeAnnotation || "assert");
                    }
                    if (
                      !(u instanceof Yt) &&
                      u.type.kind !== "resolvedImage" &&
                      Sd(u)
                    ) {
                      const d = new wc(this._scope, this.options);
                      try {
                        u = new Yt(u.type, u.evaluate(d));
                      } catch (_) {
                        return (this.error(_.message), null);
                      }
                    }
                    return u;
                  }
                  return ys.parse(["to-array", e], this);
                }
                return this.error(
                  e === void 0
                    ? "'undefined' value invalid. Use null instead."
                    : typeof e == "object"
                      ? 'Bare objects invalid. Use ["literal", {...}] instead.'
                      : `Expected an array, but found ${typeof e} instead.`,
                );
              }
              concat(e, i, o, a) {
                let u = typeof e == "number" ? this.path.concat(e) : this.path;
                u = typeof i == "string" ? u.concat(i) : u;
                const d = a ? this.scope.concat(a) : this.scope;
                return new Xh(
                  this.registry,
                  u,
                  o || null,
                  d,
                  this.errors,
                  this._scope,
                  this.options,
                );
              }
              error(e, ...i) {
                const o = `${this.key}${i.map((a) => `[${a}]`).join("")}`;
                this.errors.push(new os(o, e));
              }
              checkSubtype(e, i) {
                const o = ol(e, i);
                return (o && this.error(o), o);
              }
            }
            function Sd(n) {
              if (n instanceof Zh) return Sd(n.boundExpression);
              if (
                (n instanceof lr && n.name === "error") ||
                n instanceof Bs ||
                n instanceof Er ||
                n instanceof Sa ||
                n instanceof yl
              )
                return !1;
              const e = n instanceof ys || n instanceof Gt;
              let i = !0;
              return (
                n.eachChild((o) => {
                  i = e ? i && Sd(o) : i && o instanceof Yt;
                }),
                !!i &&
                  gl(n) &&
                  _l(n, [
                    "zoom",
                    "heatmap-density",
                    "worldview",
                    "line-progress",
                    "raster-value",
                    "sky-radial-progress",
                    "accumulated",
                    "is-supported-script",
                    "pitch",
                    "distance-from-center",
                    "measure-light",
                    "raster-particle-speed",
                  ])
              );
            }
            function Yh(n, e) {
              const i = n.length - 1;
              let o,
                a,
                u = 0,
                d = i,
                _ = 0;
              for (; u <= d; )
                if (
                  ((_ = Math.floor((u + d) / 2)),
                  (o = n[_]),
                  (a = n[_ + 1]),
                  o <= e)
                ) {
                  if (_ === i || e < a) return _;
                  u = _ + 1;
                } else {
                  if (!(o > e)) throw new Wn("Input is not a number.");
                  d = _ - 1;
                }
              return 0;
            }
            class Ac {
              constructor(e, i, o) {
                ((this.type = e),
                  (this.input = i),
                  (this.labels = []),
                  (this.outputs = []));
                for (const [a, u] of o)
                  (this.labels.push(a), this.outputs.push(u));
              }
              static parse(e, i) {
                if (e.length - 1 < 4)
                  return i.error(
                    `Expected at least 4 arguments, but found only ${e.length - 1}.`,
                  );
                if ((e.length - 1) % 2 != 0)
                  return i.error("Expected an even number of arguments.");
                const o = i.parse(e[1], 1, Ft);
                if (!o) return null;
                const a = [];
                let u = null;
                i.expectedType &&
                  i.expectedType.kind !== "value" &&
                  (u = i.expectedType);
                for (let d = 1; d < e.length; d += 2) {
                  const _ = d === 1 ? -1 / 0 : e[d],
                    v = e[d + 1],
                    b = d,
                    E = d + 1;
                  if (typeof _ != "number")
                    return i.error(
                      'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
                      b,
                    );
                  if (a.length && a[a.length - 1][0] >= _)
                    return i.error(
                      'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.',
                      b,
                    );
                  const A = i.parse(v, E, u);
                  if (!A) return null;
                  ((u = u || A.type), a.push([_, A]));
                }
                return new Ac(u, o, a);
              }
              evaluate(e) {
                const i = this.labels,
                  o = this.outputs;
                if (i.length === 1) return o[0].evaluate(e);
                const a = this.input.evaluate(e);
                if (a <= i[0]) return o[0].evaluate(e);
                const u = i.length;
                return a >= i[u - 1]
                  ? o[u - 1].evaluate(e)
                  : o[Yh(i, a)].evaluate(e);
              }
              eachChild(e) {
                e(this.input);
                for (const i of this.outputs) e(i);
              }
              outputDefined() {
                return this.outputs.every((e) => e.outputDefined());
              }
              serialize() {
                const e = ["step", this.input.serialize()];
                for (let i = 0; i < this.labels.length; i++)
                  (i > 0 && e.push(this.labels[i]),
                    e.push(this.outputs[i].serialize()));
                return e;
              }
            }
            const Op = 0.95047,
              Fp = 1.08883,
              Bp = 4 / 29,
              Lo = 6 / 29,
              Np = 3 * Lo * Lo,
              Vp = Lo * Lo * Lo,
              E_ = Math.PI / 180,
              I_ = 180 / Math.PI;
            function Ed(n) {
              return n > Vp ? Math.pow(n, 1 / 3) : n / Np + Bp;
            }
            function Kh(n) {
              return n > Lo ? n * n * n : Np * (n - Bp);
            }
            function Jh(n) {
              return (
                255 *
                (n <= 0.0031308
                  ? 12.92 * n
                  : 1.055 * Math.pow(n, 1 / 2.4) - 0.055)
              );
            }
            function Oo(n) {
              return (n /= 255) <= 0.04045
                ? n / 12.92
                : Math.pow((n + 0.055) / 1.055, 2.4);
            }
            function Id(n) {
              const e = Oo(n.r),
                i = Oo(n.g),
                o = Oo(n.b),
                a = Ed((0.4124564 * e + 0.3575761 * i + 0.1804375 * o) / Op),
                u = Ed((0.2126729 * e + 0.7151522 * i + 0.072175 * o) / 1);
              return {
                l: 116 * u - 16,
                a: 500 * (a - u),
                b:
                  200 *
                  (u - Ed((0.0193339 * e + 0.119192 * i + 0.9503041 * o) / Fp)),
                alpha: n.a,
              };
            }
            function Ad(n) {
              let e = (n.l + 16) / 116,
                i = isNaN(n.a) ? e : e + n.a / 500,
                o = isNaN(n.b) ? e : e - n.b / 200;
              return (
                (e = 1 * Kh(e)),
                (i = Op * Kh(i)),
                (o = Fp * Kh(o)),
                new Li(
                  Jh(3.2404542 * i - 1.5371385 * e - 0.4985314 * o),
                  Jh(-0.969266 * i + 1.8760108 * e + 0.041556 * o),
                  Jh(0.0556434 * i - 0.2040259 * e + 1.0572252 * o),
                  n.alpha,
                )
              );
            }
            function A_(n, e, i) {
              const o = e - n;
              return (
                n +
                i * (o > 180 || o < -180 ? o - 360 * Math.round(o / 360) : o)
              );
            }
            const Ea = {
                forward: Id,
                reverse: Ad,
                interpolate: function (n, e, i) {
                  return {
                    l: Ht(n.l, e.l, i),
                    a: Ht(n.a, e.a, i),
                    b: Ht(n.b, e.b, i),
                    alpha: Ht(n.alpha, e.alpha, i),
                  };
                },
              },
              Ia = {
                forward: function (n) {
                  const { l: e, a: i, b: o } = Id(n),
                    a = Math.atan2(o, i) * I_;
                  return {
                    h: a < 0 ? a + 360 : a,
                    c: Math.sqrt(i * i + o * o),
                    l: e,
                    alpha: n.a,
                  };
                },
                reverse: function (n) {
                  const e = n.h * E_,
                    i = n.c;
                  return Ad({
                    l: n.l,
                    a: Math.cos(e) * i,
                    b: Math.sin(e) * i,
                    alpha: n.alpha,
                  });
                },
                interpolate: function (n, e, i) {
                  return {
                    h: A_(n.h, e.h, i),
                    c: Ht(n.c, e.c, i),
                    l: Ht(n.l, e.l, i),
                    alpha: Ht(n.alpha, e.alpha, i),
                  };
                },
              };
            var Up = Object.freeze({ __proto__: null, hcl: Ia, lab: Ea });
            class ls {
              constructor(e, i, o, a, u) {
                ((this.type = e),
                  (this.operator = i),
                  (this.interpolation = o),
                  (this.input = a),
                  (this.labels = []),
                  (this.outputs = []));
                for (const [d, _] of u)
                  (this.labels.push(d), this.outputs.push(_));
              }
              static interpolationFactor(e, i, o, a) {
                let u = 0;
                if (e.name === "exponential") u = Qh(i, e.base, o, a);
                else if (e.name === "linear") u = Qh(i, 1, o, a);
                else if (e.name === "cubic-bezier") {
                  const d = e.controlPoints;
                  u = new Sh(d[0], d[1], d[2], d[3]).solve(Qh(i, 1, o, a));
                }
                return u;
              }
              static parse(e, i) {
                let [o, a, u, ...d] = e;
                if (!Array.isArray(a) || a.length === 0)
                  return i.error(
                    "Expected an interpolation type expression.",
                    1,
                  );
                if (a[0] === "linear") a = { name: "linear" };
                else if (a[0] === "exponential") {
                  const b = a[1];
                  if (typeof b != "number")
                    return i.error(
                      "Exponential interpolation requires a numeric base.",
                      1,
                      1,
                    );
                  a = { name: "exponential", base: b };
                } else {
                  if (a[0] !== "cubic-bezier")
                    return i.error(
                      `Unknown interpolation type ${String(a[0])}`,
                      1,
                      0,
                    );
                  {
                    const b = a.slice(1);
                    if (
                      b.length !== 4 ||
                      b.some((E) => typeof E != "number" || E < 0 || E > 1)
                    )
                      return i.error(
                        "Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.",
                        1,
                      );
                    a = { name: "cubic-bezier", controlPoints: b };
                  }
                }
                if (e.length - 1 < 4)
                  return i.error(
                    `Expected at least 4 arguments, but found only ${e.length - 1}.`,
                  );
                if (e.length - 1 > 3 && (e.length - 1) % 2 != 0)
                  return i.error("Expected an even number of arguments.");
                if (((u = i.parse(u, 2, Ft)), !u)) return null;
                const _ = [];
                let v = null;
                o === "interpolate-hcl" || o === "interpolate-lab"
                  ? (v = Jr)
                  : i.expectedType &&
                    i.expectedType.kind !== "value" &&
                    (v = i.expectedType);
                for (let b = 0; b < d.length; b += 2) {
                  const E = d[b],
                    A = d[b + 1],
                    M = b + 3,
                    R = b + 4;
                  if (typeof E != "number")
                    return i.error(
                      'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.',
                      M,
                    );
                  if (_.length && _[_.length - 1][0] >= E)
                    return i.error(
                      'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.',
                      M,
                    );
                  const k = i.parse(A, R, v);
                  if (!k) return null;
                  ((v = v || k.type), _.push([E, k]));
                }
                return v.kind === "number" ||
                  v.kind === "color" ||
                  (v.kind === "array" &&
                    v.itemType.kind === "number" &&
                    typeof v.N == "number")
                  ? new ls(v, o, a, u, _)
                  : i.error(`Type ${Xn(v)} is not interpolatable.`);
              }
              evaluate(e) {
                const i = this.labels,
                  o = this.outputs;
                if (i.length === 1) return o[0].evaluate(e);
                const a = this.input.evaluate(e);
                if (a <= i[0]) return o[0].evaluate(e);
                const u = i.length;
                if (a >= i[u - 1]) return o[u - 1].evaluate(e);
                const d = Yh(i, a),
                  _ = ls.interpolationFactor(
                    this.interpolation,
                    a,
                    i[d],
                    i[d + 1],
                  ),
                  v = o[d].evaluate(e),
                  b = o[d + 1].evaluate(e);
                return this.operator === "interpolate"
                  ? gc[this.type.kind.toLowerCase()](v, b, _)
                  : this.operator === "interpolate-hcl"
                    ? Ia.reverse(
                        Ia.interpolate(Ia.forward(v), Ia.forward(b), _),
                      )
                    : Ea.reverse(
                        Ea.interpolate(Ea.forward(v), Ea.forward(b), _),
                      );
              }
              eachChild(e) {
                e(this.input);
                for (const i of this.outputs) e(i);
              }
              outputDefined() {
                return this.outputs.every((e) => e.outputDefined());
              }
              serialize() {
                let e;
                e =
                  this.interpolation.name === "linear"
                    ? ["linear"]
                    : this.interpolation.name === "exponential"
                      ? this.interpolation.base === 1
                        ? ["linear"]
                        : ["exponential", this.interpolation.base]
                      : ["cubic-bezier", ...this.interpolation.controlPoints];
                const i = [this.operator, e, this.input.serialize()];
                for (let o = 0; o < this.labels.length; o++)
                  i.push(this.labels[o], this.outputs[o].serialize());
                return i;
              }
            }
            function Qh(n, e, i, o) {
              const a = o - i,
                u = n - i;
              return a === 0
                ? 0
                : e === 1
                  ? u / a
                  : (Math.pow(e, u) - 1) / (Math.pow(e, a) - 1);
            }
            class Mc {
              constructor(e, i) {
                ((this.type = e), (this.args = i));
              }
              static parse(e, i) {
                if (e.length < 2)
                  return i.error("Expectected at least one argument.");
                let o = null;
                const a = i.expectedType;
                a && a.kind !== "value" && (o = a);
                const u = [];
                for (const _ of e.slice(1)) {
                  const v = i.parse(_, 1 + u.length, o, void 0, {
                    typeAnnotation: "omit",
                  });
                  if (!v) return null;
                  ((o = o || v.type), u.push(v));
                }
                const d = a && u.some((_) => ol(a, _.type));
                return new Mc(d ? Oi : o, u);
              }
              evaluate(e) {
                let i,
                  o = null,
                  a = 0;
                for (const u of this.args) {
                  if (
                    (a++,
                    (o = u.evaluate(e)),
                    o &&
                      o instanceof Gr &&
                      !o.available &&
                      (i || (i = o), (o = null), a === this.args.length))
                  )
                    return i;
                  if (o !== null) break;
                }
                return o;
              }
              eachChild(e) {
                this.args.forEach(e);
              }
              outputDefined() {
                return this.args.every((e) => e.outputDefined());
              }
              serialize() {
                const e = ["coalesce"];
                return (
                  this.eachChild((i) => {
                    e.push(i.serialize());
                  }),
                  e
                );
              }
            }
            class eu {
              constructor(e, i) {
                ((this.type = i.type),
                  (this.bindings = [].concat(e)),
                  (this.result = i));
              }
              evaluate(e) {
                return this.result.evaluate(e);
              }
              eachChild(e) {
                for (const i of this.bindings) e(i[1]);
                e(this.result);
              }
              static parse(e, i) {
                if (e.length < 4)
                  return i.error(
                    `Expected at least 3 arguments, but found ${e.length - 1} instead.`,
                  );
                const o = [];
                for (let u = 1; u < e.length - 1; u += 2) {
                  const d = e[u];
                  if (typeof d != "string")
                    return i.error(
                      `Expected string, but found ${typeof d} instead.`,
                      u,
                    );
                  if (/[^a-zA-Z0-9_]/.test(d))
                    return i.error(
                      "Variable names must contain only alphanumeric characters or '_'.",
                      u,
                    );
                  const _ = i.parse(e[u + 1], u + 1);
                  if (!_) return null;
                  o.push([d, _]);
                }
                const a = i.parse(
                  e[e.length - 1],
                  e.length - 1,
                  i.expectedType,
                  o,
                );
                return a ? new eu(o, a) : null;
              }
              outputDefined() {
                return this.result.outputDefined();
              }
              serialize() {
                const e = ["let"];
                for (const [i, o] of this.bindings) e.push(i, o.serialize());
                return (e.push(this.result.serialize()), e);
              }
            }
            class Md {
              constructor(e, i, o) {
                ((this.type = e), (this.index = i), (this.input = o));
              }
              static parse(e, i) {
                if (e.length !== 3)
                  return i.error(
                    `Expected 2 arguments, but found ${e.length - 1} instead.`,
                  );
                const o = i.parse(e[1], 1, Ft),
                  a = i.parse(e[2], 2, Dr(i.expectedType || Oi));
                return o && a ? new Md(a.type.itemType, o, a) : null;
              }
              evaluate(e) {
                const i = this.index.evaluate(e),
                  o = this.input.evaluate(e);
                if (i < 0) throw new Wn(`Array index out of bounds: ${i} < 0.`);
                if (i >= o.length)
                  throw new Wn(
                    `Array index out of bounds: ${i} > ${o.length - 1}.`,
                  );
                if (i !== Math.floor(i))
                  throw new Wn(
                    `Array index must be an integer, but found ${i} instead. Use at-interpolated to retrieve interpolated result with a fractional index.`,
                  );
                return o[i];
              }
              eachChild(e) {
                (e(this.index), e(this.input));
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return ["at", this.index.serialize(), this.input.serialize()];
              }
            }
            class Cd {
              constructor(e, i, o) {
                ((this.type = e), (this.index = i), (this.input = o));
              }
              static parse(e, i) {
                if (e.length !== 3)
                  return i.error(
                    `Expected 2 arguments, but found ${e.length - 1} instead.`,
                  );
                const o = i.parse(e[1], 1, Ft),
                  a = i.parse(e[2], 2, Dr(i.expectedType || Oi));
                return o && a ? new Cd(a.type.itemType, o, a) : null;
              }
              evaluate(e) {
                const i = this.index.evaluate(e),
                  o = this.input.evaluate(e);
                if (i < 0) throw new Wn(`Array index out of bounds: ${i} < 0.`);
                if (i > o.length - 1)
                  throw new Wn(
                    `Array index out of bounds: ${i} > ${o.length - 1}.`,
                  );
                if (i === Math.floor(i)) return o[i];
                const a = Math.floor(i),
                  u = Math.ceil(i),
                  d = o[a],
                  _ = o[u];
                if (typeof d != "number" || typeof _ != "number")
                  throw new Wn(
                    `Cannot interpolate between non-number values at index ${i}.`,
                  );
                const v = i - a;
                return d * (1 - v) + _ * v;
              }
              eachChild(e) {
                (e(this.index), e(this.input));
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return [
                  "at-interpolated",
                  this.index.serialize(),
                  this.input.serialize(),
                ];
              }
            }
            class tu {
              constructor(e, i) {
                ((this.type = zi), (this.needle = e), (this.haystack = i));
              }
              static parse(e, i) {
                if (e.length !== 3)
                  return i.error(
                    `Expected 2 arguments, but found ${e.length - 1} instead.`,
                  );
                const o = i.parse(e[1], 1, Oi),
                  a = i.parse(e[2], 2, Oi);
                return o && a
                  ? Ro(o.type, [zi, $i, Ft, sl, Oi])
                    ? new tu(o, a)
                    : i.error(
                        `Expected first argument to be of type boolean, string, number or null, but found ${Xn(o.type)} instead`,
                      )
                  : null;
              }
              evaluate(e) {
                const i = this.needle.evaluate(e),
                  o = this.haystack.evaluate(e);
                if (o == null) return !1;
                if (!xc(i, ["boolean", "string", "number", "null"]))
                  throw new Wn(
                    `Expected first argument to be of type boolean, string, number or null, but found ${Xn(wt(i))} instead.`,
                  );
                if (!xc(o, ["string", "array"]))
                  throw new Wn(
                    `Expected second argument to be of type array or string, but found ${Xn(wt(o))} instead.`,
                  );
                return o.indexOf(i) >= 0;
              }
              eachChild(e) {
                (e(this.needle), e(this.haystack));
              }
              outputDefined() {
                return !0;
              }
              serialize() {
                return [
                  "in",
                  this.needle.serialize(),
                  this.haystack.serialize(),
                ];
              }
            }
            class Cc {
              constructor(e, i, o) {
                ((this.type = Ft),
                  (this.needle = e),
                  (this.haystack = i),
                  (this.fromIndex = o));
              }
              static parse(e, i) {
                if (e.length <= 2 || e.length >= 5)
                  return i.error(
                    `Expected 3 or 4 arguments, but found ${e.length - 1} instead.`,
                  );
                const o = i.parse(e[1], 1, Oi),
                  a = i.parse(e[2], 2, Oi);
                if (!o || !a) return null;
                if (!Ro(o.type, [zi, $i, Ft, sl, Oi]))
                  return i.error(
                    `Expected first argument to be of type boolean, string, number or null, but found ${Xn(o.type)} instead`,
                  );
                if (e.length === 4) {
                  const u = i.parse(e[3], 3, Ft);
                  return u ? new Cc(o, a, u) : null;
                }
                return new Cc(o, a);
              }
              evaluate(e) {
                const i = this.needle.evaluate(e),
                  o = this.haystack.evaluate(e);
                if (!xc(i, ["boolean", "string", "number", "null"]))
                  throw new Wn(
                    `Expected first argument to be of type boolean, string, number or null, but found ${Xn(wt(i))} instead.`,
                  );
                if (!xc(o, ["string", "array"]))
                  throw new Wn(
                    `Expected second argument to be of type array or string, but found ${Xn(wt(o))} instead.`,
                  );
                if (this.fromIndex) {
                  const a = this.fromIndex.evaluate(e);
                  return o.indexOf(i, a);
                }
                return o.indexOf(i);
              }
              eachChild(e) {
                (e(this.needle),
                  e(this.haystack),
                  this.fromIndex && e(this.fromIndex));
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                if (this.fromIndex != null && this.fromIndex !== void 0) {
                  const e = this.fromIndex.serialize();
                  return [
                    "index-of",
                    this.needle.serialize(),
                    this.haystack.serialize(),
                    e,
                  ];
                }
                return [
                  "index-of",
                  this.needle.serialize(),
                  this.haystack.serialize(),
                ];
              }
            }
            class xl {
              constructor(e, i, o, a, u, d) {
                ((this.inputType = e),
                  (this.type = i),
                  (this.input = o),
                  (this.cases = a),
                  (this.outputs = u),
                  (this.otherwise = d));
              }
              static parse(e, i) {
                if (e.length < 5)
                  return i.error(
                    `Expected at least 4 arguments, but found only ${e.length - 1}.`,
                  );
                if (e.length % 2 != 1)
                  return i.error("Expected an even number of arguments.");
                let o, a;
                i.expectedType &&
                  i.expectedType.kind !== "value" &&
                  (a = i.expectedType);
                const u = {},
                  d = [];
                for (let b = 2; b < e.length - 1; b += 2) {
                  let E = e[b];
                  const A = e[b + 1];
                  Array.isArray(E) || (E = [E]);
                  const M = i.concat(b);
                  if (E.length === 0)
                    return M.error("Expected at least one branch label.");
                  for (const k of E) {
                    if (typeof k != "number" && typeof k != "string")
                      return M.error(
                        "Branch labels must be numbers or strings.",
                      );
                    if (
                      typeof k == "number" &&
                      Math.abs(k) > Number.MAX_SAFE_INTEGER
                    )
                      return M.error(
                        `Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`,
                      );
                    if (typeof k == "number" && Math.floor(k) !== k)
                      return M.error(
                        "Numeric branch labels must be integer values.",
                      );
                    if (o) {
                      if (M.checkSubtype(o, wt(k))) return null;
                    } else o = wt(k);
                    if (u[String(k)] !== void 0)
                      return M.error("Branch labels must be unique.");
                    u[String(k)] = d.length;
                  }
                  const R = i.parse(A, b, a);
                  if (!R) return null;
                  ((a = a || R.type), d.push(R));
                }
                const _ = i.parse(e[1], 1, Oi);
                if (!_) return null;
                const v = i.parse(e[e.length - 1], e.length - 1, a);
                return v
                  ? _.type.kind !== "value" &&
                    i.concat(1).checkSubtype(o, _.type)
                    ? null
                    : new xl(o, a, _, u, d, v)
                  : null;
              }
              evaluate(e) {
                const i = this.input.evaluate(e);
                return (
                  (Oh(wt(i), this.inputType) && this.outputs[this.cases[i]]) ||
                  this.otherwise
                ).evaluate(e);
              }
              eachChild(e) {
                (e(this.input), this.outputs.forEach(e), e(this.otherwise));
              }
              outputDefined() {
                return (
                  this.outputs.every((e) => e.outputDefined()) &&
                  this.otherwise.outputDefined()
                );
              }
              serialize() {
                const e = ["match", this.input.serialize()],
                  i = Object.keys(this.cases).sort(),
                  o = [],
                  a = {};
                for (const d of i) {
                  const _ = a[this.cases[d]];
                  _ === void 0
                    ? ((a[this.cases[d]] = o.length),
                      o.push([this.cases[d], [d]]))
                    : o[_][1].push(d);
                }
                const u = (d) =>
                  this.inputType.kind === "number" ? Number(d) : d;
                for (const [d, _] of o)
                  (e.push(_.length === 1 ? u(_[0]) : _.map(u)),
                    e.push(this.outputs[d].serialize()));
                return (e.push(this.otherwise.serialize()), e);
              }
            }
            class Pd {
              constructor(e, i, o) {
                ((this.type = e), (this.branches = i), (this.otherwise = o));
              }
              static parse(e, i) {
                if (e.length < 4)
                  return i.error(
                    `Expected at least 3 arguments, but found only ${e.length - 1}.`,
                  );
                if (e.length % 2 != 0)
                  return i.error("Expected an odd number of arguments.");
                let o;
                i.expectedType &&
                  i.expectedType.kind !== "value" &&
                  (o = i.expectedType);
                const a = [];
                for (let d = 1; d < e.length - 1; d += 2) {
                  const _ = i.parse(e[d], d, zi);
                  if (!_) return null;
                  const v = i.parse(e[d + 1], d + 1, o);
                  if (!v) return null;
                  (a.push([_, v]), (o = o || v.type));
                }
                const u = i.parse(e[e.length - 1], e.length - 1, o);
                return u ? new Pd(o, a, u) : null;
              }
              evaluate(e) {
                for (const [i, o] of this.branches)
                  if (i.evaluate(e)) return o.evaluate(e);
                return this.otherwise.evaluate(e);
              }
              eachChild(e) {
                for (const [i, o] of this.branches) (e(i), e(o));
                e(this.otherwise);
              }
              outputDefined() {
                return (
                  this.branches.every(([e, i]) => i.outputDefined()) &&
                  this.otherwise.outputDefined()
                );
              }
              serialize() {
                const e = ["case"];
                return (
                  this.eachChild((i) => {
                    e.push(i.serialize());
                  }),
                  e
                );
              }
            }
            class Pc {
              constructor(e, i, o, a) {
                ((this.type = e),
                  (this.input = i),
                  (this.beginIndex = o),
                  (this.endIndex = a));
              }
              static parse(e, i) {
                if (e.length <= 2 || e.length >= 5)
                  return i.error(
                    `Expected 3 or 4 arguments, but found ${e.length - 1} instead.`,
                  );
                const o = i.parse(e[1], 1, Oi),
                  a = i.parse(e[2], 2, Ft);
                if (!o || !a) return null;
                if (!Ro(o.type, [Dr(Oi), $i, Oi]))
                  return i.error(
                    `Expected first argument to be of type array or string, but found ${Xn(o.type)} instead`,
                  );
                if (e.length === 4) {
                  const u = i.parse(e[3], 3, Ft);
                  return u ? new Pc(o.type, o, a, u) : null;
                }
                return new Pc(o.type, o, a);
              }
              evaluate(e) {
                const i = this.input.evaluate(e),
                  o = this.beginIndex.evaluate(e);
                if (!xc(i, ["string", "array"]))
                  throw new Wn(
                    `Expected first argument to be of type array or string, but found ${Xn(wt(i))} instead.`,
                  );
                if (this.endIndex) {
                  const a = this.endIndex.evaluate(e);
                  return i.slice(o, a);
                }
                return i.slice(o);
              }
              eachChild(e) {
                (e(this.input),
                  e(this.beginIndex),
                  this.endIndex && e(this.endIndex));
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                if (this.endIndex != null && this.endIndex !== void 0) {
                  const e = this.endIndex.serialize();
                  return [
                    "slice",
                    this.input.serialize(),
                    this.beginIndex.serialize(),
                    e,
                  ];
                }
                return [
                  "slice",
                  this.input.serialize(),
                  this.beginIndex.serialize(),
                ];
              }
            }
            function jp(n, e) {
              return n === "==" || n === "!="
                ? e.kind === "boolean" ||
                    e.kind === "string" ||
                    e.kind === "number" ||
                    e.kind === "null" ||
                    e.kind === "value"
                : e.kind === "string" ||
                    e.kind === "number" ||
                    e.kind === "value";
            }
            function Gp(n, e, i, o) {
              return o.compare(e, i) === 0;
            }
            function Aa(n, e, i) {
              const o = n !== "==" && n !== "!=";
              return class jT {
                constructor(u, d, _) {
                  ((this.type = zi),
                    (this.lhs = u),
                    (this.rhs = d),
                    (this.collator = _),
                    (this.hasUntypedArgument =
                      u.type.kind === "value" || d.type.kind === "value"));
                }
                static parse(u, d) {
                  if (u.length !== 3 && u.length !== 4)
                    return d.error("Expected two or three arguments.");
                  const _ = u[0];
                  let v = d.parse(u[1], 1, Oi);
                  if (!v) return null;
                  if (!jp(_, v.type))
                    return d
                      .concat(1)
                      .error(
                        `"${_}" comparisons are not supported for type '${Xn(v.type)}'.`,
                      );
                  let b = d.parse(u[2], 2, Oi);
                  if (!b) return null;
                  if (!jp(_, b.type))
                    return d
                      .concat(2)
                      .error(
                        `"${_}" comparisons are not supported for type '${Xn(b.type)}'.`,
                      );
                  if (
                    v.type.kind !== b.type.kind &&
                    v.type.kind !== "value" &&
                    b.type.kind !== "value"
                  )
                    return d.error(
                      `Cannot compare types '${Xn(v.type)}' and '${Xn(b.type)}'.`,
                    );
                  o &&
                    (v.type.kind === "value" && b.type.kind !== "value"
                      ? (v = new Gt(b.type, [v]))
                      : v.type.kind !== "value" &&
                        b.type.kind === "value" &&
                        (b = new Gt(v.type, [b])));
                  let E = null;
                  if (u.length === 4) {
                    if (
                      v.type.kind !== "string" &&
                      b.type.kind !== "string" &&
                      v.type.kind !== "value" &&
                      b.type.kind !== "value"
                    )
                      return d.error(
                        "Cannot use collator to compare non-string types.",
                      );
                    if (((E = d.parse(u[3], 3, Lh)), !E)) return null;
                  }
                  return new jT(v, b, E);
                }
                evaluate(u) {
                  const d = this.lhs.evaluate(u),
                    _ = this.rhs.evaluate(u);
                  if (o && this.hasUntypedArgument) {
                    const v = wt(d),
                      b = wt(_);
                    if (
                      v.kind !== b.kind ||
                      (v.kind !== "string" && v.kind !== "number")
                    )
                      throw new Wn(
                        `Expected arguments for "${n}" to be (string, string) or (number, number), but found (${v.kind}, ${b.kind}) instead.`,
                      );
                  }
                  if (this.collator && !o && this.hasUntypedArgument) {
                    const v = wt(d),
                      b = wt(_);
                    if (v.kind !== "string" || b.kind !== "string")
                      return e(u, d, _);
                  }
                  return this.collator
                    ? i(u, d, _, this.collator.evaluate(u))
                    : e(u, d, _);
                }
                eachChild(u) {
                  (u(this.lhs), u(this.rhs), this.collator && u(this.collator));
                }
                outputDefined() {
                  return !0;
                }
                serialize() {
                  const u = [n];
                  return (
                    this.eachChild((d) => {
                      u.push(d.serialize());
                    }),
                    u
                  );
                }
              };
            }
            const $p = Aa(
                "==",
                function (n, e, i) {
                  return e === i;
                },
                Gp,
              ),
              M_ = Aa(
                "!=",
                function (n, e, i) {
                  return e !== i;
                },
                function (n, e, i, o) {
                  return !Gp(0, e, i, o);
                },
              ),
              C_ = Aa(
                "<",
                function (n, e, i) {
                  return e < i;
                },
                function (n, e, i, o) {
                  return o.compare(e, i) < 0;
                },
              ),
              P_ = Aa(
                ">",
                function (n, e, i) {
                  return e > i;
                },
                function (n, e, i, o) {
                  return o.compare(e, i) > 0;
                },
              ),
              iu = Aa(
                "<=",
                function (n, e, i) {
                  return e <= i;
                },
                function (n, e, i, o) {
                  return o.compare(e, i) <= 0;
                },
              ),
              D_ = Aa(
                ">=",
                function (n, e, i) {
                  return e >= i;
                },
                function (n, e, i, o) {
                  return o.compare(e, i) >= 0;
                },
              );
            class nu {
              constructor(e, i, o, a, u, d) {
                ((this.type = $i),
                  (this.number = e),
                  (this.locale = i),
                  (this.currency = o),
                  (this.unit = a),
                  (this.minFractionDigits = u),
                  (this.maxFractionDigits = d));
              }
              static parse(e, i) {
                if (e.length !== 3) return i.error("Expected two arguments.");
                const o = i.parse(e[1], 1, Ft);
                if (!o) return null;
                const a = e[2];
                if (typeof a != "object" || Array.isArray(a))
                  return i.error(
                    "NumberFormat options argument must be an object.",
                  );
                let u = null;
                if (
                  a.locale &&
                  ((u = i.parseObjectValue(a.locale, 2, "locale", $i)), !u)
                )
                  return null;
                let d = null;
                if (
                  a.currency &&
                  ((d = i.parseObjectValue(a.currency, 2, "currency", $i)), !d)
                )
                  return null;
                let _ = null;
                if (
                  a.unit &&
                  ((_ = i.parseObjectValue(a.unit, 2, "unit", $i)), !_)
                )
                  return null;
                let v = null;
                if (
                  a["min-fraction-digits"] &&
                  ((v = i.parseObjectValue(
                    a["min-fraction-digits"],
                    2,
                    "min-fraction-digits",
                    Ft,
                  )),
                  !v)
                )
                  return null;
                let b = null;
                return a["max-fraction-digits"] &&
                  ((b = i.parseObjectValue(
                    a["max-fraction-digits"],
                    2,
                    "max-fraction-digits",
                    Ft,
                  )),
                  !b)
                  ? null
                  : new nu(o, u, d, _, v, b);
              }
              evaluate(e) {
                return new Intl.NumberFormat(
                  this.locale ? this.locale.evaluate(e) : [],
                  {
                    style:
                      (this.currency ? "currency" : this.unit && "unit") ||
                      "decimal",
                    currency: this.currency
                      ? this.currency.evaluate(e)
                      : void 0,
                    unit: this.unit ? this.unit.evaluate(e) : void 0,
                    minimumFractionDigits: this.minFractionDigits
                      ? this.minFractionDigits.evaluate(e)
                      : void 0,
                    maximumFractionDigits: this.maxFractionDigits
                      ? this.maxFractionDigits.evaluate(e)
                      : void 0,
                  },
                ).format(this.number.evaluate(e));
              }
              eachChild(e) {
                (e(this.number),
                  this.locale && e(this.locale),
                  this.currency && e(this.currency),
                  this.unit && e(this.unit),
                  this.minFractionDigits && e(this.minFractionDigits),
                  this.maxFractionDigits && e(this.maxFractionDigits));
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const e = {};
                return (
                  this.locale && (e.locale = this.locale.serialize()),
                  this.currency && (e.currency = this.currency.serialize()),
                  this.unit && (e.unit = this.unit.serialize()),
                  this.minFractionDigits &&
                    (e["min-fraction-digits"] =
                      this.minFractionDigits.serialize()),
                  this.maxFractionDigits &&
                    (e["max-fraction-digits"] =
                      this.maxFractionDigits.serialize()),
                  ["number-format", this.number.serialize(), e]
                );
              }
            }
            class Dd {
              constructor(e) {
                ((this.type = Ft), (this.input = e));
              }
              static parse(e, i) {
                if (e.length !== 2)
                  return i.error(
                    `Expected 1 argument, but found ${e.length - 1} instead.`,
                  );
                const o = i.parse(e[1], 1);
                return o
                  ? o.type.kind !== "array" &&
                    o.type.kind !== "string" &&
                    o.type.kind !== "value"
                    ? i.error(
                        `Expected argument of type string or array, but found ${Xn(o.type)} instead.`,
                      )
                    : new Dd(o)
                  : null;
              }
              evaluate(e) {
                const i = this.input.evaluate(e);
                if (typeof i == "string" || Array.isArray(i)) return i.length;
                throw new Wn(
                  `Expected value to be of type string or array, but found ${Xn(wt(i))} instead.`,
                );
              }
              eachChild(e) {
                e(this.input);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                const e = ["length"];
                return (
                  this.eachChild((i) => {
                    e.push(i.serialize());
                  }),
                  e
                );
              }
            }
            function Hp(n) {
              return function () {
                n = (1831565813 + (n |= 0)) | 0;
                let e = Math.imul(n ^ (n >>> 15), 1 | n);
                return (
                  (e = (e + Math.imul(e ^ (e >>> 7), 61 | e)) ^ e),
                  ((e ^ (e >>> 14)) >>> 0) / 4294967296
                );
              };
            }
            const Ma = {
              "==": $p,
              "!=": M_,
              ">": P_,
              "<": C_,
              ">=": D_,
              "<=": iu,
              array: Gt,
              at: Md,
              "at-interpolated": Cd,
              boolean: Gt,
              case: Pd,
              coalesce: Mc,
              collator: Bs,
              format: al,
              image: ll,
              in: tu,
              "index-of": Cc,
              interpolate: ls,
              "interpolate-hcl": ls,
              "interpolate-lab": ls,
              length: Dd,
              let: eu,
              literal: Yt,
              match: xl,
              number: Gt,
              "number-format": nu,
              object: Gt,
              slice: Pc,
              step: Ac,
              string: Gt,
              "to-boolean": ys,
              "to-color": ys,
              "to-number": ys,
              "to-string": ys,
              var: Zh,
              within: Er,
              distance: Sa,
              config: yl,
            };
            function Rd(n, [e, i, o, a]) {
              ((e = e.evaluate(n)), (i = i.evaluate(n)), (o = o.evaluate(n)));
              const u = a ? a.evaluate(n) : 1,
                d = ba(e, i, o, u);
              if (d) throw new Wn(d);
              return new Li(e / 255, i / 255, o / 255, u);
            }
            function zd(n, [e, i, o, a]) {
              ((e = e.evaluate(n)), (i = i.evaluate(n)), (o = o.evaluate(n)));
              const u = a ? a.evaluate(n) : 1,
                d = (function (b, E, A, M) {
                  return typeof b == "number" && b >= 0 && b <= 360
                    ? typeof E == "number" &&
                      E >= 0 &&
                      E <= 100 &&
                      typeof A == "number" &&
                      A >= 0 &&
                      A <= 100
                      ? M === void 0 ||
                        (typeof M == "number" && M >= 0 && M <= 1)
                        ? null
                        : `Invalid hsla value [${[b, E, A, M].join(", ")}]: 'a' must be between 0 and 1.`
                      : `Invalid hsla value [${(typeof M == "number" ? [b, E, A, M] : [b, E, A]).join(", ")}]: 's', and 'l' must be between 0 and 100.`
                    : `Invalid hsla value [${(typeof M == "number" ? [b, E, A, M] : [b, E, A]).join(", ")}]: 'h' must be between 0 and 360.`;
                })(e, i, o, u);
              if (d) throw new Wn(d);
              const _ = `hsla(${e}, ${i}%, ${o}%, ${u})`,
                v = Li.parse(_);
              if (!v) throw new Wn(`Failed to parse HSLA color: ${_}`);
              return v;
            }
            function Wp(n, e) {
              return n in e;
            }
            function Fo(n, e) {
              const i = e[n];
              return i === void 0 ? null : i;
            }
            function Ca(n) {
              return { type: n };
            }
            function qp(n) {
              return { result: "success", value: n };
            }
            function Bo(n) {
              return { result: "error", value: n };
            }
            function ru(n, e) {
              return !!n && !!n.parameters && n.parameters.indexOf(e) > -1;
            }
            function Dc(n) {
              return n["property-type"] === "data-driven";
            }
            function kd(n) {
              return ru(n.expression, "measure-light");
            }
            function Ld(n) {
              return ru(n.expression, "zoom");
            }
            function Rc(n) {
              return !!n.expression && n.expression.interpolated;
            }
            function zc(n) {
              return typeof n == "object" && n !== null && !Array.isArray(n);
            }
            function Zp(n) {
              return n;
            }
            function Xp(n, e) {
              const i = e.type === "color",
                o = n.stops && typeof n.stops[0][0] == "object",
                a = o || !(o || n.property !== void 0),
                u = n.type || (Rc(e) ? "exponential" : "interval");
              if (
                (i &&
                  ((n = va({}, n)).stops &&
                    (n.stops = n.stops.map((b) => [b[0], Li.parse(b[1])])),
                  (n.default = Li.parse(n.default ? n.default : e.default))),
                n.colorSpace && n.colorSpace !== "rgb" && !Up[n.colorSpace])
              )
                throw new Error(`Unknown color space: ${n.colorSpace}`);
              let d, _, v;
              if (u === "exponential") d = Od;
              else if (u === "interval") d = z_;
              else if (u === "categorical") {
                ((d = R_), (_ = Object.create(null)));
                for (const b of n.stops) _[b[0]] = b[1];
                v = typeof n.stops[0][0];
              } else {
                if (u !== "identity")
                  throw new Error(`Unknown function type "${u}"`);
                d = k_;
              }
              if (o) {
                const b = {},
                  E = [];
                for (let R = 0; R < n.stops.length; R++) {
                  const k = n.stops[R],
                    N = k[0].zoom;
                  (b[N] === void 0 &&
                    ((b[N] = {
                      zoom: N,
                      type: n.type,
                      property: n.property,
                      default: n.default,
                      stops: [],
                    }),
                    E.push(N)),
                    b[N].stops.push([k[0].value, k[1]]));
                }
                const A = [];
                for (const R of E) A.push([b[R].zoom, Xp(b[R], e)]);
                const M = { name: "linear" };
                return {
                  kind: "composite",
                  interpolationType: M,
                  interpolationFactor: ls.interpolationFactor.bind(void 0, M),
                  zoomStops: A.map((R) => R[0]),
                  evaluate: ({ zoom: R }, k) =>
                    Od({ stops: A, base: n.base }, e, R).evaluate(R, k),
                };
              }
              if (a) {
                const b =
                  u === "exponential"
                    ? {
                        name: "exponential",
                        base: n.base !== void 0 ? n.base : 1,
                      }
                    : null;
                return {
                  kind: "camera",
                  interpolationType: b,
                  interpolationFactor: ls.interpolationFactor.bind(void 0, b),
                  zoomStops: n.stops.map((E) => E[0]),
                  evaluate: ({ zoom: E }) => d(n, e, E, _, v),
                };
              }
              return {
                kind: "source",
                evaluate(b, E) {
                  const A =
                    E && E.properties ? E.properties[n.property] : void 0;
                  return A === void 0
                    ? vs(n.default, e.default)
                    : d(n, e, A, _, v);
                },
              };
            }
            function vs(n, e, i) {
              return n !== void 0
                ? n
                : e !== void 0
                  ? e
                  : i !== void 0
                    ? i
                    : void 0;
            }
            function R_(n, e, i, o, a) {
              return vs(typeof i === a ? o[i] : void 0, n.default, e.default);
            }
            function z_(n, e, i) {
              if (zo(i) !== "number") return vs(n.default, e.default);
              const o = n.stops.length;
              if (o === 1 || i <= n.stops[0][0]) return n.stops[0][1];
              if (i >= n.stops[o - 1][0]) return n.stops[o - 1][1];
              const a = Yh(
                n.stops.map((u) => u[0]),
                i,
              );
              return n.stops[a][1];
            }
            function Od(n, e, i) {
              const o = n.base !== void 0 ? n.base : 1;
              if (zo(i) !== "number") return vs(n.default, e.default);
              const a = n.stops.length;
              if (a === 1 || i <= n.stops[0][0]) return n.stops[0][1];
              if (i >= n.stops[a - 1][0]) return n.stops[a - 1][1];
              const u = Yh(
                  n.stops.map((E) => E[0]),
                  i,
                ),
                d = (function (E, A, M, R) {
                  const k = R - M,
                    N = E - M;
                  return k === 0
                    ? 0
                    : A === 1
                      ? N / k
                      : (Math.pow(A, N) - 1) / (Math.pow(A, k) - 1);
                })(i, o, n.stops[u][0], n.stops[u + 1][0]),
                _ = n.stops[u][1],
                v = n.stops[u + 1][1];
              let b = gc[e.type] || Zp;
              if (n.colorSpace && n.colorSpace !== "rgb") {
                const E = Up[n.colorSpace];
                b = (A, M) =>
                  E.reverse(E.interpolate(E.forward(A), E.forward(M), d));
              }
              return typeof _.evaluate == "function"
                ? {
                    evaluate(...E) {
                      const A = _.evaluate.apply(void 0, E),
                        M = v.evaluate.apply(void 0, E);
                      if (A !== void 0 && M !== void 0) return b(A, M, d);
                    },
                  }
                : b(_, v, d);
            }
            function k_(n, e, i) {
              return (
                e.type === "color"
                  ? (i = Li.parse(i))
                  : e.type === "formatted"
                    ? (i = Rr.fromString(i.toString()))
                    : e.type === "resolvedImage"
                      ? (i = Gr.build(i.toString()))
                      : zo(i) === e.type ||
                        (e.type === "enum" && e.values[i]) ||
                        (i = void 0),
                vs(i, n.default, e.default)
              );
            }
            lr.register(Ma, {
              error: [
                { kind: "error" },
                [$i],
                (n, [e]) => {
                  throw new Wn(e.evaluate(n));
                },
              ],
              typeof: [$i, [Oi], (n, [e]) => Xn(wt(e.evaluate(n)))],
              "to-rgba": [
                Dr(Ft, 4),
                [Jr],
                (n, [e]) =>
                  e.evaluate(n).toNonPremultipliedRenderColor(null).toArray(),
              ],
              "to-hsla": [
                Dr(Ft, 4),
                [Jr],
                (n, [e]) =>
                  e
                    .evaluate(n)
                    .toNonPremultipliedRenderColor(null)
                    .toHslaArray(),
              ],
              rgb: [Jr, [Ft, Ft, Ft], Rd],
              rgba: [Jr, [Ft, Ft, Ft, Ft], Rd],
              hsl: [Jr, [Ft, Ft, Ft], zd],
              hsla: [Jr, [Ft, Ft, Ft, Ft], zd],
              has: {
                type: zi,
                overloads: [
                  [[$i], (n, [e]) => Wp(e.evaluate(n), n.properties())],
                  [[$i, so], (n, [e, i]) => Wp(e.evaluate(n), i.evaluate(n))],
                ],
              },
              get: {
                type: Oi,
                overloads: [
                  [[$i], (n, [e]) => Fo(e.evaluate(n), n.properties())],
                  [[$i, so], (n, [e, i]) => Fo(e.evaluate(n), i.evaluate(n))],
                ],
              },
              "feature-state": [
                Oi,
                [$i],
                (n, [e]) => Fo(e.evaluate(n), n.featureState || {}),
              ],
              properties: [so, [], (n) => n.properties()],
              "geometry-type": [$i, [], (n) => n.geometryType()],
              worldview: [$i, [], (n) => n.globals.worldview || ""],
              id: [Oi, [], (n) => n.id()],
              zoom: [Ft, [], (n) => n.globals.zoom],
              pitch: [Ft, [], (n) => n.globals.pitch || 0],
              "distance-from-center": [Ft, [], (n) => n.distanceFromCenter()],
              "measure-light": [
                Ft,
                [$i],
                (n, [e]) => n.measureLight(e.evaluate(n)),
              ],
              "heatmap-density": [Ft, [], (n) => n.globals.heatmapDensity || 0],
              "line-progress": [Ft, [], (n) => n.globals.lineProgress || 0],
              "raster-value": [Ft, [], (n) => n.globals.rasterValue || 0],
              "raster-particle-speed": [
                Ft,
                [],
                (n) => n.globals.rasterParticleSpeed || 0,
              ],
              "sky-radial-progress": [
                Ft,
                [],
                (n) => n.globals.skyRadialProgress || 0,
              ],
              accumulated: [
                Oi,
                [],
                (n) =>
                  n.globals.accumulated === void 0
                    ? null
                    : n.globals.accumulated,
              ],
              "+": [
                Ft,
                Ca(Ft),
                (n, e) => {
                  let i = 0;
                  for (const o of e) i += o.evaluate(n);
                  return i;
                },
              ],
              "*": [
                Ft,
                Ca(Ft),
                (n, e) => {
                  let i = 1;
                  for (const o of e) i *= o.evaluate(n);
                  return i;
                },
              ],
              "-": {
                type: Ft,
                overloads: [
                  [[Ft, Ft], (n, [e, i]) => e.evaluate(n) - i.evaluate(n)],
                  [[Ft], (n, [e]) => -e.evaluate(n)],
                ],
              },
              "/": [Ft, [Ft, Ft], (n, [e, i]) => e.evaluate(n) / i.evaluate(n)],
              "%": [Ft, [Ft, Ft], (n, [e, i]) => e.evaluate(n) % i.evaluate(n)],
              ln2: [Ft, [], () => Math.LN2],
              pi: [Ft, [], () => Math.PI],
              e: [Ft, [], () => Math.E],
              "^": [
                Ft,
                [Ft, Ft],
                (n, [e, i]) => Math.pow(e.evaluate(n), i.evaluate(n)),
              ],
              sqrt: [Ft, [Ft], (n, [e]) => Math.sqrt(e.evaluate(n))],
              log10: [
                Ft,
                [Ft],
                (n, [e]) => Math.log(e.evaluate(n)) / Math.LN10,
              ],
              ln: [Ft, [Ft], (n, [e]) => Math.log(e.evaluate(n))],
              log2: [Ft, [Ft], (n, [e]) => Math.log(e.evaluate(n)) / Math.LN2],
              sin: [Ft, [Ft], (n, [e]) => Math.sin(e.evaluate(n))],
              cos: [Ft, [Ft], (n, [e]) => Math.cos(e.evaluate(n))],
              tan: [Ft, [Ft], (n, [e]) => Math.tan(e.evaluate(n))],
              asin: [Ft, [Ft], (n, [e]) => Math.asin(e.evaluate(n))],
              acos: [Ft, [Ft], (n, [e]) => Math.acos(e.evaluate(n))],
              atan: [Ft, [Ft], (n, [e]) => Math.atan(e.evaluate(n))],
              min: [
                Ft,
                Ca(Ft),
                (n, e) => Math.min(...e.map((i) => i.evaluate(n))),
              ],
              max: [
                Ft,
                Ca(Ft),
                (n, e) => Math.max(...e.map((i) => i.evaluate(n))),
              ],
              abs: [Ft, [Ft], (n, [e]) => Math.abs(e.evaluate(n))],
              round: [
                Ft,
                [Ft],
                (n, [e]) => {
                  const i = e.evaluate(n);
                  return i < 0 ? -Math.round(-i) : Math.round(i);
                },
              ],
              floor: [Ft, [Ft], (n, [e]) => Math.floor(e.evaluate(n))],
              ceil: [Ft, [Ft], (n, [e]) => Math.ceil(e.evaluate(n))],
              "filter-==": [
                zi,
                [$i, Oi],
                (n, [e, i]) => n.properties()[e.value] === i.value,
              ],
              "filter-id-==": [zi, [Oi], (n, [e]) => n.id() === e.value],
              "filter-type-==": [
                zi,
                [$i],
                (n, [e]) => n.geometryType() === e.value,
              ],
              "filter-<": [
                zi,
                [$i, Oi],
                (n, [e, i]) => {
                  const o = n.properties()[e.value],
                    a = i.value;
                  return typeof o == typeof a && o < a;
                },
              ],
              "filter-id-<": [
                zi,
                [Oi],
                (n, [e]) => {
                  const i = n.id(),
                    o = e.value;
                  return typeof i == typeof o && i < o;
                },
              ],
              "filter->": [
                zi,
                [$i, Oi],
                (n, [e, i]) => {
                  const o = n.properties()[e.value],
                    a = i.value;
                  return typeof o == typeof a && o > a;
                },
              ],
              "filter-id->": [
                zi,
                [Oi],
                (n, [e]) => {
                  const i = n.id(),
                    o = e.value;
                  return typeof i == typeof o && i > o;
                },
              ],
              "filter-<=": [
                zi,
                [$i, Oi],
                (n, [e, i]) => {
                  const o = n.properties()[e.value],
                    a = i.value;
                  return typeof o == typeof a && o <= a;
                },
              ],
              "filter-id-<=": [
                zi,
                [Oi],
                (n, [e]) => {
                  const i = n.id(),
                    o = e.value;
                  return typeof i == typeof o && i <= o;
                },
              ],
              "filter->=": [
                zi,
                [$i, Oi],
                (n, [e, i]) => {
                  const o = n.properties()[e.value],
                    a = i.value;
                  return typeof o == typeof a && o >= a;
                },
              ],
              "filter-id->=": [
                zi,
                [Oi],
                (n, [e]) => {
                  const i = n.id(),
                    o = e.value;
                  return typeof i == typeof o && i >= o;
                },
              ],
              "filter-has": [zi, [Oi], (n, [e]) => e.value in n.properties()],
              "filter-has-id": [
                zi,
                [],
                (n) => n.id() !== null && n.id() !== void 0,
              ],
              "filter-type-in": [
                zi,
                [Dr($i)],
                (n, [e]) => e.value.indexOf(n.geometryType()) >= 0,
              ],
              "filter-id-in": [
                zi,
                [Dr(Oi)],
                (n, [e]) => e.value.indexOf(n.id()) >= 0,
              ],
              "filter-in-small": [
                zi,
                [$i, Dr(Oi)],
                (n, [e, i]) => i.value.indexOf(n.properties()[e.value]) >= 0,
              ],
              "filter-in-large": [
                zi,
                [$i, Dr(Oi)],
                (n, [e, i]) =>
                  (function (o, a, u, d) {
                    for (; u <= d; ) {
                      const _ = (u + d) >> 1;
                      if (a[_] === o) return !0;
                      a[_] > o ? (d = _ - 1) : (u = _ + 1);
                    }
                    return !1;
                  })(n.properties()[e.value], i.value, 0, i.value.length - 1),
              ],
              all: {
                type: zi,
                overloads: [
                  [[zi, zi], (n, [e, i]) => e.evaluate(n) && i.evaluate(n)],
                  [
                    Ca(zi),
                    (n, e) => {
                      for (const i of e) if (!i.evaluate(n)) return !1;
                      return !0;
                    },
                  ],
                ],
              },
              any: {
                type: zi,
                overloads: [
                  [[zi, zi], (n, [e, i]) => e.evaluate(n) || i.evaluate(n)],
                  [
                    Ca(zi),
                    (n, e) => {
                      for (const i of e) if (i.evaluate(n)) return !0;
                      return !1;
                    },
                  ],
                ],
              },
              "!": [zi, [zi], (n, [e]) => !e.evaluate(n)],
              "is-supported-script": [
                zi,
                [$i],
                (n, [e]) => {
                  const i = n.globals && n.globals.isSupportedScript;
                  return !i || i(e.evaluate(n));
                },
              ],
              upcase: [$i, [$i], (n, [e]) => e.evaluate(n).toUpperCase()],
              downcase: [$i, [$i], (n, [e]) => e.evaluate(n).toLowerCase()],
              concat: [
                $i,
                Ca(Oi),
                (n, e) => e.map((i) => _s(i.evaluate(n))).join(""),
              ],
              "resolved-locale": [
                $i,
                [Lh],
                (n, [e]) => e.evaluate(n).resolvedLocale(),
              ],
              random: [
                Ft,
                [Ft, Ft, Oi],
                (n, e) => {
                  const [i, o, a] = e.map((d) => d.evaluate(n));
                  if (i > o || i === o) return i;
                  let u;
                  if (typeof a == "string")
                    u = (function (d) {
                      let _ = 0;
                      if (d.length === 0) return _;
                      for (let v = 0; v < d.length; v++)
                        ((_ = (_ << 5) - _ + d.charCodeAt(v)), (_ |= 0));
                      return _;
                    })(a);
                  else {
                    if (typeof a != "number")
                      throw new Wn(`Invalid seed input: ${a}`);
                    u = a;
                  }
                  return i + Hp(u)() * (o - i);
                },
              ],
            });
            class vl {
              constructor(e, i, o, a) {
                ((this.expression = e),
                  (this._warningHistory = {}),
                  (this._evaluator = new wc(o, a)),
                  (this._defaultValue = i
                    ? (function (u) {
                        return u.type === "color" &&
                          (zc(u.default) || Array.isArray(u.default))
                          ? new Li(0, 0, 0, 0)
                          : u.type === "color"
                            ? Li.parse(u.default) || null
                            : u.default === void 0
                              ? null
                              : u.default;
                      })(i)
                    : null),
                  (this._enumValues = i && i.type === "enum" ? i.values : null),
                  (this.configDependencies = qh(e)));
              }
              evaluateWithoutErrorHandling(e, i, o, a, u, d, _, v) {
                return (
                  (this._evaluator.globals = e),
                  (this._evaluator.feature = i),
                  (this._evaluator.featureState = o),
                  (this._evaluator.canonical = a || null),
                  (this._evaluator.availableImages = u || null),
                  (this._evaluator.formattedSection = d),
                  (this._evaluator.featureTileCoord = _ || null),
                  (this._evaluator.featureDistanceData = v || null),
                  this.expression.evaluate(this._evaluator)
                );
              }
              evaluate(e, i, o, a, u, d, _, v) {
                ((this._evaluator.globals = e),
                  (this._evaluator.feature = i || null),
                  (this._evaluator.featureState = o || null),
                  (this._evaluator.canonical = a || null),
                  (this._evaluator.availableImages = u || null),
                  (this._evaluator.formattedSection = d || null),
                  (this._evaluator.featureTileCoord = _ || null),
                  (this._evaluator.featureDistanceData = v || null));
                try {
                  const b = this.expression.evaluate(this._evaluator);
                  if (b == null || (typeof b == "number" && b != b))
                    return this._defaultValue;
                  if (this._enumValues && !(b in this._enumValues))
                    throw new Wn(
                      `Expected value to be one of ${Object.keys(
                        this._enumValues,
                      )
                        .map((E) => JSON.stringify(E))
                        .join(", ")}, but found ${JSON.stringify(b)} instead.`,
                    );
                  return b;
                } catch (b) {
                  return (
                    this._warningHistory[b.message] ||
                      ((this._warningHistory[b.message] = !0),
                      typeof console < "u" &&
                        console.warn(
                          `Failed to evaluate expression "${JSON.stringify(this.expression.serialize())}". ${b.message}`,
                        )),
                    this._defaultValue
                  );
                }
              }
            }
            function su(n) {
              return (
                Array.isArray(n) &&
                n.length > 0 &&
                typeof n[0] == "string" &&
                n[0] in Ma
              );
            }
            function lo(n, e, i, o) {
              const a = new Xh(
                  Ma,
                  [],
                  e
                    ? (function (d) {
                        const _ = {
                          color: Jr,
                          string: $i,
                          number: Ft,
                          enum: $i,
                          boolean: zi,
                          formatted: _c,
                          resolvedImage: yc,
                        };
                        return d.type === "array"
                          ? Dr(_[d.value] || Oi, d.length)
                          : _[d.type];
                      })(e)
                    : void 0,
                  void 0,
                  void 0,
                  i,
                  o,
                ),
                u = a.parse(
                  n,
                  void 0,
                  void 0,
                  void 0,
                  e && e.type === "string"
                    ? { typeAnnotation: "coerce" }
                    : void 0,
                );
              return u ? qp(new vl(u, e, i, o)) : Bo(a.errors);
            }
            class kc {
              constructor(e, i, o, a) {
                ((this.kind = e),
                  (this._styleExpression = i),
                  (this.isLightConstant = o),
                  (this.isLineProgressConstant = a),
                  (this.isStateDependent =
                    e !== "constant" && !Wh(i.expression)),
                  (this.configDependencies = qh(i.expression)));
              }
              evaluateWithoutErrorHandling(e, i, o, a, u, d) {
                return this._styleExpression.evaluateWithoutErrorHandling(
                  e,
                  i,
                  o,
                  a,
                  u,
                  d,
                );
              }
              evaluate(e, i, o, a, u, d) {
                return this._styleExpression.evaluate(e, i, o, a, u, d);
              }
            }
            class Lc {
              constructor(e, i, o, a, u, d) {
                ((this.kind = e),
                  (this.zoomStops = o),
                  (this._styleExpression = i),
                  (this.isStateDependent = e !== "camera" && !Wh(i.expression)),
                  (this.isLightConstant = u),
                  (this.isLineProgressConstant = d),
                  (this.configDependencies = qh(i.expression)),
                  (this.interpolationType = a));
              }
              evaluateWithoutErrorHandling(e, i, o, a, u, d) {
                return this._styleExpression.evaluateWithoutErrorHandling(
                  e,
                  i,
                  o,
                  a,
                  u,
                  d,
                );
              }
              evaluate(e, i, o, a, u, d) {
                return this._styleExpression.evaluate(e, i, o, a, u, d);
              }
              interpolationFactor(e, i, o) {
                return this.interpolationType
                  ? ls.interpolationFactor(this.interpolationType, e, i, o)
                  : 0;
              }
            }
            function Yp(n, e, i, o) {
              if ((n = lo(n, e, i, o)).result === "error") return n;
              const a = n.value.expression,
                u = gl(a);
              if (!u && !Dc(e))
                return Bo([new os("", "data expressions not supported")]);
              const d = _l(a, ["zoom", "pitch", "distance-from-center"]);
              if (!d && !Ld(e))
                return Bo([new os("", "zoom expressions not supported")]);
              const _ = _l(a, ["measure-light"]);
              if (!_ && !kd(e))
                return Bo([
                  new os("", "measure-light expression not supported"),
                ]);
              const v = _l(a, ["line-progress"]);
              if (
                !v &&
                !(function (A) {
                  return ru(A.expression, "line-progress");
                })(e)
              )
                return Bo([
                  new os("", "line-progress expression not supported"),
                ]);
              const b = e.expression && e.expression.relaxZoomRestriction,
                E = wl(a);
              return E || d || b
                ? E instanceof os
                  ? Bo([E])
                  : E instanceof ls && !Rc(e)
                    ? Bo([
                        new os(
                          "",
                          '"interpolate" expressions cannot be used with this property',
                        ),
                      ])
                    : qp(
                        E
                          ? new Lc(
                              u && v ? "camera" : "composite",
                              n.value,
                              E.labels,
                              E instanceof ls ? E.interpolation : void 0,
                              _,
                              v,
                            )
                          : new kc(
                              u && v ? "constant" : "source",
                              n.value,
                              _,
                              v,
                            ),
                      )
                : Bo([
                    new os(
                      "",
                      '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.',
                    ),
                  ]);
            }
            class bl {
              constructor(e, i) {
                ((this._parameters = e),
                  (this._specification = i),
                  va(this, Xp(this._parameters, this._specification)));
              }
              static deserialize(e) {
                return new bl(e._parameters, e._specification);
              }
              static serialize(e) {
                return {
                  _parameters: e._parameters,
                  _specification: e._specification,
                };
              }
            }
            function wl(n) {
              let e = null;
              if (n instanceof eu) e = wl(n.result);
              else if (n instanceof Mc) {
                for (const i of n.args) if (((e = wl(i)), e)) break;
              } else
                (n instanceof Ac || n instanceof ls) &&
                  n.input instanceof lr &&
                  n.input.name === "zoom" &&
                  (e = n);
              return (
                e instanceof os ||
                  n.eachChild((i) => {
                    const o = wl(i);
                    o instanceof os
                      ? (e = o)
                      : e &&
                        o &&
                        e !== o &&
                        (e = new os(
                          "",
                          'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.',
                        ));
                  }),
                e
              );
            }
            var ou,
              Fd,
              Bd = (function () {
                if (Fd) return ou;
                ((Fd = 1), (ou = e));
                var n = 3;
                function e(i, o, a) {
                  var u = (this.cells = []);
                  if (i instanceof ArrayBuffer) {
                    this.arrayBuffer = i;
                    var d = new Int32Array(this.arrayBuffer);
                    ((i = d[0]), (this.d = (o = d[1]) + 2 * (a = d[2])));
                    for (var _ = 0; _ < this.d * this.d; _++) {
                      var v = d[n + _],
                        b = d[n + _ + 1];
                      u.push(v === b ? null : d.subarray(v, b));
                    }
                    var E = d[n + u.length + 1];
                    ((this.keys = d.subarray(d[n + u.length], E)),
                      (this.bboxes = d.subarray(E)),
                      (this.insert = this._insertReadonly));
                  } else {
                    this.d = o + 2 * a;
                    for (var A = 0; A < this.d * this.d; A++) u.push([]);
                    ((this.keys = []), (this.bboxes = []));
                  }
                  ((this.n = o),
                    (this.extent = i),
                    (this.padding = a),
                    (this.scale = o / i),
                    (this.uid = 0));
                  var M = (a / o) * i;
                  ((this.min = -M), (this.max = i + M));
                }
                return (
                  (e.prototype.insert = function (i, o, a, u, d) {
                    (this._forEachCell(
                      o,
                      a,
                      u,
                      d,
                      this._insertCell,
                      this.uid++,
                    ),
                      this.keys.push(i),
                      this.bboxes.push(o),
                      this.bboxes.push(a),
                      this.bboxes.push(u),
                      this.bboxes.push(d));
                  }),
                  (e.prototype._insertReadonly = function () {
                    throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
                  }),
                  (e.prototype._insertCell = function (i, o, a, u, d, _) {
                    this.cells[d].push(_);
                  }),
                  (e.prototype.query = function (i, o, a, u, d) {
                    var _ = this.min,
                      v = this.max;
                    if (i <= _ && o <= _ && v <= a && v <= u && !d)
                      return Array.prototype.slice.call(this.keys);
                    var b = [];
                    return (
                      this._forEachCell(i, o, a, u, this._queryCell, b, {}, d),
                      b
                    );
                  }),
                  (e.prototype._queryCell = function (i, o, a, u, d, _, v, b) {
                    var E = this.cells[d];
                    if (E !== null)
                      for (
                        var A = this.keys, M = this.bboxes, R = 0;
                        R < E.length;
                        R++
                      ) {
                        var k = E[R];
                        if (v[k] === void 0) {
                          var N = 4 * k;
                          (
                            b
                              ? b(M[N + 0], M[N + 1], M[N + 2], M[N + 3])
                              : i <= M[N + 2] &&
                                o <= M[N + 3] &&
                                a >= M[N + 0] &&
                                u >= M[N + 1]
                          )
                            ? ((v[k] = !0), _.push(A[k]))
                            : (v[k] = !1);
                        }
                      }
                  }),
                  (e.prototype._forEachCell = function (
                    i,
                    o,
                    a,
                    u,
                    d,
                    _,
                    v,
                    b,
                  ) {
                    for (
                      var E = this._convertToCellCoord(i),
                        A = this._convertToCellCoord(o),
                        M = this._convertToCellCoord(a),
                        R = this._convertToCellCoord(u),
                        k = E;
                      k <= M;
                      k++
                    )
                      for (var N = A; N <= R; N++) {
                        var j = this.d * N + k;
                        if (
                          (!b ||
                            b(
                              this._convertFromCellCoord(k),
                              this._convertFromCellCoord(N),
                              this._convertFromCellCoord(k + 1),
                              this._convertFromCellCoord(N + 1),
                            )) &&
                          d.call(this, i, o, a, u, j, _, v, b)
                        )
                          return;
                      }
                  }),
                  (e.prototype._convertFromCellCoord = function (i) {
                    return (i - this.padding) / this.scale;
                  }),
                  (e.prototype._convertToCellCoord = function (i) {
                    return Math.max(
                      0,
                      Math.min(
                        this.d - 1,
                        Math.floor(i * this.scale) + this.padding,
                      ),
                    );
                  }),
                  (e.prototype.toArrayBuffer = function () {
                    if (this.arrayBuffer) return this.arrayBuffer;
                    for (
                      var i = this.cells,
                        o = n + this.cells.length + 1 + 1,
                        a = 0,
                        u = 0;
                      u < this.cells.length;
                      u++
                    )
                      a += this.cells[u].length;
                    var d = new Int32Array(
                      o + a + this.keys.length + this.bboxes.length,
                    );
                    ((d[0] = this.extent),
                      (d[1] = this.n),
                      (d[2] = this.padding));
                    for (var _ = o, v = 0; v < i.length; v++) {
                      var b = i[v];
                      ((d[n + v] = _), d.set(b, _), (_ += b.length));
                    }
                    return (
                      (d[n + i.length] = _),
                      d.set(this.keys, _),
                      (d[n + i.length + 1] = _ += this.keys.length),
                      d.set(this.bboxes, _),
                      (_ += this.bboxes.length),
                      d.buffer
                    );
                  }),
                  ou
                );
              })(),
              co = Co(Bd);
            const ho = {};
            function Tt(n, e, i = {}) {
              (Object.defineProperty(n, "_classRegistryKey", {
                value: e,
                writable: !1,
              }),
                (ho[e] = { klass: n, omit: i.omit || [] }));
            }
            (Tt(Object, "Object"),
              (co.serialize = function (n, e) {
                const i = n.toArrayBuffer();
                return (e && e.add(i), { buffer: i });
              }),
              (co.deserialize = function (n) {
                return new co(n.buffer);
              }),
              Object.defineProperty(co, "name", { value: "Grid" }),
              Tt(co, "Grid"),
              typeof DOMMatrix < "u" && Tt(DOMMatrix, "DOMMatrix"),
              Tt(Li, "Color"),
              Tt(Error, "Error"),
              Tt(Rr, "Formatted"),
              Tt(Fh, "FormattedSection"),
              Tt(Ei, "AJAXError"),
              Tt(Gr, "ResolvedImage"),
              Tt(bl, "StylePropertyFunction"),
              Tt(vl, "StyleExpression", { omit: ["_evaluator"] }),
              Tt(Kr, "ImageId"),
              Tt(oo, "ImageVariant"),
              Tt(Lc, "ZoomDependentExpression"),
              Tt(kc, "ZoomConstantExpression"),
              Tt(lr, "CompoundExpression", { omit: ["_evaluate"] }));
            for (const n in Ma)
              ho[Ma[n]._classRegistryKey] || Tt(Ma[n], `Expression${n}`);
            function Kp(n) {
              return (
                n &&
                typeof ArrayBuffer < "u" &&
                (n instanceof ArrayBuffer ||
                  (n.constructor && n.constructor.name === "ArrayBuffer"))
              );
            }
            function Jp(n) {
              return self.ImageBitmap && n instanceof ImageBitmap;
            }
            function No(n, e) {
              if (
                n == null ||
                typeof n == "boolean" ||
                typeof n == "number" ||
                typeof n == "string" ||
                n instanceof Boolean ||
                n instanceof Number ||
                n instanceof String ||
                n instanceof Date ||
                n instanceof RegExp
              )
                return n;
              if (Kp(n) || Jp(n)) return (e && e.add(n), n);
              if (ArrayBuffer.isView(n)) return (e && e.add(n.buffer), n);
              if (n instanceof ImageData) return (e && e.add(n.data.buffer), n);
              if (Array.isArray(n)) {
                const i = [];
                for (const o of n) i.push(No(o, e));
                return i;
              }
              if (n instanceof Map) {
                const i = { $name: "Map", entries: [] };
                for (const [o, a] of n.entries())
                  i.entries.push(No(o), No(a, e));
                return i;
              }
              if (n instanceof Set) {
                const i = { $name: "Set" };
                let o = 0;
                for (const a of n.values()) i[++o] = No(a);
                return i;
              }
              if (n instanceof DOMMatrix) {
                const i = { $name: "DOMMatrix" },
                  o = [
                    "is2D",
                    "m11",
                    "m12",
                    "m13",
                    "m14",
                    "m21",
                    "m22",
                    "m23",
                    "m24",
                    "m31",
                    "m32",
                    "m33",
                    "m34",
                    "m41",
                    "m42",
                    "m43",
                    "m44",
                    "a",
                    "b",
                    "c",
                    "d",
                    "e",
                    "f",
                  ];
                for (const a of o) i[a] = n[a];
                return i;
              }
              if (typeof n == "bigint")
                return { $name: "BigInt", value: n.toString() };
              if (typeof n == "object") {
                const i = n.constructor,
                  o = i._classRegistryKey;
                if (!o)
                  throw new Error(
                    `Can't serialize object of unregistered class "${i.name}".`,
                  );
                const a = i.serialize ? i.serialize(n, e) : {};
                if (!i.serialize) {
                  for (const u in n)
                    n.hasOwnProperty(u) &&
                      (ho[o].omit.indexOf(u) >= 0 || (a[u] = No(n[u], e)));
                  n instanceof Error && (a.message = n.message);
                }
                if (a.$name)
                  throw new Error(
                    "$name property is reserved for worker serialization logic.",
                  );
                return (o !== "Object" && (a.$name = o), a);
              }
              throw new Error("can't serialize object of type " + typeof n);
            }
            function Vo(n) {
              if (
                n == null ||
                typeof n == "boolean" ||
                typeof n == "number" ||
                typeof n == "string" ||
                n instanceof Boolean ||
                n instanceof Number ||
                n instanceof String ||
                n instanceof Date ||
                n instanceof RegExp ||
                Kp(n) ||
                Jp(n) ||
                ArrayBuffer.isView(n) ||
                n instanceof ImageData
              )
                return n;
              if (Array.isArray(n)) return n.map(Vo);
              if (typeof n == "object") {
                const e = n.$name || "Object";
                if (e === "Map") {
                  const a = n.entries || [],
                    u = new Map();
                  for (let d = 0; d < a.length; d += 2)
                    u.set(Vo(a[d]), Vo(a[d + 1]));
                  return u;
                }
                if (e === "Set") {
                  const a = new Set();
                  for (const u of Object.keys(n))
                    u !== "$name" && a.add(Vo(n[u]));
                  return a;
                }
                if (e === "DOMMatrix") {
                  let a;
                  return (
                    (a = n.is2D
                      ? [n.a, n.b, n.c, n.d, n.e, n.f]
                      : [
                          n.m11,
                          n.m12,
                          n.m13,
                          n.m14,
                          n.m21,
                          n.m22,
                          n.m23,
                          n.m24,
                          n.m31,
                          n.m32,
                          n.m33,
                          n.m34,
                          n.m41,
                          n.m42,
                          n.m43,
                          n.m44,
                        ]),
                    new DOMMatrix(a)
                  );
                }
                if (e === "BigInt") return BigInt(n.value);
                const { klass: i } = ho[e];
                if (!i)
                  throw new Error(
                    `Can't deserialize unregistered class "${e}".`,
                  );
                if (i.deserialize) return i.deserialize(n);
                const o = Object.create(i.prototype);
                for (const a of Object.keys(n))
                  a !== "$name" && (o[a] = Vo(n[a]));
                return o;
              }
              throw new Error("can't deserialize object of type " + typeof n);
            }
            const Ut = {
              "Latin-1 Supplement": (n) => n >= 128 && n <= 255,
              Arabic: (n) => n >= 1536 && n <= 1791,
              "Arabic Supplement": (n) => n >= 1872 && n <= 1919,
              "Arabic Extended-A": (n) => n >= 2208 && n <= 2303,
              "Hangul Jamo": (n) => n >= 4352 && n <= 4607,
              "Unified Canadian Aboriginal Syllabics": (n) =>
                n >= 5120 && n <= 5759,
              Khmer: (n) => n >= 6016 && n <= 6143,
              "Unified Canadian Aboriginal Syllabics Extended": (n) =>
                n >= 6320 && n <= 6399,
              "General Punctuation": (n) => n >= 8192 && n <= 8303,
              "Letterlike Symbols": (n) => n >= 8448 && n <= 8527,
              "Number Forms": (n) => n >= 8528 && n <= 8591,
              "Miscellaneous Technical": (n) => n >= 8960 && n <= 9215,
              "Control Pictures": (n) => n >= 9216 && n <= 9279,
              "Optical Character Recognition": (n) => n >= 9280 && n <= 9311,
              "Enclosed Alphanumerics": (n) => n >= 9312 && n <= 9471,
              "Geometric Shapes": (n) => n >= 9632 && n <= 9727,
              "Miscellaneous Symbols": (n) => n >= 9728 && n <= 9983,
              "Miscellaneous Symbols and Arrows": (n) =>
                n >= 11008 && n <= 11263,
              "CJK Radicals Supplement": (n) => n >= 11904 && n <= 12031,
              "Kangxi Radicals": (n) => n >= 12032 && n <= 12255,
              "Ideographic Description Characters": (n) =>
                n >= 12272 && n <= 12287,
              "CJK Symbols and Punctuation": (n) => n >= 12288 && n <= 12351,
              Hiragana: (n) => n >= 12352 && n <= 12447,
              Katakana: (n) => n >= 12448 && n <= 12543,
              Bopomofo: (n) => n >= 12544 && n <= 12591,
              "Hangul Compatibility Jamo": (n) => n >= 12592 && n <= 12687,
              Kanbun: (n) => n >= 12688 && n <= 12703,
              "Bopomofo Extended": (n) => n >= 12704 && n <= 12735,
              "CJK Strokes": (n) => n >= 12736 && n <= 12783,
              "Katakana Phonetic Extensions": (n) => n >= 12784 && n <= 12799,
              "Enclosed CJK Letters and Months": (n) =>
                n >= 12800 && n <= 13055,
              "CJK Compatibility": (n) => n >= 13056 && n <= 13311,
              "CJK Unified Ideographs Extension A": (n) =>
                n >= 13312 && n <= 19903,
              "Yijing Hexagram Symbols": (n) => n >= 19904 && n <= 19967,
              "CJK Unified Ideographs": (n) => n >= 19968 && n <= 40959,
              "Yi Syllables": (n) => n >= 40960 && n <= 42127,
              "Yi Radicals": (n) => n >= 42128 && n <= 42191,
              "Hangul Jamo Extended-A": (n) => n >= 43360 && n <= 43391,
              "Hangul Syllables": (n) => n >= 44032 && n <= 55215,
              "Hangul Jamo Extended-B": (n) => n >= 55216 && n <= 55295,
              "Private Use Area": (n) => n >= 57344 && n <= 63743,
              "CJK Compatibility Ideographs": (n) => n >= 63744 && n <= 64255,
              "Arabic Presentation Forms-A": (n) => n >= 64336 && n <= 65023,
              "Vertical Forms": (n) => n >= 65040 && n <= 65055,
              "CJK Compatibility Forms": (n) => n >= 65072 && n <= 65103,
              "Small Form Variants": (n) => n >= 65104 && n <= 65135,
              "Arabic Presentation Forms-B": (n) => n >= 65136 && n <= 65279,
              "Halfwidth and Fullwidth Forms": (n) => n >= 65280 && n <= 65519,
              Osage: (n) => n >= 66736 && n <= 66815,
              "CJK Unified Ideographs Extension B": (n) =>
                n >= 131072 && n <= 173791,
            };
            function Oc(n) {
              for (const e of n) if (Nd(e.charCodeAt(0))) return !0;
              return !1;
            }
            function L_(n) {
              for (const e of n) if (!O_(e.charCodeAt(0))) return !1;
              return !0;
            }
            function O_(n) {
              return !(
                Ut.Arabic(n) ||
                Ut["Arabic Supplement"](n) ||
                Ut["Arabic Extended-A"](n) ||
                Ut["Arabic Presentation Forms-A"](n) ||
                Ut["Arabic Presentation Forms-B"](n)
              );
            }
            function Nd(n) {
              return !(
                n !== 746 &&
                n !== 747 &&
                (n < 4352 ||
                  !(
                    Ut["Bopomofo Extended"](n) ||
                    Ut.Bopomofo(n) ||
                    (Ut["CJK Compatibility Forms"](n) &&
                      !(n >= 65097 && n <= 65103)) ||
                    Ut["CJK Compatibility Ideographs"](n) ||
                    Ut["CJK Compatibility"](n) ||
                    Ut["CJK Radicals Supplement"](n) ||
                    Ut["CJK Strokes"](n) ||
                    !(
                      !Ut["CJK Symbols and Punctuation"](n) ||
                      (n >= 12296 && n <= 12305) ||
                      (n >= 12308 && n <= 12319) ||
                      n === 12336
                    ) ||
                    Ut["CJK Unified Ideographs Extension A"](n) ||
                    Ut["CJK Unified Ideographs"](n) ||
                    Ut["Enclosed CJK Letters and Months"](n) ||
                    Ut["Hangul Compatibility Jamo"](n) ||
                    Ut["Hangul Jamo Extended-A"](n) ||
                    Ut["Hangul Jamo Extended-B"](n) ||
                    Ut["Hangul Jamo"](n) ||
                    Ut["Hangul Syllables"](n) ||
                    Ut.Hiragana(n) ||
                    Ut["Ideographic Description Characters"](n) ||
                    Ut.Kanbun(n) ||
                    Ut["Kangxi Radicals"](n) ||
                    Ut["Katakana Phonetic Extensions"](n) ||
                    (Ut.Katakana(n) && n !== 12540) ||
                    !(
                      !Ut["Halfwidth and Fullwidth Forms"](n) ||
                      n === 65288 ||
                      n === 65289 ||
                      n === 65293 ||
                      (n >= 65306 && n <= 65310) ||
                      n === 65339 ||
                      n === 65341 ||
                      n === 65343 ||
                      (n >= 65371 && n <= 65503) ||
                      n === 65507 ||
                      (n >= 65512 && n <= 65519)
                    ) ||
                    !(
                      !Ut["Small Form Variants"](n) ||
                      (n >= 65112 && n <= 65118) ||
                      (n >= 65123 && n <= 65126)
                    ) ||
                    Ut["Unified Canadian Aboriginal Syllabics"](n) ||
                    Ut["Unified Canadian Aboriginal Syllabics Extended"](n) ||
                    Ut["Vertical Forms"](n) ||
                    Ut["Yijing Hexagram Symbols"](n) ||
                    Ut["Yi Syllables"](n) ||
                    Ut["Yi Radicals"](n)
                  ))
              );
            }
            function Qp(n) {
              return !(
                Nd(n) ||
                (function (e) {
                  return !!(
                    (Ut["Latin-1 Supplement"](e) &&
                      (e === 167 ||
                        e === 169 ||
                        e === 174 ||
                        e === 177 ||
                        e === 188 ||
                        e === 189 ||
                        e === 190 ||
                        e === 215 ||
                        e === 247)) ||
                    (Ut["General Punctuation"](e) &&
                      (e === 8214 ||
                        e === 8224 ||
                        e === 8225 ||
                        e === 8240 ||
                        e === 8241 ||
                        e === 8251 ||
                        e === 8252 ||
                        e === 8258 ||
                        e === 8263 ||
                        e === 8264 ||
                        e === 8265 ||
                        e === 8273)) ||
                    Ut["Letterlike Symbols"](e) ||
                    Ut["Number Forms"](e) ||
                    (Ut["Miscellaneous Technical"](e) &&
                      ((e >= 8960 && e <= 8967) ||
                        (e >= 8972 && e <= 8991) ||
                        (e >= 8996 && e <= 9e3) ||
                        e === 9003 ||
                        (e >= 9085 && e <= 9114) ||
                        (e >= 9150 && e <= 9165) ||
                        e === 9167 ||
                        (e >= 9169 && e <= 9179) ||
                        (e >= 9186 && e <= 9215))) ||
                    (Ut["Control Pictures"](e) && e !== 9251) ||
                    Ut["Optical Character Recognition"](e) ||
                    Ut["Enclosed Alphanumerics"](e) ||
                    Ut["Geometric Shapes"](e) ||
                    (Ut["Miscellaneous Symbols"](e) &&
                      !(e >= 9754 && e <= 9759)) ||
                    (Ut["Miscellaneous Symbols and Arrows"](e) &&
                      ((e >= 11026 && e <= 11055) ||
                        (e >= 11088 && e <= 11097) ||
                        (e >= 11192 && e <= 11243))) ||
                    Ut["CJK Symbols and Punctuation"](e) ||
                    Ut.Katakana(e) ||
                    Ut["Private Use Area"](e) ||
                    Ut["CJK Compatibility Forms"](e) ||
                    Ut["Small Form Variants"](e) ||
                    Ut["Halfwidth and Fullwidth Forms"](e) ||
                    e === 8734 ||
                    e === 8756 ||
                    e === 8757 ||
                    (e >= 9984 && e <= 10087) ||
                    (e >= 10102 && e <= 10131) ||
                    e === 65532 ||
                    e === 65533
                  );
                })(n)
              );
            }
            function F_(n) {
              return (
                Ut.Arabic(n) ||
                Ut["Arabic Supplement"](n) ||
                Ut["Arabic Extended-A"](n) ||
                Ut["Arabic Presentation Forms-A"](n) ||
                Ut["Arabic Presentation Forms-B"](n)
              );
            }
            function em(n) {
              return (
                (n >= 1424 && n <= 2303) ||
                Ut["Arabic Presentation Forms-A"](n) ||
                Ut["Arabic Presentation Forms-B"](n)
              );
            }
            function B_(n, e) {
              return !(
                (!e && em(n)) ||
                (n >= 2304 && n <= 3583) ||
                (n >= 3840 && n <= 4255) ||
                Ut.Khmer(n)
              );
            }
            function N_(n) {
              for (const e of n) if (em(e.charCodeAt(0))) return !0;
              return !1;
            }
            const Qr = {
              unavailable: "unavailable",
              deferred: "deferred",
              loading: "loading",
              parsing: "parsing",
              parsed: "parsed",
              loaded: "loaded",
              error: "error",
            };
            let Vd = null,
              kr = Qr.unavailable,
              uo = null;
            const Pa = function (n) {
              (n &&
                typeof n == "string" &&
                n.indexOf("NetworkError") > -1 &&
                (kr = Qr.error),
                Vd && Vd(n));
            };
            function au() {
              lu.fire(
                new _a("pluginStateChange", {
                  pluginStatus: kr,
                  pluginURL: uo,
                }),
              );
            }
            const lu = new ya(),
              Tl = function () {
                return kr;
              },
              tm = function () {
                if (kr !== Qr.deferred || !uo)
                  throw new Error(
                    "rtl-text-plugin cannot be downloaded unless a pluginURL is specified",
                  );
                ((kr = Qr.loading),
                  au(),
                  uo &&
                    fc({ url: uo }, (n) => {
                      n ? Pa(n) : ((kr = Qr.loaded), au());
                    }));
              },
              fo = {
                applyArabicShaping: null,
                processBidirectionalText: null,
                processStyledBidirectionalText: null,
                isLoaded: () =>
                  kr === Qr.loaded || fo.applyArabicShaping != null,
                isLoading: () => kr === Qr.loading,
                setState(n) {
                  ((kr = n.pluginStatus), (uo = n.pluginURL));
                },
                isParsing: () => kr === Qr.parsing,
                isParsed: () => kr === Qr.parsed,
                getPluginURL: () => uo,
              };
            class qi {
              constructor(e, i) {
                ((this.zoom = e),
                  i
                    ? ((this.now = i.now),
                      (this.fadeDuration = i.fadeDuration),
                      (this.transition = i.transition),
                      (this.pitch = i.pitch),
                      (this.brightness = i.brightness),
                      (this.worldview = i.worldview))
                    : ((this.now = 0),
                      (this.fadeDuration = 0),
                      (this.transition = {}),
                      (this.pitch = 0),
                      (this.brightness = 0)));
              }
              isSupportedScript(e) {
                return (function (i, o) {
                  for (const a of i) if (!B_(a.charCodeAt(0), o)) return !1;
                  return !0;
                })(e, fo.isLoaded());
              }
            }
            class Fc {
              constructor(e, i, o, a) {
                ((this.property = e),
                  (this.value = i),
                  (this.expression = (function (u, d, _, v) {
                    if (zc(u)) return new bl(u, d);
                    if (su(u) || (Array.isArray(u) && u.length > 0)) {
                      const b = Yp(u, d, _, v);
                      if (b.result === "error")
                        throw new Error(
                          b.value
                            .map((E) => `${E.key}: ${E.message}`)
                            .join(", "),
                        );
                      return b.value;
                    }
                    {
                      let b = u;
                      return (
                        typeof u == "string" &&
                          d.type === "color" &&
                          (b = Li.parse(u)),
                        {
                          kind: "constant",
                          configDependencies: new Set(),
                          evaluate: () => b,
                        }
                      );
                    }
                  })(
                    i === void 0 ? e.specification.default : i,
                    e.specification,
                    o,
                    a,
                  )));
              }
              isDataDriven() {
                return (
                  this.expression.kind === "source" ||
                  this.expression.kind === "composite"
                );
              }
              possiblyEvaluate(e, i, o) {
                return this.property.possiblyEvaluate(this, e, i, o);
              }
            }
            class Uo {
              constructor(e, i, o) {
                ((this.property = e), (this.value = new Fc(e, void 0, i, o)));
              }
              transitioned(e, i) {
                return new nm(
                  this.property,
                  this.value,
                  i,
                  Le({}, e.transition, this.transition),
                  e.now,
                );
              }
              untransitioned() {
                return new nm(this.property, this.value, null, {}, 0);
              }
            }
            class im {
              constructor(e, i, o) {
                ((this._properties = e),
                  (this._values = Object.create(
                    e.defaultTransitionablePropertyValues,
                  )),
                  (this._scope = i),
                  (this._options = o),
                  (this.configDependencies = new Set()));
              }
              getValue(e) {
                return Kt(this._values[e].value.value);
              }
              setValue(e, i) {
                (this._values.hasOwnProperty(e) ||
                  (this._values[e] = new Uo(
                    this._values[e].property,
                    this._scope,
                    this._options,
                  )),
                  (this._values[e].value = new Fc(
                    this._values[e].property,
                    i === null ? void 0 : Kt(i),
                    this._scope,
                    this._options,
                  )),
                  this._values[e].value.expression.configDependencies &&
                    (this.configDependencies = new Set([
                      ...this.configDependencies,
                      ...this._values[e].value.expression.configDependencies,
                    ])));
              }
              setTransitionOrValue(e, i) {
                i && (this._options = i);
                const o = this._properties.properties;
                if (e)
                  for (const a in e) {
                    const u = e[a];
                    if (a.endsWith("-transition")) {
                      const d = a.slice(0, -11);
                      o[d] && this.setTransition(d, u);
                    } else o.hasOwnProperty(a) && this.setValue(a, u);
                  }
              }
              getTransition(e) {
                return Kt(this._values[e].transition);
              }
              setTransition(e, i) {
                (this._values.hasOwnProperty(e) ||
                  (this._values[e] = new Uo(this._values[e].property)),
                  (this._values[e].transition = Kt(i) || void 0));
              }
              serialize() {
                const e = {};
                for (const i of Object.keys(this._values)) {
                  const o = this.getValue(i);
                  o !== void 0 && (e[i] = o);
                  const a = this.getTransition(i);
                  a !== void 0 && (e[`${i}-transition`] = a);
                }
                return e;
              }
              transitioned(e, i) {
                const o = new rm(this._properties);
                for (const a of Object.keys(this._values))
                  o._values[a] = this._values[a].transitioned(e, i._values[a]);
                return o;
              }
              untransitioned() {
                const e = new rm(this._properties);
                for (const i of Object.keys(this._values))
                  e._values[i] = this._values[i].untransitioned();
                return e;
              }
            }
            class nm {
              constructor(e, i, o, a, u) {
                const d = a.delay || 0,
                  _ = a.duration || 0;
                ((u = u || 0),
                  (this.property = e),
                  (this.value = i),
                  (this.begin = u + d),
                  (this.end = this.begin + _),
                  e.specification.transition &&
                    (a.delay || a.duration) &&
                    (this.prior = o));
              }
              possiblyEvaluate(e, i, o) {
                const a = e.now || 0,
                  u = this.value.possiblyEvaluate(e, i, o),
                  d = this.prior;
                if (d) {
                  if (a > this.end) return ((this.prior = null), u);
                  if (this.value.isDataDriven())
                    return ((this.prior = null), u);
                  if (a < this.begin) return d.possiblyEvaluate(e, i, o);
                  {
                    const _ = (a - this.begin) / (this.end - this.begin);
                    return this.property.interpolate(
                      d.possiblyEvaluate(e, i, o),
                      u,
                      K(_),
                    );
                  }
                }
                return u;
              }
            }
            class rm {
              constructor(e) {
                ((this._properties = e),
                  (this._values = Object.create(
                    e.defaultTransitioningPropertyValues,
                  )));
              }
              possiblyEvaluate(e, i, o) {
                const a = new Da(this._properties);
                for (const u of Object.keys(this._values))
                  a._values[u] = this._values[u].possiblyEvaluate(e, i, o);
                return a;
              }
              hasTransition() {
                for (const e of Object.keys(this._values))
                  if (this._values[e].prior) return !0;
                return !1;
              }
            }
            class V_ {
              constructor(e, i, o) {
                ((this._properties = e),
                  (this._values = Object.create(e.defaultPropertyValues)),
                  (this._scope = i),
                  (this._options = o),
                  (this.configDependencies = new Set()));
              }
              getValue(e) {
                return Kt(this._values[e].value);
              }
              setValue(e, i) {
                ((this._values[e] = new Fc(
                  this._values[e].property,
                  i === null ? void 0 : Kt(i),
                  this._scope,
                  this._options,
                )),
                  this._values[e].expression.configDependencies &&
                    (this.configDependencies = new Set([
                      ...this.configDependencies,
                      ...this._values[e].expression.configDependencies,
                    ])));
              }
              serialize() {
                const e = {};
                for (const i of Object.keys(this._values)) {
                  const o = this.getValue(i);
                  o !== void 0 && (e[i] = o);
                }
                return e;
              }
              possiblyEvaluate(e, i, o) {
                const a = new Da(this._properties);
                for (const u of Object.keys(this._values))
                  a._values[u] = this._values[u].possiblyEvaluate(e, i, o);
                return a;
              }
            }
            class Sl {
              constructor(e, i, o) {
                ((this.property = e), (this.value = i), (this.parameters = o));
              }
              isConstant() {
                return this.value.kind === "constant";
              }
              constantOr(e) {
                return this.value.kind === "constant" ? this.value.value : e;
              }
              evaluate(e, i, o, a) {
                return this.property.evaluate(
                  this.value,
                  this.parameters,
                  e,
                  i,
                  o,
                  a,
                );
              }
            }
            class Da {
              constructor(e) {
                ((this._properties = e),
                  (this._values = Object.create(
                    e.defaultPossiblyEvaluatedValues,
                  )));
              }
              get(e) {
                return this._values[e];
              }
            }
            class st {
              constructor(e) {
                this.specification = e;
              }
              possiblyEvaluate(e, i) {
                return e.expression.evaluate(i);
              }
              interpolate(e, i, o) {
                const a = gc[this.specification.type];
                return a ? a(e, i, o) : e;
              }
            }
            class vt {
              constructor(e, i) {
                ((this.specification = e), (this.overrides = i));
              }
              possiblyEvaluate(e, i, o, a) {
                return new Sl(
                  this,
                  e.expression.kind === "constant" ||
                  e.expression.kind === "camera"
                    ? {
                        kind: "constant",
                        value: e.expression.evaluate(i, null, {}, o, a),
                      }
                    : e.expression,
                  i,
                );
              }
              interpolate(e, i, o) {
                if (e.value.kind !== "constant" || i.value.kind !== "constant")
                  return e;
                if (e.value.value === void 0 || i.value.value === void 0)
                  return new Sl(
                    this,
                    { kind: "constant", value: void 0 },
                    e.parameters,
                  );
                const a = gc[this.specification.type];
                return a
                  ? new Sl(
                      this,
                      {
                        kind: "constant",
                        value: a(e.value.value, i.value.value, o),
                      },
                      e.parameters,
                    )
                  : e;
              }
              evaluate(e, i, o, a, u, d) {
                return e.kind === "constant"
                  ? e.value
                  : e.evaluate(i, o, a, u, d);
              }
            }
            class Ra {
              constructor(e) {
                this.specification = e;
              }
              possiblyEvaluate(e, i, o, a) {
                return !!e.expression.evaluate(i, null, {}, o, a);
              }
              interpolate() {
                return !1;
              }
            }
            class Cn {
              constructor(e) {
                ((this.properties = e),
                  (this.defaultPropertyValues = {}),
                  (this.defaultTransitionablePropertyValues = {}),
                  (this.defaultTransitioningPropertyValues = {}),
                  (this.defaultPossiblyEvaluatedValues = {}),
                  (this.overridableProperties = []));
                const i = new qi(0, {});
                for (const o in e) {
                  const a = e[o];
                  a.specification.overridable &&
                    this.overridableProperties.push(o);
                  const u = (this.defaultPropertyValues[o] = new Fc(a, void 0)),
                    d = (this.defaultTransitionablePropertyValues[o] = new Uo(
                      a,
                    ));
                  ((this.defaultTransitioningPropertyValues[o] =
                    d.untransitioned()),
                    (this.defaultPossiblyEvaluatedValues[o] =
                      u.possiblyEvaluate(i)));
                }
              }
            }
            (Tt(vt, "DataDrivenProperty"),
              Tt(st, "DataConstantProperty"),
              Tt(Ra, "ColorRampProperty"));
            var Pe = JSON.parse(
              '{"$version":8,"$root":{"version":{"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"snow":{"type":"snow"},"rain":{"type":"rain"},"camera":{"type":"camera"},"color-theme":{"type":"colorTheme"},"indoor":{"type":"indoor"},"imports":{"type":"array","value":"import"},"iconsets":{"type":"iconsets"},"schema":{"type":"schema"},"sources":{"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"type":"array","value":"layer"},"models":{"type":"models"},"featuresets":{"type":"featuresets"}},"featuresets":{"*":{"type":"featureset"}},"featureset":{"metadata":{"type":"*"},"selectors":{"type":"array","value":"selector"}},"selector":{"layer":{"type":"string"},"properties":{"type":"selectorProperty"},"featureNamespace":{"type":"string"},"_uniqueFeatureID":{"type":"boolean"}},"selectorProperty":{"*":{"type":"*"}},"model":{"type":"string"},"import":{"id":{"type":"string"},"url":{"type":"string"},"config":{"type":"config"},"data":{"type":"$root"},"color-theme":{"type":"colorTheme","optional":true}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","expression":{}},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string"},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false},"shadow-quality":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"parameters":["zoom"]}},"shadow-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"iconsets":{"*":{"type":"iconset"}},"iconset":["iconset_sprite","iconset_source"],"iconset_sprite":{"type":{"type":"enum","values":{"sprite":1}},"url":{"type":"string"}},"iconset_source":{"type":{"type":"enum","values":{"source":1}},"source":{"type":"string"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"type":{"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"},"dynamic":{"type":"boolean","default":false}},"source_video":{"type":{"type":"enum","values":{"video":1}},"urls":{"type":"array","value":"string"},"coordinates":{"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"type":"enum","values":{"image":1}},"url":{"type":"string"},"coordinates":{"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string"},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"building":{},"raster":{},"raster-particle":{},"hillshade":{},"model":{},"background":{},"sky":{},"slot":{},"clip":{}}},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_clip","layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_building","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_clip":{"clip-layer-types":{"type":"array","value":"enum","values":{"model":1,"symbol":1},"default":[],"expression":{}},"clip-layer-scope":{"type":"array","value":"string","default":[],"expression":{}}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"fill-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-base":1,"hd-road-markup":1},"default":"none","expression":{}},"fill-construct-bridge-guard-rail":{"type":"boolean","default":"true","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"circle-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-markup":1},"default":"none","expression":{}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"fill-extrusion-edge-radius":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}}},"layout_building":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"building-roof-shape":{"type":"enum","values":{"flat":1,"hipped":1,"gabled":1,"parapet":1,"mansard":1,"skillion":1,"pyramidal":1},"default":"flat","expression":{"parameters":["feature"]},"property-type":"data-driven"},"building-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{},"property-type":"data-driven"},"building-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{},"property-type":"data-driven"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1,"none":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-z-offset":{"type":"number","default":0,"expression":{"parameters":["zoom","feature","line-progress"]},"property-type":"data-driven"},"line-elevation-reference":{"type":"enum","values":{"none":1,"sea":1,"ground":1,"hd-road-markup":1},"default":"none","expression":{}},"line-cross-slope":{"type":"number","expression":{}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"line-width-unit":{"type":"enum","values":{"pixels":1,"meters":1},"default":"pixels","expression":{"parameters":["zoom"]}}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]}},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]}},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]}},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"symbol-elevation-reference":{"type":"enum","values":{"sea":1,"ground":1,"hd-road-markup":1},"default":"ground","expression":{"parameters":["zoom"]}},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"expression":{}},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"expression":{}},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]}},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]}},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_hillshade":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster-particle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_clip":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_model":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_building":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*"}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"high-color":{"type":"color","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"space-color":{"type":"color","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"horizon-blend":{"type":"number","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"snow":{"density":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.85],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.3],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"center-thinning":{"type":"number","default":0.4,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,50],"minimum":0,"maximum":360,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"flake-size":{"type":"number","default":0.71,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"rain":{"density":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.5],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","default":["interpolate",["linear"],["measure-light","brightness"],0,"#03113d",0.3,"#a8adbc"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"opacity":{"type":"number","default":["interpolate",["linear"],["measure-light","brightness"],0,0.88,1,0.7],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","default":["interpolate",["linear"],["measure-light","brightness"],0,"#001736",0.3,"#464646"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"use-theme":true,"transition":true},"center-thinning":{"type":"number","default":0.57,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,80],"minimum":0,"maximum":360,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"droplet-size":{"type":"array","default":[2.6,18.2],"minimum":0,"maximum":50,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"distortion-strength":{"type":"number","default":0.7,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective"}},"colorTheme":{"data":{"type":"string","expression":{}}},"indoor":{"floorplanFeaturesetId":{"type":"string","expression":{}},"buildingFeaturesetId":{"type":"string","expression":{}}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"use-theme":true,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator"},"center":{"type":"array","length":2,"value":"number","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string"},"exaggeration":{"type":"number","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_building","paint_symbol","paint_raster","paint_raster-particle","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-bridge-guard-rail-color":{"type":"color","default":"rgba(241, 236, 225, 255)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature"]},"property-type":"data-driven"},"fill-tunnel-structure-color":{"type":"color","default":"rgba(241, 236, 225, 255)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-height-alignment":{"type":"enum","values":{"terrain":1,"flat":1},"default":"flat"},"fill-extrusion-base-alignment":{"type":"enum","values":{"terrain":1,"flat":1},"default":"terrain"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-ambient-occlusion-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"type":"color","default":"#ffffff","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"fill-extrusion-line-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-cast-shadows":{"type":"boolean","default":true}},"paint_building":{"building-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-ambient-occlusion-wall-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"building-ambient-occlusion-ground-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"building-ambient-occlusion-ground-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"building-ambient-occlusion-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-vertical-scale":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-cast-shadows":{"type":"boolean","default":true},"building-color":{"type":"color","default":"rgba(193, 154, 127, 1)","use-theme":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]},"property-type":"data-driven"},"building-emissive-strength":{"type":"number","default":0,"minimum":0,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"property-type":"data-driven"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light","line-progress"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-gradient":{"type":"color","use-theme":true,"expression":{"interpolated":true,"parameters":["line-progress"]}},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1]},"line-trim-fade-range":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-trim-color":{"type":"color","default":"transparent","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-border-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","default":"rgba(0, 0, 0, 0)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-occlusion-opacity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]}},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"use-theme":true,"expression":{"interpolated":true,"parameters":["heatmap-density"]}},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"icon-image-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"icon-color-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{}},"icon-color-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{}},"icon-color-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"icon-color-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{}},"symbol-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color":{"type":"color","use-theme":true,"expression":{"interpolated":true,"parameters":["raster-value"]}},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]}},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"raster-array-band":{"type":"string"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string"},"raster-particle-count":{"type":"number","default":512,"minimum":1},"raster-particle-color":{"type":"color","use-theme":true,"expression":{"interpolated":true,"parameters":["raster-particle-speed"]}},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1},"raster-particle-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]}},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]}},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"hillshade-shadow-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-accent-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_background":{"background-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":[]}},"background-color":{"type":"color","default":"#000000","use-theme":true,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]}},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]}},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]}},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]}},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]}},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"use-theme":true,"expression":{"interpolated":true,"parameters":["sky-radial-progress"]}},"sky-atmosphere-halo-color":{"type":"color","default":"white","use-theme":true},"sky-atmosphere-color":{"type":"color","default":"white","use-theme":true},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"property-type":"data-driven"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"use-theme":true,"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d"},"model-cast-shadows":{"type":"boolean","default":true},"model-receive-shadows":{"type":"boolean","default":true},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"model-front-cutoff":{"type":"array","value":"number","expression":{"interpolated":true,"parameters":["zoom"]},"length":3,"default":[0,0,1],"minimum":[0,0,0],"maximum":[1,1,1]}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"promoteId":{"*":{"type":"*"}}}',
            );
            function Ds(n) {
              return n instanceof Number ||
                n instanceof String ||
                n instanceof Boolean
                ? n.valueOf()
                : n;
            }
            function cu(n) {
              if (Array.isArray(n)) return n.map(cu);
              if (
                n instanceof Object &&
                !(
                  n instanceof Number ||
                  n instanceof String ||
                  n instanceof Boolean
                )
              ) {
                const e = {};
                for (const i in n) e[i] = cu(n[i]);
                return e;
              }
              return Ds(n);
            }
            function hu(n) {
              if (n === !0 || n === !1) return !0;
              if (!Array.isArray(n) || n.length === 0) return !1;
              switch (n[0]) {
                case "has":
                  return n.length >= 2 && n[1] !== "$id" && n[1] !== "$type";
                case "in":
                  return (
                    n.length >= 3 &&
                    (typeof n[1] != "string" || Array.isArray(n[2]))
                  );
                case "!in":
                case "!has":
                case "none":
                  return !1;
                case "==":
                case "!=":
                case ">":
                case ">=":
                case "<":
                case "<=":
                  return (
                    n.length !== 3 || Array.isArray(n[1]) || Array.isArray(n[2])
                  );
                case "any":
                case "all":
                  for (const e of n.slice(1))
                    if (!hu(e) && typeof e != "boolean") return !1;
                  return !0;
                default:
                  return !0;
              }
            }
            function Ud(n, e = "", i = null, o = "fill") {
              if (n == null)
                return { filter: () => !0, needGeometry: !1, needFeature: !1 };
              hu(n) || (n = uu(n));
              const a = n;
              let u = !0;
              try {
                u = (function (E) {
                  if (!El(E)) return E;
                  let A = cu(E);
                  return (om(A), (A = sm(A)), A);
                })(a);
              } catch {
                console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(a, null, 2)}
        `);
              }
              let d = null,
                _ = null;
              if (o !== "background" && o !== "sky" && o !== "slot") {
                _ = Pe[`filter_${o}`];
                const E = lo(u, _, e, i);
                if (E.result === "error")
                  throw new Error(
                    E.value.map((A) => `${A.key}: ${A.message}`).join(", "),
                  );
                d = (A, M, R) => E.value.evaluate(A, M, {}, R);
              }
              let v = null,
                b = null;
              if (u !== a) {
                const E = lo(a, _, e, i);
                if (E.result === "error")
                  throw new Error(
                    E.value.map((A) => `${A.key}: ${A.message}`).join(", "),
                  );
                ((v = (A, M, R, k, N) =>
                  E.value.evaluate(A, M, {}, R, void 0, void 0, k, N)),
                  (b = !gl(E.value.expression)));
              }
              return {
                filter: d,
                dynamicFilter: v || void 0,
                needGeometry: am(u),
                needFeature: !!b,
              };
            }
            function sm(n) {
              if (!Array.isArray(n)) return n;
              const e = (function (i) {
                if (U_.has(i[0])) {
                  for (let o = 1; o < i.length; o++) if (El(i[o])) return !0;
                }
                return i;
              })(n);
              return e === !0 ? e : e.map((i) => sm(i));
            }
            function om(n) {
              let e = !1;
              const i = [];
              if (n[0] === "case") {
                for (let o = 1; o < n.length - 1; o += 2)
                  ((e = e || El(n[o])), i.push(n[o + 1]));
                i.push(n[n.length - 1]);
              } else if (n[0] === "match") {
                e = e || El(n[1]);
                for (let o = 2; o < n.length - 1; o += 2) i.push(n[o + 1]);
                i.push(n[n.length - 1]);
              } else if (n[0] === "step") {
                e = e || El(n[1]);
                for (let o = 1; o < n.length - 1; o += 2) i.push(n[o + 1]);
              }
              e && ((n.length = 0), n.push("any", ...i));
              for (let o = 1; o < n.length; o++) om(n[o]);
            }
            function El(n) {
              if (!Array.isArray(n)) return !1;
              if ((e = n[0]) === "pitch" || e === "distance-from-center")
                return !0;
              var e;
              for (let i = 1; i < n.length; i++) if (El(n[i])) return !0;
              return !1;
            }
            const U_ = new Set([
              "in",
              "==",
              "!=",
              ">",
              ">=",
              "<",
              "<=",
              "to-boolean",
            ]);
            function j_(n, e) {
              return n < e ? -1 : n > e ? 1 : 0;
            }
            function am(n) {
              if (!Array.isArray(n)) return !1;
              if (n[0] === "within" || n[0] === "distance") return !0;
              for (let e = 1; e < n.length; e++) if (am(n[e])) return !0;
              return !1;
            }
            function uu(n) {
              if (!n) return !0;
              const e = n[0];
              return n.length <= 1
                ? e !== "any"
                : e === "=="
                  ? jd(n[1], n[2], "==")
                  : e === "!="
                    ? du(jd(n[1], n[2], "=="))
                    : e === "<" || e === ">" || e === "<=" || e === ">="
                      ? jd(n[1], n[2], e)
                      : e === "any"
                        ? ((i = n.slice(1)), ["any"].concat(i.map(uu)))
                        : e === "all"
                          ? ["all"].concat(n.slice(1).map(uu))
                          : e === "none"
                            ? ["all"].concat(n.slice(1).map(uu).map(du))
                            : e === "in"
                              ? Gd(n[1], n.slice(2))
                              : e === "!in"
                                ? du(Gd(n[1], n.slice(2)))
                                : e === "has"
                                  ? lm(n[1])
                                  : e !== "!has" || du(lm(n[1]));
              var i;
            }
            function jd(n, e, i) {
              switch (n) {
                case "$type":
                  return [`filter-type-${i}`, e];
                case "$id":
                  return [`filter-id-${i}`, e];
                default:
                  return [`filter-${i}`, n, e];
              }
            }
            function Gd(n, e) {
              if (e.length === 0) return !1;
              switch (n) {
                case "$type":
                  return ["filter-type-in", ["literal", e]];
                case "$id":
                  return ["filter-id-in", ["literal", e]];
                default:
                  return e.length > 200 &&
                    !e.some((i) => typeof i != typeof e[0])
                    ? ["filter-in-large", n, ["literal", e.sort(j_)]]
                    : ["filter-in-small", n, ["literal", e]];
              }
            }
            function lm(n) {
              switch (n) {
                case "$type":
                  return !0;
                case "$id":
                  return ["filter-has-id"];
                default:
                  return ["filter-has", n];
              }
            }
            function du(n) {
              return ["!", n];
            }
            const Bc = "";
            function za(n, e) {
              return e ? `${n}${Bc}${e}` : n;
            }
            const $d = "-transition",
              jo = new Set([
                "fill",
                "line",
                "background",
                "hillshade",
                "raster",
              ]);
            class Ir extends ya {
              constructor(e, i, o, a, u) {
                if (
                  (super(),
                  (this.id = e.id),
                  (this.fqid = za(this.id, o)),
                  (this.type = e.type),
                  (this.scope = o),
                  (this.lut = a),
                  (this.options = u),
                  (this._featureFilter = {
                    filter: () => !0,
                    needGeometry: !1,
                    needFeature: !1,
                  }),
                  (this._filterCompiled = !1),
                  (this.configDependencies = new Set()),
                  e.type !== "custom")
                ) {
                  if (
                    ((this.metadata = e.metadata),
                    (this.minzoom = e.minzoom),
                    (this.maxzoom = e.maxzoom),
                    e.type &&
                      e.type !== "background" &&
                      e.type !== "sky" &&
                      e.type !== "slot")
                  ) {
                    ((this.source = e.source),
                      (this.sourceLayer = e["source-layer"]),
                      (this.filter = e.filter));
                    const d = lo(this.filter, Pe[`filter_${e.type}`]);
                    d.result !== "error" &&
                      (this.configDependencies = new Set([
                        ...this.configDependencies,
                        ...d.value.configDependencies,
                      ]));
                  }
                  if (
                    (e.slot && (this.slot = e.slot),
                    i.layout &&
                      ((this._unevaluatedLayout = new V_(
                        i.layout,
                        this.scope,
                        u,
                      )),
                      (this.configDependencies = new Set([
                        ...this.configDependencies,
                        ...this._unevaluatedLayout.configDependencies,
                      ]))),
                    i.paint)
                  ) {
                    this._transitionablePaint = new im(i.paint, this.scope, u);
                    for (const d in e.paint)
                      this.setPaintProperty(d, e.paint[d]);
                    for (const d in e.layout)
                      this.setLayoutProperty(d, e.layout[d]);
                    ((this.configDependencies = new Set([
                      ...this.configDependencies,
                      ...this._transitionablePaint.configDependencies,
                    ])),
                      (this._transitioningPaint =
                        this._transitionablePaint.untransitioned()),
                      (this.paint = new Da(i.paint)));
                  }
                }
              }
              onAdd(e) {}
              onRemove(e) {}
              isDraped(e) {
                return !this.is3D(!0) && jo.has(this.type);
              }
              getLayoutProperty(e) {
                return e === "visibility"
                  ? this.visibility
                  : this._unevaluatedLayout.getValue(e);
              }
              setLayoutProperty(e, i) {
                if (this.type === "custom" && e === "visibility")
                  return void (this.visibility = i);
                const o = this._unevaluatedLayout;
                o._properties.properties[e] &&
                  (o.setValue(e, i),
                  (this.configDependencies = new Set([
                    ...this.configDependencies,
                    ...o.configDependencies,
                  ])),
                  e === "visibility" && this.possiblyEvaluateVisibility());
              }
              possiblyEvaluateVisibility() {
                this._unevaluatedLayout._values.visibility &&
                  (this.visibility =
                    this._unevaluatedLayout._values.visibility.possiblyEvaluate(
                      { zoom: 0 },
                    ));
              }
              getPaintProperty(e) {
                return e.endsWith($d)
                  ? this._transitionablePaint.getTransition(e.slice(0, -11))
                  : this._transitionablePaint.getValue(e);
              }
              setPaintProperty(e, i) {
                const o = this._transitionablePaint,
                  a = o._properties.properties;
                if (e.endsWith($d)) {
                  const A = e.slice(0, -11);
                  return (a[A] && o.setTransition(A, i || void 0), !1);
                }
                if (!a[e]) return !1;
                const u = o._values[e],
                  d = u.value.isDataDriven(),
                  _ = u.value;
                (o.setValue(e, i),
                  (this.configDependencies = new Set([
                    ...this.configDependencies,
                    ...o.configDependencies,
                  ])),
                  this._handleSpecialPaintPropertyUpdate(e));
                const v = o._values[e].value,
                  b = v.isDataDriven(),
                  E = e.endsWith("pattern") || e === "line-dasharray";
                return (
                  b ||
                  d ||
                  E ||
                  this._handleOverridablePaintPropertyUpdate(e, _, v)
                );
              }
              _handleSpecialPaintPropertyUpdate(e) {}
              getProgramIds() {
                return null;
              }
              getDefaultProgramParams(e, i, o) {
                return null;
              }
              _handleOverridablePaintPropertyUpdate(e, i, o) {
                return !1;
              }
              isHidden(e) {
                return (
                  !!(this.minzoom && e < this.minzoom) ||
                  !!(this.maxzoom && e >= this.maxzoom) ||
                  this.visibility === "none"
                );
              }
              updateTransitions(e) {
                this._transitioningPaint =
                  this._transitionablePaint.transitioned(
                    e,
                    this._transitioningPaint,
                  );
              }
              hasTransition() {
                return this._transitioningPaint.hasTransition();
              }
              recalculate(e, i) {
                (this._unevaluatedLayout &&
                  (this.layout = this._unevaluatedLayout.possiblyEvaluate(
                    e,
                    void 0,
                    i,
                  )),
                  (this.paint = this._transitioningPaint.possiblyEvaluate(
                    e,
                    void 0,
                    i,
                  )));
              }
              serialize() {
                return Xt(
                  {
                    id: this.id,
                    type: this.type,
                    slot: this.slot,
                    source: this.source,
                    "source-layer": this.sourceLayer,
                    metadata: this.metadata,
                    minzoom: this.minzoom,
                    maxzoom: this.maxzoom,
                    filter: this.filter,
                    layout:
                      this._unevaluatedLayout &&
                      this._unevaluatedLayout.serialize(),
                    paint:
                      this._transitionablePaint &&
                      this._transitionablePaint.serialize(),
                  },
                  (e, i) =>
                    !(
                      e === void 0 ||
                      (i === "layout" && !Object.keys(e).length) ||
                      (i === "paint" && !Object.keys(e).length)
                    ),
                );
              }
              is3D(e) {
                return !1;
              }
              hasElevation() {
                return !1;
              }
              isSky() {
                return !1;
              }
              isTileClipped() {
                return !1;
              }
              hasOffscreenPass() {
                return !1;
              }
              hasShadowPass() {
                return !1;
              }
              canCastShadows() {
                return !1;
              }
              hasLightBeamPass() {
                return !1;
              }
              cutoffRange() {
                return 0;
              }
              tileCoverLift() {
                return 0;
              }
              resize() {}
              isStateDependent() {
                for (const e in this.paint._values) {
                  const i = this.paint.get(e);
                  if (
                    i instanceof Sl &&
                    Dc(i.property.specification) &&
                    (i.value.kind === "source" ||
                      i.value.kind === "composite") &&
                    i.value.isStateDependent
                  )
                    return !0;
                }
                return !1;
              }
              compileFilter(e) {
                this._filterCompiled ||
                  ((this._featureFilter = Ud(this.filter, this.scope, e)),
                  (this._filterCompiled = !0));
              }
              invalidateCompiledFilter() {
                this._filterCompiled = !1;
              }
              dynamicFilter() {
                return this._featureFilter.dynamicFilter;
              }
              dynamicFilterNeedsFeature() {
                return this._featureFilter.needFeature;
              }
              getLayerRenderingStats() {
                return this._stats;
              }
              resetLayerRenderingStats(e) {
                this._stats &&
                  (e.renderPass === "shadow"
                    ? (this._stats.numRenderedVerticesInShadowPass = 0)
                    : (this._stats.numRenderedVerticesInTransparentPass = 0));
              }
              queryRadius(e) {}
              queryIntersectsFeature(e, i, o, a, u, d, _, v, b) {}
            }
            const G_ = {
              Int8: Int8Array,
              Uint8: Uint8Array,
              Int16: Int16Array,
              Uint16: Uint16Array,
              Int32: Int32Array,
              Uint32: Uint32Array,
              Float32: Float32Array,
            };
            class Nc {
              constructor(e, i) {
                ((this._structArray = e),
                  (this._pos1 = i * this.size),
                  (this._pos2 = this._pos1 / 2),
                  (this._pos4 = this._pos1 / 4),
                  (this._pos8 = this._pos1 / 8));
              }
            }
            class yn {
              constructor() {
                ((this.capacity = -1), this.resize(0));
              }
              static serialize(e, i) {
                return (
                  e._trim(),
                  i && i.add(e.arrayBuffer),
                  { length: e.length, arrayBuffer: e.arrayBuffer }
                );
              }
              static deserialize(e) {
                const i = Object.create(this.prototype);
                return (
                  (i.arrayBuffer = e.arrayBuffer),
                  (i.length = e.length),
                  (i.capacity = e.arrayBuffer.byteLength / i.bytesPerElement),
                  i._refreshViews(),
                  i
                );
              }
              _trim() {
                this.length !== this.capacity &&
                  ((this.capacity = this.length),
                  (this.arrayBuffer = this.arrayBuffer.slice(
                    0,
                    this.length * this.bytesPerElement,
                  )),
                  this._refreshViews());
              }
              clear() {
                this.length = 0;
              }
              resize(e) {
                (this.reserve(e), (this.length = e));
              }
              reserve(e) {
                if (e > this.capacity) {
                  ((this.capacity = Math.max(
                    e,
                    Math.floor(5 * this.capacity),
                    128,
                  )),
                    (this.arrayBuffer = new ArrayBuffer(
                      this.capacity * this.bytesPerElement,
                    )));
                  const i = this.uint8;
                  (this._refreshViews(), i && this.uint8.set(i));
                }
              }
              _refreshViews() {
                throw new Error(
                  "StructArray#_refreshViews() must be implemented by each concrete StructArray layout",
                );
              }
              emplace(...e) {
                throw new Error(
                  "StructArray#emplace() must be implemented by each concrete StructArray layout",
                );
              }
              emplaceBack(...e) {
                throw new Error(
                  "StructArray#emplaceBack() must be implemented by each concrete StructArray layout",
                );
              }
              destroy() {
                ((this.int8 =
                  this.uint8 =
                  this.int16 =
                  this.uint16 =
                  this.int32 =
                  this.uint32 =
                  this.float32 =
                    null),
                  (this.arrayBuffer = null));
              }
            }
            function Ai(n, e = 1) {
              let i = 0,
                o = 0;
              return {
                members: n.map((a) => {
                  const u = G_[a.type].BYTES_PER_ELEMENT,
                    d = (i = Hd(i, Math.max(e, u))),
                    _ = a.components || 1;
                  return (
                    (o = Math.max(o, u)),
                    (i += u * _),
                    { name: a.name, type: a.type, components: _, offset: d }
                  );
                }),
                size: Hd(i, Math.max(o, e)),
                alignment: e,
              };
            }
            function Hd(n, e) {
              return Math.ceil(n / e) * e;
            }
            class po extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)));
              }
              emplaceBack(e, i) {
                const o = this.length;
                return (this.resize(o + 1), this.emplace(o, e, i));
              }
              emplace(e, i, o) {
                const a = 2 * e;
                return ((this.int16[a + 0] = i), (this.int16[a + 1] = o), e);
              }
            }
            ((po.prototype.bytesPerElement = 4),
              Tt(po, "StructArrayLayout2i4"));
            class Vc extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o) {
                const a = this.length;
                return (this.resize(a + 1), this.emplace(a, e, i, o));
              }
              emplace(e, i, o, a) {
                const u = 3 * e;
                return (
                  (this.int16[u + 0] = i),
                  (this.int16[u + 1] = o),
                  (this.int16[u + 2] = a),
                  e
                );
              }
            }
            ((Vc.prototype.bytesPerElement = 6),
              Tt(Vc, "StructArrayLayout3i6"));
            class Il extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a) {
                const u = this.length;
                return (this.resize(u + 1), this.emplace(u, e, i, o, a));
              }
              emplace(e, i, o, a, u) {
                const d = 4 * e;
                return (
                  (this.int16[d + 0] = i),
                  (this.int16[d + 1] = o),
                  (this.int16[d + 2] = a),
                  (this.int16[d + 3] = u),
                  e
                );
              }
            }
            ((Il.prototype.bytesPerElement = 8),
              Tt(Il, "StructArrayLayout4i8"));
            class Go extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)));
              }
              emplaceBack(e) {
                const i = this.length;
                return (this.resize(i + 1), this.emplace(i, e));
              }
              emplace(e, i) {
                return ((this.float32[1 * e + 0] = i), e);
              }
            }
            ((Go.prototype.bytesPerElement = 4),
              Tt(Go, "StructArrayLayout1f4"));
            class Wd extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o) {
                const a = this.length;
                return (this.resize(a + 1), this.emplace(a, e, i, o));
              }
              emplace(e, i, o, a) {
                const u = 4 * e,
                  d = 2 * e;
                return (
                  (this.int16[u + 0] = i),
                  (this.int16[u + 1] = o),
                  (this.float32[d + 1] = a),
                  e
                );
              }
            }
            ((Wd.prototype.bytesPerElement = 8),
              Tt(Wd, "StructArrayLayout2i1f8"));
            class fu extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o) {
                const a = this.length;
                return (this.resize(a + 1), this.emplace(a, e, i, o));
              }
              emplace(e, i, o, a) {
                const u = 4 * e;
                return (
                  (this.int16[u + 0] = i),
                  (this.int16[u + 1] = o),
                  (this.int16[u + 2] = a),
                  e
                );
              }
            }
            ((fu.prototype.bytesPerElement = 8),
              Tt(fu, "StructArrayLayout3i8"));
            class Al extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a, u) {
                const d = this.length;
                return (this.resize(d + 1), this.emplace(d, e, i, o, a, u));
              }
              emplace(e, i, o, a, u, d) {
                const _ = 5 * e;
                return (
                  (this.int16[_ + 0] = i),
                  (this.int16[_ + 1] = o),
                  (this.int16[_ + 2] = a),
                  (this.int16[_ + 3] = u),
                  (this.int16[_ + 4] = d),
                  e
                );
              }
            }
            ((Al.prototype.bytesPerElement = 10),
              Tt(Al, "StructArrayLayout5i10"));
            class qd extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a, u, d, _) {
                const v = this.length;
                return (
                  this.resize(v + 1),
                  this.emplace(v, e, i, o, a, u, d, _)
                );
              }
              emplace(e, i, o, a, u, d, _, v) {
                const b = 6 * e,
                  E = 12 * e,
                  A = 3 * e;
                return (
                  (this.int16[b + 0] = i),
                  (this.int16[b + 1] = o),
                  (this.uint8[E + 4] = a),
                  (this.uint8[E + 5] = u),
                  (this.uint8[E + 6] = d),
                  (this.uint8[E + 7] = _),
                  (this.float32[A + 2] = v),
                  e
                );
              }
            }
            ((qd.prototype.bytesPerElement = 12),
              Tt(qd, "StructArrayLayout2i4ub1f12"));
            class Vs extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o) {
                const a = this.length;
                return (this.resize(a + 1), this.emplace(a, e, i, o));
              }
              emplace(e, i, o, a) {
                const u = 3 * e;
                return (
                  (this.float32[u + 0] = i),
                  (this.float32[u + 1] = o),
                  (this.float32[u + 2] = a),
                  e
                );
              }
            }
            ((Vs.prototype.bytesPerElement = 12),
              Tt(Vs, "StructArrayLayout3f12"));
            class $o extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a, u) {
                const d = this.length;
                return (this.resize(d + 1), this.emplace(d, e, i, o, a, u));
              }
              emplace(e, i, o, a, u, d) {
                const _ = 6 * e,
                  v = 3 * e;
                return (
                  (this.uint16[_ + 0] = i),
                  (this.uint16[_ + 1] = o),
                  (this.uint16[_ + 2] = a),
                  (this.uint16[_ + 3] = u),
                  (this.float32[v + 2] = d),
                  e
                );
              }
            }
            (($o.prototype.bytesPerElement = 12),
              Tt($o, "StructArrayLayout4ui1f12"));
            class Uc extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a) {
                const u = this.length;
                return (this.resize(u + 1), this.emplace(u, e, i, o, a));
              }
              emplace(e, i, o, a, u) {
                const d = 4 * e;
                return (
                  (this.uint16[d + 0] = i),
                  (this.uint16[d + 1] = o),
                  (this.uint16[d + 2] = a),
                  (this.uint16[d + 3] = u),
                  e
                );
              }
            }
            ((Uc.prototype.bytesPerElement = 8),
              Tt(Uc, "StructArrayLayout4ui8"));
            class pu extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a, u, d) {
                const _ = this.length;
                return (this.resize(_ + 1), this.emplace(_, e, i, o, a, u, d));
              }
              emplace(e, i, o, a, u, d, _) {
                const v = 6 * e;
                return (
                  (this.int16[v + 0] = i),
                  (this.int16[v + 1] = o),
                  (this.int16[v + 2] = a),
                  (this.int16[v + 3] = u),
                  (this.int16[v + 4] = d),
                  (this.int16[v + 5] = _),
                  e
                );
              }
            }
            ((pu.prototype.bytesPerElement = 12),
              Tt(pu, "StructArrayLayout6i12"));
            class Ml extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a, u, d, _, v, b, E, A, M) {
                const R = this.length;
                return (
                  this.resize(R + 1),
                  this.emplace(R, e, i, o, a, u, d, _, v, b, E, A, M)
                );
              }
              emplace(e, i, o, a, u, d, _, v, b, E, A, M, R) {
                const k = 12 * e;
                return (
                  (this.int16[k + 0] = i),
                  (this.int16[k + 1] = o),
                  (this.int16[k + 2] = a),
                  (this.int16[k + 3] = u),
                  (this.uint16[k + 4] = d),
                  (this.uint16[k + 5] = _),
                  (this.uint16[k + 6] = v),
                  (this.uint16[k + 7] = b),
                  (this.int16[k + 8] = E),
                  (this.int16[k + 9] = A),
                  (this.int16[k + 10] = M),
                  (this.int16[k + 11] = R),
                  e
                );
              }
            }
            ((Ml.prototype.bytesPerElement = 24),
              Tt(Ml, "StructArrayLayout4i4ui4i24"));
            class Cl extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a, u, d) {
                const _ = this.length;
                return (this.resize(_ + 1), this.emplace(_, e, i, o, a, u, d));
              }
              emplace(e, i, o, a, u, d, _) {
                const v = 10 * e,
                  b = 5 * e;
                return (
                  (this.int16[v + 0] = i),
                  (this.int16[v + 1] = o),
                  (this.int16[v + 2] = a),
                  (this.float32[b + 2] = u),
                  (this.float32[b + 3] = d),
                  (this.float32[b + 4] = _),
                  e
                );
              }
            }
            ((Cl.prototype.bytesPerElement = 20),
              Tt(Cl, "StructArrayLayout3i3f20"));
            class ur extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a) {
                const u = this.length;
                return (this.resize(u + 1), this.emplace(u, e, i, o, a));
              }
              emplace(e, i, o, a, u) {
                const d = 4 * e;
                return (
                  (this.float32[d + 0] = i),
                  (this.float32[d + 1] = o),
                  (this.float32[d + 2] = a),
                  (this.float32[d + 3] = u),
                  e
                );
              }
            }
            ((ur.prototype.bytesPerElement = 16),
              Tt(ur, "StructArrayLayout4f16"));
            class Pl extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer)));
              }
              emplaceBack(e) {
                const i = this.length;
                return (this.resize(i + 1), this.emplace(i, e));
              }
              emplace(e, i) {
                return ((this.uint32[1 * e + 0] = i), e);
              }
            }
            ((Pl.prototype.bytesPerElement = 4),
              Tt(Pl, "StructArrayLayout1ul4"));
            class Ho extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)));
              }
              emplaceBack(e, i) {
                const o = this.length;
                return (this.resize(o + 1), this.emplace(o, e, i));
              }
              emplace(e, i, o) {
                const a = 2 * e;
                return ((this.uint16[a + 0] = i), (this.uint16[a + 1] = o), e);
              }
            }
            ((Ho.prototype.bytesPerElement = 4),
              Tt(Ho, "StructArrayLayout2ui4"));
            class Zd extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a, u, d, _, v, b, E, A, M, R) {
                const k = this.length;
                return (
                  this.resize(k + 1),
                  this.emplace(k, e, i, o, a, u, d, _, v, b, E, A, M, R)
                );
              }
              emplace(e, i, o, a, u, d, _, v, b, E, A, M, R, k) {
                const N = 20 * e,
                  j = 10 * e;
                return (
                  (this.int16[N + 0] = i),
                  (this.int16[N + 1] = o),
                  (this.int16[N + 2] = a),
                  (this.int16[N + 3] = u),
                  (this.int16[N + 4] = d),
                  (this.float32[j + 3] = _),
                  (this.float32[j + 4] = v),
                  (this.float32[j + 5] = b),
                  (this.float32[j + 6] = E),
                  (this.int16[N + 14] = A),
                  (this.uint32[j + 8] = M),
                  (this.uint16[N + 18] = R),
                  (this.uint16[N + 19] = k),
                  e
                );
              }
            }
            ((Zd.prototype.bytesPerElement = 40),
              Tt(Zd, "StructArrayLayout5i4f1i1ul2ui40"));
            class mu extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a, u, d, _) {
                const v = this.length;
                return (
                  this.resize(v + 1),
                  this.emplace(v, e, i, o, a, u, d, _)
                );
              }
              emplace(e, i, o, a, u, d, _, v) {
                const b = 8 * e;
                return (
                  (this.int16[b + 0] = i),
                  (this.int16[b + 1] = o),
                  (this.int16[b + 2] = a),
                  (this.int16[b + 4] = u),
                  (this.int16[b + 5] = d),
                  (this.int16[b + 6] = _),
                  (this.int16[b + 7] = v),
                  e
                );
              }
            }
            ((mu.prototype.bytesPerElement = 16),
              Tt(mu, "StructArrayLayout3i2i2i16"));
            class Xd extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a, u) {
                const d = this.length;
                return (this.resize(d + 1), this.emplace(d, e, i, o, a, u));
              }
              emplace(e, i, o, a, u, d) {
                const _ = 4 * e,
                  v = 8 * e;
                return (
                  (this.float32[_ + 0] = i),
                  (this.float32[_ + 1] = o),
                  (this.float32[_ + 2] = a),
                  (this.int16[v + 6] = u),
                  (this.int16[v + 7] = d),
                  e
                );
              }
            }
            ((Xd.prototype.bytesPerElement = 16),
              Tt(Xd, "StructArrayLayout2f1f2i16"));
            class jc extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a, u, d) {
                const _ = this.length;
                return (this.resize(_ + 1), this.emplace(_, e, i, o, a, u, d));
              }
              emplace(e, i, o, a, u, d, _) {
                const v = 20 * e,
                  b = 5 * e;
                return (
                  (this.uint8[v + 0] = i),
                  (this.uint8[v + 1] = o),
                  (this.float32[b + 1] = a),
                  (this.float32[b + 2] = u),
                  (this.float32[b + 3] = d),
                  (this.float32[b + 4] = _),
                  e
                );
              }
            }
            ((jc.prototype.bytesPerElement = 20),
              Tt(jc, "StructArrayLayout2ub4f20"));
            class dr extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o) {
                const a = this.length;
                return (this.resize(a + 1), this.emplace(a, e, i, o));
              }
              emplace(e, i, o, a) {
                const u = 3 * e;
                return (
                  (this.uint16[u + 0] = i),
                  (this.uint16[u + 1] = o),
                  (this.uint16[u + 2] = a),
                  e
                );
              }
            }
            ((dr.prototype.bytesPerElement = 6),
              Tt(dr, "StructArrayLayout3ui6"));
            class Gc extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer)));
              }
              emplaceBack(
                e,
                i,
                o,
                a,
                u,
                d,
                _,
                v,
                b,
                E,
                A,
                M,
                R,
                k,
                N,
                j,
                H,
                J,
                Q,
                V,
                X,
              ) {
                const ee = this.length;
                return (
                  this.resize(ee + 1),
                  this.emplace(
                    ee,
                    e,
                    i,
                    o,
                    a,
                    u,
                    d,
                    _,
                    v,
                    b,
                    E,
                    A,
                    M,
                    R,
                    k,
                    N,
                    j,
                    H,
                    J,
                    Q,
                    V,
                    X,
                  )
                );
              }
              emplace(
                e,
                i,
                o,
                a,
                u,
                d,
                _,
                v,
                b,
                E,
                A,
                M,
                R,
                k,
                N,
                j,
                H,
                J,
                Q,
                V,
                X,
                ee,
              ) {
                const re = 30 * e,
                  ve = 15 * e,
                  ge = 60 * e;
                return (
                  (this.int16[re + 0] = i),
                  (this.int16[re + 1] = o),
                  (this.int16[re + 2] = a),
                  (this.float32[ve + 2] = u),
                  (this.float32[ve + 3] = d),
                  (this.uint16[re + 8] = _),
                  (this.uint16[re + 9] = v),
                  (this.uint32[ve + 5] = b),
                  (this.uint32[ve + 6] = E),
                  (this.uint32[ve + 7] = A),
                  (this.uint16[re + 16] = M),
                  (this.uint16[re + 17] = R),
                  (this.uint16[re + 18] = k),
                  (this.float32[ve + 10] = N),
                  (this.float32[ve + 11] = j),
                  (this.uint8[ge + 48] = H),
                  (this.uint8[ge + 49] = J),
                  (this.uint8[ge + 50] = Q),
                  (this.uint32[ve + 13] = V),
                  (this.int16[re + 28] = X),
                  (this.uint8[ge + 58] = ee),
                  e
                );
              }
            }
            ((Gc.prototype.bytesPerElement = 60),
              Tt(Gc, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60"));
            class Yd extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer)));
              }
              emplaceBack(
                e,
                i,
                o,
                a,
                u,
                d,
                _,
                v,
                b,
                E,
                A,
                M,
                R,
                k,
                N,
                j,
                H,
                J,
                Q,
                V,
                X,
                ee,
                re,
                ve,
                ge,
                be,
                Me,
                Ue,
                it,
                Xe,
                tt,
                nt,
                Ge,
              ) {
                const Je = this.length;
                return (
                  this.resize(Je + 1),
                  this.emplace(
                    Je,
                    e,
                    i,
                    o,
                    a,
                    u,
                    d,
                    _,
                    v,
                    b,
                    E,
                    A,
                    M,
                    R,
                    k,
                    N,
                    j,
                    H,
                    J,
                    Q,
                    V,
                    X,
                    ee,
                    re,
                    ve,
                    ge,
                    be,
                    Me,
                    Ue,
                    it,
                    Xe,
                    tt,
                    nt,
                    Ge,
                  )
                );
              }
              emplace(
                e,
                i,
                o,
                a,
                u,
                d,
                _,
                v,
                b,
                E,
                A,
                M,
                R,
                k,
                N,
                j,
                H,
                J,
                Q,
                V,
                X,
                ee,
                re,
                ve,
                ge,
                be,
                Me,
                Ue,
                it,
                Xe,
                tt,
                nt,
                Ge,
                Je,
              ) {
                const Ne = 20 * e,
                  je = 40 * e,
                  at = 80 * e;
                return (
                  (this.float32[Ne + 0] = i),
                  (this.float32[Ne + 1] = o),
                  (this.int16[je + 4] = a),
                  (this.int16[je + 5] = u),
                  (this.int16[je + 6] = d),
                  (this.int16[je + 7] = _),
                  (this.int16[je + 8] = v),
                  (this.int16[je + 9] = b),
                  (this.int16[je + 10] = E),
                  (this.int16[je + 11] = A),
                  (this.int16[je + 12] = M),
                  (this.uint16[je + 13] = R),
                  (this.uint16[je + 14] = k),
                  (this.uint16[je + 15] = N),
                  (this.uint16[je + 16] = j),
                  (this.uint16[je + 17] = H),
                  (this.uint16[je + 18] = J),
                  (this.uint16[je + 19] = Q),
                  (this.uint16[je + 20] = V),
                  (this.uint16[je + 21] = X),
                  (this.uint16[je + 22] = ee),
                  (this.uint16[je + 23] = re),
                  (this.uint16[je + 24] = ve),
                  (this.uint16[je + 25] = ge),
                  (this.uint16[je + 26] = be),
                  (this.uint16[je + 27] = Me),
                  (this.uint32[Ne + 14] = Ue),
                  (this.float32[Ne + 15] = it),
                  (this.float32[Ne + 16] = Xe),
                  (this.float32[Ne + 17] = tt),
                  (this.float32[Ne + 18] = nt),
                  (this.uint8[at + 76] = Ge),
                  (this.uint16[je + 39] = Je),
                  e
                );
              }
            }
            ((Yd.prototype.bytesPerElement = 80),
              Tt(Yd, "StructArrayLayout2f9i15ui1ul4f1ub1ui80"));
            class Kd extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a, u, d) {
                const _ = this.length;
                return (this.resize(_ + 1), this.emplace(_, e, i, o, a, u, d));
              }
              emplace(e, i, o, a, u, d, _) {
                const v = 6 * e;
                return (
                  (this.float32[v + 0] = i),
                  (this.float32[v + 1] = o),
                  (this.float32[v + 2] = a),
                  (this.float32[v + 3] = u),
                  (this.float32[v + 4] = d),
                  (this.float32[v + 5] = _),
                  e
                );
              }
            }
            ((Kd.prototype.bytesPerElement = 24),
              Tt(Kd, "StructArrayLayout6f24"));
            class Wo extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a, u) {
                const d = this.length;
                return (this.resize(d + 1), this.emplace(d, e, i, o, a, u));
              }
              emplace(e, i, o, a, u, d) {
                const _ = 5 * e;
                return (
                  (this.float32[_ + 0] = i),
                  (this.float32[_ + 1] = o),
                  (this.float32[_ + 2] = a),
                  (this.float32[_ + 3] = u),
                  (this.float32[_ + 4] = d),
                  e
                );
              }
            }
            ((Wo.prototype.bytesPerElement = 20),
              Tt(Wo, "StructArrayLayout5f20"));
            class $c extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a, u, d, _) {
                const v = this.length;
                return (
                  this.resize(v + 1),
                  this.emplace(v, e, i, o, a, u, d, _)
                );
              }
              emplace(e, i, o, a, u, d, _, v) {
                const b = 7 * e;
                return (
                  (this.float32[b + 0] = i),
                  (this.float32[b + 1] = o),
                  (this.float32[b + 2] = a),
                  (this.float32[b + 3] = u),
                  (this.float32[b + 4] = d),
                  (this.float32[b + 5] = _),
                  (this.float32[b + 6] = v),
                  e
                );
              }
            }
            (($c.prototype.bytesPerElement = 28),
              Tt($c, "StructArrayLayout7f28"));
            class Jd extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a, u, d, _, v, b, E, A) {
                const M = this.length;
                return (
                  this.resize(M + 1),
                  this.emplace(M, e, i, o, a, u, d, _, v, b, E, A)
                );
              }
              emplace(e, i, o, a, u, d, _, v, b, E, A, M) {
                const R = 11 * e;
                return (
                  (this.float32[R + 0] = i),
                  (this.float32[R + 1] = o),
                  (this.float32[R + 2] = a),
                  (this.float32[R + 3] = u),
                  (this.float32[R + 4] = d),
                  (this.float32[R + 5] = _),
                  (this.float32[R + 6] = v),
                  (this.float32[R + 7] = b),
                  (this.float32[R + 8] = E),
                  (this.float32[R + 9] = A),
                  (this.float32[R + 10] = M),
                  e
                );
              }
            }
            ((Jd.prototype.bytesPerElement = 44),
              Tt(Jd, "StructArrayLayout11f44"));
            class gu extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a, u, d, _, v, b) {
                const E = this.length;
                return (
                  this.resize(E + 1),
                  this.emplace(E, e, i, o, a, u, d, _, v, b)
                );
              }
              emplace(e, i, o, a, u, d, _, v, b, E) {
                const A = 9 * e;
                return (
                  (this.float32[A + 0] = i),
                  (this.float32[A + 1] = o),
                  (this.float32[A + 2] = a),
                  (this.float32[A + 3] = u),
                  (this.float32[A + 4] = d),
                  (this.float32[A + 5] = _),
                  (this.float32[A + 6] = v),
                  (this.float32[A + 7] = b),
                  (this.float32[A + 8] = E),
                  e
                );
              }
            }
            ((gu.prototype.bytesPerElement = 36),
              Tt(gu, "StructArrayLayout9f36"));
            class ka extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)));
              }
              emplaceBack(e, i) {
                const o = this.length;
                return (this.resize(o + 1), this.emplace(o, e, i));
              }
              emplace(e, i, o) {
                const a = 2 * e;
                return (
                  (this.float32[a + 0] = i),
                  (this.float32[a + 1] = o),
                  e
                );
              }
            }
            ((ka.prototype.bytesPerElement = 8),
              Tt(ka, "StructArrayLayout2f8"));
            class Qd extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint32 = new Uint32Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a) {
                const u = this.length;
                return (this.resize(u + 1), this.emplace(u, e, i, o, a));
              }
              emplace(e, i, o, a, u) {
                const d = 6 * e;
                return (
                  (this.uint32[3 * e + 0] = i),
                  (this.uint16[d + 2] = o),
                  (this.uint16[d + 3] = a),
                  (this.uint16[d + 4] = u),
                  e
                );
              }
            }
            ((Qd.prototype.bytesPerElement = 12),
              Tt(Qd, "StructArrayLayout1ul3ui12"));
            class Hc extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)));
              }
              emplaceBack(e) {
                const i = this.length;
                return (this.resize(i + 1), this.emplace(i, e));
              }
              emplace(e, i) {
                return ((this.uint16[1 * e + 0] = i), e);
              }
            }
            ((Hc.prototype.bytesPerElement = 2),
              Tt(Hc, "StructArrayLayout1ui2"));
            class Dl extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a, u, d, _, v, b, E, A, M, R, k, N, j) {
                const H = this.length;
                return (
                  this.resize(H + 1),
                  this.emplace(
                    H,
                    e,
                    i,
                    o,
                    a,
                    u,
                    d,
                    _,
                    v,
                    b,
                    E,
                    A,
                    M,
                    R,
                    k,
                    N,
                    j,
                  )
                );
              }
              emplace(e, i, o, a, u, d, _, v, b, E, A, M, R, k, N, j, H) {
                const J = 16 * e;
                return (
                  (this.float32[J + 0] = i),
                  (this.float32[J + 1] = o),
                  (this.float32[J + 2] = a),
                  (this.float32[J + 3] = u),
                  (this.float32[J + 4] = d),
                  (this.float32[J + 5] = _),
                  (this.float32[J + 6] = v),
                  (this.float32[J + 7] = b),
                  (this.float32[J + 8] = E),
                  (this.float32[J + 9] = A),
                  (this.float32[J + 10] = M),
                  (this.float32[J + 11] = R),
                  (this.float32[J + 12] = k),
                  (this.float32[J + 13] = N),
                  (this.float32[J + 14] = j),
                  (this.float32[J + 15] = H),
                  e
                );
              }
            }
            ((Dl.prototype.bytesPerElement = 64),
              Tt(Dl, "StructArrayLayout16f64"));
            class Wc extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.uint16 = new Uint16Array(this.arrayBuffer)),
                  (this.float32 = new Float32Array(this.arrayBuffer)));
              }
              emplaceBack(e, i, o, a, u, d, _) {
                const v = this.length;
                return (
                  this.resize(v + 1),
                  this.emplace(v, e, i, o, a, u, d, _)
                );
              }
              emplace(e, i, o, a, u, d, _, v) {
                const b = 10 * e,
                  E = 5 * e;
                return (
                  (this.uint16[b + 0] = i),
                  (this.uint16[b + 1] = o),
                  (this.uint16[b + 2] = a),
                  (this.uint16[b + 3] = u),
                  (this.float32[E + 2] = d),
                  (this.float32[E + 3] = _),
                  (this.float32[E + 4] = v),
                  e
                );
              }
            }
            ((Wc.prototype.bytesPerElement = 20),
              Tt(Wc, "StructArrayLayout4ui3f20"));
            class ef extends yn {
              _refreshViews() {
                ((this.uint8 = new Uint8Array(this.arrayBuffer)),
                  (this.int16 = new Int16Array(this.arrayBuffer)));
              }
              emplaceBack(e) {
                const i = this.length;
                return (this.resize(i + 1), this.emplace(i, e));
              }
              emplace(e, i) {
                return ((this.int16[1 * e + 0] = i), e);
              }
            }
            ((ef.prototype.bytesPerElement = 2),
              Tt(ef, "StructArrayLayout1i2"));
            class _u extends yn {
              _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer);
              }
              emplaceBack(e) {
                const i = this.length;
                return (this.resize(i + 1), this.emplace(i, e));
              }
              emplace(e, i) {
                return ((this.uint8[1 * e + 0] = i), e);
              }
            }
            ((_u.prototype.bytesPerElement = 1),
              Tt(_u, "StructArrayLayout1ub1"));
            class cm extends Nc {
              get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
              }
              get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
              }
              get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
              }
              get tileAnchorX() {
                return this._structArray.int16[this._pos2 + 3];
              }
              get tileAnchorY() {
                return this._structArray.int16[this._pos2 + 4];
              }
              get x1() {
                return this._structArray.float32[this._pos4 + 3];
              }
              get y1() {
                return this._structArray.float32[this._pos4 + 4];
              }
              get x2() {
                return this._structArray.float32[this._pos4 + 5];
              }
              get y2() {
                return this._structArray.float32[this._pos4 + 6];
              }
              get padding() {
                return this._structArray.int16[this._pos2 + 14];
              }
              get featureIndex() {
                return this._structArray.uint32[this._pos4 + 8];
              }
              get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 18];
              }
              get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 19];
              }
            }
            cm.prototype.size = 40;
            class yu extends Zd {
              get(e) {
                return new cm(this, e);
              }
            }
            Tt(yu, "CollisionBoxArray");
            class hm extends Nc {
              get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
              }
              get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
              }
              get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
              }
              get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2];
              }
              get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3];
              }
              get glyphStartIndex() {
                return this._structArray.uint16[this._pos2 + 8];
              }
              get numGlyphs() {
                return this._structArray.uint16[this._pos2 + 9];
              }
              get vertexStartIndex() {
                return this._structArray.uint32[this._pos4 + 5];
              }
              get lineStartIndex() {
                return this._structArray.uint32[this._pos4 + 6];
              }
              get lineLength() {
                return this._structArray.uint32[this._pos4 + 7];
              }
              get segment() {
                return this._structArray.uint16[this._pos2 + 16];
              }
              get lowerSize() {
                return this._structArray.uint16[this._pos2 + 17];
              }
              get upperSize() {
                return this._structArray.uint16[this._pos2 + 18];
              }
              get lineOffsetX() {
                return this._structArray.float32[this._pos4 + 10];
              }
              get lineOffsetY() {
                return this._structArray.float32[this._pos4 + 11];
              }
              get writingMode() {
                return this._structArray.uint8[this._pos1 + 48];
              }
              get placedOrientation() {
                return this._structArray.uint8[this._pos1 + 49];
              }
              set placedOrientation(e) {
                this._structArray.uint8[this._pos1 + 49] = e;
              }
              get hidden() {
                return this._structArray.uint8[this._pos1 + 50];
              }
              set hidden(e) {
                this._structArray.uint8[this._pos1 + 50] = e;
              }
              get crossTileID() {
                return this._structArray.uint32[this._pos4 + 13];
              }
              set crossTileID(e) {
                this._structArray.uint32[this._pos4 + 13] = e;
              }
              get associatedIconIndex() {
                return this._structArray.int16[this._pos2 + 28];
              }
              get flipState() {
                return this._structArray.uint8[this._pos1 + 58];
              }
              set flipState(e) {
                this._structArray.uint8[this._pos1 + 58] = e;
              }
            }
            hm.prototype.size = 60;
            class um extends Gc {
              get(e) {
                return new hm(this, e);
              }
            }
            Tt(um, "PlacedSymbolArray");
            class dm extends Nc {
              get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 0];
              }
              get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 1];
              }
              get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 4];
              }
              get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 5];
              }
              get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 6];
              }
              get rightJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 7];
              }
              get centerJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 8];
              }
              get leftJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 9];
              }
              get verticalPlacedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 10];
              }
              get placedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 11];
              }
              get verticalPlacedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 12];
              }
              get key() {
                return this._structArray.uint16[this._pos2 + 13];
              }
              get textBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 14];
              }
              get textBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 15];
              }
              get verticalTextBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 16];
              }
              get verticalTextBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 17];
              }
              get iconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 18];
              }
              get iconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 19];
              }
              get verticalIconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 20];
              }
              get verticalIconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 21];
              }
              get featureIndex() {
                return this._structArray.uint16[this._pos2 + 22];
              }
              get numHorizontalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 23];
              }
              get numVerticalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 24];
              }
              get numIconVertices() {
                return this._structArray.uint16[this._pos2 + 25];
              }
              get numVerticalIconVertices() {
                return this._structArray.uint16[this._pos2 + 26];
              }
              get useRuntimeCollisionCircles() {
                return this._structArray.uint16[this._pos2 + 27];
              }
              get crossTileID() {
                return this._structArray.uint32[this._pos4 + 14];
              }
              set crossTileID(e) {
                this._structArray.uint32[this._pos4 + 14] = e;
              }
              get textOffset0() {
                return this._structArray.float32[this._pos4 + 15];
              }
              get textOffset1() {
                return this._structArray.float32[this._pos4 + 16];
              }
              get collisionCircleDiameter() {
                return this._structArray.float32[this._pos4 + 17];
              }
              get zOffset() {
                return this._structArray.float32[this._pos4 + 18];
              }
              set zOffset(e) {
                this._structArray.float32[this._pos4 + 18] = e;
              }
              get hasIconTextFit() {
                return this._structArray.uint8[this._pos1 + 76];
              }
              get elevationFeatureIndex() {
                return this._structArray.uint16[this._pos2 + 39];
              }
            }
            dm.prototype.size = 80;
            class fm extends Yd {
              get(e) {
                return new dm(this, e);
              }
            }
            Tt(fm, "SymbolInstanceArray");
            class tf extends Go {
              getoffsetX(e) {
                return this.float32[1 * e + 0];
              }
            }
            Tt(tf, "GlyphOffsetArray");
            class pm extends po {
              getx(e) {
                return this.int16[2 * e + 0];
              }
              gety(e) {
                return this.int16[2 * e + 1];
              }
            }
            Tt(pm, "SymbolLineVertexArray");
            class mm extends Nc {
              get featureIndex() {
                return this._structArray.uint32[this._pos4 + 0];
              }
              get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 2];
              }
              get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 3];
              }
              get layoutVertexArrayOffset() {
                return this._structArray.uint16[this._pos2 + 4];
              }
            }
            mm.prototype.size = 12;
            class gm extends Qd {
              get(e) {
                return new mm(this, e);
              }
            }
            Tt(gm, "FeatureIndexArray");
            class _m extends Ho {
              geta_centroid_pos0(e) {
                return this.uint16[2 * e + 0];
              }
              geta_centroid_pos1(e) {
                return this.uint16[2 * e + 1];
              }
            }
            Tt(_m, "FillExtrusionCentroidArray");
            class ym extends Nc {
              get a_join_normal_inside0() {
                return this._structArray.int16[this._pos2 + 0];
              }
              get a_join_normal_inside1() {
                return this._structArray.int16[this._pos2 + 1];
              }
              get a_join_normal_inside2() {
                return this._structArray.int16[this._pos2 + 2];
              }
            }
            ym.prototype.size = 6;
            class xm extends Vc {
              get(e) {
                return new ym(this, e);
              }
            }
            Tt(xm, "FillExtrusionWallArray");
            const $_ = Ai([{ name: "a_pos", components: 2, type: "Int16" }], 4),
              H_ = Ai(
                [{ name: "a_circle_z_offset", components: 1, type: "Float32" }],
                4,
              ),
              xu = Ai([
                { name: "a_pos_3", components: 3, type: "Int16" },
                { name: "a_pos_normal_3", components: 3, type: "Int16" },
              ]);
            class Rn {
              constructor(e = []) {
                this.segments = e;
              }
              _prepareSegment(e, i, o, a) {
                let u = this.segments[this.segments.length - 1];
                return (
                  e > Rn.MAX_VERTEX_ARRAY_LENGTH &&
                    ri(
                      `Max vertices per segment is ${Rn.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${e}`,
                    ),
                  (!u ||
                    u.vertexLength + e > Rn.MAX_VERTEX_ARRAY_LENGTH ||
                    u.sortKey !== a) &&
                    ((u = {
                      vertexOffset: i,
                      primitiveOffset: o,
                      vertexLength: 0,
                      primitiveLength: 0,
                    }),
                    a !== void 0 && (u.sortKey = a),
                    this.segments.push(u)),
                  u
                );
              }
              prepareSegment(e, i, o, a) {
                return this._prepareSegment(e, i.length, o.length, a);
              }
              get() {
                return this.segments;
              }
              destroy() {
                for (const e of this.segments)
                  for (const i in e.vaos) e.vaos[i].destroy();
              }
              static simpleSegment(e, i, o, a) {
                return new Rn([
                  {
                    vertexOffset: e,
                    primitiveOffset: i,
                    vertexLength: o,
                    primitiveLength: a,
                    vaos: {},
                    sortKey: 0,
                  },
                ]);
              }
            }
            function vm(n, e) {
              return (
                256 * (n = he(Math.floor(n), 0, 255)) +
                he(Math.floor(e), 0, 255)
              );
            }
            ((Rn.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1),
              Tt(Rn, "SegmentVector"));
            const vu = Ai([
                { name: "a_pattern", components: 4, type: "Uint16" },
                { name: "a_pixel_ratio", components: 1, type: "Float32" },
              ]),
              nf = Ai([{ name: "a_pattern_b", components: 4, type: "Uint16" }]),
              bm = Ai([{ name: "a_dash", components: 4, type: "Uint16" }]);
            class qc {
              constructor() {
                ((this.ids = []),
                  (this.uniqueIds = []),
                  (this.positions = []),
                  (this.indexed = !1));
              }
              add(e, i, o, a) {
                (this.ids.push(rf(e)), this.positions.push(i, o, a));
              }
              eachPosition(e, i) {
                const o = rf(e);
                let a = 0,
                  u = this.ids.length - 1;
                for (; a < u; ) {
                  const d = (a + u) >> 1;
                  this.ids[d] >= o ? (u = d) : (a = d + 1);
                }
                for (; this.ids[a] === o; )
                  (i(
                    this.positions[3 * a],
                    this.positions[3 * a + 1],
                    this.positions[3 * a + 2],
                  ),
                    a++);
              }
              static serialize(e, i) {
                const o = new Float64Array(e.ids),
                  a = new Uint32Array(e.positions);
                return (
                  bu(o, a, 0, o.length - 1),
                  i && (i.add(o.buffer), i.add(a.buffer)),
                  { ids: o, positions: a }
                );
              }
              static deserialize(e) {
                const i = new qc();
                let o;
                ((i.ids = e.ids), (i.positions = e.positions));
                for (const a of i.ids)
                  (a !== o && i.uniqueIds.push(a), (o = a));
                return ((i.indexed = !0), i);
              }
            }
            function rf(n) {
              const e = +n;
              return !isNaN(e) &&
                Number.MIN_SAFE_INTEGER <= e &&
                e <= Number.MAX_SAFE_INTEGER
                ? e
                : mc(String(n));
            }
            function bu(n, e, i, o) {
              for (; i < o; ) {
                const a = n[(i + o) >> 1];
                let u = i - 1,
                  d = o + 1;
                for (;;) {
                  do u++;
                  while (n[u] < a);
                  do d--;
                  while (n[d] > a);
                  if (u >= d) break;
                  (Zc(n, u, d),
                    Zc(e, 3 * u, 3 * d),
                    Zc(e, 3 * u + 1, 3 * d + 1),
                    Zc(e, 3 * u + 2, 3 * d + 2));
                }
                d - i < o - d
                  ? (bu(n, e, i, d), (i = d + 1))
                  : (bu(n, e, d + 1, o), (o = d));
              }
            }
            function Zc(n, e, i) {
              const o = n[e];
              ((n[e] = n[i]), (n[i] = o));
            }
            Tt(qc, "FeaturePositionMap");
            class mo {
              constructor(e) {
                ((this.gl = e.gl), (this.initialized = !1));
              }
              fetchUniformLocation(e, i) {
                return (
                  this.location ||
                    this.initialized ||
                    ((this.location = this.gl.getUniformLocation(e, i)),
                    (this.initialized = !0)),
                  !!this.location
                );
              }
              set(e, i, o) {
                throw new Error(
                  "Uniform#set() must be implemented by each concrete Uniform",
                );
              }
            }
            class wu extends mo {
              constructor(e) {
                (super(e), (this.current = 0));
              }
              set(e, i, o) {
                this.fetchUniformLocation(e, i) &&
                  this.current !== o &&
                  ((this.current = o), this.gl.uniform1i(this.location, o));
              }
            }
            class Vn extends mo {
              constructor(e) {
                (super(e), (this.current = 0));
              }
              set(e, i, o) {
                this.fetchUniformLocation(e, i) &&
                  this.current !== o &&
                  ((this.current = o), this.gl.uniform1f(this.location, o));
              }
            }
            class Us extends mo {
              constructor(e) {
                (super(e), (this.current = [0, 0]));
              }
              set(e, i, o) {
                this.fetchUniformLocation(e, i) &&
                  ((o[0] === this.current[0] && o[1] === this.current[1]) ||
                    ((this.current = o),
                    this.gl.uniform2f(this.location, o[0], o[1])));
              }
            }
            class Xc extends mo {
              constructor(e) {
                (super(e), (this.current = [0, 0, 0]));
              }
              set(e, i, o) {
                this.fetchUniformLocation(e, i) &&
                  ((o[0] === this.current[0] &&
                    o[1] === this.current[1] &&
                    o[2] === this.current[2]) ||
                    ((this.current = o),
                    this.gl.uniform3f(this.location, o[0], o[1], o[2])));
              }
            }
            class Tu extends mo {
              constructor(e) {
                (super(e), (this.current = [0, 0, 0, 0]));
              }
              set(e, i, o) {
                this.fetchUniformLocation(e, i) &&
                  ((o[0] === this.current[0] &&
                    o[1] === this.current[1] &&
                    o[2] === this.current[2] &&
                    o[3] === this.current[3]) ||
                    ((this.current = o),
                    this.gl.uniform4f(this.location, o[0], o[1], o[2], o[3])));
              }
            }
            class wm extends mo {
              constructor(e) {
                (super(e),
                  (this.current =
                    Li.transparent.toPremultipliedRenderColor(null)));
              }
              set(e, i, o) {
                this.fetchUniformLocation(e, i) &&
                  ((o.r === this.current.r &&
                    o.g === this.current.g &&
                    o.b === this.current.b &&
                    o.a === this.current.a) ||
                    ((this.current = o),
                    this.gl.uniform4f(this.location, o.r, o.g, o.b, o.a)));
              }
            }
            const W_ = new Float32Array(16);
            class Rl extends mo {
              constructor(e) {
                (super(e), (this.current = W_));
              }
              set(e, i, o) {
                if (this.fetchUniformLocation(e, i)) {
                  if (o[12] !== this.current[12] || o[0] !== this.current[0])
                    return (
                      (this.current = o),
                      void this.gl.uniformMatrix4fv(this.location, !1, o)
                    );
                  for (let a = 1; a < 16; a++)
                    if (o[a] !== this.current[a]) {
                      ((this.current = o),
                        this.gl.uniformMatrix4fv(this.location, !1, o));
                      break;
                    }
                }
              }
            }
            const sf = new Float32Array(9),
              js = new Float32Array(4);
            class Yc extends mo {
              constructor(e) {
                (super(e), (this.current = js));
              }
              set(e, i, o) {
                if (this.fetchUniformLocation(e, i)) {
                  for (let a = 0; a < 4; a++)
                    if (o[a] !== this.current[a]) {
                      ((this.current = o),
                        this.gl.uniformMatrix2fv(this.location, !1, o));
                      break;
                    }
                }
              }
            }
            function of(n) {
              return [vm(255 * n.r, 255 * n.g), vm(255 * n.b, 255 * n.a)];
            }
            class Kc {
              constructor(e, i, o, a) {
                ((this.value = e),
                  (this.uniformNames = i.map((u) => `u_${u}`)),
                  (this.type = o),
                  (this.context = a));
              }
              setUniform(e, i, o, a, u) {
                const d = a.constantOr(this.value);
                i.set(
                  e,
                  u,
                  d instanceof Li
                    ? d.toPremultipliedRenderColor(
                        this.lutExpression &&
                          this.lutExpression.value === "none"
                          ? null
                          : this.context.lut,
                      )
                    : d,
                );
              }
              getBinding(e, i) {
                return this.type === "color" ? new wm(e) : new Vn(e);
              }
            }
            class zl {
              constructor(e, i) {
                ((this.uniformNames = i.map((o) => `u_${o}`)),
                  (this.pattern = null),
                  (this.patternTransition = null),
                  (this.pixelRatio = 1));
              }
              setConstantPatternPositions(e, i) {
                ((this.pixelRatio = e.pixelRatio || 1),
                  (this.pattern = e.tl.concat(e.br)),
                  (this.patternTransition = i
                    ? i.tl.concat(i.br)
                    : this.pattern));
              }
              setUniform(e, i, o, a, u) {
                let d = null;
                ((u !== "u_pattern" && u !== "u_dash") || (d = this.pattern),
                  u === "u_pattern_b" && (d = this.patternTransition),
                  u === "u_pixel_ratio" && (d = this.pixelRatio),
                  d && i.set(e, u, d));
              }
              getBinding(e, i) {
                return i === "u_pattern" ||
                  i === "u_pattern_b" ||
                  i === "u_dash"
                  ? new Tu(e)
                  : new Vn(e);
              }
            }
            class go {
              constructor(e, i, o, a) {
                ((this.expression = e),
                  (this.type = o),
                  (this.maxValue = 0),
                  (this.paintVertexAttributes = i.map((u) => ({
                    name: `a_${u}`,
                    type: "Float32",
                    components: o === "color" ? 2 : 1,
                    offset: 0,
                  }))),
                  (this.paintVertexArray = new a()));
              }
              populatePaintArray(e, i, o, a, u, d, _, v) {
                const b = this.paintVertexArray.length,
                  E =
                    this.expression.kind === "composite" ||
                    this.expression.kind === "source"
                      ? this.expression.evaluate(
                          new qi(0, { brightness: d, worldview: v }),
                          i,
                          {},
                          u,
                          a,
                          _,
                        )
                      : this.expression.kind === "constant" &&
                        this.expression.value,
                  A =
                    !!this.lutExpression &&
                    (this.lutExpression.kind === "composite" ||
                    this.lutExpression.kind === "source"
                      ? this.lutExpression.evaluate(
                          new qi(0, { brightness: d, worldview: v }),
                          i,
                          {},
                          u,
                          a,
                          _,
                        )
                      : this.lutExpression.value) === "none";
                (this.paintVertexArray.resize(e),
                  this._setPaintValue(b, e, E, A ? null : this.context.lut));
              }
              updatePaintArray(e, i, o, a, u, d, _, v) {
                const b =
                    this.expression.kind === "composite" ||
                    this.expression.kind === "source"
                      ? this.expression.evaluate(
                          { zoom: 0, brightness: _, worldview: v },
                          o,
                          a,
                          void 0,
                          u,
                        )
                      : this.expression.kind === "constant" &&
                        this.expression.value,
                  E =
                    !!this.lutExpression &&
                    (this.lutExpression.kind === "composite" ||
                    this.lutExpression.kind === "source"
                      ? this.lutExpression.evaluate(
                          new qi(0, { brightness: _, worldview: v }),
                          o,
                          a,
                          void 0,
                          u,
                        )
                      : this.lutExpression.value) === "none";
                this._setPaintValue(e, i, b, E ? null : this.context.lut);
              }
              _setPaintValue(e, i, o, a) {
                if (this.type === "color") {
                  const u = of(o.toPremultipliedRenderColor(a));
                  for (let d = e; d < i; d++)
                    this.paintVertexArray.emplace(d, u[0], u[1]);
                } else {
                  for (let u = e; u < i; u++)
                    this.paintVertexArray.emplace(u, o);
                  this.maxValue = Math.max(this.maxValue, Math.abs(o));
                }
              }
              upload(e) {
                this.paintVertexArray &&
                  this.paintVertexArray.arrayBuffer &&
                  (this.paintVertexBuffer && this.paintVertexBuffer.buffer
                    ? this.paintVertexBuffer.updateData(this.paintVertexArray)
                    : (this.paintVertexBuffer = e.createVertexBuffer(
                        this.paintVertexArray,
                        this.paintVertexAttributes,
                        (this.lutExpression &&
                          this.lutExpression.kind !== "constant" &&
                          (this.lutExpression.isStateDependent ||
                            !this.lutExpression.isLightConstant)) ||
                          (this.expression.kind !== "constant" &&
                            (this.expression.isStateDependent ||
                              !this.expression.isLightConstant)),
                      )));
              }
              destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
              }
            }
            class Rs {
              constructor(e, i, o, a, u, d) {
                ((this.expression = e),
                  (this.uniformNames = i.map((_) => `u_${_}_t`)),
                  (this.type = o),
                  (this.useIntegerZoom = a),
                  (this.context = u),
                  (this.maxValue = 0),
                  (this.paintVertexAttributes = i.map((_) => ({
                    name: `a_${_}`,
                    type: "Float32",
                    components: o === "color" ? 4 : 2,
                    offset: 0,
                  }))),
                  (this.paintVertexArray = new d()));
              }
              populatePaintArray(e, i, o, a, u, d, _, v) {
                const b = this.expression.evaluate(
                    new qi(this.context.zoom, { brightness: d, worldview: v }),
                    i,
                    {},
                    u,
                    a,
                    _,
                  ),
                  E = this.expression.evaluate(
                    new qi(this.context.zoom + 1, {
                      brightness: d,
                      worldview: v,
                    }),
                    i,
                    {},
                    u,
                    a,
                    _,
                  ),
                  A =
                    !!this.lutExpression &&
                    (this.lutExpression.kind === "composite" ||
                    this.lutExpression.kind === "source"
                      ? this.lutExpression.evaluate(
                          new qi(0, { brightness: d, worldview: v }),
                          i,
                          {},
                          u,
                          a,
                          _,
                        )
                      : this.lutExpression.value) === "none",
                  M = this.paintVertexArray.length;
                (this.paintVertexArray.resize(e),
                  this._setPaintValue(M, e, b, E, A ? null : this.context.lut));
              }
              updatePaintArray(e, i, o, a, u, d, _, v) {
                const b = this.expression.evaluate(
                    { zoom: this.context.zoom, brightness: _, worldview: v },
                    o,
                    a,
                    void 0,
                    u,
                  ),
                  E = this.expression.evaluate(
                    {
                      zoom: this.context.zoom + 1,
                      brightness: _,
                      worldview: v,
                    },
                    o,
                    a,
                    void 0,
                    u,
                  ),
                  A =
                    !!this.lutExpression &&
                    (this.lutExpression.kind === "composite" ||
                    this.lutExpression.kind === "source"
                      ? this.lutExpression.evaluate(
                          new qi(0, { brightness: _, worldview: v }),
                          o,
                          a,
                          void 0,
                          u,
                        )
                      : this.lutExpression.value) === "none";
                this._setPaintValue(e, i, b, E, A ? null : this.context.lut);
              }
              _setPaintValue(e, i, o, a, u) {
                if (this.type === "color") {
                  const d = of(o.toPremultipliedRenderColor(u)),
                    _ = of(o.toPremultipliedRenderColor(u));
                  for (let v = e; v < i; v++)
                    this.paintVertexArray.emplace(v, d[0], d[1], _[0], _[1]);
                } else {
                  for (let d = e; d < i; d++)
                    this.paintVertexArray.emplace(d, o, a);
                  this.maxValue = Math.max(
                    this.maxValue,
                    Math.abs(o),
                    Math.abs(a),
                  );
                }
              }
              upload(e) {
                this.paintVertexArray &&
                  this.paintVertexArray.arrayBuffer &&
                  (this.paintVertexBuffer && this.paintVertexBuffer.buffer
                    ? this.paintVertexBuffer.updateData(this.paintVertexArray)
                    : (this.paintVertexBuffer = e.createVertexBuffer(
                        this.paintVertexArray,
                        this.paintVertexAttributes,
                        this.expression.isStateDependent ||
                          !this.expression.isLightConstant,
                      )));
              }
              destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
              }
              setUniform(e, i, o, a, u) {
                const d = this.useIntegerZoom ? Math.floor(o.zoom) : o.zoom,
                  _ = he(
                    this.expression.interpolationFactor(
                      d,
                      this.context.zoom,
                      this.context.zoom + 1,
                    ),
                    0,
                    1,
                  );
                i.set(e, u, _);
              }
              getBinding(e, i) {
                return new Vn(e);
              }
            }
            class bs {
              constructor(e, i, o, a, u) {
                ((this.expression = e),
                  (this.layerId = u),
                  (this.paintVertexAttributes = (
                    o === "array" ? bm : vu
                  ).members));
                for (let d = 0; d < i.length; ++d);
                ((this.paintVertexArray = new a()),
                  (this.paintTransitionVertexArray = new Uc()));
              }
              populatePaintArray(e, i, o, a) {
                const u = this.paintVertexArray.length;
                (this.paintVertexArray.resize(e),
                  this._setPaintValues(
                    u,
                    e,
                    i.patterns && i.patterns[this.layerId],
                    o,
                  ));
              }
              updatePaintArray(e, i, o, a, u, d, _) {
                this._setPaintValues(
                  e,
                  i,
                  o.patterns && o.patterns[this.layerId],
                  d,
                );
              }
              _setPaintValues(e, i, o, a) {
                if (!a || !o) return;
                const u = a[o[0]],
                  d = a[o[1]];
                if (u) {
                  if (u) {
                    const { tl: _, br: v, pixelRatio: b } = u;
                    for (let E = e; E < i; E++)
                      this.paintVertexArray.emplace(
                        E,
                        _[0],
                        _[1],
                        v[0],
                        v[1],
                        b,
                      );
                  }
                  if (d) {
                    this.paintTransitionVertexArray.resize(
                      this.paintVertexArray.length,
                    );
                    const { tl: _, br: v } = d;
                    for (let b = e; b < i; b++)
                      this.paintTransitionVertexArray.emplace(
                        b,
                        _[0],
                        _[1],
                        v[0],
                        v[1],
                      );
                  }
                }
              }
              upload(e) {
                const i =
                  this.expression.isStateDependent ||
                  !this.expression.isLightConstant;
                (this.paintVertexArray &&
                  this.paintVertexArray.arrayBuffer &&
                  (this.paintVertexBuffer = e.createVertexBuffer(
                    this.paintVertexArray,
                    this.paintVertexAttributes,
                    i,
                  )),
                  this.paintTransitionVertexArray &&
                    this.paintTransitionVertexArray.length &&
                    (this.paintTransitionVertexBuffer = e.createVertexBuffer(
                      this.paintTransitionVertexArray,
                      nf.members,
                      i,
                    )));
              }
              destroy() {
                (this.paintVertexBuffer && this.paintVertexBuffer.destroy(),
                  this.paintTransitionVertexBuffer &&
                    this.paintTransitionVertexBuffer.destroy());
              }
            }
            class kl {
              constructor(e, i, o = () => !0) {
                ((this.binders = {}), (this._buffers = []), (this.context = i));
                const a = [];
                for (const u in e.paint._values) {
                  const d = e.paint.get(u);
                  if (
                    u.endsWith("-use-theme") ||
                    !o(u) ||
                    !(d instanceof Sl && Dc(d.property.specification))
                  )
                    continue;
                  const _ = s(u, e.type),
                    v = d.value,
                    b = d.property.specification.type,
                    E = !!d.property.useIntegerZoom,
                    A = u === "line-dasharray" || u.endsWith("pattern"),
                    M = e.paint.get(`${u}-use-theme`),
                    R =
                      (u === "line-dasharray" &&
                        e.layout.get("line-cap").value.kind !== "constant") ||
                      (M && M.value.kind !== "constant");
                  if (v.kind !== "constant" || R)
                    if (v.kind === "source" || R || A) {
                      const k = g(u, b, "source");
                      ((this.binders[u] = A
                        ? new bs(v, _, b, k, e.id)
                        : new go(v, _, b, k)),
                        a.push(`/a_${u}`));
                    } else {
                      const k = g(u, b, "composite");
                      ((this.binders[u] = new Rs(v, _, b, E, i, k)),
                        a.push(`/z_${u}`));
                    }
                  else
                    ((this.binders[u] = A
                      ? new zl(v.value, _)
                      : new Kc(v.value, _, b, i)),
                      a.push(`/u_${u}`));
                  M && (this.binders[u].lutExpression = M.value);
                }
                this.cacheKey = a.sort().join("");
              }
              getMaxValue(e) {
                const i = this.binders[e];
                return i instanceof go || i instanceof Rs ? i.maxValue : 0;
              }
              populatePaintArrays(e, i, o, a, u, d, _, v) {
                for (const b in this.binders) {
                  const E = this.binders[b];
                  ((E.context = this.context),
                    (E instanceof go || E instanceof Rs || E instanceof bs) &&
                      E.populatePaintArray(e, i, o, a, u, d, _, v));
                }
              }
              setConstantPatternPositions(e, i) {
                for (const o in this.binders) {
                  const a = this.binders[o];
                  a instanceof zl && a.setConstantPatternPositions(e, i);
                }
              }
              getPatternTransitionVertexBuffer(e) {
                const i = this.binders[e];
                return i instanceof bs ? i.paintTransitionVertexBuffer : null;
              }
              updatePaintArrays(e, i, o, a, u, d, _, v, b, E) {
                let A = !1;
                const M = Object.keys(e),
                  R = M.length !== 0 && !v,
                  k = R ? M : i.uniqueIds;
                this.context.lut = u.lut;
                for (const N in this.binders) {
                  const j = this.binders[N];
                  if (
                    ((j.context = this.context),
                    (j instanceof go || j instanceof Rs || j instanceof bs) &&
                      j.expression &&
                      j.expression.kind &&
                      j.expression.kind !== "constant" &&
                      (j.expression.isStateDependent === !0 ||
                        j.expression.isLightConstant === !1))
                  ) {
                    const H = u.paint.get(N);
                    j.expression = H.value;
                    for (const J of k) {
                      const Q = e[J.toString()];
                      i.eachPosition(J, (V, X, ee) => {
                        const re = a.feature(V);
                        j.updatePaintArray(X, ee, re, Q, d, _, b, E);
                      });
                    }
                    if (!R)
                      for (const J of o.uniqueIds) {
                        const Q = e[J.toString()];
                        o.eachPosition(J, (V, X, ee) => {
                          const re = a.feature(V);
                          j.updatePaintArray(X, ee, re, Q, d, _, b, E);
                        });
                      }
                    A = !0;
                  }
                }
                return A;
              }
              defines() {
                const e = [];
                for (const i in this.binders) {
                  const o = this.binders[i];
                  (o instanceof Kc || o instanceof zl) &&
                    e.push(
                      ...o.uniformNames.map((a) => `#define HAS_UNIFORM_${a}`),
                    );
                }
                return e;
              }
              getBinderAttributes() {
                const e = [];
                for (const i in this.binders) {
                  const o = this.binders[i];
                  if (o instanceof go || o instanceof Rs || o instanceof bs)
                    for (let a = 0; a < o.paintVertexAttributes.length; a++)
                      e.push(o.paintVertexAttributes[a].name);
                  if (o instanceof bs)
                    for (let a = 0; a < nf.members.length; a++)
                      e.push(nf.members[a].name);
                }
                return e;
              }
              getBinderUniforms() {
                const e = [];
                for (const i in this.binders) {
                  const o = this.binders[i];
                  if (o instanceof Kc || o instanceof zl || o instanceof Rs)
                    for (const a of o.uniformNames) e.push(a);
                }
                return e;
              }
              getPaintVertexBuffers() {
                return this._buffers;
              }
              getUniforms(e) {
                const i = [];
                for (const o in this.binders) {
                  const a = this.binders[o];
                  if (a instanceof Kc || a instanceof zl || a instanceof Rs)
                    for (const u of a.uniformNames)
                      i.push({
                        name: u,
                        property: o,
                        binding: a.getBinding(e, u),
                      });
                }
                return i;
              }
              setUniforms(e, i, o, a, u) {
                for (const { name: d, property: _, binding: v } of o)
                  this.binders[_].setUniform(e, v, u, a.get(_), d);
              }
              updatePaintBuffers() {
                this._buffers = [];
                for (const e in this.binders) {
                  const i = this.binders[e];
                  ((i instanceof go || i instanceof Rs || i instanceof bs) &&
                    i.paintVertexBuffer &&
                    this._buffers.push(i.paintVertexBuffer),
                    i instanceof bs &&
                      i.paintTransitionVertexBuffer &&
                      this._buffers.push(i.paintTransitionVertexBuffer));
                }
              }
              upload(e) {
                for (const i in this.binders) {
                  const o = this.binders[i];
                  (o instanceof go || o instanceof Rs || o instanceof bs) &&
                    o.upload(e);
                }
                this.updatePaintBuffers();
              }
              destroy() {
                for (const e in this.binders) {
                  const i = this.binders[e];
                  (i instanceof go || i instanceof Rs || i instanceof bs) &&
                    i.destroy();
                }
              }
            }
            class c {
              constructor(e, i, o = () => !0) {
                this.programConfigurations = {};
                for (const a of e)
                  this.programConfigurations[a.id] = new kl(a, i, o);
                ((this.needsUpload = !1),
                  (this._featureMap = new qc()),
                  (this._featureMapWithoutIds = new qc()),
                  (this._bufferOffset = 0),
                  (this._idlessCounter = 0));
              }
              populatePaintArrays(e, i, o, a, u, d, _, v, b) {
                for (const E in this.programConfigurations)
                  this.programConfigurations[E].populatePaintArrays(
                    e,
                    i,
                    a,
                    u,
                    d,
                    _,
                    v,
                    b,
                  );
                (i.id !== void 0
                  ? this._featureMap.add(i.id, o, this._bufferOffset, e)
                  : (this._featureMapWithoutIds.add(
                      this._idlessCounter,
                      o,
                      this._bufferOffset,
                      e,
                    ),
                    (this._idlessCounter += 1)),
                  (this._bufferOffset = e),
                  (this.needsUpload = !0));
              }
              updatePaintArrays(e, i, o, a, u, d, _, v) {
                for (const b of o)
                  this.needsUpload =
                    this.programConfigurations[b.id].updatePaintArrays(
                      e,
                      this._featureMap,
                      this._featureMapWithoutIds,
                      i,
                      b,
                      a,
                      u,
                      d,
                      _ || 0,
                      v,
                    ) || this.needsUpload;
              }
              get(e) {
                return this.programConfigurations[e];
              }
              upload(e) {
                if (this.needsUpload) {
                  for (const i in this.programConfigurations)
                    this.programConfigurations[i].upload(e);
                  this.needsUpload = !1;
                }
              }
              destroy() {
                for (const e in this.programConfigurations)
                  this.programConfigurations[e].destroy();
              }
            }
            const t = {
              "text-opacity": ["opacity"],
              "icon-opacity": ["opacity"],
              "text-occlusion-opacity": ["occlusion_opacity"],
              "icon-occlusion-opacity": ["occlusion_opacity"],
              "text-color": ["fill_color"],
              "icon-color": ["fill_color"],
              "text-emissive-strength": ["emissive_strength"],
              "icon-emissive-strength": ["emissive_strength"],
              "text-halo-color": ["halo_color"],
              "icon-halo-color": ["halo_color"],
              "text-halo-blur": ["halo_blur"],
              "icon-halo-blur": ["halo_blur"],
              "text-halo-width": ["halo_width"],
              "icon-halo-width": ["halo_width"],
              "symbol-z-offset": ["z_offset"],
              "line-gap-width": ["gapwidth"],
              "line-pattern": ["pattern", "pixel_ratio", "pattern_b"],
              "fill-pattern": ["pattern", "pixel_ratio", "pattern_b"],
              "fill-extrusion-pattern": ["pattern", "pixel_ratio", "pattern_b"],
              "line-dasharray": ["dash"],
              "fill-bridge-guard-rail-color": ["structure_color"],
              "fill-tunnel-structure-color": ["structure_color"],
            };
            function s(n, e) {
              return t[n] || [n.replace(`${e}-`, "").replace(/-/g, "_")];
            }
            const h = {
                "line-pattern": { source: $o, composite: $o },
                "fill-pattern": { source: $o, composite: $o },
                "fill-extrusion-pattern": { source: $o, composite: $o },
                "line-dasharray": { source: Uc, composite: Uc },
              },
              p = {
                color: { source: ka, composite: ur },
                number: { source: Go, composite: ka },
              };
            function g(n, e, i) {
              const o = h[n];
              return (o && o[i]) || p[e][i];
            }
            (Tt(Kc, "ConstantBinder"),
              Tt(zl, "PatternConstantBinder"),
              Tt(go, "SourceExpressionBinder"),
              Tt(bs, "PatternCompositeBinder"),
              Tt(Rs, "CompositeExpressionBinder"),
              Tt(kl, "ProgramConfiguration", { omit: ["_buffers"] }),
              Tt(c, "ProgramConfigurationSet"));
            const x = mt / Math.PI / 2,
              w = 5,
              S = 6,
              C = 16383,
              D = 64,
              L = [D, 32, 16],
              z = -x,
              O = x;
            function G(n, e, i, o = x) {
              return (
                (i = Mi(i)),
                [n * Math.sin(i) * o, -e * o, n * Math.cos(i) * o]
              );
            }
            function U(n, e, i) {
              return G(Math.cos(Mi(n)), Math.sin(Mi(n)), e, i);
            }
            const $ = 63710088e-1,
              Z = 2 * Math.PI * $;
            class Y {
              constructor(e, i) {
                if (isNaN(e) || isNaN(i))
                  throw new Error(`Invalid LngLat object: (${e}, ${i})`);
                if (
                  ((this.lng = +e),
                  (this.lat = +i),
                  this.lat > 90 || this.lat < -90)
                )
                  throw new Error(
                    "Invalid LngLat latitude value: must be between -90 and 90",
                  );
              }
              wrap() {
                return new Y(ke(this.lng, -180, 180), this.lat);
              }
              toArray() {
                return [this.lng, this.lat];
              }
              toString() {
                return `LngLat(${this.lng}, ${this.lat})`;
              }
              distanceTo(e) {
                const i = Math.PI / 180,
                  o = this.lat * i,
                  a = e.lat * i,
                  u =
                    Math.sin(o) * Math.sin(a) +
                    Math.cos(o) *
                      Math.cos(a) *
                      Math.cos((e.lng - this.lng) * i);
                return $ * Math.acos(Math.min(u, 1));
              }
              toBounds(e = 0) {
                const i = (360 * e) / 40075017,
                  o = i / Math.cos((Math.PI / 180) * this.lat);
                return new ie(
                  { lng: this.lng - o, lat: this.lat - i },
                  { lng: this.lng + o, lat: this.lat + i },
                );
              }
              toEcef(e) {
                return U(this.lat, this.lng, x + (e * x) / $);
              }
              static convert(e) {
                if (e instanceof Y) return e;
                if (Array.isArray(e) && (e.length === 2 || e.length === 3))
                  return new Y(Number(e[0]), Number(e[1]));
                if (!Array.isArray(e) && typeof e == "object" && e !== null)
                  return new Y(
                    Number("lng" in e ? e.lng : e.lon),
                    Number(e.lat),
                  );
                throw new Error(
                  "`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]",
                );
              }
            }
            class ie {
              constructor(e, i) {
                if (e)
                  if (i) this.setSouthWest(e).setNorthEast(i);
                  else if (e.length === 4) {
                    const o = e;
                    this.setSouthWest([o[0], o[1]]).setNorthEast([o[2], o[3]]);
                  } else {
                    const o = e;
                    this.setSouthWest(o[0]).setNorthEast(o[1]);
                  }
              }
              setNorthEast(e) {
                return (
                  (this._ne =
                    e instanceof Y ? new Y(e.lng, e.lat) : Y.convert(e)),
                  this
                );
              }
              setSouthWest(e) {
                return (
                  (this._sw =
                    e instanceof Y ? new Y(e.lng, e.lat) : Y.convert(e)),
                  this
                );
              }
              extend(e) {
                const i = this._sw,
                  o = this._ne;
                let a, u;
                if (e instanceof Y) ((a = e), (u = e));
                else {
                  if (!(e instanceof ie))
                    return Array.isArray(e)
                      ? e.length === 4 || e.every(Array.isArray)
                        ? this.extend(ie.convert(e))
                        : this.extend(Y.convert(e))
                      : typeof e == "object" &&
                          e !== null &&
                          e.hasOwnProperty("lat") &&
                          (e.hasOwnProperty("lon") || e.hasOwnProperty("lng"))
                        ? this.extend(Y.convert(e))
                        : this;
                  if (((a = e._sw), (u = e._ne), !a || !u)) return this;
                }
                return (
                  i || o
                    ? ((i.lng = Math.min(a.lng, i.lng)),
                      (i.lat = Math.min(a.lat, i.lat)),
                      (o.lng = Math.max(u.lng, o.lng)),
                      (o.lat = Math.max(u.lat, o.lat)))
                    : ((this._sw = new Y(a.lng, a.lat)),
                      (this._ne = new Y(u.lng, u.lat))),
                  this
                );
              }
              getCenter() {
                return new Y(
                  (this._sw.lng + this._ne.lng) / 2,
                  (this._sw.lat + this._ne.lat) / 2,
                );
              }
              getSouthWest() {
                return this._sw;
              }
              getNorthEast() {
                return this._ne;
              }
              getNorthWest() {
                return new Y(this.getWest(), this.getNorth());
              }
              getSouthEast() {
                return new Y(this.getEast(), this.getSouth());
              }
              getWest() {
                return this._sw.lng;
              }
              getSouth() {
                return this._sw.lat;
              }
              getEast() {
                return this._ne.lng;
              }
              getNorth() {
                return this._ne.lat;
              }
              toArray() {
                return [this._sw.toArray(), this._ne.toArray()];
              }
              toString() {
                return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
              }
              isEmpty() {
                return !(this._sw && this._ne);
              }
              contains(e) {
                const { lng: i, lat: o } = Y.convert(e);
                let a = this._sw.lng <= i && i <= this._ne.lng;
                return (
                  this._sw.lng > this._ne.lng &&
                    (a = this._sw.lng >= i && i >= this._ne.lng),
                  this._sw.lat <= o && o <= this._ne.lat && a
                );
              }
              static convert(e) {
                if (e) return e instanceof ie ? e : new ie(e);
              }
            }
            const ae = 0,
              pe = 25.5;
            function ue(n) {
              return Z * Math.cos((n * Math.PI) / 180);
            }
            function ce(n) {
              return (180 + n) / 360;
            }
            function le(n) {
              return (
                (180 -
                  (180 / Math.PI) *
                    Math.log(Math.tan(Math.PI / 4 + (n * Math.PI) / 360))) /
                360
              );
            }
            function me(n, e) {
              return n / ue(e);
            }
            function _e(n) {
              return 360 * n - 180;
            }
            function De(n) {
              return (
                (360 / Math.PI) *
                  Math.atan(Math.exp(((180 - 360 * n) * Math.PI) / 180)) -
                90
              );
            }
            function ze(n, e) {
              return n * ue(De(e));
            }
            const He = 85.051129;
            function We(n) {
              return Math.cos(Mi(he(n, -85.051129, He)));
            }
            function et(n, e) {
              const i = he(e, ae, pe),
                o = Math.pow(2, i);
              return (We(n) * Z) / (512 * o);
            }
            function Ce(n) {
              return 1 / Math.cos((n * Math.PI) / 180);
            }
            function Ve(n, e = 0) {
              const i = Math.exp(
                Math.PI * (1 - ((n.y + e / mt) / (1 << n.z)) * 2),
              );
              return (80150034 * i) / (i * i + 1) / mt / (1 << n.z);
            }
            class Te {
              constructor(e, i, o = 0) {
                ((this.x = +e), (this.y = +i), (this.z = +o));
              }
              static fromLngLat(e, i = 0) {
                const o = Y.convert(e);
                return new Te(ce(o.lng), le(o.lat), me(i, o.lat));
              }
              toLngLat() {
                return new Y(_e(this.x), De(this.y));
              }
              toAltitude() {
                return ze(this.z, this.y);
              }
              meterInMercatorCoordinateUnits() {
                return (1 / Z) * Ce(De(this.y));
              }
            }
            function Ze(n, e, i, o, a, u, d, _, v) {
              const b = (e + o) / 2,
                E = (i + a) / 2,
                A = new ft(b, E);
              (_(A),
                (function (M, R, k, N, j, H) {
                  const J = k - j,
                    Q = N - H;
                  return Math.abs((N - R) * J - (k - M) * Q) / Math.hypot(J, Q);
                })(A.x, A.y, u.x, u.y, d.x, d.y) >= v
                  ? (Ze(n, e, i, b, E, u, A, _, v),
                    Ze(n, b, E, o, a, A, d, _, v))
                  : n.push(d));
            }
            function Oe(n, e, i) {
              let o = n[0],
                a = o.x,
                u = o.y;
              e(o);
              const d = [o];
              for (let _ = 1; _ < n.length; _++) {
                const v = n[_],
                  { x: b, y: E } = v;
                (e(v),
                  Ze(d, a, u, b, E, o, v, e, i),
                  (a = b),
                  (u = E),
                  (o = v));
              }
              return d;
            }
            function Ke(n, e, i, o) {
              if (o(e, i)) {
                const a = e.add(i)._mult(0.5);
                (Ke(n, e, a, o), Ke(n, a, i, o));
              } else n.push(i);
            }
            function ht(n, e) {
              let i = n[0];
              const o = [i];
              for (let a = 1; a < n.length; a++) {
                const u = n[a];
                (Ke(o, i, u, e), (i = u));
              }
              return o;
            }
            const qe = Math.pow(2, 14) - 1,
              lt = -qe - 1;
            function St(n, e) {
              const i = Math.round(n.x * e),
                o = Math.round(n.y * e);
              return (
                (n.x = he(i, lt, qe)),
                (n.y = he(o, lt, qe)),
                (i < n.x || i > n.x + 1 || o < n.y || o > n.y + 1) &&
                  ri(
                    "Geometry exceeds allowed extent, reduce your vector tile buffer size",
                  ),
                n
              );
            }
            function Et(n, e, i) {
              const o = n.loadGeometry(),
                a = n.extent,
                u = mt / a;
              if (e && i && i.projection.isReprojectedInTileSpace) {
                const d = 1 << e.z,
                  { scale: _, x: v, y: b, projection: E } = i,
                  A = (M) => {
                    const R = _e((e.x + M.x / a) / d),
                      k = De((e.y + M.y / a) / d),
                      N = E.project(R, k);
                    ((M.x = (N.x * _ - v) * a), (M.y = (N.y * _ - b) * a));
                  };
                for (let M = 0; M < o.length; M++)
                  if (n.type !== 1) o[M] = Oe(o[M], A, 1);
                  else {
                    const R = [];
                    for (const k of o[M])
                      k.x < 0 ||
                        k.x >= a ||
                        k.y < 0 ||
                        k.y >= a ||
                        (A(k), R.push(k));
                    o[M] = R;
                  }
              }
              for (const d of o) for (const _ of d) St(_, u);
              return o;
            }
            function bt(n, e) {
              return {
                type: n.type,
                id: n.id,
                properties: n.properties,
                geometry: e ? Et(n) : [],
              };
            }
            var kt,
              Bt,
              Vt,
              Zt,
              si,
              Fi,
              nn,
              ji = {};
            function Hi() {
              if (Bt) return kt;
              Bt = 1;
              var n = ua();
              function e(a, u, d, _, v) {
                ((this.properties = {}),
                  (this.extent = d),
                  (this.type = 0),
                  (this._pbf = a),
                  (this._geometry = -1),
                  (this._keys = _),
                  (this._values = v),
                  a.readFields(i, this, u));
              }
              function i(a, u, d) {
                a == 1
                  ? (u.id = d.readVarint())
                  : a == 2
                    ? (function (_, v) {
                        for (var b = _.readVarint() + _.pos; _.pos < b; ) {
                          var E = v._keys[_.readVarint()],
                            A = v._values[_.readVarint()];
                          v.properties[E] = A;
                        }
                      })(d, u)
                    : a == 3
                      ? (u.type = d.readVarint())
                      : a == 4 && (u._geometry = d.pos);
              }
              function o(a) {
                for (
                  var u, d, _ = 0, v = 0, b = a.length, E = b - 1;
                  v < b;
                  E = v++
                )
                  _ += ((d = a[E]).x - (u = a[v]).x) * (u.y + d.y);
                return _;
              }
              return (
                (kt = e),
                (e.types = ["Unknown", "Point", "LineString", "Polygon"]),
                (e.prototype.loadGeometry = function () {
                  var a = this._pbf;
                  a.pos = this._geometry;
                  for (
                    var u,
                      d = a.readVarint() + a.pos,
                      _ = 1,
                      v = 0,
                      b = 0,
                      E = 0,
                      A = [];
                    a.pos < d;

                  ) {
                    if (v <= 0) {
                      var M = a.readVarint();
                      ((_ = 7 & M), (v = M >> 3));
                    }
                    if ((v--, _ === 1 || _ === 2))
                      ((b += a.readSVarint()),
                        (E += a.readSVarint()),
                        _ === 1 && (u && A.push(u), (u = [])),
                        u.push(new n(b, E)));
                    else {
                      if (_ !== 7) throw new Error("unknown command " + _);
                      u && u.push(u[0].clone());
                    }
                  }
                  return (u && A.push(u), A);
                }),
                (e.prototype.bbox = function () {
                  var a = this._pbf;
                  a.pos = this._geometry;
                  for (
                    var u = a.readVarint() + a.pos,
                      d = 1,
                      _ = 0,
                      v = 0,
                      b = 0,
                      E = 1 / 0,
                      A = -1 / 0,
                      M = 1 / 0,
                      R = -1 / 0;
                    a.pos < u;

                  ) {
                    if (_ <= 0) {
                      var k = a.readVarint();
                      ((d = 7 & k), (_ = k >> 3));
                    }
                    if ((_--, d === 1 || d === 2))
                      ((v += a.readSVarint()) < E && (E = v),
                        v > A && (A = v),
                        (b += a.readSVarint()) < M && (M = b),
                        b > R && (R = b));
                    else if (d !== 7) throw new Error("unknown command " + d);
                  }
                  return [E, M, A, R];
                }),
                (e.prototype.toGeoJSON = function (a, u, d) {
                  var _,
                    v,
                    b = this.extent * Math.pow(2, d),
                    E = this.extent * a,
                    A = this.extent * u,
                    M = this.loadGeometry(),
                    R = e.types[this.type];
                  function k(H) {
                    for (var J = 0; J < H.length; J++) {
                      var Q = H[J];
                      H[J] = [
                        (360 * (Q.x + E)) / b - 180,
                        (360 / Math.PI) *
                          Math.atan(
                            Math.exp(
                              ((180 - (360 * (Q.y + A)) / b) * Math.PI) / 180,
                            ),
                          ) -
                          90,
                      ];
                    }
                  }
                  switch (this.type) {
                    case 1:
                      var N = [];
                      for (_ = 0; _ < M.length; _++) N[_] = M[_][0];
                      k((M = N));
                      break;
                    case 2:
                      for (_ = 0; _ < M.length; _++) k(M[_]);
                      break;
                    case 3:
                      for (
                        M = (function (H) {
                          var J = H.length;
                          if (J <= 1) return [H];
                          for (var Q, V, X = [], ee = 0; ee < J; ee++) {
                            var re = o(H[ee]);
                            re !== 0 &&
                              (V === void 0 && (V = re < 0),
                              V === re < 0
                                ? (Q && X.push(Q), (Q = [H[ee]]))
                                : Q.push(H[ee]));
                          }
                          return (Q && X.push(Q), X);
                        })(M),
                          _ = 0;
                        _ < M.length;
                        _++
                      )
                        for (v = 0; v < M[_].length; v++) k(M[_][v]);
                  }
                  M.length === 1 ? (M = M[0]) : (R = "Multi" + R);
                  var j = {
                    type: "Feature",
                    geometry: { type: R, coordinates: M },
                    properties: this.properties,
                  };
                  return ("id" in this && (j.id = this.id), j);
                }),
                kt
              );
            }
            function Fn() {
              if (Zt) return Vt;
              Zt = 1;
              var n = Hi();
              function e(o, a) {
                ((this.version = 1),
                  (this.name = null),
                  (this.extent = 4096),
                  (this.length = 0),
                  (this._pbf = o),
                  (this._keys = []),
                  (this._values = []),
                  (this._features = []),
                  o.readFields(i, this, a),
                  (this.length = this._features.length));
              }
              function i(o, a, u) {
                o === 15
                  ? (a.version = u.readVarint())
                  : o === 1
                    ? (a.name = u.readString())
                    : o === 5
                      ? (a.extent = u.readVarint())
                      : o === 2
                        ? a._features.push(u.pos)
                        : o === 3
                          ? a._keys.push(u.readString())
                          : o === 4 &&
                            a._values.push(
                              (function (d) {
                                for (
                                  var _ = null, v = d.readVarint() + d.pos;
                                  d.pos < v;

                                ) {
                                  var b = d.readVarint() >> 3;
                                  _ =
                                    b === 1
                                      ? d.readString()
                                      : b === 2
                                        ? d.readFloat()
                                        : b === 3
                                          ? d.readDouble()
                                          : b === 4
                                            ? d.readVarint64()
                                            : b === 5
                                              ? d.readVarint()
                                              : b === 6
                                                ? d.readSVarint()
                                                : b === 7
                                                  ? d.readBoolean()
                                                  : null;
                                }
                                return _;
                              })(u),
                            );
              }
              return (
                (Vt = e),
                (e.prototype.feature = function (o) {
                  if (o < 0 || o >= this._features.length)
                    throw new Error("feature index out of bounds");
                  this._pbf.pos = this._features[o];
                  var a = this._pbf.readVarint() + this._pbf.pos;
                  return new n(
                    this._pbf,
                    a,
                    this.extent,
                    this._keys,
                    this._values,
                  );
                }),
                Vt
              );
            }
            function ti() {
              return (
                nn ||
                  ((nn = 1),
                  (ji.VectorTile = (function () {
                    if (Fi) return si;
                    Fi = 1;
                    var n = Fn();
                    function e(i, o, a) {
                      if (i === 3) {
                        var u = new n(a, a.readVarint() + a.pos);
                        u.length && (o[u.name] = u);
                      }
                    }
                    return (
                      (si = function (i, o) {
                        this.layers = i.readFields(e, {}, o);
                      }),
                      si
                    );
                  })()),
                  (ji.VectorTileFeature = Hi()),
                  (ji.VectorTileLayer = Fn())),
                ji
              );
            }
            var li = ti();
            const gi = "3d_elevation_id",
              cn = "level";
            class qn {
              constructor() {
                this._valid = !1;
              }
              reset(e) {
                return (
                  (this.feature = e),
                  (this._valid = !0),
                  (this._geometry = e.loadGeometry()),
                  (this._geometry.length !== 0 &&
                    this._geometry[0].length !== 0) ||
                    (this._valid = !1),
                  this
                );
              }
              geometry(e, i) {
                return (this._valid && e(i(this._geometry)), this);
              }
              require(e, i, o) {
                return this.get(e, !0, i, o);
              }
              optional(e, i, o) {
                return this.get(e, !1, i, o);
              }
              success() {
                return this._valid;
              }
              get(e, i, o, a) {
                const u = this.feature.properties.hasOwnProperty(e)
                  ? +this.feature.properties[e]
                  : void 0;
                return (
                  this._valid && u !== void 0 && !Number.isNaN(u)
                    ? o(a ? a(u) : u)
                    : i && (this._valid = !1),
                  this
                );
              }
            }
            class rn {
              constructor(e, i) {
                ((this.featureFunc = e), (this.vertexFunc = i));
              }
              parseFeature(e, i, o) {
                return this.featureFunc(e, i, o);
              }
              parseVertex(e, i, o) {
                return this.vertexFunc(e, i, o);
              }
            }
            const Di = new rn(
                (n, e, i) =>
                  n
                    .reset(e)
                    .require(gi, (o) => {
                      i.id = o;
                    })
                    .optional(
                      "fixed_height_relative",
                      (o) => {
                        i.constantHeight = o;
                      },
                      Ti.decodeRelativeHeight,
                    )
                    .geometry((o) => {
                      i.bounds = o;
                    }, dd)
                    .success(),
                (n, e, i) =>
                  n
                    .reset(e)
                    .require(gi, (o) => {
                      i.id = o;
                    })
                    .require("elevation_idx", (o) => {
                      i.idx = o;
                    })
                    .require("extent", (o) => {
                      i.extent = o;
                    })
                    .require(
                      "height_relative",
                      (o) => {
                        i.height = o;
                      },
                      Ti.decodeRelativeHeight,
                    )
                    .geometry((o) => {
                      i.position = o;
                    }, Ti.getPoint)
                    .success(),
              ),
              Pn = new rn(
                (n, e, i) =>
                  n
                    .reset(e)
                    .require(gi, (o) => {
                      i.id = o;
                    })
                    .optional(
                      "fixed_height",
                      (o) => {
                        i.constantHeight = o;
                      },
                      Ti.decodeMetricHeight,
                    )
                    .geometry((o) => {
                      i.bounds = o;
                    }, dd)
                    .success(),
                (n, e, i) =>
                  n
                    .reset(e)
                    .require(gi, (o) => {
                      i.id = o;
                    })
                    .require("elevation_idx", (o) => {
                      i.idx = o;
                    })
                    .require("extent", (o) => {
                      i.extent = o;
                    })
                    .require(
                      "height",
                      (o) => {
                        i.height = o;
                      },
                      Ti.decodeMetricHeight,
                    )
                    .geometry((o) => {
                      i.position = o;
                    }, Ti.getPoint)
                    .success(),
              );
            class Ti {
              static getPoint(e) {
                return ms(e[0][0].x, e[0][0].y);
              }
              static decodeRelativeHeight(e) {
                return 1e-4 * e * 5;
              }
              static decodeMetricHeight(e) {
                return 1e-4 * e;
              }
              static parse(e) {
                const i = [],
                  o = [],
                  a = e.length,
                  u = new qn();
                for (let _ = 0; _ < a; _++) {
                  const v = e.feature(_),
                    b = v.properties.hasOwnProperty("version")
                      ? String(v.properties.version)
                      : void 0,
                    E = (d = b) ? (d === "1.0.1" ? Pn : void 0) : Di;
                  if (E === void 0) {
                    ri(
                      `Unknown elevation feature version number ${b || "(unknown)"}`,
                    );
                    continue;
                  }
                  const A = v.properties.hasOwnProperty("type")
                    ? v.properties.type
                    : void 0;
                  if (A) {
                    if (
                      li.VectorTileFeature.types[v.type] === "Point" &&
                      A === "curve_point"
                    ) {
                      const M = {};
                      E.parseVertex(u, v, M) && i.push(M);
                    } else if (
                      li.VectorTileFeature.types[v.type] === "Polygon" &&
                      A === "curve_meta"
                    ) {
                      const M = {};
                      E.parseFeature(u, v, M) && o.push(M);
                    }
                  }
                }
                var d;
                return { vertices: i, features: o };
              }
            }
            class Un {
              constructor(e, i) {
                ((this.pos = e), (this.dir = i));
              }
              intersectsPlane(e, i, o) {
                const a = bn(i, this.dir);
                if (Math.abs(a) < 1e-6) return !1;
                const u =
                  ((e[0] - this.pos[0]) * i[0] + (e[1] - this.pos[1]) * i[1]) /
                  a;
                return (
                  (o[0] = this.pos[0] + this.dir[0] * u),
                  (o[1] = this.pos[1] + this.dir[1] * u),
                  !0
                );
              }
            }
            class hn {
              constructor(e, i) {
                ((this.pos = e), (this.dir = i));
              }
              intersectsPlane(e, i, o) {
                const a = wn(i, this.dir);
                if (Math.abs(a) < 1e-6) return !1;
                const u =
                  ((e[0] - this.pos[0]) * i[0] +
                    (e[1] - this.pos[1]) * i[1] +
                    (e[2] - this.pos[2]) * i[2]) /
                  a;
                return (
                  (o[0] = this.pos[0] + this.dir[0] * u),
                  (o[1] = this.pos[1] + this.dir[1] * u),
                  (o[2] = this.pos[2] + this.dir[2] * u),
                  !0
                );
              }
              closestPointOnSphere(e, i, o) {
                if (
                  (function (R, k) {
                    var N = R[0],
                      j = R[1],
                      H = R[2],
                      J = k[0],
                      Q = k[1],
                      V = k[2];
                    return (
                      Math.abs(N - J) <=
                        F * Math.max(1, Math.abs(N), Math.abs(J)) &&
                      Math.abs(j - Q) <=
                        F * Math.max(1, Math.abs(j), Math.abs(Q)) &&
                      Math.abs(H - V) <=
                        F * Math.max(1, Math.abs(H), Math.abs(V))
                    );
                  })(this.pos, e) ||
                  i === 0
                )
                  return ((o[0] = o[1] = o[2] = 0), !1);
                const [a, u, d] = this.dir,
                  _ = this.pos[0] - e[0],
                  v = this.pos[1] - e[1],
                  b = this.pos[2] - e[2],
                  E = a * a + u * u + d * d,
                  A = 2 * (_ * a + v * u + b * d),
                  M = A * A - 4 * E * (_ * _ + v * v + b * b - i * i);
                if (M < 0) {
                  const R = Math.max(-A / 2, 0),
                    k = _ + a * R,
                    N = v + u * R,
                    j = b + d * R,
                    H = Math.hypot(k, N, j);
                  return (
                    (o[0] = (k * i) / H),
                    (o[1] = (N * i) / H),
                    (o[2] = (j * i) / H),
                    !1
                  );
                }
                {
                  const R = (-A - Math.sqrt(M)) / (2 * E);
                  if (R < 0) {
                    const k = Math.hypot(_, v, b);
                    return (
                      (o[0] = (_ * i) / k),
                      (o[1] = (v * i) / k),
                      (o[2] = (b * i) / k),
                      !1
                    );
                  }
                  return (
                    (o[0] = _ + a * R),
                    (o[1] = v + u * R),
                    (o[2] = b + d * R),
                    !0
                  );
                }
              }
            }
            class Ji {
              constructor(e, i, o, a, u) {
                ((this.TL = e),
                  (this.TR = i),
                  (this.BR = o),
                  (this.BL = a),
                  (this.horizon = u));
              }
              static fromInvProjectionMatrix(e, i, o) {
                const a = [-1, 1, 1],
                  u = [1, 1, 1],
                  d = [1, -1, 1],
                  _ = [-1, -1, 1],
                  v = mn(a, a, e),
                  b = mn(u, u, e),
                  E = mn(d, d, e),
                  A = mn(_, _, e);
                return new Ji(v, b, E, A, i / o);
              }
            }
            function un(n, e, i) {
              let o = 1 / 0,
                a = -1 / 0;
              const u = [];
              for (const d of n) {
                Gn(u, d, e);
                const _ = wn(u, i);
                ((o = Math.min(o, _)), (a = Math.max(a, _)));
              }
              return [o, a];
            }
            function ki(n, e) {
              let i = !0;
              for (let o = 0; o < n.planes.length; o++) {
                const a = n.planes[o];
                let u = 0;
                for (let d = 0; d < e.length; d++) u += wn(a, e[d]) + a[3] >= 0;
                if (u === 0) return 0;
                u !== e.length && (i = !1);
              }
              return i ? 2 : 1;
            }
            function zn(n, e) {
              for (const i of n.projections) {
                const o = un(e, n.points[0], i.axis);
                if (i.projection[1] < o[0] || i.projection[0] > o[1]) return 0;
              }
              return 1;
            }
            function fr(n, e) {
              let i = 0;
              const o = [0, 0, 0, 0];
              for (let d = 0; d < n.length; d++)
                ((o[0] = n[d][0]),
                  (o[1] = n[d][1]),
                  (o[2] = n[d][2]),
                  (o[3] = 1),
                  (a = o)[0] * (u = e)[0] +
                    a[1] * u[1] +
                    a[2] * u[2] +
                    a[3] * u[3] >=
                    0 && i++);
              var a, u;
              return i;
            }
            class xn {
              constructor(e, i) {
                ((this.points = e || new Array(8).fill([0, 0, 0])),
                  (this.planes = i || new Array(6).fill([0, 0, 0, 0])),
                  (this.bounds = Ci.fromPoints(this.points)),
                  (this.projections = []),
                  (this.frustumEdges = [
                    Gn([], this.points[2], this.points[3]),
                    Gn([], this.points[0], this.points[3]),
                    Gn([], this.points[4], this.points[0]),
                    Gn([], this.points[5], this.points[1]),
                    Gn([], this.points[6], this.points[2]),
                    Gn([], this.points[7], this.points[3]),
                  ]));
                for (const o of this.frustumEdges) {
                  const a = [0, -o[2], o[1]],
                    u = [o[2], 0, -o[0]];
                  (this.projections.push({
                    axis: a,
                    projection: un(this.points, this.points[0], a),
                  }),
                    this.projections.push({
                      axis: u,
                      projection: un(this.points, this.points[0], u),
                    }));
                }
              }
              static fromInvProjectionMatrix(e, i, o, a) {
                const u = Math.pow(2, o),
                  d = [
                    [-1, 1, -1, 1],
                    [1, 1, -1, 1],
                    [1, -1, -1, 1],
                    [-1, -1, -1, 1],
                    [-1, 1, 1, 1],
                    [1, 1, 1, 1],
                    [1, -1, 1, 1],
                    [-1, -1, 1, 1],
                  ].map((b) => {
                    const E = Cr([], b, e),
                      A = (1 / E[3] / i) * u;
                    return (
                      ((M = E)[0] =
                        (R = E)[0] * (k = [A, A, a ? 1 / E[3] : A, A])[0]),
                      (M[1] = R[1] * k[1]),
                      (M[2] = R[2] * k[2]),
                      (M[3] = R[3] * k[3]),
                      M
                    );
                    var M, R, k;
                  }),
                  _ = [
                    [0, 1, 2],
                    [6, 5, 4],
                    [0, 3, 7],
                    [2, 1, 5],
                    [3, 2, 6],
                    [0, 4, 5],
                  ].map((b) => {
                    const E = tn(
                        [],
                        nr(
                          [],
                          Gn([], d[b[0]], d[b[1]]),
                          Gn([], d[b[2]], d[b[1]]),
                        ),
                      ),
                      A = -wn(E, d[b[1]]);
                    return E.concat(A);
                  }),
                  v = [];
                for (let b = 0; b < d.length; b++)
                  v.push([d[b][0], d[b][1], d[b][2]]);
                return new xn(v, _);
              }
              intersectsPrecise(e, i, o) {
                for (let a = 0; a < i.length; a++) if (!fr(e, i[a])) return 0;
                for (let a = 0; a < this.planes.length; a++)
                  if (!fr(e, this.planes[a])) return 0;
                for (const a of o)
                  for (const u of this.frustumEdges) {
                    const d = nr([], a, u),
                      _ = Ri(d);
                    if (_ === 0) continue;
                    Vi(d, d, 1 / _);
                    const v = un(this.points, this.points[0], d),
                      b = un(e, this.points[0], d);
                    if (v[0] > b[1] || b[0] > v[1]) return 0;
                  }
                return 1;
              }
              containsPoint(e) {
                for (const i of this.planes) {
                  const o = i[3];
                  if (wn([i[0], i[1], i[2]], e) + o < 0) return !1;
                }
                return !0;
              }
            }
            class Ci {
              static fromPoints(e) {
                const i = [1 / 0, 1 / 0, 1 / 0],
                  o = [-1 / 0, -1 / 0, -1 / 0];
                for (const a of e) (ir(i, i, a), or(o, o, a));
                return new Ci(i, o);
              }
              static fromTileIdAndHeight(e, i, o) {
                const a = 1 << e.canonical.z,
                  u = e.canonical.x,
                  d = e.canonical.y;
                return new Ci([u / a, d / a, i], [(u + 1) / a, (d + 1) / a, o]);
              }
              static applyTransform(e, i) {
                const o = e.getCorners();
                for (let a = 0; a < o.length; ++a) mn(o[a], o[a], i);
                return Ci.fromPoints(o);
              }
              static applyTransformFast(e, i) {
                const o = [i[12], i[13], i[14]],
                  a = [...o];
                for (let u = 0; u < 3; u++)
                  for (let d = 0; d < 3; d++) {
                    const _ = i[4 * d + u],
                      v = _ * e.min[d],
                      b = _ * e.max[d];
                    ((o[u] += Math.min(v, b)), (a[u] += Math.max(v, b)));
                  }
                return new Ci(o, a);
              }
              static projectAabbCorners(e, i) {
                const o = e.getCorners();
                for (let a = 0; a < o.length; ++a) mn(o[a], o[a], i);
                return o;
              }
              constructor(e, i) {
                ((this.min = e),
                  (this.max = i),
                  (this.center = Vi([], ei([], this.min, this.max), 0.5)));
              }
              quadrant(e) {
                const i = [e % 2 == 0, e < 2],
                  o = pi(this.min),
                  a = pi(this.max);
                for (let u = 0; u < i.length; u++)
                  ((o[u] = i[u] ? this.min[u] : this.center[u]),
                    (a[u] = i[u] ? this.center[u] : this.max[u]));
                return ((a[2] = this.max[2]), new Ci(o, a));
              }
              distanceX(e) {
                return (
                  Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
                );
              }
              distanceY(e) {
                return (
                  Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
                );
              }
              distanceZ(e) {
                return (
                  Math.max(Math.min(this.max[2], e[2]), this.min[2]) - e[2]
                );
              }
              getCorners() {
                const e = this.min,
                  i = this.max;
                return [
                  [e[0], e[1], e[2]],
                  [i[0], e[1], e[2]],
                  [i[0], i[1], e[2]],
                  [e[0], i[1], e[2]],
                  [e[0], e[1], i[2]],
                  [i[0], e[1], i[2]],
                  [i[0], i[1], i[2]],
                  [e[0], i[1], i[2]],
                ];
              }
              intersects(e) {
                return this.intersectsAabb(e.bounds)
                  ? ki(e, this.getCorners())
                  : 0;
              }
              intersectsFlat(e) {
                return this.intersectsAabb(e.bounds)
                  ? ki(e, [
                      [this.min[0], this.min[1], 0],
                      [this.max[0], this.min[1], 0],
                      [this.max[0], this.max[1], 0],
                      [this.min[0], this.max[1], 0],
                    ])
                  : 0;
              }
              intersectsPrecise(e, i) {
                return i || this.intersects(e) ? zn(e, this.getCorners()) : 0;
              }
              intersectsPreciseFlat(e, i) {
                return i || this.intersectsFlat(e)
                  ? zn(e, [
                      [this.min[0], this.min[1], 0],
                      [this.max[0], this.min[1], 0],
                      [this.max[0], this.max[1], 0],
                      [this.min[0], this.max[1], 0],
                    ])
                  : 0;
              }
              intersectsAabb(e) {
                for (let i = 0; i < 3; ++i)
                  if (this.min[i] > e.max[i] || e.min[i] > this.max[i])
                    return !1;
                return !0;
              }
              intersectsAabbXY(e) {
                return !(
                  this.min[0] > e.max[0] ||
                  e.min[0] > this.max[0] ||
                  this.min[1] > e.max[1] ||
                  e.min[1] > this.max[1]
                );
              }
              encapsulate(e) {
                for (let i = 0; i < 3; i++)
                  ((this.min[i] = Math.min(this.min[i], e.min[i])),
                    (this.max[i] = Math.max(this.max[i], e.max[i])));
              }
              encapsulatePoint(e) {
                for (let i = 0; i < 3; i++)
                  ((this.min[i] = Math.min(this.min[i], e[i])),
                    (this.max[i] = Math.max(this.max[i], e[i])));
              }
              closestPoint(e) {
                return [
                  Math.max(Math.min(this.max[0], e[0]), this.min[0]),
                  Math.max(Math.min(this.max[1], e[1]), this.min[1]),
                  Math.max(Math.min(this.max[2], e[2]), this.min[2]),
                ];
              }
            }
            Tt(Ci, "Aabb");
            class es {
              constructor(e, i) {
                ((this.feature = e), (this.metersToTile = i), (this.index = 0));
              }
              get() {
                const e = this.feature.vertices[this.index],
                  i = this.feature.vertexProps[this.index].dir,
                  o = i[1],
                  a = -i[0],
                  u = (e.extent + 1) * this.metersToTile;
                return [
                  new ft(
                    Math.trunc(e.position[0] + o * u),
                    Math.trunc(e.position[1] + a * u),
                  ),
                  new ft(
                    Math.trunc(e.position[0] - o * u),
                    Math.trunc(e.position[1] - a * u),
                  ),
                ];
              }
              next() {
                this.index++;
              }
              valid() {
                return this.index < this.feature.vertices.length;
              }
            }
            class $r {
              constructor(e, i, o, a, u, d) {
                if (
                  ((this.vertices = new Array()),
                  (this.vertexProps = new Array()),
                  (this.edges = new Array()),
                  (this.edgeProps = new Array()),
                  (this.id = e),
                  (this.heightRange = { min: o, max: o }),
                  (this.safeArea = i),
                  (this.constantHeight = o),
                  this.constantHeight == null &&
                    (this.constantHeight != null || a.length !== 0))
                ) {
                  ((this.vertices = a),
                    (this.edges = u),
                    (this.edges = this.edges.filter((_) => {
                      return (
                        _.a < this.vertices.length &&
                        _.b < this.vertices.length &&
                        !(
                          (v = this.vertices[_.a].position)[0] ===
                            (b = this.vertices[_.b].position)[0] &&
                          v[1] === b[1]
                        )
                      );
                      var v, b;
                    })),
                    (this.heightRange = {
                      min: Number.POSITIVE_INFINITY,
                      max: Number.NEGATIVE_INFINITY,
                    }));
                  for (const _ of this.vertices)
                    (this.vertexProps.push({ dir: ms(0, 0) }),
                      (this.heightRange.min = Math.min(
                        this.heightRange.min,
                        _.height,
                      )),
                      (this.heightRange.max = Math.max(
                        this.heightRange.max,
                        _.height,
                      )));
                  for (const _ of this.edges) {
                    const v = this.vertices[_.a].position,
                      b = this.vertices[_.b].position,
                      E = Ao(wr(), b, v),
                      A = Mo(E),
                      M = ha(wr(), E, 1 / A);
                    this.edgeProps.push({ vec: E, dir: M, len: A });
                    const R = this.vertexProps[_.a].dir,
                      k = this.vertexProps[_.b].dir;
                    (ca(R, R, M), ca(k, k, M));
                  }
                  for (const _ of this.vertexProps)
                    (_.dir[0] === 0 && _.dir[1] === 0) || Qa(_.dir, _.dir);
                  this.tessellate(d);
                }
              }
              pointElevation(e) {
                if (this.constantHeight != null) return this.constantHeight;
                const i = this.getClosestEdge(e);
                if (i == null) return 0;
                const [o, a] = i;
                return Ht(
                  this.vertices[this.edges[o].a].height,
                  this.vertices[this.edges[o].b].height,
                  a,
                );
              }
              computeSlopeNormal(e, i) {
                const o = this.getClosestEdge(e);
                if (!o) return wi(0, 0, 1);
                const a = o[0],
                  u = this.edges[a],
                  d = this.edgeProps[a].vec,
                  _ = wi(
                    d[0],
                    d[1],
                    (this.vertices[u.b].height - this.vertices[u.a].height) * i,
                  ),
                  v = wi(_[1], -_[0], 0);
                nr(v, v, _);
                const b = Ri(v);
                return b > 0 ? Vi(v, v, 1 / b) : wi(0, 0, 1);
              }
              getSafeArea() {
                return this.safeArea;
              }
              isTunnel() {
                return this.heightRange.max <= -5;
              }
              getClosestEdge(e) {
                if (this.edges.length === 0) return;
                let i = 0,
                  o = Number.POSITIVE_INFINITY,
                  a = 0;
                const u = ms(e.x, e.y);
                for (let d = 0; d < this.edges.length; d++) {
                  const _ = this.edges[d],
                    v = this.edgeProps[d].dir,
                    b = new Un(u, this.edgeProps[d].dir),
                    E = this.vertices[_.a].position,
                    A = this.vertices[_.b].position,
                    M = wr(),
                    R = wr(),
                    k = b.intersectsPlane(E, this.vertexProps[_.a].dir, M),
                    N = b.intersectsPlane(A, this.vertexProps[_.b].dir, R);
                  if (!k || !N) continue;
                  const j = Ao(wr(), R, M),
                    H = Ao(wr(), u, M),
                    J = bn(j, j),
                    Q = J > 0 ? bn(H, j) / J : 0,
                    V = he(Q, 0, 1),
                    X = Math.abs((Q - V) * this.edgeProps[d].len),
                    ee = Ao(wr(), u, E),
                    re = X + Math.abs(bn(ee, ms(v[1], -v[0])));
                  re < o && ((i = d), (o = re), (a = V));
                }
                return [i, a];
              }
              tessellate(e) {
                for (let i = this.edges.length - 1; i >= 0; --i) {
                  const o = this.edges[i].a,
                    a = this.edges[i].b,
                    { position: u, height: d, extent: _ } = this.vertices[o],
                    { position: v, height: b, extent: E } = this.vertices[a],
                    A = this.vertexProps[o].dir,
                    M = this.vertexProps[a].dir,
                    R = wi(u[0] / e, u[1] / e, d),
                    k = wi(v[0] / e, v[1] / e, b),
                    N = wi(A[1], -A[0], 0);
                  Vi(N, N, _);
                  const j = wi(M[1], -M[0], 0);
                  if (
                    (Vi(j, j, E),
                    this.distSqLines(
                      wi(
                        R[0] + 0.5 * N[0],
                        R[1] + 0.5 * N[1],
                        R[2] + 0.5 * N[2],
                      ),
                      wi(
                        k[0] - 0.5 * j[0],
                        k[1] - 0.5 * j[1],
                        k[2] - 0.5 * j[2],
                      ),
                      wi(
                        R[0] - 0.5 * N[0],
                        R[1] - 0.5 * N[1],
                        R[2] - 0.5 * N[2],
                      ),
                      wi(
                        k[0] + 0.5 * j[0],
                        k[1] + 0.5 * j[1],
                        k[2] + 0.5 * j[2],
                      ),
                    ) <= 0.0025000000000000005)
                  )
                    continue;
                  const H = this.vertices.length,
                    J = ca(wr(), u, v);
                  this.vertices.push({
                    position: ha(J, J, 0.5),
                    height: 0.5 * (d + b),
                    extent: 0.5 * (_ + E),
                  });
                  const Q = ca(wr(), A, M);
                  (this.vertexProps.push({ dir: Qa(Q, Q) }),
                    this.edges.splice(i, 1),
                    this.edgeProps.splice(i, 1),
                    this.edges.push({ a: o, b: H }),
                    this.edges.push({ a: H, b: a }));
                  const V = Ao(wr(), this.vertices[H].position, u),
                    X = Mo(V),
                    ee = { vec: V, dir: ha(wr(), V, 1 / X), len: X };
                  (this.edgeProps.push(ee), this.edgeProps.push(ee));
                }
              }
              distSqLines(e, i, o, a) {
                const u = Ii(qt(), i, e),
                  d = Ii(qt(), a, o),
                  _ = Ii(qt(), e, o),
                  v = wn(u, u),
                  b = wn(u, d),
                  E = wn(u, _),
                  A = wn(d, d),
                  M = wn(d, _),
                  R = v * A - b * b;
                if (R === 0) {
                  const j = wn(_, d) / wn(d, d);
                  return yr(ps(qt(), o, a, j), e);
                }
                const k = (b * M - E * A) / R,
                  N = (v * M - b * E) / R;
                return yr(ps(qt(), e, i, k), ps(qt(), o, a, N));
              }
            }
            class cs {
              static parseFrom(e, i) {
                const o = Ti.parse(e);
                if (!o) return [];
                let { vertices: a, features: u } = o;
                const d = 1 / Ve(i);
                (u.sort((E, A) => E.id - A.id),
                  a.sort((E, A) => E.id - A.id || E.idx - A.idx),
                  (a = a.filter(
                    (E, A, M) =>
                      A ===
                      M.findIndex((R) => R.id === E.id && R.idx === E.idx),
                  )));
                const _ = new Array();
                let v = 0;
                const b = a.length;
                for (const E of u) {
                  if (E.constantHeight) {
                    _.push(new $r(E.id, E.bounds, E.constantHeight));
                    continue;
                  }
                  for (; v !== b && a[v].id < E.id; ) v++;
                  if (v === b || a[v].id !== E.id) continue;
                  const A = new Array(),
                    M = new Array(),
                    R = v;
                  for (; v !== b && a[v].id === E.id; ) {
                    const k = a[v];
                    if (
                      (A.push({
                        position: k.position,
                        height: k.height,
                        extent: k.extent,
                      }),
                      v !== R && a[v - 1].idx === k.idx - 1)
                    ) {
                      const N = v - R;
                      M.push({ a: N - 1, b: N });
                    }
                    v++;
                  }
                  _.push(new $r(E.id, E.bounds, void 0, A, M, d));
                }
                return _;
              }
              static getElevationFeature(e, i) {
                if (!i) return;
                const o = +e.properties[gi];
                return Number.isNaN(o) ? void 0 : i.find((a) => a.id === o);
              }
            }
            class zs {
              constructor(e, i) {
                ((this.zScale = 1),
                  (this.xOffset = 0),
                  (this.yOffset = 0),
                  e.equals(i) ||
                    ((this.zScale = Math.pow(2, i.z - e.z)),
                    (this.xOffset = (e.x * this.zScale - i.x) * mt),
                    (this.yOffset = (e.y * this.zScale - i.y) * mt)));
              }
              constantElevation(e, i) {
                if (e.constantHeight != null)
                  return this.computeBiasedHeight(e.constantHeight, i);
              }
              pointElevation(e, i, o) {
                const a = this.constantElevation(i, o);
                return (
                  a ??
                  ((e.x = e.x * this.zScale + this.xOffset),
                  (e.y = e.y * this.zScale + this.yOffset),
                  this.computeBiasedHeight(i.pointElevation(e), o))
                );
              }
              computeBiasedHeight(e, i) {
                return i <= 0
                  ? e
                  : e + i * Se(0, i, e >= 0 ? e : Math.abs(0.5 * e));
              }
            }
            Tt($r, "ElevationFeature");
            class ws {
              constructor(e) {
                ((this.zoom = e.zoom),
                  (this.overscaling = e.overscaling),
                  (this.layers = e.layers),
                  (this.layerIds = this.layers.map((i) => i.fqid)),
                  (this.index = e.index),
                  (this.hasPattern = !1),
                  (this.projection = e.projection),
                  (this.layoutVertexArray = new po()),
                  (this.indexArray = new dr()),
                  (this.segments = new Rn()),
                  (this.programConfigurations = new c(e.layers, {
                    zoom: e.zoom,
                    lut: e.lut,
                  })),
                  (this.stateDependentLayerIds = this.layers
                    .filter((i) => i.isStateDependent())
                    .map((i) => i.id)),
                  (this.elevationMode = this.layers[0].layout.get(
                    "circle-elevation-reference",
                  )),
                  (this.hasElevation = !1),
                  this.elevationMode !== "none" &&
                    (this.elevatedLayoutVertexArray = new Go()),
                  (this.worldview = e.worldview));
              }
              updateFootprints(e, i) {}
              populate(e, i, o, a) {
                const u = this.layers[0],
                  d = [];
                let _ = null;
                u.type === "circle" && (_ = u.layout.get("circle-sort-key"));
                for (const {
                  feature: b,
                  id: E,
                  index: A,
                  sourceLayerIndex: M,
                } of e) {
                  const R = this.layers[0]._featureFilter.needGeometry,
                    k = bt(b, R);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new qi(this.zoom, { worldview: this.worldview }),
                      k,
                      o,
                    )
                  )
                    continue;
                  const N = _ ? _.evaluate(k, {}, o) : void 0,
                    j = {
                      id: E,
                      properties: b.properties,
                      type: b.type,
                      sourceLayerIndex: M,
                      index: A,
                      geometry: R ? k.geometry : Et(b, o, a),
                      patterns: {},
                      sortKey: N,
                    };
                  d.push(j);
                }
                _ && d.sort((b, E) => b.sortKey - E.sortKey);
                let v = null;
                a.projection.name === "globe" &&
                  ((this.globeExtVertexArray = new pu()), (v = a.projection));
                for (const b of d) {
                  const { geometry: E, index: A, sourceLayerIndex: M } = b,
                    R = e[A].feature;
                  (this.addFeature(
                    b,
                    E,
                    A,
                    i.availableImages,
                    o,
                    v,
                    i.brightness,
                    i.elevationFeatures,
                  ),
                    i.featureIndex.insert(R, E, A, M, this.index));
                }
                this.hasElevation || (this.elevatedLayoutVertexArray = void 0);
              }
              update(e, i, o, a, u, d, _) {
                this.programConfigurations.updatePaintArrays(
                  e,
                  i,
                  u,
                  o,
                  a,
                  d,
                  _,
                  this.worldview,
                );
              }
              isEmpty() {
                return this.layoutVertexArray.length === 0;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(e) {
                (this.uploaded ||
                  ((this.layoutVertexBuffer = e.createVertexBuffer(
                    this.layoutVertexArray,
                    $_.members,
                  )),
                  (this.indexBuffer = e.createIndexBuffer(this.indexArray)),
                  this.globeExtVertexArray &&
                    (this.globeExtVertexBuffer = e.createVertexBuffer(
                      this.globeExtVertexArray,
                      xu.members,
                    )),
                  this.elevatedLayoutVertexArray &&
                    (this.elevatedLayoutVertexBuffer = e.createVertexBuffer(
                      this.elevatedLayoutVertexArray,
                      H_.members,
                    ))),
                  this.programConfigurations.upload(e),
                  (this.uploaded = !0));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy(),
                  this.globeExtVertexBuffer &&
                    this.globeExtVertexBuffer.destroy(),
                  this.elevatedLayoutVertexBuffer &&
                    this.elevatedLayoutVertexBuffer.destroy());
              }
              addFeature(e, i, o, a, u, d, _, v) {
                let b;
                this.elevationMode !== "none" &&
                  (b = cs.getElevationFeature(e, v));
                for (const E of i)
                  for (const A of E) {
                    const M = A.x,
                      R = A.y;
                    if (M < 0 || M >= mt || R < 0 || R >= mt) continue;
                    if (d) {
                      const j = d.projectTilePoint(M, R, u),
                        H = d.upVector(u, M, R);
                      (this.addGlobeExtVertex(j, H),
                        this.addGlobeExtVertex(j, H),
                        this.addGlobeExtVertex(j, H),
                        this.addGlobeExtVertex(j, H));
                    }
                    const k = this.segments.prepareSegment(
                        4,
                        this.layoutVertexArray,
                        this.indexArray,
                        e.sortKey,
                      ),
                      N = k.vertexLength;
                    if (
                      (this.addCircleVertex(M, R, -1, -1),
                      this.addCircleVertex(M, R, 1, -1),
                      this.addCircleVertex(M, R, 1, 1),
                      this.addCircleVertex(M, R, -1, 1),
                      this.elevationMode !== "none")
                    ) {
                      const j = b ? b.pointElevation(new ft(M, R)) : 0;
                      this.hasElevation = this.hasElevation || j !== 0;
                      for (let H = 0; H < 4; H++)
                        this.elevatedLayoutVertexArray.emplaceBack(j);
                    }
                    (this.indexArray.emplaceBack(N, N + 1, N + 2),
                      this.indexArray.emplaceBack(N, N + 2, N + 3),
                      (k.vertexLength += 4),
                      (k.primitiveLength += 2));
                  }
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  e,
                  o,
                  {},
                  a,
                  u,
                  _,
                  void 0,
                  this.worldview,
                );
              }
              addCircleVertex(e, i, o, a) {
                this.layoutVertexArray.emplaceBack(
                  2 * e + (o + 1) / 2,
                  2 * i + (a + 1) / 2,
                );
              }
              addGlobeExtVertex(e, i) {
                this.globeExtVertexArray.emplaceBack(
                  e.x,
                  e.y,
                  e.z,
                  i[0] * 16384,
                  i[1] * 16384,
                  i[2] * 16384,
                );
              }
            }
            function Hr(n, e) {
              for (let i = 0; i < n.length; i++) if (Gs(e, n[i])) return !0;
              for (let i = 0; i < e.length; i++) if (Gs(n, e[i])) return !0;
              return !!Jc(n, e);
            }
            function qo(n, e, i) {
              return !!Gs(n, e) || !!Qc(e, n, i);
            }
            function ks(n, e) {
              if (n.length === 1) return Eu(e, n[0]);
              for (let i = 0; i < e.length; i++) {
                const o = e[i];
                for (let a = 0; a < o.length; a++) if (Gs(n, o[a])) return !0;
              }
              for (let i = 0; i < n.length; i++) if (Eu(e, n[i])) return !0;
              for (let i = 0; i < e.length; i++) if (Jc(n, e[i])) return !0;
              return !1;
            }
            function Zo(n, e, i) {
              if (n.length > 1) {
                if (Jc(n, e)) return !0;
                for (let o = 0; o < e.length; o++)
                  if (Qc(e[o], n, i)) return !0;
              }
              for (let o = 0; o < n.length; o++) if (Qc(n[o], e, i)) return !0;
              return !1;
            }
            function Jc(n, e) {
              if (n.length === 0 || e.length === 0) return !1;
              for (let i = 0; i < n.length - 1; i++) {
                const o = n[i],
                  a = n[i + 1];
                for (let u = 0; u < e.length - 1; u++)
                  if (af(o, a, e[u], e[u + 1])) return !0;
              }
              return !1;
            }
            function af(n, e, i, o) {
              return Ki(n, i, o) !== Ki(e, i, o) && Ki(n, e, i) !== Ki(n, e, o);
            }
            function Ll(n, e, i) {
              return (n.x - i.x) * (e.y - i.y) - (n.y - i.y) * (e.x - i.x);
            }
            function lf(n, e, i, o) {
              const a = Ll(n, e, o),
                u = Ll(n, e, i);
              if (Math.sign(a) === Math.sign(u)) return;
              const d = Ll(i, o, n),
                _ = d + u - a;
              return Math.sign(d) !== Math.sign(_)
                ? [d / (d - _), u / (u - a)]
                : void 0;
            }
            function Qc(n, e, i) {
              const o = i * i;
              if (e.length === 1) return n.distSqr(e[0]) < o;
              for (let a = 1; a < e.length; a++)
                if (Su(n, e[a - 1], e[a]) < o) return !0;
              return !1;
            }
            function Su(n, e, i) {
              const o = e.distSqr(i);
              if (o === 0) return n.distSqr(e);
              const a =
                ((n.x - e.x) * (i.x - e.x) + (n.y - e.y) * (i.y - e.y)) / o;
              return n.distSqr(
                a < 0 ? e : a > 1 ? i : i.sub(e)._mult(a)._add(e),
              );
            }
            function Eu(n, e) {
              let i,
                o,
                a,
                u = !1;
              for (let d = 0; d < n.length; d++) {
                i = n[d];
                for (let _ = 0, v = i.length - 1; _ < i.length; v = _++)
                  ((o = i[_]),
                    (a = i[v]),
                    o.y > e.y != a.y > e.y &&
                      e.x < ((a.x - o.x) * (e.y - o.y)) / (a.y - o.y) + o.x &&
                      (u = !u));
              }
              return u;
            }
            function Gs(n, e) {
              let i = !1;
              for (let o = 0, a = n.length - 1; o < n.length; a = o++) {
                const u = n[o],
                  d = n[a];
                u.y > e.y != d.y > e.y &&
                  e.x < ((d.x - u.x) * (e.y - u.y)) / (d.y - u.y) + u.x &&
                  (i = !i);
              }
              return i;
            }
            function Ol(n, e, i, o, a) {
              for (const d of n)
                if (e <= d.x && i <= d.y && o >= d.x && a >= d.y) return !0;
              const u = [
                new ft(e, i),
                new ft(e, a),
                new ft(o, a),
                new ft(o, i),
              ];
              if (n.length > 2) {
                for (const d of u) if (Gs(n, d)) return !0;
              }
              for (let d = 0; d < n.length - 1; d++)
                if (La(n[d], n[d + 1], u)) return !0;
              return !1;
            }
            function La(n, e, i) {
              const o = i[0],
                a = i[2];
              if (
                (n.x < o.x && e.x < o.x) ||
                (n.x > a.x && e.x > a.x) ||
                (n.y < o.y && e.y < o.y) ||
                (n.y > a.y && e.y > a.y)
              )
                return !1;
              const u = Ki(n, e, i[0]);
              return (
                u !== Ki(n, e, i[1]) ||
                u !== Ki(n, e, i[2]) ||
                u !== Ki(n, e, i[3])
              );
            }
            function Xo(n, e, i, o, a, u) {
              let d = e.y - n.y,
                _ = n.x - e.x;
              if ((u = u || 0)) {
                const v = d * d + _ * _;
                if (v === 0) return !0;
                const b = Math.sqrt(v);
                ((d /= b), (_ /= b));
              }
              return !(
                (i.x - n.x) * d + (i.y - n.y) * _ - u < 0 ||
                (o.x - n.x) * d + (o.y - n.y) * _ - u < 0 ||
                (a.x - n.x) * d + (a.y - n.y) * _ - u < 0
              );
            }
            function q_(n, e, i, o, a, u, d) {
              return !(
                Xo(n, e, o, a, u, d) ||
                Xo(e, i, o, a, u, d) ||
                Xo(i, n, o, a, u, d) ||
                Xo(o, a, n, e, i, d) ||
                Xo(a, u, n, e, i, d) ||
                Xo(u, o, n, e, i, d)
              );
            }
            function Iu(n, e, i) {
              const o = e.paint.get(n).value;
              return o.kind === "constant"
                ? o.value
                : i.programConfigurations.get(e.id).getMaxValue(n);
            }
            function Tm(n) {
              return Math.sqrt(n[0] * n[0] + n[1] * n[1]);
            }
            function yv(n, e, i, o, a) {
              if (!e[0] && !e[1]) return n;
              const u = ft.convert(e)._mult(a);
              i === "viewport" && u._rotate(-o);
              const d = [];
              for (let _ = 0; _ < n.length; _++) d.push(n[_].sub(u));
              return d;
            }
            function xv(n, e, i, o) {
              const a = ft.convert(n)._mult(o);
              return (e === "viewport" && a._rotate(-i), a);
            }
            let vv, bv;
            function wv(n, e, i) {
              var o = (2 * Math.PI * 6378137) / 256 / Math.pow(2, i);
              return [
                n * o - (2 * Math.PI * 6378137) / 2,
                e * o - (2 * Math.PI * 6378137) / 2,
              ];
            }
            Tt(ws, "CircleBucket", { omit: ["layers"] });
            class eh {
              constructor(e, i, o) {
                ((this.z = e),
                  (this.x = i),
                  (this.y = o),
                  (this.key = Au(0, e, e, i, o)));
              }
              equals(e) {
                return this.z === e.z && this.x === e.x && this.y === e.y;
              }
              url(e, i) {
                const o = (function (u, d, _) {
                    var v = wv(256 * u, 256 * (d = Math.pow(2, _) - d - 1), _),
                      b = wv(256 * (u + 1), 256 * (d + 1), _);
                    return v[0] + "," + v[1] + "," + b[0] + "," + b[1];
                  })(this.x, this.y, this.z),
                  a = (function (u, d, _) {
                    let v,
                      b = "";
                    for (let E = u; E > 0; E--)
                      ((v = 1 << (E - 1)),
                        (b += (d & v ? 1 : 0) + (_ & v ? 2 : 0)));
                    return b;
                  })(this.z, this.x, this.y);
                return e[(this.x + this.y) % e.length]
                  .replace(
                    "{prefix}",
                    (this.x % 16).toString(16) + (this.y % 16).toString(16),
                  )
                  .replace(/{z}/g, String(this.z))
                  .replace(/{x}/g, String(this.x))
                  .replace(
                    /{y}/g,
                    String(
                      i === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y,
                    ),
                  )
                  .replace("{quadkey}", a)
                  .replace("{bbox-epsg-3857}", o);
              }
              toString() {
                return `${this.z}/${this.x}/${this.y}`;
              }
            }
            class Tv {
              constructor(e, i) {
                ((this.wrap = e),
                  (this.canonical = i),
                  (this.key = Au(e, i.z, i.z, i.x, i.y)));
              }
            }
            class Lr {
              constructor(e, i, o, a, u) {
                ((this.overscaledZ = e),
                  (this.wrap = i),
                  (this.canonical = new eh(o, +a, +u)),
                  (this.key =
                    i === 0 && e === o
                      ? this.canonical.key
                      : Au(i, e, o, a, u)));
              }
              equals(e) {
                return (
                  this.overscaledZ === e.overscaledZ &&
                  this.wrap === e.wrap &&
                  this.canonical.equals(e.canonical)
                );
              }
              scaledTo(e) {
                const i = this.canonical.z - e;
                return e > this.canonical.z
                  ? new Lr(
                      e,
                      this.wrap,
                      this.canonical.z,
                      this.canonical.x,
                      this.canonical.y,
                    )
                  : new Lr(
                      e,
                      this.wrap,
                      e,
                      this.canonical.x >> i,
                      this.canonical.y >> i,
                    );
              }
              calculateScaledKey(e, i = !0) {
                if (this.overscaledZ === e && i) return this.key;
                if (e > this.canonical.z)
                  return Au(
                    this.wrap * +i,
                    e,
                    this.canonical.z,
                    this.canonical.x,
                    this.canonical.y,
                  );
                {
                  const o = this.canonical.z - e;
                  return Au(
                    this.wrap * +i,
                    e,
                    e,
                    this.canonical.x >> o,
                    this.canonical.y >> o,
                  );
                }
              }
              isChildOf(e) {
                if (e.wrap !== this.wrap) return !1;
                const i = this.canonical.z - e.canonical.z;
                return (
                  e.overscaledZ === 0 ||
                  (e.overscaledZ < this.overscaledZ &&
                    e.canonical.z < this.canonical.z &&
                    e.canonical.x === this.canonical.x >> i &&
                    e.canonical.y === this.canonical.y >> i)
                );
              }
              children(e) {
                if (this.overscaledZ >= e)
                  return [
                    new Lr(
                      this.overscaledZ + 1,
                      this.wrap,
                      this.canonical.z,
                      this.canonical.x,
                      this.canonical.y,
                    ),
                  ];
                const i = this.canonical.z + 1,
                  o = 2 * this.canonical.x,
                  a = 2 * this.canonical.y;
                return [
                  new Lr(i, this.wrap, i, o, a),
                  new Lr(i, this.wrap, i, o + 1, a),
                  new Lr(i, this.wrap, i, o, a + 1),
                  new Lr(i, this.wrap, i, o + 1, a + 1),
                ];
              }
              isLessThan(e) {
                return (
                  this.wrap < e.wrap ||
                  (!(this.wrap > e.wrap) &&
                    (this.overscaledZ < e.overscaledZ ||
                      (!(this.overscaledZ > e.overscaledZ) &&
                        (this.canonical.x < e.canonical.x ||
                          (!(this.canonical.x > e.canonical.x) &&
                            this.canonical.y < e.canonical.y)))))
                );
              }
              wrapped() {
                return new Lr(
                  this.overscaledZ,
                  0,
                  this.canonical.z,
                  this.canonical.x,
                  this.canonical.y,
                );
              }
              unwrapTo(e) {
                return new Lr(
                  this.overscaledZ,
                  e,
                  this.canonical.z,
                  this.canonical.x,
                  this.canonical.y,
                );
              }
              overscaleFactor() {
                return Math.pow(2, this.overscaledZ - this.canonical.z);
              }
              toUnwrapped() {
                return new Tv(this.wrap, this.canonical);
              }
              toString() {
                return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
              }
            }
            function Au(n, e, i, o, a) {
              const u = 1 << Math.min(i, 22);
              let d = u * (a % u) + (o % u);
              return (
                n &&
                  i < 22 &&
                  (d +=
                    u *
                    u *
                    ((n < 0 ? -2 * n - 1 : 2 * n) % (1 << (2 * (22 - i))))),
                16 * (32 * d + i) + (e - i)
              );
            }
            const nS = [
              (n) => {
                let e = n.canonical.x - 1,
                  i = n.wrap;
                return (
                  e < 0 && ((e = (1 << n.canonical.z) - 1), i--),
                  new Lr(n.overscaledZ, i, n.canonical.z, e, n.canonical.y)
                );
              },
              (n) => {
                let e = n.canonical.x + 1,
                  i = n.wrap;
                return (
                  e === 1 << n.canonical.z && ((e = 0), i++),
                  new Lr(n.overscaledZ, i, n.canonical.z, e, n.canonical.y)
                );
              },
              (n) =>
                new Lr(
                  n.overscaledZ,
                  n.wrap,
                  n.canonical.z,
                  n.canonical.x,
                  (n.canonical.y === 0 ? 1 << n.canonical.z : n.canonical.y) -
                    1,
                ),
              (n) =>
                new Lr(
                  n.overscaledZ,
                  n.wrap,
                  n.canonical.z,
                  n.canonical.x,
                  n.canonical.y === (1 << n.canonical.z) - 1
                    ? 0
                    : n.canonical.y + 1,
                ),
            ];
            (Tt(eh, "CanonicalTileID"),
              Tt(Lr, "OverscaledTileID", {
                omit: ["projMatrix", "expandedProjMatrix"],
              }));
            const rS = Ai([
                { type: "Float32", name: "a_globe_pos", components: 3 },
                { type: "Float32", name: "a_uv", components: 2 },
              ]),
              { members: Sm } = rS,
              sS = Ai([{ name: "a_pos_3", components: 3, type: "Int16" }]);
            var Sv = Ai([{ name: "a_pos", type: "Int16", components: 2 }]);
            function Em(n) {
              return (n * x) / $;
            }
            const oS = [
              new Ci([z, z, z], [O, O, O]),
              new Ci([z, z, z], [0, 0, O]),
              new Ci([0, z, z], [O, 0, O]),
              new Ci([z, 0, z], [0, O, O]),
              new Ci([0, 0, z], [O, O, O]),
            ];
            function Ev(n, e, i, o = !0) {
              const a = Vi([], n._camera.position, n.worldSize),
                u = [e, i, 1, 1];
              (Cr(u, u, n.pixelMatrixInverse), la(u, u, 1 / u[3]));
              const d = tn([], Gn([], u, a)),
                _ = n.globeMatrix,
                v = [_[12], _[13], _[14]],
                b = Gn([], v, a),
                E = Ri(b),
                A = tn([], b),
                M = n.worldSize / (2 * Math.PI),
                R = wn(A, d),
                k = Math.asin(M / E);
              if (k < Math.acos(R)) {
                if (!o) return null;
                const be = [],
                  Me = [];
                (Vi(be, d, E / R),
                  tn(Me, Gn(Me, be, b)),
                  tn(d, ei(d, b, Vi(d, Me, Math.tan(k) * E))));
              }
              const N = [];
              new hn(a, d).closestPointOnSphere(v, M, N);
              const j = tn([], Mn(_, 0)),
                H = tn([], Mn(_, 1)),
                J = tn([], Mn(_, 2)),
                Q = wn(j, N),
                V = wn(H, N),
                X = wn(J, N),
                ee = Fe(Math.asin(-V / M));
              let re = Fe(Math.atan2(Q, X));
              re =
                n.center.lng +
                (function (be, Me) {
                  const Ue = ((Me - be + 180) % 360) - 180;
                  return Ue < -180 ? Ue + 360 : Ue;
                })(n.center.lng, re);
              const ve = ce(re),
                ge = he(le(ee), 0, 1);
              return new Te(ve, ge);
            }
            class aS {
              constructor(e, i, o) {
                ((this.a = Gn([], e, o)),
                  (this.b = Gn([], i, o)),
                  (this.center = o));
                const a = tn([], this.a),
                  u = tn([], this.b);
                this.angle = Math.acos(wn(a, u));
              }
            }
            function Z_(n, e) {
              if (n.angle === 0) return null;
              let i;
              return (
                (i =
                  n.a[e] === 0
                    ? (1 / n.angle) * 0.5 * Math.PI
                    : (1 / n.angle) *
                      Math.atan(
                        n.b[e] / n.a[e] / Math.sin(n.angle) -
                          1 / Math.tan(n.angle),
                      )),
                i < 0 || i > 1
                  ? null
                  : (function (o, a, u, d) {
                      const _ = Math.sin(u);
                      return (
                        o * (Math.sin((1 - d) * u) / _) +
                        a * (Math.sin(d * u) / _)
                      );
                    })(n.a[e], n.b[e], n.angle, he(i, 0, 1)) + n.center[e]
              );
            }
            function Yo(n) {
              if (n.z <= 1) return oS[n.z + 2 * n.y + n.x];
              const e = X_(Im(n));
              return Ci.fromPoints(e);
            }
            function Oa(n, e, i) {
              return (Vi(n, n, 1 - i), _r(n, n, e, i));
            }
            function Iv(n, e, i) {
              for (const o of n) (mn(o, o, e), Vi(o, o, i));
            }
            function Av(n, e, i, o) {
              const a = e / n.worldSize,
                u = n.globeMatrix;
              if (i.z <= 1) {
                const ge = Yo(i).getCorners();
                return (Iv(ge, u, a), Ci.fromPoints(ge));
              }
              const d = Im(i, o),
                _ = X_(d, x + Em(n._tileCoverLift));
              Iv(_, u, a);
              const v = Number.MAX_VALUE,
                b = [-v, -v, -v],
                E = [v, v, v];
              if (d.contains(n.center)) {
                for (const Me of _) (ir(E, E, Me), or(b, b, Me));
                b[2] = 0;
                const ge = n.point,
                  be = [ge.x * a, ge.y * a, 0];
                return (ir(E, E, be), or(b, b, be), new Ci(E, b));
              }
              if (n._tileCoverLift > 0) {
                for (const ge of _) (ir(E, E, ge), or(b, b, ge));
                return new Ci(E, b);
              }
              const A = [u[12] * a, u[13] * a, u[14] * a],
                M = d.getCenter(),
                R = he(n.center.lat, -85.051129, He),
                k = he(M.lat, -85.051129, He),
                N = ce(n.center.lng),
                j = le(R);
              let H = N - ce(M.lng);
              const J = j - le(k);
              H > 0.5 ? (H -= 1) : H < -0.5 && (H += 1);
              let Q = 0;
              Math.abs(H) > Math.abs(J)
                ? (Q = H >= 0 ? 1 : 3)
                : ((Q = J >= 0 ? 0 : 2),
                  _r(
                    A,
                    A,
                    [u[4] * a, u[5] * a, u[6] * a],
                    -Math.sin(Mi(J >= 0 ? d.getSouth() : d.getNorth())) * x,
                  ));
              const V = _[Q],
                X = _[(Q + 1) % 4],
                ee = new aS(V, X, A),
                re = [Z_(ee, 0) || V[0], Z_(ee, 1) || V[1], Z_(ee, 2) || V[2]],
                ve = Fl(n.zoom);
              if (ve > 0) {
                const ge = (function ({ x: Me, y: Ue, z: it }, Xe, tt, nt, Ge) {
                  const Je = 1 / (1 << it);
                  let Ne = Me * Je,
                    je = Ne + Je,
                    at = Ue * Je,
                    ct = at + Je,
                    Nt = 0;
                  const Ct = (Ne + je) / 2 - nt;
                  return (
                    Ct > 0.5 ? (Nt = -1) : Ct < -0.5 && (Nt = 1),
                    (Ne = ((Ne + Nt) * Xe - (nt *= Xe)) * tt + nt),
                    (je = ((je + Nt) * Xe - nt) * tt + nt),
                    (at = (at * Xe - (Ge *= Xe)) * tt + Ge),
                    (ct = (ct * Xe - Ge) * tt + Ge),
                    [
                      [Ne, ct, 0],
                      [je, ct, 0],
                      [je, at, 0],
                      [Ne, at, 0],
                    ]
                  );
                })(i, e, n._pixelsPerMercatorPixel, N, j);
                for (let Me = 0; Me < _.length; Me++) Oa(_[Me], ge[Me], ve);
                const be = ei([], ge[Q], ge[(Q + 1) % 4]);
                (Vi(be, be, 0.5), Oa(re, be, ve));
              }
              for (const ge of _) (ir(E, E, ge), or(b, b, ge));
              return (
                (E[2] = Math.min(V[2], X[2])),
                ir(E, E, re),
                or(b, b, re),
                new Ci(E, b)
              );
            }
            function Im({ x: n, y: e, z: i }, o = !1) {
              const a = 1 / (1 << i),
                u = new Y(
                  _e(n * a),
                  e === (1 << i) - 1 && o ? -90 : De((e + 1) * a),
                ),
                d = new Y(_e((n + 1) * a), e === 0 && o ? 90 : De(e * a));
              return new ie(u, d);
            }
            function X_(n, e = x) {
              const i = Mi(n.getNorth()),
                o = Mi(n.getSouth()),
                a = Math.cos(i),
                u = Math.cos(o),
                d = Math.sin(i),
                _ = Math.sin(o),
                v = n.getWest(),
                b = n.getEast();
              return [
                G(u, _, v, e),
                G(u, _, b, e),
                G(a, d, b, e),
                G(a, d, v, e),
              ];
            }
            function cf(n, e, i, o) {
              const a = 1 << i.z,
                u = (n / mt + i.x) / a;
              return U(De((e / mt + i.y) / a), _e(u), o);
            }
            function Am({ min: n, max: e }) {
              return C / Math.max(e[0] - n[0], e[1] - n[1], e[2] - n[2]);
            }
            const Mv = new Float64Array(16);
            function Mm(n) {
              const e = Am(n),
                i = Re(Mv, [e, e, e]);
              return Qe(i, i, qr([], n.min));
            }
            function Y_(n) {
              const e =
                ((o = n.min),
                ((i = Mv)[0] = 1),
                (i[1] = 0),
                (i[2] = 0),
                (i[3] = 0),
                (i[4] = 0),
                (i[5] = 1),
                (i[6] = 0),
                (i[7] = 0),
                (i[8] = 0),
                (i[9] = 0),
                (i[10] = 1),
                (i[11] = 0),
                (i[12] = o[0]),
                (i[13] = o[1]),
                (i[14] = o[2]),
                (i[15] = 1),
                i);
              var i, o;
              const a = 1 / Am(n);
              return gt(e, e, [a, a, a]);
            }
            function K_(n) {
              const e = mt / (2 * Math.PI);
              return n / (2 * Math.PI) / e;
            }
            function Cv(n, e) {
              return (mt / (512 * Math.pow(2, n))) * Am(Yo(e));
            }
            function Pv(n, e, i, o, a) {
              const u = K_(i),
                d = [n, e, -i / (2 * Math.PI)],
                _ = xe(new Float64Array(16));
              return (
                Qe(_, _, d),
                gt(_, _, [u, u, u]),
                Rt(_, _, Mi(-a)),
                Mt(_, _, Mi(-o)),
                _
              );
            }
            function Fl(n) {
              return Se(w, S, n);
            }
            function Dv(n, e) {
              const i = U(e.lat, e.lng),
                o = (function (k) {
                  const N = U(k._center.lat, k._center.lng);
                  let j = nr([], wi(0, 1, 0), N);
                  const H = rt([], -k.angle, N);
                  ((j = mn(j, j, H)), rt(H, -k._pitch, j));
                  const J = tn([], N);
                  return (
                    Vi(J, J, Em(k.cameraToCenterDistance / k.pixelsPerMeter)),
                    mn(J, J, H),
                    ei([], N, J)
                  );
                })(n);
              return (
                (d = (a = Ii([], o, i))[0]),
                (_ = a[1]),
                (v = a[2]),
                (b = (u = i)[0]),
                (E = u[1]),
                (A = u[2]),
                (R =
                  (M =
                    Math.sqrt(d * d + _ * _ + v * v) *
                    Math.sqrt(b * b + E * E + A * A)) && wn(a, u) / M),
                Math.acos(Math.min(Math.max(R, -1), 1))
              );
              var a, u, d, _, v, b, E, A, M, R;
            }
            function J_(n, e) {
              return Dv(n, e) > (Math.PI / 2) * 1.01;
            }
            const Rv = Mi(85),
              lS = Math.cos(Rv),
              cS = Math.sin(Rv),
              hS = Ie(),
              zv = (n) => {
                const e = [];
                return (
                  n.paint.get("circle-pitch-alignment") === "map" &&
                    e.push("PITCH_WITH_MAP"),
                  n.paint.get("circle-pitch-scale") === "map" &&
                    e.push("SCALE_WITH_MAP"),
                  e
                );
              };
            function kv(n, e, i, o, a, u, d, _, v) {
              if (u && n.queryGeometry.isAboveHorizon) return !1;
              u && (v *= n.pixelToTileUnitsFactor);
              const b = n.tileID.canonical,
                E = i.projection.upVectorScale(
                  b,
                  i.center.lat,
                  i.worldSize,
                ).metersToTile;
              for (const A of e)
                for (const M of A) {
                  const R = M.add(_),
                    k =
                      a && i.elevation
                        ? i.elevation.exaggeration() *
                          a.getElevationAt(R.x, R.y, !0)
                        : 0,
                    N = i.projection.projectTilePoint(R.x, R.y, b);
                  if (k > 0) {
                    const Q = i.projection.upVector(b, R.x, R.y);
                    ((N.x += Q[0] * E * k),
                      (N.y += Q[1] * E * k),
                      (N.z += Q[2] * E * k));
                  }
                  const j = u ? R : uS(N.x, N.y, N.z, o),
                    H = u
                      ? n.tilespaceRays.map((Q) => fS(Q, k))
                      : n.queryGeometry.screenGeometry,
                    J = Cr([], [N.x, N.y, N.z, 1], o);
                  if (
                    (!d && u
                      ? (v *= J[3] / i.cameraToCenterDistance)
                      : d && !u && (v *= i.cameraToCenterDistance / J[3]),
                    u)
                  ) {
                    const Q = De((M.y / mt + b.y) / (1 << b.z));
                    v /= i.projection.pixelsPerMeter(Q, 1) / me(1, Q);
                  }
                  if (qo(H, j, v)) return !0;
                }
              return !1;
            }
            function uS(n, e, i, o) {
              const a = Cr([], [n, e, i, 1], o);
              return new ft(a[0] / a[3], a[1] / a[3]);
            }
            const Lv = wi(0, 0, 0),
              dS = wi(0, 0, 1);
            function fS(n, e) {
              const i = qt();
              return (
                (Lv[2] = e),
                n.intersectsPlane(Lv, dS, i),
                new ft(i[0], i[1])
              );
            }
            class Ov extends ws {}
            let Fv, Bv, Nv, Vv;
            function Uv(n, { width: e, height: i }, o, a) {
              if (a) {
                if (a instanceof Uint8ClampedArray)
                  a = new Uint8Array(a.buffer);
                else if (a.length !== e * i * o)
                  throw new RangeError("mismatched image size");
              } else a = new Uint8Array(e * i * o);
              return ((n.width = e), (n.height = i), (n.data = a), n);
            }
            function jv(n, e, i) {
              const { width: o, height: a } = e;
              (o === n.width && a === n.height) ||
                (Q_(
                  n,
                  e,
                  { x: 0, y: 0 },
                  { x: 0, y: 0 },
                  {
                    width: Math.min(n.width, o),
                    height: Math.min(n.height, a),
                  },
                  i,
                  null,
                ),
                (n.width = o),
                (n.height = a),
                (n.data = e.data));
            }
            function Q_(n, e, i, o, a, u, d, _) {
              if (a.width === 0 || a.height === 0) return e;
              if (
                a.width > n.width ||
                a.height > n.height ||
                i.x > n.width - a.width ||
                i.y > n.height - a.height
              )
                throw new RangeError(
                  "out of range source coordinates for image copy",
                );
              if (
                a.width > e.width ||
                a.height > e.height ||
                o.x > e.width - a.width ||
                o.y > e.height - a.height
              )
                throw new RangeError(
                  "out of range destination coordinates for image copy",
                );
              const v = n.data,
                b = e.data,
                E = u === 4 && _;
              for (let A = 0; A < a.height; A++) {
                const M = ((i.y + A) * n.width + i.x) * u,
                  R = ((o.y + A) * e.width + o.x) * u;
                if (E)
                  for (let k = 0; k < a.width; k++) {
                    const N = M + k * u + 3,
                      j = R + k * u;
                    ((b[j + 0] = 255),
                      (b[j + 1] = 255),
                      (b[j + 2] = 255),
                      (b[j + 3] = v[N]));
                  }
                else if (d)
                  for (let k = 0; k < a.width; k++) {
                    const N = M + k * u,
                      j = R + k * u,
                      H = new Li(
                        v[N + 0] / 255,
                        v[N + 1] / 255,
                        v[N + 2] / 255,
                        v[N + 3],
                      )
                        .toNonPremultipliedRenderColor(d)
                        .toArray();
                    ((b[j + 0] = H[0]),
                      (b[j + 1] = H[1]),
                      (b[j + 2] = H[2]),
                      (b[j + 3] = H[3]));
                  }
                else for (let k = 0; k < a.width * u; k++) b[R + k] = v[M + k];
              }
              return e;
            }
            Tt(Ov, "HeatmapBucket", { omit: ["layers"] });
            class Bl {
              constructor(e, i) {
                Uv(this, e, 1, i);
              }
              resize(e) {
                jv(this, new Bl(e), 1);
              }
              clone() {
                return new Bl(
                  { width: this.width, height: this.height },
                  new Uint8Array(this.data),
                );
              }
              static copy(e, i, o, a, u) {
                Q_(e, i, o, a, u, 1, null);
              }
            }
            class xr {
              constructor(e, i) {
                Uv(this, e, 4, i);
              }
              resize(e) {
                jv(this, new xr(e), 4);
              }
              replace(e, i) {
                i
                  ? this.data.set(e)
                  : (this.data =
                      e instanceof Uint8ClampedArray
                        ? new Uint8Array(e.buffer)
                        : e);
              }
              clone() {
                return new xr(
                  { width: this.width, height: this.height },
                  new Uint8Array(this.data),
                );
              }
              static copy(e, i, o, a, u, d, _) {
                Q_(e, i, o, a, u, 4, d, _);
              }
            }
            class Gv {
              constructor(e, i) {
                ((this.width = e.width),
                  (this.height = e.height),
                  (this.data =
                    i instanceof Uint8Array ? new Float32Array(i.buffer) : i));
              }
            }
            function hf(n) {
              const e = {},
                i = n.resolution || 256,
                o = n.clips ? n.clips.length : 1,
                a = n.image || new xr({ width: i, height: o }),
                u = (d, _, v) => {
                  e[n.evaluationKey] = v;
                  const b = n.expression.evaluate(e),
                    E = b ? b.toNonPremultipliedRenderColor(null) : null;
                  E &&
                    ((a.data[d + _ + 0] = Math.floor(255 * E.r)),
                    (a.data[d + _ + 1] = Math.floor(255 * E.g)),
                    (a.data[d + _ + 2] = Math.floor(255 * E.b)),
                    (a.data[d + _ + 3] = Math.floor(255 * E.a)));
                };
              if (n.clips)
                for (let d = 0, _ = 0; d < o; ++d, _ += 4 * i)
                  for (let v = 0, b = 0; v < i; v++, b += 4) {
                    const E = v / (i - 1),
                      { start: A, end: M } = n.clips[d];
                    u(_, b, A * (1 - E) + M * E);
                  }
              else
                for (let d = 0, _ = 0; d < i; d++, _ += 4) u(0, _, d / (i - 1));
              return a;
            }
            (Tt(Bl, "AlphaImage"), Tt(xr, "RGBAImage"));
            const pS = Ai([{ name: "a_pos", components: 2, type: "Int16" }], 4),
              mS = Ai(
                [{ name: "a_road_z_offset", components: 1, type: "Float32" }],
                4,
              ),
              gS = Ai(
                [
                  { name: "a_pos", components: 2, type: "Int16" },
                  { name: "a_height", components: 1, type: "Float32" },
                ],
                4,
              ),
              _S = Ai(
                [{ name: "a_pos_normal_3", components: 3, type: "Int16" }],
                4,
              );
            function uf(n, e, i = 2) {
              const o = e && e.length,
                a = o ? e[0] * i : n.length;
              let u = $v(n, 0, a, i, !0);
              const d = [];
              if (!u || u.next === u.prev) return d;
              let _, v, b;
              if (
                (o &&
                  (u = (function (E, A, M, R) {
                    const k = [];
                    for (let N = 0, j = A.length; N < j; N++) {
                      const H = $v(
                        E,
                        A[N] * R,
                        N < j - 1 ? A[N + 1] * R : E.length,
                        R,
                        !1,
                      );
                      (H === H.next && (H.steiner = !0), k.push(ES(H)));
                    }
                    k.sort(wS);
                    for (let N = 0; N < k.length; N++) M = TS(k[N], M);
                    return M;
                  })(n, e, u, i)),
                n.length > 80 * i)
              ) {
                ((_ = 1 / 0), (v = 1 / 0));
                let E = -1 / 0,
                  A = -1 / 0;
                for (let M = i; M < a; M += i) {
                  const R = n[M],
                    k = n[M + 1];
                  (R < _ && (_ = R),
                    k < v && (v = k),
                    R > E && (E = R),
                    k > A && (A = k));
                }
                ((b = Math.max(E - _, A - v)), (b = b !== 0 ? 32767 / b : 0));
              }
              return (df(u, d, i, _, v, b, 0), d);
            }
            function $v(n, e, i, o, a) {
              let u;
              if (
                a ===
                (function (d, _, v, b) {
                  let E = 0;
                  for (let A = _, M = v - b; A < v; A += b)
                    ((E += (d[M] - d[A]) * (d[A + 1] + d[M + 1])), (M = A));
                  return E;
                })(n, e, i, o) >
                  0
              )
                for (let d = e; d < i; d += o)
                  u = Zv((d / o) | 0, n[d], n[d + 1], u);
              else
                for (let d = i - o; d >= e; d -= o)
                  u = Zv((d / o) | 0, n[d], n[d + 1], u);
              return (u && Mu(u, u.next) && (mf(u), (u = u.next)), u);
            }
            function th(n, e) {
              if (!n) return n;
              e || (e = n);
              let i,
                o = n;
              do
                if (
                  ((i = !1),
                  o.steiner || (!Mu(o, o.next) && rr(o.prev, o, o.next) !== 0))
                )
                  o = o.next;
                else {
                  if ((mf(o), (o = e = o.prev), o === o.next)) break;
                  i = !0;
                }
              while (i || o !== e);
              return e;
            }
            function df(n, e, i, o, a, u, d) {
              if (!n) return;
              !d &&
                u &&
                (function (v, b, E, A) {
                  let M = v;
                  do
                    (M.z === 0 && (M.z = ey(M.x, M.y, b, E, A)),
                      (M.prevZ = M.prev),
                      (M.nextZ = M.next),
                      (M = M.next));
                  while (M !== v);
                  ((M.prevZ.nextZ = null),
                    (M.prevZ = null),
                    (function (R) {
                      let k,
                        N = 1;
                      do {
                        let j,
                          H = R;
                        R = null;
                        let J = null;
                        for (k = 0; H; ) {
                          k++;
                          let Q = H,
                            V = 0;
                          for (
                            let ee = 0;
                            ee < N && (V++, (Q = Q.nextZ), Q);
                            ee++
                          );
                          let X = N;
                          for (; V > 0 || (X > 0 && Q); )
                            (V !== 0 && (X === 0 || !Q || H.z <= Q.z)
                              ? ((j = H), (H = H.nextZ), V--)
                              : ((j = Q), (Q = Q.nextZ), X--),
                              J ? (J.nextZ = j) : (R = j),
                              (j.prevZ = J),
                              (J = j));
                          H = Q;
                        }
                        ((J.nextZ = null), (N *= 2));
                      } while (k > 1);
                    })(M));
                })(n, o, a, u);
              let _ = n;
              for (; n.prev !== n.next; ) {
                const v = n.prev,
                  b = n.next;
                if (u ? xS(n, o, a, u) : yS(n))
                  (e.push(v.i, n.i, b.i), mf(n), (n = b.next), (_ = b.next));
                else if ((n = b) === _) {
                  d
                    ? d === 1
                      ? df((n = vS(th(n), e)), e, i, o, a, u, 2)
                      : d === 2 && bS(n, e, i, o, a, u)
                    : df(th(n), e, i, o, a, u, 1);
                  break;
                }
              }
            }
            function yS(n) {
              const e = n.prev,
                i = n,
                o = n.next;
              if (rr(e, i, o) >= 0) return !1;
              const a = e.x,
                u = i.x,
                d = o.x,
                _ = e.y,
                v = i.y,
                b = o.y,
                E = Math.min(a, u, d),
                A = Math.min(_, v, b),
                M = Math.max(a, u, d),
                R = Math.max(_, v, b);
              let k = o.next;
              for (; k !== e; ) {
                if (
                  k.x >= E &&
                  k.x <= M &&
                  k.y >= A &&
                  k.y <= R &&
                  ff(a, _, u, v, d, b, k.x, k.y) &&
                  rr(k.prev, k, k.next) >= 0
                )
                  return !1;
                k = k.next;
              }
              return !0;
            }
            function xS(n, e, i, o) {
              const a = n.prev,
                u = n,
                d = n.next;
              if (rr(a, u, d) >= 0) return !1;
              const _ = a.x,
                v = u.x,
                b = d.x,
                E = a.y,
                A = u.y,
                M = d.y,
                R = Math.min(_, v, b),
                k = Math.min(E, A, M),
                N = Math.max(_, v, b),
                j = Math.max(E, A, M),
                H = ey(R, k, e, i, o),
                J = ey(N, j, e, i, o);
              let Q = n.prevZ,
                V = n.nextZ;
              for (; Q && Q.z >= H && V && V.z <= J; ) {
                if (
                  (Q.x >= R &&
                    Q.x <= N &&
                    Q.y >= k &&
                    Q.y <= j &&
                    Q !== a &&
                    Q !== d &&
                    ff(_, E, v, A, b, M, Q.x, Q.y) &&
                    rr(Q.prev, Q, Q.next) >= 0) ||
                  ((Q = Q.prevZ),
                  V.x >= R &&
                    V.x <= N &&
                    V.y >= k &&
                    V.y <= j &&
                    V !== a &&
                    V !== d &&
                    ff(_, E, v, A, b, M, V.x, V.y) &&
                    rr(V.prev, V, V.next) >= 0)
                )
                  return !1;
                V = V.nextZ;
              }
              for (; Q && Q.z >= H; ) {
                if (
                  Q.x >= R &&
                  Q.x <= N &&
                  Q.y >= k &&
                  Q.y <= j &&
                  Q !== a &&
                  Q !== d &&
                  ff(_, E, v, A, b, M, Q.x, Q.y) &&
                  rr(Q.prev, Q, Q.next) >= 0
                )
                  return !1;
                Q = Q.prevZ;
              }
              for (; V && V.z <= J; ) {
                if (
                  V.x >= R &&
                  V.x <= N &&
                  V.y >= k &&
                  V.y <= j &&
                  V !== a &&
                  V !== d &&
                  ff(_, E, v, A, b, M, V.x, V.y) &&
                  rr(V.prev, V, V.next) >= 0
                )
                  return !1;
                V = V.nextZ;
              }
              return !0;
            }
            function vS(n, e) {
              let i = n;
              do {
                const o = i.prev,
                  a = i.next.next;
                (!Mu(o, a) &&
                  Wv(o, i, i.next, a) &&
                  pf(o, a) &&
                  pf(a, o) &&
                  (e.push(o.i, i.i, a.i), mf(i), mf(i.next), (i = n = a)),
                  (i = i.next));
              } while (i !== n);
              return th(i);
            }
            function bS(n, e, i, o, a, u) {
              let d = n;
              do {
                let _ = d.next.next;
                for (; _ !== d.prev; ) {
                  if (d.i !== _.i && IS(d, _)) {
                    let v = qv(d, _);
                    return (
                      (d = th(d, d.next)),
                      (v = th(v, v.next)),
                      df(d, e, i, o, a, u, 0),
                      void df(v, e, i, o, a, u, 0)
                    );
                  }
                  _ = _.next;
                }
                d = d.next;
              } while (d !== n);
            }
            function wS(n, e) {
              let i = n.x - e.x;
              return (
                i === 0 &&
                  ((i = n.y - e.y), i === 0) &&
                  (i =
                    (n.next.y - n.y) / (n.next.x - n.x) -
                    (e.next.y - e.y) / (e.next.x - e.x)),
                i
              );
            }
            function TS(n, e) {
              const i = (function (a, u) {
                let d = u;
                const _ = a.x,
                  v = a.y;
                let b,
                  E = -1 / 0;
                if (Mu(a, d)) return d;
                do {
                  if (Mu(a, d.next)) return d.next;
                  if (v <= d.y && v >= d.next.y && d.next.y !== d.y) {
                    const N =
                      d.x + ((v - d.y) * (d.next.x - d.x)) / (d.next.y - d.y);
                    if (
                      N <= _ &&
                      N > E &&
                      ((E = N), (b = d.x < d.next.x ? d : d.next), N === _)
                    )
                      return b;
                  }
                  d = d.next;
                } while (d !== u);
                if (!b) return null;
                const A = b,
                  M = b.x,
                  R = b.y;
                let k = 1 / 0;
                d = b;
                do {
                  if (
                    _ >= d.x &&
                    d.x >= M &&
                    _ !== d.x &&
                    Hv(v < R ? _ : E, v, M, R, v < R ? E : _, v, d.x, d.y)
                  ) {
                    const N = Math.abs(v - d.y) / (_ - d.x);
                    pf(d, a) &&
                      (N < k ||
                        (N === k &&
                          (d.x > b.x || (d.x === b.x && SS(b, d))))) &&
                      ((b = d), (k = N));
                  }
                  d = d.next;
                } while (d !== A);
                return b;
              })(n, e);
              if (!i) return e;
              const o = qv(i, n);
              return (th(o, o.next), th(i, i.next));
            }
            function SS(n, e) {
              return rr(n.prev, n, e.prev) < 0 && rr(e.next, n, n.next) < 0;
            }
            function ey(n, e, i, o, a) {
              return (
                (n =
                  1431655765 &
                  ((n =
                    858993459 &
                    ((n =
                      252645135 &
                      ((n = 16711935 & ((n = ((n - i) * a) | 0) | (n << 8))) |
                        (n << 4))) |
                      (n << 2))) |
                    (n << 1))) |
                ((e =
                  1431655765 &
                  ((e =
                    858993459 &
                    ((e =
                      252645135 &
                      ((e = 16711935 & ((e = ((e - o) * a) | 0) | (e << 8))) |
                        (e << 4))) |
                      (e << 2))) |
                    (e << 1))) <<
                  1)
              );
            }
            function ES(n) {
              let e = n,
                i = n;
              do
                ((e.x < i.x || (e.x === i.x && e.y < i.y)) && (i = e),
                  (e = e.next));
              while (e !== n);
              return i;
            }
            function Hv(n, e, i, o, a, u, d, _) {
              return (
                (a - d) * (e - _) >= (n - d) * (u - _) &&
                (n - d) * (o - _) >= (i - d) * (e - _) &&
                (i - d) * (u - _) >= (a - d) * (o - _)
              );
            }
            function ff(n, e, i, o, a, u, d, _) {
              return !(n === d && e === _) && Hv(n, e, i, o, a, u, d, _);
            }
            function IS(n, e) {
              return (
                n.next.i !== e.i &&
                n.prev.i !== e.i &&
                !(function (i, o) {
                  let a = i;
                  do {
                    if (
                      a.i !== i.i &&
                      a.next.i !== i.i &&
                      a.i !== o.i &&
                      a.next.i !== o.i &&
                      Wv(a, a.next, i, o)
                    )
                      return !0;
                    a = a.next;
                  } while (a !== i);
                  return !1;
                })(n, e) &&
                ((pf(n, e) &&
                  pf(e, n) &&
                  (function (i, o) {
                    let a = i,
                      u = !1;
                    const d = (i.x + o.x) / 2,
                      _ = (i.y + o.y) / 2;
                    do
                      (a.y > _ != a.next.y > _ &&
                        a.next.y !== a.y &&
                        d <
                          ((a.next.x - a.x) * (_ - a.y)) / (a.next.y - a.y) +
                            a.x &&
                        (u = !u),
                        (a = a.next));
                    while (a !== i);
                    return u;
                  })(n, e) &&
                  (rr(n.prev, n, e.prev) || rr(n, e.prev, e))) ||
                  (Mu(n, e) &&
                    rr(n.prev, n, n.next) > 0 &&
                    rr(e.prev, e, e.next) > 0))
              );
            }
            function rr(n, e, i) {
              return (e.y - n.y) * (i.x - e.x) - (e.x - n.x) * (i.y - e.y);
            }
            function Mu(n, e) {
              return n.x === e.x && n.y === e.y;
            }
            function Wv(n, e, i, o) {
              const a = Pm(rr(n, e, i)),
                u = Pm(rr(n, e, o)),
                d = Pm(rr(i, o, n)),
                _ = Pm(rr(i, o, e));
              return (
                (a !== u && d !== _) ||
                !(a !== 0 || !Cm(n, i, e)) ||
                !(u !== 0 || !Cm(n, o, e)) ||
                !(d !== 0 || !Cm(i, n, o)) ||
                !(_ !== 0 || !Cm(i, e, o))
              );
            }
            function Cm(n, e, i) {
              return (
                e.x <= Math.max(n.x, i.x) &&
                e.x >= Math.min(n.x, i.x) &&
                e.y <= Math.max(n.y, i.y) &&
                e.y >= Math.min(n.y, i.y)
              );
            }
            function Pm(n) {
              return n > 0 ? 1 : n < 0 ? -1 : 0;
            }
            function pf(n, e) {
              return rr(n.prev, n, n.next) < 0
                ? rr(n, e, n.next) >= 0 && rr(n, n.prev, e) >= 0
                : rr(n, e, n.prev) < 0 || rr(n, n.next, e) < 0;
            }
            function qv(n, e) {
              const i = ty(n.i, n.x, n.y),
                o = ty(e.i, e.x, e.y),
                a = n.next,
                u = e.prev;
              return (
                (n.next = e),
                (e.prev = n),
                (i.next = a),
                (a.prev = i),
                (o.next = i),
                (i.prev = o),
                (u.next = o),
                (o.prev = u),
                o
              );
            }
            function Zv(n, e, i, o) {
              const a = ty(n, e, i);
              return (
                o
                  ? ((a.next = o.next),
                    (a.prev = o),
                    (o.next.prev = a),
                    (o.next = a))
                  : ((a.prev = a), (a.next = a)),
                a
              );
            }
            function mf(n) {
              ((n.next.prev = n.prev),
                (n.prev.next = n.next),
                n.prevZ && (n.prevZ.nextZ = n.nextZ),
                n.nextZ && (n.nextZ.prevZ = n.prevZ));
            }
            function ty(n, e, i) {
              return {
                i: n,
                x: e,
                y: i,
                prev: null,
                next: null,
                z: 0,
                prevZ: null,
                nextZ: null,
                steiner: !1,
              };
            }
            function Dm(n, e) {
              const i = n.length;
              if (i <= 1) return [n];
              const o = [];
              let a, u;
              for (let d = 0; d < i; d++) {
                const _ = gn(n[d]);
                _ !== 0 &&
                  ((n[d].area = Math.abs(_)),
                  u === void 0 && (u = _ < 0),
                  u === _ < 0 ? (a && o.push(a), (a = [n[d]])) : a.push(n[d]));
              }
              if ((a && o.push(a), e > 1))
                for (let d = 0; d < o.length; d++)
                  o[d].length <= e ||
                    (Sr(o[d], e, 1, o[d].length - 1, AS),
                    (o[d] = o[d].slice(0, e)));
              return o;
            }
            function AS(n, e) {
              return e.area - n.area;
            }
            function Xv(n, e, i = 1) {
              if (!n) return null;
              const o =
                  typeof n == "string"
                    ? Gr.from(n).getPrimary()
                    : n.getPrimary(),
                a = typeof n == "string" ? null : n.getSecondary();
              for (const u of [o, a]) {
                if (!u) continue;
                const d = u.id.toString();
                (e.has(d) || e.set(d, []), u.scaleSelf(i), e.get(d).push(u));
              }
              return {
                primary: o.toString(),
                secondary: a ? a.toString() : null,
              };
            }
            function iy(n, e, i, o) {
              const a = o.patternDependencies;
              let u = !1;
              for (const d of e) {
                const _ = d.paint.get(`${n}-pattern`);
                (_.isConstant() || (u = !0),
                  Xv(_.constantOr(null), a, i) && (u = !0));
              }
              return u;
            }
            function ny(n, e, i, o, a, u) {
              const d = u.patternDependencies;
              for (const _ of e) {
                const v = _.paint.get(`${n}-pattern`).value;
                if (v.kind !== "constant") {
                  let b = v.evaluate({ zoom: o }, i, {}, u.availableImages);
                  b = b && b.name ? b.name : b;
                  const E = Xv(b, d, a);
                  if (!E) continue;
                  const { primary: A, secondary: M } = E;
                  A && (i.patterns[_.id] = [A, M].filter(Boolean));
                }
              }
              return i;
            }
            class Yv {
              constructor() {
                this.polygons = new Map();
              }
              add(e, ...i) {
                this.polygons.has(e)
                  ? this.polygons.get(e).push(...i)
                  : this.polygons.set(e, i);
              }
              merge(e) {
                for (const [i, o] of e.polygons) this.add(i, ...o);
              }
            }
            class ih {
              constructor() {
                this.portals = [];
              }
              static evaluate(e) {
                if (e.length === 0) return new ih();
                let i = [];
                for (const b of e) i.push(...b.portals);
                if (i.length === 0) return new ih();
                const o = (b, E) => (b <= 0 && E <= 0) || (b >= mt && E >= mt);
                for (const b of i) {
                  const E = b.va,
                    A = b.vb;
                  (o(E.x, A.x) || o(E.y, A.y)) && (b.type = "border");
                }
                const a = i.filter((b) => b.type !== "unevaluated"),
                  u = i.filter((b) => b.type === "unevaluated");
                if (u.length === 0) return new ih();
                (u.sort((b, E) =>
                  b.hash === E.hash
                    ? b.isTunnel === E.isTunnel
                      ? 0
                      : b.isTunnel
                        ? -1
                        : 1
                    : b.hash < E.hash
                      ? 1
                      : -1,
                ),
                  (i = a.concat(u)));
                let d = a.length,
                  _ = d,
                  v = d;
                do
                  if ((_++, _ === i.length || i[d].hash !== i[_].hash)) {
                    if (_ - d == 2) {
                      v < d && ((i[v] = i[d]), (i[d] = null));
                      const b = i[v],
                        E = i[_ - 1];
                      ((b.type =
                        b.isTunnel !== E.isTunnel ? "tunnel" : "polygon"),
                        (b.connection = {
                          a: b.connection.a,
                          b: E.connection.a,
                        }),
                        v++);
                    }
                    d = _;
                  }
                while (d !== i.length);
                return (
                  i.splice(v),
                  i.sort((b, E) => (b.hash < E.hash ? 1 : -1)),
                  { portals: i }
                );
              }
            }
            (Tt(ih, "ElevationPortalGraph"), Tt(Yv, "ElevationPolygons"));
            class MS {
              constructor(e, i, o) {
                ((this.outPositions = e),
                  (this.outNormals = i),
                  (this.outIndices = o),
                  (this.vertexLookup = new Map()),
                  (this.buffer = new ArrayBuffer(4)),
                  (this.view = new DataView(this.buffer)));
              }
              addVertex(e, i, o) {
                let a = e[2];
                o != null && (a *= o);
                const u = (this.getVec3Bits(e) << 96n) | this.getVec3Bits(i),
                  d = this.vertexLookup.get(u);
                if (d != null) return d;
                const _ = this.outPositions.length;
                this.vertexLookup.set(u, _);
                const v = Math.trunc(16384 * i[0]),
                  b = Math.trunc(16384 * i[1]),
                  E = Math.trunc(16384 * i[2]);
                return (
                  this.outPositions.emplaceBack(e[0], e[1], a),
                  this.outNormals.emplaceBack(v, b, E),
                  _
                );
              }
              addVertices(e, i, ...o) {
                const a = [];
                for (const u of o) {
                  const d = this.addVertex(u, e, i);
                  a.push(d);
                }
                return a;
              }
              addTriangles(e, i, o) {
                if (i && o) {
                  const a = o.length === 1,
                    u = wi(0, 0, 0);
                  for (let d = 0; d < e.length; d += 3) {
                    const _ = i[e[d + 0]],
                      v = i[e[d + 1]],
                      b = i[e[d + 2]],
                      E = a ? o[0] : o[e[d + 1]],
                      A = a ? o[0] : o[e[d + 2]],
                      M = this.addVertex(
                        wi(_.x, _.y, a ? o[0] : o[e[d + 0]]),
                        u,
                      ),
                      R = this.addVertex(wi(v.x, v.y, E), u),
                      k = this.addVertex(wi(b.x, b.y, A), u);
                    this.outIndices.emplaceBack(M, R, k);
                  }
                } else
                  for (let a = 0; a < e.length; a += 3)
                    this.outIndices.emplaceBack(e[a + 0], e[a + 1], e[a + 2]);
              }
              addQuad(e, i) {
                const o = this.addVertices(
                    i,
                    void 0,
                    ...e.map((v) => wi(v.coord.x, v.coord.y, v.height)),
                  ),
                  [a, u, d, _] = o;
                this.addTriangles([a, u, d, d, _, a]);
              }
              getVertexCount() {
                return this.outPositions.length;
              }
              clearVertexLookup() {
                this.vertexLookup.clear();
              }
              getBits(e) {
                return (
                  this.view.setFloat32(0, e),
                  BigInt(this.view.getUint32(0))
                );
              }
              getVec3Bits(e) {
                return (
                  (this.getBits(e[0]) << 64n) |
                  (this.getBits(e[1]) << 32n) |
                  this.getBits(e[2])
                );
              }
            }
            class Ts {
              constructor(e, i, o, a) {
                ((this.unevaluatedPortals = new ih()),
                  (this.portalPolygons = new Yv()),
                  (this.bridgeFeatureSections = []),
                  (this.tunnelFeatureSections = []),
                  (this.vertexHashLookup = new Map()),
                  (this.unevalVertices = []),
                  (this.unevalHeights = []),
                  (this.unevalTriangles = []),
                  (this.unevalTunnelTriangles = []),
                  (this.unevalEdges = []),
                  (this.vertexPositions = new Wd()),
                  (this.vertexNormals = new fu()),
                  (this.indexArray = new dr()),
                  (this.tileToMeters = Ve(e)),
                  (this.bridgeProgramConfigurations = new c(
                    i,
                    { zoom: o, lut: a },
                    (u) => u !== "fill-tunnel-structure-color",
                  )),
                  (this.tunnelProgramConfigurations = new c(
                    i,
                    { zoom: o, lut: a },
                    (u) => u !== "fill-bridge-guard-rail-color",
                  )));
              }
              addVertices(e, i) {
                const o = this.unevalVertices.length;
                for (let a = 0; a < e.length; a++)
                  (this.unevalVertices.push(e[a]),
                    this.unevalHeights.push(i[a]));
                return o;
              }
              addTriangles(e, i, o) {
                const a = o ? this.unevalTunnelTriangles : this.unevalTriangles;
                for (const u of e) a.push(u + i);
              }
              addRenderableRing(e, i, o, a, u, d) {
                const _ = [
                  new ft(u.min.x, u.min.y),
                  new ft(u.max.x, u.min.y),
                  new ft(u.max.x, u.max.y),
                  new ft(u.min.x, u.max.y),
                ];
                for (let v = 0; v < o - 1; v++) {
                  const b = i + v,
                    E = b + 1,
                    A = this.unevalVertices[b],
                    M = this.unevalVertices[E];
                  if (
                    !(
                      (A.x >= u.min.x &&
                        A.x <= u.max.x &&
                        A.y >= u.min.y &&
                        A.y <= u.max.y) ||
                      (M.x >= u.min.x &&
                        M.x <= u.max.x &&
                        M.y >= u.min.y &&
                        M.y <= u.max.y) ||
                      La(A, M, _)
                    ) ||
                    this.isOnBorder(A.x, M.x) ||
                    this.isOnBorder(A.y, M.y)
                  )
                    continue;
                  const R = Ts.computeEdgeHash(
                    this.unevalVertices[b],
                    this.unevalVertices[E],
                  );
                  let k,
                    N = this.vertexHashLookup.get(Ts.computePosHash(A));
                  (N != null
                    ? (k = N.next)
                    : ((N = this.vertexHashLookup.get(Ts.computePosHash(M))),
                      (k = N != null ? N.prev : R)),
                    this.unevalEdges.push({
                      polygonIdx: e,
                      a: b,
                      b: E,
                      hash: R,
                      portalHash: k,
                      isTunnel: a,
                      type: "unevaluated",
                      featureInfo: d,
                    }));
                }
              }
              addPortalCandidates(e, i, o, a, u) {
                if (i.length === 0) return;
                this.portalPolygons.add(e, { geometry: i, zLevel: u });
                const d = i[0];
                this.vertexHashLookup.clear();
                let _ = Ts.computeEdgeHash(d[d.length - 2], d[d.length - 1]);
                for (let v = 0; v < d.length - 1; v++) {
                  const b = d[v + 0],
                    E = d[v + 1],
                    A = ms(E.x - b.x, E.y - b.y),
                    M = Mo(A);
                  if (M === 0) continue;
                  let R = "unevaluated";
                  const k = a.pointElevation(b),
                    N = a.pointElevation(E);
                  Math.abs(k) < 0.01 && Math.abs(N) < 0.01
                    ? (R = "entrance")
                    : (this.isOnBorder(b.x, E.x) ||
                        this.isOnBorder(b.y, E.y)) &&
                      (R = "border");
                  const j = Ts.computeEdgeHash(b, E);
                  this.unevaluatedPortals.portals.push({
                    connection: { a: e, b: void 0 },
                    va: b,
                    vb: E,
                    vab: A,
                    length: M,
                    hash: j,
                    isTunnel: o,
                    type: R,
                  });
                  const H = Ts.computePosHash(b);
                  (this.vertexHashLookup.set(H, { prev: _, next: j }), (_ = j));
                }
              }
              construct(e) {
                if (this.unevalVertices.length === 0) return;
                const i = () => ({
                    vertexOffset: 0,
                    primitiveOffset: this.indexArray.length,
                  }),
                  o = (M) => {
                    M.primitiveLength =
                      this.indexArray.length - M.primitiveOffset;
                  },
                  a = new MS(
                    this.vertexPositions,
                    this.vertexNormals,
                    this.indexArray,
                  );
                this.prepareEdges(e.portals, this.unevalEdges);
                const u = i(),
                  d = i(),
                  _ = i(),
                  v = (M, R) => {
                    M.sort((N, j) =>
                      N.type === R && j.type !== R
                        ? -1
                        : N.type !== R && j.type === R
                          ? 1
                          : 0,
                    );
                    const k = M.findIndex((N) => N.type !== R);
                    return k >= 0 ? k : M.length;
                  };
                let b = 0;
                (this.unevalEdges.length > 0 &&
                  ((b = v(this.unevalEdges, "none")),
                  this.constructBridgeStructures(
                    a,
                    this.unevalVertices,
                    this.unevalHeights,
                    this.unevalEdges,
                    { min: 0, max: b },
                    this.tileToMeters,
                  )),
                  o(_));
                const E = i(),
                  A = i();
                if (this.unevalEdges.length > 0) {
                  const M = this.unevalEdges.splice(b),
                    R = v(M, "tunnel") + b;
                  (this.unevalEdges.push(...M),
                    this.constructTunnelStructures(
                      a,
                      this.unevalVertices,
                      this.unevalHeights,
                      this.unevalEdges,
                      { min: 0, max: b },
                      { min: b, max: R },
                    ));
                }
                (o(E),
                  a.addTriangles(
                    this.unevalTriangles,
                    this.unevalVertices,
                    this.unevalHeights,
                  ),
                  o(A),
                  a.addTriangles(
                    this.unevalTunnelTriangles,
                    this.unevalVertices,
                    this.unevalHeights,
                  ),
                  o(d),
                  a.addTriangles(
                    this.unevalTunnelTriangles,
                    this.unevalVertices,
                    [-0.1],
                  ),
                  o(u),
                  (this.maskSegments = Rn.simpleSegment(
                    0,
                    A.primitiveOffset,
                    0,
                    A.primitiveLength,
                  )),
                  (this.depthSegments = Rn.simpleSegment(
                    0,
                    d.primitiveOffset,
                    0,
                    d.primitiveLength,
                  )),
                  (this.renderableBridgeSegments = Rn.simpleSegment(
                    0,
                    _.primitiveOffset,
                    0,
                    _.primitiveLength,
                  )),
                  (this.renderableTunnelSegments = Rn.simpleSegment(
                    0,
                    E.primitiveOffset,
                    0,
                    E.primitiveLength,
                  )),
                  (this.shadowCasterSegments = Rn.simpleSegment(
                    0,
                    u.primitiveOffset,
                    0,
                    u.primitiveLength,
                  )));
              }
              update(e, i, o, a, u, d, _, v) {
                (this.bridgeProgramConfigurations.updatePaintArrays(
                  e,
                  i,
                  u,
                  o,
                  a,
                  d,
                  _,
                  v,
                ),
                  this.tunnelProgramConfigurations.updatePaintArrays(
                    e,
                    i,
                    u,
                    o,
                    a,
                    d,
                    _,
                    v,
                  ));
              }
              upload(e) {
                this.vertexBuffer ||
                  this.vertexPositions.length === 0 ||
                  this.vertexNormals.length === 0 ||
                  this.indexArray.length === 0 ||
                  ((this.vertexBuffer = e.createVertexBuffer(
                    this.vertexPositions,
                    gS.members,
                  )),
                  (this.vertexBufferNormal = e.createVertexBuffer(
                    this.vertexNormals,
                    _S.members,
                  )),
                  (this.indexBuffer = e.createIndexBuffer(this.indexArray)),
                  this.bridgeProgramConfigurations.upload(e),
                  this.tunnelProgramConfigurations.upload(e));
              }
              destroy() {
                (this.vertexBuffer &&
                  (this.vertexBuffer.destroy(),
                  this.vertexBufferNormal.destroy(),
                  this.indexBuffer.destroy()),
                  this.maskSegments &&
                    (this.maskSegments.destroy(),
                    this.depthSegments.destroy(),
                    this.renderableBridgeSegments.destroy(),
                    this.renderableTunnelSegments.destroy(),
                    this.shadowCasterSegments.destroy()),
                  this.bridgeProgramConfigurations.destroy(),
                  this.tunnelProgramConfigurations.destroy());
              }
              populatePaintArrays(e, i, o, a, u) {
                const d = (_, v) => {
                  for (let b = 0; b < v.length - 1; b++) {
                    const E = v[b].featureIndex,
                      A = v[b + 1].vertexStart,
                      M = e.feature(E);
                    _.populatePaintArrays(A, M, E, {}, o, i, a, void 0, u);
                  }
                };
                (d(
                  this.bridgeProgramConfigurations,
                  this.bridgeFeatureSections,
                ),
                  d(
                    this.tunnelProgramConfigurations,
                    this.tunnelFeatureSections,
                  ));
              }
              computeVertexConnections(e, i, o, a, u) {
                const d = new Map();
                for (let _ = a; _ < u; _++) {
                  const v = o[_],
                    b = v.a,
                    E = v.b,
                    A = Ts.computePosHash(e[b]),
                    M = Ts.computePosHash(e[E]);
                  (d.has(A) || d.set(A, {}), d.has(M) || d.set(M, {}));
                  const R = d.get(A),
                    k = d.get(M);
                  (i[b] <= 0 && i[E] <= 0) || ((R.to = E), (k.from = b));
                }
                return d;
              }
              constructBridgeStructures(e, i, o, a, u, d) {
                e.clearVertexLookup();
                const _ = this.computeVertexConnections(i, o, a, u.min, u.max),
                  v = 1 / d,
                  b = 0.5 * v,
                  E = (R) => wi(i[R].x, i[R].y, o[R] * v),
                  A = (R) => {
                    const k = _.get(Ts.computePosHash(i[R])),
                      N = k.from,
                      j = k.to;
                    if (!N || !j) return;
                    const H = E(N),
                      J = E(R),
                      Q = E(j),
                      V = wi(0, 0, 0);
                    if (!Is(H, J)) {
                      const ee = Gn(qt(), J, H);
                      ei(V, V, tn(ee, ee));
                    }
                    if (!Is(Q, J)) {
                      const ee = Gn(qt(), Q, J);
                      ei(V, V, tn(ee, ee));
                    }
                    const X = To(V);
                    return X > 0 ? Vi(V, V, 1 / X) : void 0;
                  };
                let M = Number.POSITIVE_INFINITY;
                this.sortSubarray(
                  a,
                  u.min,
                  u.max,
                  (R, k) =>
                    R.featureInfo.featureIndex - k.featureInfo.featureIndex,
                );
                for (let R = u.min; R < u.max; R++) {
                  const k = a[R];
                  if (!k.featureInfo.guardRailEnabled) continue;
                  const N = this.prepareEdgePoints(
                    i,
                    o,
                    k,
                    (Jt, At) => Jt > At,
                  );
                  if (N == null) continue;
                  const j = N[0],
                    H = N[1],
                    J = wi(j.coord.x, j.coord.y, v * j.height),
                    Q = wi(H.coord.x, H.coord.y, v * H.height);
                  if (Is(J, Q)) continue;
                  const V = Gn(qt(), Q, J);
                  tn(V, V);
                  const X = (Jt) => tn(Jt, Jt),
                    ee = A(k.a) || V,
                    re = A(k.b) || V,
                    ve = X(wi(ee[1], -ee[0], 0)),
                    ge = X(wi(re[1], -re[0], 0)),
                    be = X(nr(qt(), ve, ee)),
                    Me = X(nr(qt(), ge, re)),
                    Ue = qt(),
                    it = [
                      ei(qt(), J, Vi(Ue, Gn(Ue, ve, be), b)),
                      ei(qt(), J, Vi(Ue, ei(Ue, ve, be), b)),
                      ei(qt(), J, Vi(Ue, be, b)),
                      J,
                    ],
                    Xe = [
                      ei(qt(), Q, Vi(Ue, Gn(Ue, ge, Me), b)),
                      ei(qt(), Q, Vi(Ue, ei(Ue, ge, Me), b)),
                      ei(qt(), Q, Vi(Ue, Me, b)),
                      Q,
                    ];
                  M = this.addFeatureSection(
                    k.featureInfo.featureIndex,
                    M,
                    this.bridgeFeatureSections,
                    e,
                  );
                  const [tt, nt] = e.addVertices(ve, d, it[0], it[1]),
                    [Ge, Je] = e.addVertices(ge, d, Xe[0], Xe[1]);
                  e.addTriangles([tt, nt, Ge, nt, Je, Ge]);
                  const [Ne, je] = e.addVertices(be, d, it[1], it[2]),
                    [at, ct] = e.addVertices(Me, d, Xe[1], Xe[2]);
                  e.addTriangles([Ne, je, at, je, ct, at]);
                  const [Nt, Ct] = e.addVertices(qr(ve, ve), d, it[2], it[3]),
                    [yt, ot] = e.addVertices(qr(ge, ge), d, Xe[2], Xe[3]);
                  e.addTriangles([Nt, Ct, yt, Ct, ot, yt]);
                }
                this.bridgeFeatureSections.push({
                  featureIndex: Number.POSITIVE_INFINITY,
                  vertexStart: e.getVertexCount(),
                });
              }
              constructTunnelStructures(e, i, o, a, u, d) {
                e.clearVertexLookup();
                let _ = Number.POSITIVE_INFINITY;
                const v = (E, A) =>
                  E.featureInfo.featureIndex - A.featureInfo.featureIndex;
                (this.sortSubarray(a, u.min, u.max, v),
                  this.sortSubarray(a, d.min, d.max, v));
                const b = (E) => tn(E, E);
                for (let E = u.min; E < u.max; E++) {
                  const A = this.prepareEdgePoints(i, o, a[E], (N, j) => N < j);
                  if (A == null) continue;
                  const [M, R] = A,
                    k = b(
                      wi(-(R.coord.y - M.coord.y), R.coord.x - M.coord.x, 0),
                    );
                  ((_ = this.addFeatureSection(
                    a[E].featureInfo.featureIndex,
                    _,
                    this.tunnelFeatureSections,
                    e,
                  )),
                    e.addQuad(
                      [
                        M,
                        R,
                        { coord: R.coord, height: a[E].isTunnel ? -0.1 : 0 },
                        { coord: M.coord, height: a[E].isTunnel ? -0.1 : 0 },
                      ],
                      k,
                    ));
                }
                for (let E = d.min; E < d.max; E++) {
                  const A = a[E];
                  A.isTunnel && ([A.a, A.b] = [A.b, A.a]);
                  const M = i[A.a],
                    R = i[A.b],
                    k = b(wi(-(R.y - M.y), R.x - M.x, 0));
                  ((_ = this.addFeatureSection(
                    A.featureInfo.featureIndex,
                    _,
                    this.tunnelFeatureSections,
                    e,
                  )),
                    e.addQuad(
                      [
                        { coord: R, height: 0 },
                        { coord: M, height: 0 },
                        { coord: M, height: o[A.a] + 4 },
                        { coord: R, height: o[A.b] + 4 },
                      ],
                      k,
                    ),
                    e.addQuad(
                      [
                        { coord: M, height: 0 },
                        { coord: R, height: 0 },
                        { coord: R, height: o[A.b] + 4 },
                        { coord: M, height: o[A.a] + 4 },
                      ],
                      k,
                    ));
                }
                this.tunnelFeatureSections.push({
                  featureIndex: Number.POSITIVE_INFINITY,
                  vertexStart: e.getVertexCount(),
                });
              }
              prepareEdgePoints(e, i, o, a) {
                let u = i[o.a],
                  d = i[o.b];
                const _ = a(u, 0),
                  v = a(d, 0);
                if (_ && v)
                  return [
                    { coord: e[o.a], height: u },
                    { coord: e[o.b], height: d },
                  ];
                if (!_ && !v) return;
                const b = e[o.a].clone(),
                  E = e[o.b].clone();
                if (_) {
                  if (!v) {
                    const A = d / (d - u);
                    ((E.x = Ht(E.x, b.x, A)),
                      (E.y = Ht(E.y, b.y, A)),
                      (d = Ht(d, u, A)));
                  }
                } else {
                  const A = u / (u - d);
                  ((b.x = Ht(b.x, E.x, A)),
                    (b.y = Ht(b.y, E.y, A)),
                    (u = Ht(u, d, A)));
                }
                return [
                  { coord: b, height: u },
                  { coord: E, height: d },
                ];
              }
              prepareEdges(e, i) {
                if (i.length === 0) return;
                i.sort((_, v) =>
                  _.hash === v.hash
                    ? v.polygonIdx - _.polygonIdx
                    : v.hash > _.hash
                      ? 1
                      : -1,
                );
                let o = 0,
                  a = 0,
                  u = 0,
                  d = i[o].polygonIdx;
                do
                  (a++,
                    (a === i.length || i[o].hash !== i[a].hash) &&
                      ((a - o == 1 || i[a - 1].polygonIdx !== d) &&
                        (u < o && ((i[u] = i[o]), (i[o] = null)),
                        (i[u].type = "none"),
                        u++),
                      (o = a),
                      o !== i.length && (d = i[o].polygonIdx)));
                while (o !== i.length);
                if ((i.splice(u), i.length !== 0 && e.length !== 0)) {
                  i.sort((b, E) => (b.portalHash < E.portalHash ? 1 : -1));
                  let _ = 0,
                    v = 0;
                  for (; _ !== i.length && v !== e.length; ) {
                    const b = i[_],
                      E = e[v];
                    b.portalHash > E.hash
                      ? _++
                      : E.hash > b.portalHash
                        ? v++
                        : ((b.type = E.type), _++);
                  }
                }
              }
              isOnBorder(e, i) {
                return (e <= 0 && i <= 0) || (e >= mt && i >= mt);
              }
              addFeatureSection(e, i, o, a) {
                return (
                  e !== i &&
                    ((i = e),
                    o.push({
                      featureIndex: e,
                      vertexStart: a.getVertexCount(),
                    }),
                    a.clearVertexLookup()),
                  i
                );
              }
              sortSubarray(e, i, o, a) {
                const u = e.slice(i, o);
                (u.sort(a), e.splice(i, u.length, ...u));
              }
              static computeEdgeHash(e, i) {
                return (
                  ((e.y === i.y && e.x > i.x) || e.y > i.y) &&
                    ([e, i] = [i, e]),
                  (BigInt(Ts.computePosHash(e)) << 32n) |
                    BigInt(Ts.computePosHash(i))
                );
              }
              static computePosHash(e) {
                return (((65535 & e.x) << 16) | (65535 & e.y)) >>> 0;
              }
            }
            var Kv,
              Jv = { exports: {} },
              Qv =
                (Kv ||
                  ((Kv = 1),
                  (function (n, e) {
                    (function (i) {
                      function o(te, se) {
                        return te > se ? 1 : te < se ? -1 : 0;
                      }
                      var a = function (te, se) {
                          (te === void 0 && (te = o),
                            se === void 0 && (se = !1),
                            (this._compare = te),
                            (this._root = null),
                            (this._size = 0),
                            (this._noDuplicates = !!se));
                        },
                        u = { size: { configurable: !0 } };
                      function d(te, se, $e, ut, xt) {
                        var _t = xt - ut;
                        if (_t > 0) {
                          var It = ut + Math.floor(_t / 2),
                            $t = { key: se[It], data: $e[It], parent: te };
                          return (
                            ($t.left = d($t, se, $e, ut, It)),
                            ($t.right = d($t, se, $e, It + 1, xt)),
                            $t
                          );
                        }
                        return null;
                      }
                      function _(te, se, $e, ut, xt) {
                        if (!($e >= ut)) {
                          for (
                            var _t = te[($e + ut) >> 1],
                              It = $e - 1,
                              $t = ut + 1;
                            ;

                          ) {
                            do It++;
                            while (xt(te[It], _t) < 0);
                            do $t--;
                            while (xt(te[$t], _t) > 0);
                            if (It >= $t) break;
                            var yi = te[It];
                            ((te[It] = te[$t]),
                              (te[$t] = yi),
                              (yi = se[It]),
                              (se[It] = se[$t]),
                              (se[$t] = yi));
                          }
                          (_(te, se, $e, $t, xt), _(te, se, $t + 1, ut, xt));
                        }
                      }
                      ((a.prototype.rotateLeft = function (te) {
                        var se = te.right;
                        (se &&
                          ((te.right = se.left),
                          se.left && (se.left.parent = te),
                          (se.parent = te.parent)),
                          te.parent
                            ? te === te.parent.left
                              ? (te.parent.left = se)
                              : (te.parent.right = se)
                            : (this._root = se),
                          se && (se.left = te),
                          (te.parent = se));
                      }),
                        (a.prototype.rotateRight = function (te) {
                          var se = te.left;
                          (se &&
                            ((te.left = se.right),
                            se.right && (se.right.parent = te),
                            (se.parent = te.parent)),
                            te.parent
                              ? te === te.parent.left
                                ? (te.parent.left = se)
                                : (te.parent.right = se)
                              : (this._root = se),
                            se && (se.right = te),
                            (te.parent = se));
                        }),
                        (a.prototype._splay = function (te) {
                          for (; te.parent; ) {
                            var se = te.parent;
                            se.parent
                              ? se.left === te && se.parent.left === se
                                ? (this.rotateRight(se.parent),
                                  this.rotateRight(se))
                                : se.right === te && se.parent.right === se
                                  ? (this.rotateLeft(se.parent),
                                    this.rotateLeft(se))
                                  : se.left === te && se.parent.right === se
                                    ? (this.rotateRight(se),
                                      this.rotateLeft(se))
                                    : (this.rotateLeft(se),
                                      this.rotateRight(se))
                              : se.left === te
                                ? this.rotateRight(se)
                                : this.rotateLeft(se);
                          }
                        }),
                        (a.prototype.splay = function (te) {
                          for (var se, $e, ut, xt, _t; te.parent; )
                            (($e = (se = te.parent).parent) && $e.parent
                              ? ((ut = $e.parent).left === $e
                                  ? (ut.left = te)
                                  : (ut.right = te),
                                (te.parent = ut))
                              : ((te.parent = null), (this._root = te)),
                              (xt = te.left),
                              (_t = te.right),
                              te === se.left
                                ? ($e &&
                                    ($e.left === se
                                      ? (se.right
                                          ? (($e.left = se.right),
                                            ($e.left.parent = $e))
                                          : ($e.left = null),
                                        (se.right = $e),
                                        ($e.parent = se))
                                      : (xt
                                          ? (($e.right = xt), (xt.parent = $e))
                                          : ($e.right = null),
                                        (te.left = $e),
                                        ($e.parent = te))),
                                  _t
                                    ? ((se.left = _t), (_t.parent = se))
                                    : (se.left = null),
                                  (te.right = se),
                                  (se.parent = te))
                                : ($e &&
                                    ($e.right === se
                                      ? (se.left
                                          ? (($e.right = se.left),
                                            ($e.right.parent = $e))
                                          : ($e.right = null),
                                        (se.left = $e),
                                        ($e.parent = se))
                                      : (_t
                                          ? (($e.left = _t), (_t.parent = $e))
                                          : ($e.left = null),
                                        (te.right = $e),
                                        ($e.parent = te))),
                                  xt
                                    ? ((se.right = xt), (xt.parent = se))
                                    : (se.right = null),
                                  (te.left = se),
                                  (se.parent = te)));
                        }),
                        (a.prototype.replace = function (te, se) {
                          (te.parent
                            ? te === te.parent.left
                              ? (te.parent.left = se)
                              : (te.parent.right = se)
                            : (this._root = se),
                            se && (se.parent = te.parent));
                        }),
                        (a.prototype.minNode = function (te) {
                          if ((te === void 0 && (te = this._root), te))
                            for (; te.left; ) te = te.left;
                          return te;
                        }),
                        (a.prototype.maxNode = function (te) {
                          if ((te === void 0 && (te = this._root), te))
                            for (; te.right; ) te = te.right;
                          return te;
                        }),
                        (a.prototype.insert = function (te, se) {
                          var $e = this._root,
                            ut = null,
                            xt = this._compare;
                          if (this._noDuplicates)
                            for (; $e; ) {
                              if (((ut = $e), xt($e.key, te) === 0)) return;
                              $e = xt($e.key, te) < 0 ? $e.right : $e.left;
                            }
                          else
                            for (; $e; )
                              ((ut = $e),
                                ($e = xt($e.key, te) < 0 ? $e.right : $e.left));
                          return (
                            ($e = {
                              key: te,
                              data: se,
                              left: null,
                              right: null,
                              parent: ut,
                            }),
                            ut
                              ? xt(ut.key, $e.key) < 0
                                ? (ut.right = $e)
                                : (ut.left = $e)
                              : (this._root = $e),
                            this.splay($e),
                            this._size++,
                            $e
                          );
                        }),
                        (a.prototype.find = function (te) {
                          for (var se = this._root, $e = this._compare; se; ) {
                            var ut = $e(se.key, te);
                            if (ut < 0) se = se.right;
                            else {
                              if (!(ut > 0)) return se;
                              se = se.left;
                            }
                          }
                          return null;
                        }),
                        (a.prototype.contains = function (te) {
                          for (var se = this._root, $e = this._compare; se; ) {
                            var ut = $e(te, se.key);
                            if (ut === 0) return !0;
                            se = ut < 0 ? se.left : se.right;
                          }
                          return !1;
                        }),
                        (a.prototype.remove = function (te) {
                          var se = this.find(te);
                          if (!se) return !1;
                          if ((this.splay(se), se.left))
                            if (se.right) {
                              var $e = this.minNode(se.right);
                              ($e.parent !== se &&
                                (this.replace($e, $e.right),
                                ($e.right = se.right),
                                ($e.right.parent = $e)),
                                this.replace(se, $e),
                                ($e.left = se.left),
                                ($e.left.parent = $e));
                            } else this.replace(se, se.left);
                          else this.replace(se, se.right);
                          return (this._size--, !0);
                        }),
                        (a.prototype.removeNode = function (te) {
                          if (!te) return !1;
                          if ((this.splay(te), te.left))
                            if (te.right) {
                              var se = this.minNode(te.right);
                              (se.parent !== te &&
                                (this.replace(se, se.right),
                                (se.right = te.right),
                                (se.right.parent = se)),
                                this.replace(te, se),
                                (se.left = te.left),
                                (se.left.parent = se));
                            } else this.replace(te, te.left);
                          else this.replace(te, te.right);
                          return (this._size--, !0);
                        }),
                        (a.prototype.erase = function (te) {
                          var se = this.find(te);
                          if (se) {
                            this.splay(se);
                            var $e = se.left,
                              ut = se.right,
                              xt = null;
                            ($e &&
                              (($e.parent = null),
                              (xt = this.maxNode($e)),
                              this.splay(xt),
                              (this._root = xt)),
                              ut &&
                                ($e ? (xt.right = ut) : (this._root = ut),
                                (ut.parent = xt)),
                              this._size--);
                          }
                        }),
                        (a.prototype.pop = function () {
                          var te = this._root,
                            se = null;
                          if (te) {
                            for (; te.left; ) te = te.left;
                            ((se = { key: te.key, data: te.data }),
                              this.remove(te.key));
                          }
                          return se;
                        }),
                        (a.prototype.next = function (te) {
                          var se = te;
                          if (se)
                            if (se.right)
                              for (se = se.right; se && se.left; ) se = se.left;
                            else
                              for (se = te.parent; se && se.right === te; )
                                ((te = se), (se = se.parent));
                          return se;
                        }),
                        (a.prototype.prev = function (te) {
                          var se = te;
                          if (se)
                            if (se.left)
                              for (se = se.left; se && se.right; )
                                se = se.right;
                            else
                              for (se = te.parent; se && se.left === te; )
                                ((te = se), (se = se.parent));
                          return se;
                        }),
                        (a.prototype.forEach = function (te) {
                          for (
                            var se = this._root, $e = [], ut = !1, xt = 0;
                            !ut;

                          )
                            se
                              ? ($e.push(se), (se = se.left))
                              : $e.length > 0
                                ? (te((se = $e.pop()), xt++), (se = se.right))
                                : (ut = !0);
                          return this;
                        }),
                        (a.prototype.range = function (te, se, $e, ut) {
                          for (
                            var xt = [], _t = this._compare, It = this._root;
                            xt.length !== 0 || It;

                          )
                            if (It) (xt.push(It), (It = It.left));
                            else {
                              if (_t((It = xt.pop()).key, se) > 0) break;
                              if (_t(It.key, te) >= 0 && $e.call(ut, It))
                                return this;
                              It = It.right;
                            }
                          return this;
                        }),
                        (a.prototype.keys = function () {
                          for (
                            var te = this._root, se = [], $e = [], ut = !1;
                            !ut;

                          )
                            te
                              ? (se.push(te), (te = te.left))
                              : se.length > 0
                                ? ((te = se.pop()),
                                  $e.push(te.key),
                                  (te = te.right))
                                : (ut = !0);
                          return $e;
                        }),
                        (a.prototype.values = function () {
                          for (
                            var te = this._root, se = [], $e = [], ut = !1;
                            !ut;

                          )
                            te
                              ? (se.push(te), (te = te.left))
                              : se.length > 0
                                ? ((te = se.pop()),
                                  $e.push(te.data),
                                  (te = te.right))
                                : (ut = !0);
                          return $e;
                        }),
                        (a.prototype.at = function (te) {
                          for (
                            var se = this._root, $e = [], ut = !1, xt = 0;
                            !ut;

                          )
                            if (se) ($e.push(se), (se = se.left));
                            else if ($e.length > 0) {
                              if (((se = $e.pop()), xt === te)) return se;
                              (xt++, (se = se.right));
                            } else ut = !0;
                          return null;
                        }),
                        (a.prototype.load = function (te, se, $e) {
                          if (
                            (te === void 0 && (te = []),
                            se === void 0 && (se = []),
                            $e === void 0 && ($e = !1),
                            this._size !== 0)
                          )
                            throw new Error("bulk-load: tree is not empty");
                          var ut = te.length;
                          return (
                            $e && _(te, se, 0, ut - 1, this._compare),
                            (this._root = d(null, te, se, 0, ut)),
                            (this._size = ut),
                            this
                          );
                        }),
                        (a.prototype.min = function () {
                          var te = this.minNode(this._root);
                          return te ? te.key : null;
                        }),
                        (a.prototype.max = function () {
                          var te = this.maxNode(this._root);
                          return te ? te.key : null;
                        }),
                        (a.prototype.isEmpty = function () {
                          return this._root === null;
                        }),
                        (u.size.get = function () {
                          return this._size;
                        }),
                        (a.createTree = function (te, se, $e, ut, xt) {
                          return new a($e, xt).load(te, se, ut);
                        }),
                        Object.defineProperties(a.prototype, u));
                      var v = 0,
                        b = 1,
                        E = 2,
                        A = 3,
                        M = 0,
                        R = 1,
                        k = 2,
                        N = 3;
                      function j(te, se, $e) {
                        se === null
                          ? ((te.inOut = !1), (te.otherInOut = !0))
                          : (te.isSubject === se.isSubject
                              ? ((te.inOut = !se.inOut),
                                (te.otherInOut = se.otherInOut))
                              : ((te.inOut = !se.otherInOut),
                                (te.otherInOut = se.isVertical()
                                  ? !se.inOut
                                  : se.inOut)),
                            se &&
                              (te.prevInResult =
                                !H(se, $e) || se.isVertical()
                                  ? se.prevInResult
                                  : se));
                        var ut = H(te, $e);
                        te.resultTransition = ut
                          ? (function (xt, _t) {
                              var It,
                                $t = !xt.inOut,
                                yi = !xt.otherInOut;
                              switch (_t) {
                                case M:
                                  It = $t && yi;
                                  break;
                                case R:
                                  It = $t || yi;
                                  break;
                                case N:
                                  It = $t ^ yi;
                                  break;
                                case k:
                                  It = xt.isSubject ? $t && !yi : yi && !$t;
                              }
                              return It ? 1 : -1;
                            })(te, $e)
                          : 0;
                      }
                      function H(te, se) {
                        switch (te.type) {
                          case v:
                            switch (se) {
                              case M:
                                return !te.otherInOut;
                              case R:
                                return te.otherInOut;
                              case k:
                                return (
                                  (te.isSubject && te.otherInOut) ||
                                  (!te.isSubject && !te.otherInOut)
                                );
                              case N:
                                return !0;
                            }
                            break;
                          case E:
                            return se === M || se === R;
                          case A:
                            return se === k;
                          case b:
                            return !1;
                        }
                        return !1;
                      }
                      var J = function (te, se, $e, ut, xt) {
                          ((this.left = se),
                            (this.point = te),
                            (this.otherEvent = $e),
                            (this.isSubject = ut),
                            (this.type = xt || v),
                            (this.inOut = !1),
                            (this.otherInOut = !1),
                            (this.prevInResult = null),
                            (this.resultTransition = 0),
                            (this.otherPos = -1),
                            (this.outputContourId = -1),
                            (this.isExteriorRing = !0));
                        },
                        Q = { inResult: { configurable: !0 } };
                      function V(te, se) {
                        return te[0] === se[0] && te[1] === se[1];
                      }
                      ((J.prototype.isBelow = function (te) {
                        var se = this.point,
                          $e = this.otherEvent.point;
                        return this.left
                          ? (se[0] - te[0]) * ($e[1] - te[1]) -
                              ($e[0] - te[0]) * (se[1] - te[1]) >
                              0
                          : ($e[0] - te[0]) * (se[1] - te[1]) -
                              (se[0] - te[0]) * ($e[1] - te[1]) >
                              0;
                      }),
                        (J.prototype.isAbove = function (te) {
                          return !this.isBelow(te);
                        }),
                        (J.prototype.isVertical = function () {
                          return this.point[0] === this.otherEvent.point[0];
                        }),
                        (Q.inResult.get = function () {
                          return this.resultTransition !== 0;
                        }),
                        (J.prototype.clone = function () {
                          var te = new J(
                            this.point,
                            this.left,
                            this.otherEvent,
                            this.isSubject,
                            this.type,
                          );
                          return (
                            (te.contourId = this.contourId),
                            (te.resultTransition = this.resultTransition),
                            (te.prevInResult = this.prevInResult),
                            (te.isExteriorRing = this.isExteriorRing),
                            (te.inOut = this.inOut),
                            (te.otherInOut = this.otherInOut),
                            te
                          );
                        }),
                        Object.defineProperties(J.prototype, Q));
                      var X = 11102230246251565e-32,
                        ee = 134217729,
                        re = (3 + 8 * X) * X;
                      function ve(te, se, $e, ut, xt) {
                        var _t,
                          It,
                          $t,
                          yi,
                          xi = se[0],
                          ai = ut[0],
                          Gi = 0,
                          Qi = 0;
                        ai > xi == ai > -xi
                          ? ((_t = xi), (xi = se[++Gi]))
                          : ((_t = ai), (ai = ut[++Qi]));
                        var vi = 0;
                        if (Gi < te && Qi < $e)
                          for (
                            ai > xi == ai > -xi
                              ? (($t = _t - ((It = xi + _t) - xi)),
                                (xi = se[++Gi]))
                              : (($t = _t - ((It = ai + _t) - ai)),
                                (ai = ut[++Qi])),
                              _t = It,
                              $t !== 0 && (xt[vi++] = $t);
                            Gi < te && Qi < $e;

                          )
                            (ai > xi == ai > -xi
                              ? (($t =
                                  _t -
                                  ((It = _t + xi) - (yi = It - _t)) +
                                  (xi - yi)),
                                (xi = se[++Gi]))
                              : (($t =
                                  _t -
                                  ((It = _t + ai) - (yi = It - _t)) +
                                  (ai - yi)),
                                (ai = ut[++Qi])),
                              (_t = It),
                              $t !== 0 && (xt[vi++] = $t));
                        for (; Gi < te; )
                          (($t =
                            _t - ((It = _t + xi) - (yi = It - _t)) + (xi - yi)),
                            (xi = se[++Gi]),
                            (_t = It),
                            $t !== 0 && (xt[vi++] = $t));
                        for (; Qi < $e; )
                          (($t =
                            _t - ((It = _t + ai) - (yi = It - _t)) + (ai - yi)),
                            (ai = ut[++Qi]),
                            (_t = It),
                            $t !== 0 && (xt[vi++] = $t));
                        return ((_t === 0 && vi !== 0) || (xt[vi++] = _t), vi);
                      }
                      function ge(te) {
                        return new Float64Array(te);
                      }
                      var be = 33306690738754716e-32,
                        Me = 22204460492503146e-32,
                        Ue = 11093356479670487e-47,
                        it = ge(4),
                        Xe = ge(8),
                        tt = ge(12),
                        nt = ge(16),
                        Ge = ge(4);
                      function Je(te, se, $e) {
                        var ut = (function (xt, _t, It, $t, yi, xi) {
                          var ai = (_t - xi) * (It - yi),
                            Gi = (xt - yi) * ($t - xi),
                            Qi = ai - Gi;
                          if (ai === 0 || Gi === 0 || ai > 0 != Gi > 0)
                            return Qi;
                          var vi = Math.abs(ai + Gi);
                          return Math.abs(Qi) >= be * vi
                            ? Qi
                            : -(function (En, on, Ni, Bn, dn, en, an) {
                                var Wi,
                                  hi,
                                  Zi,
                                  In,
                                  jt,
                                  Si,
                                  fn,
                                  kn,
                                  vn,
                                  Yn,
                                  Yi,
                                  Zn,
                                  ts,
                                  vr,
                                  pr,
                                  is,
                                  Qo,
                                  Kn,
                                  tr = En - dn,
                                  br = Ni - dn,
                                  Or = on - en,
                                  Ar = Bn - en;
                                ((it[0] =
                                  (pr =
                                    (kn =
                                      tr - (fn = (Si = ee * tr) - (Si - tr))) *
                                      (Yn =
                                        Ar -
                                        (vn = (Si = ee * Ar) - (Si - Ar))) -
                                    ((vr = tr * Ar) -
                                      fn * vn -
                                      kn * vn -
                                      fn * Yn)) -
                                  ((Yi =
                                    pr -
                                    (Qo =
                                      (kn =
                                        Or -
                                        (fn = (Si = ee * Or) - (Si - Or))) *
                                        (Yn =
                                          br -
                                          (vn = (Si = ee * br) - (Si - br))) -
                                      ((is = Or * br) -
                                        fn * vn -
                                        kn * vn -
                                        fn * Yn))) +
                                    (jt = pr - Yi)) +
                                  (jt - Qo)),
                                  (it[1] =
                                    (ts =
                                      vr -
                                      ((Zn = vr + Yi) - (jt = Zn - vr)) +
                                      (Yi - jt)) -
                                    ((Yi = ts - is) + (jt = ts - Yi)) +
                                    (jt - is)),
                                  (it[2] =
                                    Zn -
                                    ((Kn = Zn + Yi) - (jt = Kn - Zn)) +
                                    (Yi - jt)),
                                  (it[3] = Kn));
                                var $l = (function (rL, lw) {
                                    for (var cw = lw[0], lx = 1; lx < 4; lx++)
                                      cw += lw[lx];
                                    return cw;
                                  })(0, it),
                                  Gf = Me * an;
                                if (
                                  $l >= Gf ||
                                  -$l >= Gf ||
                                  ((Wi =
                                    En - (tr + (jt = En - tr)) + (jt - dn)),
                                  (Zi = Ni - (br + (jt = Ni - br)) + (jt - dn)),
                                  (hi = on - (Or + (jt = on - Or)) + (jt - en)),
                                  (In = Bn - (Ar + (jt = Bn - Ar)) + (jt - en)),
                                  Wi === 0 &&
                                    hi === 0 &&
                                    Zi === 0 &&
                                    In === 0) ||
                                  ((Gf = Ue * an + re * Math.abs($l)),
                                  ($l +=
                                    tr * In + Ar * Wi - (Or * Zi + br * hi)) >=
                                    Gf || -$l >= Gf)
                                )
                                  return $l;
                                ((Ge[0] =
                                  (pr =
                                    (kn =
                                      Wi - (fn = (Si = ee * Wi) - (Si - Wi))) *
                                      (Yn =
                                        Ar -
                                        (vn = (Si = ee * Ar) - (Si - Ar))) -
                                    ((vr = Wi * Ar) -
                                      fn * vn -
                                      kn * vn -
                                      fn * Yn)) -
                                  ((Yi =
                                    pr -
                                    (Qo =
                                      (kn =
                                        hi -
                                        (fn = (Si = ee * hi) - (Si - hi))) *
                                        (Yn =
                                          br -
                                          (vn = (Si = ee * br) - (Si - br))) -
                                      ((is = hi * br) -
                                        fn * vn -
                                        kn * vn -
                                        fn * Yn))) +
                                    (jt = pr - Yi)) +
                                  (jt - Qo)),
                                  (Ge[1] =
                                    (ts =
                                      vr -
                                      ((Zn = vr + Yi) - (jt = Zn - vr)) +
                                      (Yi - jt)) -
                                    ((Yi = ts - is) + (jt = ts - Yi)) +
                                    (jt - is)),
                                  (Ge[2] =
                                    Zn -
                                    ((Kn = Zn + Yi) - (jt = Kn - Zn)) +
                                    (Yi - jt)),
                                  (Ge[3] = Kn));
                                var gA = ve(4, it, 4, Ge, Xe);
                                ((Ge[0] =
                                  (pr =
                                    (kn =
                                      tr - (fn = (Si = ee * tr) - (Si - tr))) *
                                      (Yn =
                                        In -
                                        (vn = (Si = ee * In) - (Si - In))) -
                                    ((vr = tr * In) -
                                      fn * vn -
                                      kn * vn -
                                      fn * Yn)) -
                                  ((Yi =
                                    pr -
                                    (Qo =
                                      (kn =
                                        Or -
                                        (fn = (Si = ee * Or) - (Si - Or))) *
                                        (Yn =
                                          Zi -
                                          (vn = (Si = ee * Zi) - (Si - Zi))) -
                                      ((is = Or * Zi) -
                                        fn * vn -
                                        kn * vn -
                                        fn * Yn))) +
                                    (jt = pr - Yi)) +
                                  (jt - Qo)),
                                  (Ge[1] =
                                    (ts =
                                      vr -
                                      ((Zn = vr + Yi) - (jt = Zn - vr)) +
                                      (Yi - jt)) -
                                    ((Yi = ts - is) + (jt = ts - Yi)) +
                                    (jt - is)),
                                  (Ge[2] =
                                    Zn -
                                    ((Kn = Zn + Yi) - (jt = Kn - Zn)) +
                                    (Yi - jt)),
                                  (Ge[3] = Kn));
                                var _A = ve(gA, Xe, 4, Ge, tt);
                                ((Ge[0] =
                                  (pr =
                                    (kn =
                                      Wi - (fn = (Si = ee * Wi) - (Si - Wi))) *
                                      (Yn =
                                        In -
                                        (vn = (Si = ee * In) - (Si - In))) -
                                    ((vr = Wi * In) -
                                      fn * vn -
                                      kn * vn -
                                      fn * Yn)) -
                                  ((Yi =
                                    pr -
                                    (Qo =
                                      (kn =
                                        hi -
                                        (fn = (Si = ee * hi) - (Si - hi))) *
                                        (Yn =
                                          Zi -
                                          (vn = (Si = ee * Zi) - (Si - Zi))) -
                                      ((is = hi * Zi) -
                                        fn * vn -
                                        kn * vn -
                                        fn * Yn))) +
                                    (jt = pr - Yi)) +
                                  (jt - Qo)),
                                  (Ge[1] =
                                    (ts =
                                      vr -
                                      ((Zn = vr + Yi) - (jt = Zn - vr)) +
                                      (Yi - jt)) -
                                    ((Yi = ts - is) + (jt = ts - Yi)) +
                                    (jt - is)),
                                  (Ge[2] =
                                    Zn -
                                    ((Kn = Zn + Yi) - (jt = Kn - Zn)) +
                                    (Yi - jt)),
                                  (Ge[3] = Kn));
                                var yA = ve(_A, tt, 4, Ge, nt);
                                return nt[yA - 1];
                              })(xt, _t, It, $t, yi, xi, vi);
                        })(te[0], te[1], se[0], se[1], $e[0], $e[1]);
                        return ut > 0 ? -1 : ut < 0 ? 1 : 0;
                      }
                      function Ne(te, se) {
                        var $e = te.point,
                          ut = se.point;
                        return $e[0] > ut[0]
                          ? 1
                          : $e[0] < ut[0]
                            ? -1
                            : $e[1] !== ut[1]
                              ? $e[1] > ut[1]
                                ? 1
                                : -1
                              : (function (xt, _t, It, $t) {
                                  return xt.left !== _t.left
                                    ? xt.left
                                      ? 1
                                      : -1
                                    : Je(
                                          It,
                                          xt.otherEvent.point,
                                          _t.otherEvent.point,
                                        ) !== 0
                                      ? xt.isBelow(_t.otherEvent.point)
                                        ? -1
                                        : 1
                                      : !xt.isSubject && _t.isSubject
                                        ? 1
                                        : -1;
                                })(te, se, $e);
                      }
                      function je(te, se, $e) {
                        var ut = new J(se, !1, te, te.isSubject),
                          xt = new J(se, !0, te.otherEvent, te.isSubject);
                        return (
                          V(te.point, te.otherEvent.point) &&
                            console.warn(
                              "what is that, a collapsed segment?",
                              te,
                            ),
                          (ut.contourId = xt.contourId = te.contourId),
                          Ne(xt, te.otherEvent) > 0 &&
                            ((te.otherEvent.left = !0), (xt.left = !1)),
                          (te.otherEvent.otherEvent = xt),
                          (te.otherEvent = ut),
                          $e.push(xt),
                          $e.push(ut),
                          $e
                        );
                      }
                      function at(te, se) {
                        return te[0] * se[1] - te[1] * se[0];
                      }
                      function ct(te, se) {
                        return te[0] * se[0] + te[1] * se[1];
                      }
                      function Nt(te, se, $e) {
                        var ut = (function (yi, xi, ai, Gi, Qi) {
                            var vi = [xi[0] - yi[0], xi[1] - yi[1]],
                              En = [Gi[0] - ai[0], Gi[1] - ai[1]];
                            function on(Si, fn, kn) {
                              return [Si[0] + fn * kn[0], Si[1] + fn * kn[1]];
                            }
                            var Ni = [ai[0] - yi[0], ai[1] - yi[1]],
                              Bn = at(vi, En),
                              dn = Bn * Bn,
                              en = ct(vi, vi);
                            if (dn > 0) {
                              var an = at(Ni, En) / Bn;
                              if (an < 0 || an > 1) return null;
                              var Wi = at(Ni, vi) / Bn;
                              return Wi < 0 || Wi > 1
                                ? null
                                : an === 0 || an === 1
                                  ? [on(yi, an, vi)]
                                  : Wi === 0 || Wi === 1
                                    ? [on(ai, Wi, En)]
                                    : [on(yi, an, vi)];
                            }
                            if ((dn = (Bn = at(Ni, vi)) * Bn) > 0) return null;
                            var hi = ct(vi, Ni) / en,
                              Zi = hi + ct(vi, En) / en,
                              In = Math.min(hi, Zi),
                              jt = Math.max(hi, Zi);
                            return In <= 1 && jt >= 0
                              ? In === 1
                                ? [on(yi, In > 0 ? In : 0, vi)]
                                : jt === 0
                                  ? [on(yi, jt < 1 ? jt : 1, vi)]
                                  : [
                                      on(yi, In > 0 ? In : 0, vi),
                                      on(yi, jt < 1 ? jt : 1, vi),
                                    ]
                              : null;
                          })(
                            te.point,
                            te.otherEvent.point,
                            se.point,
                            se.otherEvent.point,
                          ),
                          xt = ut ? ut.length : 0;
                        if (
                          xt === 0 ||
                          (xt === 1 &&
                            (V(te.point, se.point) ||
                              V(te.otherEvent.point, se.otherEvent.point))) ||
                          (xt === 2 && te.isSubject === se.isSubject)
                        )
                          return 0;
                        if (xt === 1)
                          return (
                            V(te.point, ut[0]) ||
                              V(te.otherEvent.point, ut[0]) ||
                              je(te, ut[0], $e),
                            V(se.point, ut[0]) ||
                              V(se.otherEvent.point, ut[0]) ||
                              je(se, ut[0], $e),
                            1
                          );
                        var _t = [],
                          It = !1,
                          $t = !1;
                        return (
                          V(te.point, se.point)
                            ? (It = !0)
                            : Ne(te, se) === 1
                              ? _t.push(se, te)
                              : _t.push(te, se),
                          V(te.otherEvent.point, se.otherEvent.point)
                            ? ($t = !0)
                            : Ne(te.otherEvent, se.otherEvent) === 1
                              ? _t.push(se.otherEvent, te.otherEvent)
                              : _t.push(te.otherEvent, se.otherEvent),
                          (It && $t) || It
                            ? ((se.type = b),
                              (te.type = se.inOut === te.inOut ? E : A),
                              It &&
                                !$t &&
                                je(_t[1].otherEvent, _t[0].point, $e),
                              2)
                            : $t
                              ? (je(_t[0], _t[1].point, $e), 3)
                              : _t[0] !== _t[3].otherEvent
                                ? (je(_t[0], _t[1].point, $e),
                                  je(_t[1], _t[2].point, $e),
                                  3)
                                : (je(_t[0], _t[1].point, $e),
                                  je(_t[3].otherEvent, _t[2].point, $e),
                                  3)
                        );
                      }
                      function Ct(te, se) {
                        if (te === se) return 0;
                        if (
                          Je(te.point, te.otherEvent.point, se.point) !== 0 ||
                          Je(
                            te.point,
                            te.otherEvent.point,
                            se.otherEvent.point,
                          ) !== 0
                        )
                          return V(te.point, se.point)
                            ? te.isBelow(se.otherEvent.point)
                              ? -1
                              : 1
                            : te.point[0] === se.point[0]
                              ? te.point[1] < se.point[1]
                                ? -1
                                : 1
                              : Ne(te, se) === 1
                                ? se.isAbove(te.point)
                                  ? -1
                                  : 1
                                : te.isBelow(se.point)
                                  ? -1
                                  : 1;
                        if (te.isSubject !== se.isSubject)
                          return te.isSubject ? -1 : 1;
                        var $e = te.point,
                          ut = se.point;
                        return $e[0] === ut[0] && $e[1] === ut[1]
                          ? ($e = te.otherEvent.point)[0] ===
                              (ut = se.otherEvent.point)[0] && $e[1] === ut[1]
                            ? 0
                            : te.contourId > se.contourId
                              ? 1
                              : -1
                          : Ne(te, se) === 1
                            ? 1
                            : -1;
                      }
                      var yt = function () {
                        ((this.points = []),
                          (this.holeIds = []),
                          (this.holeOf = null),
                          (this.depth = null));
                      };
                      function ot(te, se, $e, ut) {
                        var xt,
                          _t = te + 1,
                          It = se[te].point,
                          $t = se.length;
                        for (
                          _t < $t && (xt = se[_t].point);
                          _t < $t && xt[0] === It[0] && xt[1] === It[1];

                        ) {
                          if (!$e[_t]) return _t;
                          ++_t < $t && (xt = se[_t].point);
                        }
                        for (_t = te - 1; $e[_t] && _t > ut; ) _t--;
                        return _t;
                      }
                      yt.prototype.isExterior = function () {
                        return this.holeOf == null;
                      };
                      var Jt = Dt,
                        At = Dt;
                      function Dt(te, se) {
                        if (!(this instanceof Dt)) return new Dt(te, se);
                        if (
                          ((this.data = te || []),
                          (this.length = this.data.length),
                          (this.compare = se || Wt),
                          this.length > 0)
                        )
                          for (var $e = (this.length >> 1) - 1; $e >= 0; $e--)
                            this._down($e);
                      }
                      function Wt(te, se) {
                        return te < se ? -1 : te > se ? 1 : 0;
                      }
                      ((Dt.prototype = {
                        push: function (te) {
                          (this.data.push(te),
                            this.length++,
                            this._up(this.length - 1));
                        },
                        pop: function () {
                          if (this.length !== 0) {
                            var te = this.data[0];
                            return (
                              this.length--,
                              this.length > 0 &&
                                ((this.data[0] = this.data[this.length]),
                                this._down(0)),
                              this.data.pop(),
                              te
                            );
                          }
                        },
                        peek: function () {
                          return this.data[0];
                        },
                        _up: function (te) {
                          for (
                            var se = this.data, $e = this.compare, ut = se[te];
                            te > 0;

                          ) {
                            var xt = (te - 1) >> 1,
                              _t = se[xt];
                            if ($e(ut, _t) >= 0) break;
                            ((se[te] = _t), (te = xt));
                          }
                          se[te] = ut;
                        },
                        _down: function (te) {
                          for (
                            var se = this.data,
                              $e = this.compare,
                              ut = this.length >> 1,
                              xt = se[te];
                            te < ut;

                          ) {
                            var _t = 1 + (te << 1),
                              It = _t + 1,
                              $t = se[_t];
                            if (
                              (It < this.length &&
                                $e(se[It], $t) < 0 &&
                                ((_t = It), ($t = se[It])),
                              $e($t, xt) >= 0)
                            )
                              break;
                            ((se[te] = $t), (te = _t));
                          }
                          se[te] = xt;
                        },
                      }),
                        (Jt.default = At));
                      var ni = Math.max,
                        ii = Math.min,
                        di = 0;
                      function oi(te, se, $e, ut, xt, _t) {
                        var It, $t, yi, xi, ai, Gi;
                        for (It = 0, $t = te.length - 1; It < $t; It++)
                          if (
                            ((xi = te[It + 1]),
                            (ai = new J((yi = te[It]), !1, void 0, se)),
                            (Gi = new J(xi, !1, ai, se)),
                            (ai.otherEvent = Gi),
                            yi[0] !== xi[0] || yi[1] !== xi[1])
                          ) {
                            ((ai.contourId = Gi.contourId = $e),
                              _t ||
                                ((ai.isExteriorRing = !1),
                                (Gi.isExteriorRing = !1)),
                              Ne(ai, Gi) > 0 ? (Gi.left = !0) : (ai.left = !0));
                            var Qi = yi[0],
                              vi = yi[1];
                            ((xt[0] = ii(xt[0], Qi)),
                              (xt[1] = ii(xt[1], vi)),
                              (xt[2] = ni(xt[2], Qi)),
                              (xt[3] = ni(xt[3], vi)),
                              ut.push(ai),
                              ut.push(Gi));
                          }
                      }
                      var fi = [];
                      function Bi(te, se, $e) {
                        (typeof te[0][0][0] == "number" && (te = [te]),
                          typeof se[0][0][0] == "number" && (se = [se]));
                        var ut = (function (vi, En, on) {
                          var Ni = null;
                          return (
                            vi.length * En.length == 0 &&
                              (on === M
                                ? (Ni = fi)
                                : on === k
                                  ? (Ni = vi)
                                  : (on !== R && on !== N) ||
                                    (Ni = vi.length === 0 ? En : vi)),
                            Ni
                          );
                        })(te, se, $e);
                        if (ut) return ut === fi ? null : ut;
                        var xt = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                          _t = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                          It = (function (vi, En, on, Ni, Bn) {
                            var dn,
                              en,
                              an,
                              Wi,
                              hi,
                              Zi,
                              In = new Jt(null, Ne);
                            for (an = 0, Wi = vi.length; an < Wi; an++)
                              for (
                                hi = 0, Zi = (dn = vi[an]).length;
                                hi < Zi;
                                hi++
                              )
                                ((en = hi === 0) && di++,
                                  oi(dn[hi], !0, di, In, on, en));
                            for (an = 0, Wi = En.length; an < Wi; an++)
                              for (
                                hi = 0, Zi = (dn = En[an]).length;
                                hi < Zi;
                                hi++
                              )
                                ((en = hi === 0),
                                  Bn === k && (en = !1),
                                  en && di++,
                                  oi(dn[hi], !1, di, In, Ni, en));
                            return In;
                          })(te, se, xt, _t, $e);
                        if (
                          (ut = (function (vi, En, on, Ni, Bn) {
                            var dn = null;
                            return (
                              (on[0] > Ni[2] ||
                                Ni[0] > on[2] ||
                                on[1] > Ni[3] ||
                                Ni[1] > on[3]) &&
                                (Bn === M
                                  ? (dn = fi)
                                  : Bn === k
                                    ? (dn = vi)
                                    : (Bn !== R && Bn !== N) ||
                                      (dn = vi.concat(En))),
                              dn
                            );
                          })(te, se, xt, _t, $e))
                        )
                          return ut === fi ? null : ut;
                        for (
                          var $t = (function (vi) {
                              var En,
                                on,
                                Ni = (function (an) {
                                  var Wi,
                                    hi,
                                    Zi,
                                    In,
                                    jt = [];
                                  for (hi = 0, Zi = an.length; hi < Zi; hi++)
                                    (((Wi = an[hi]).left && Wi.inResult) ||
                                      (!Wi.left && Wi.otherEvent.inResult)) &&
                                      jt.push(Wi);
                                  for (var Si = !1; !Si; )
                                    for (
                                      Si = !0, hi = 0, Zi = jt.length;
                                      hi < Zi;
                                      hi++
                                    )
                                      hi + 1 < Zi &&
                                        Ne(jt[hi], jt[hi + 1]) === 1 &&
                                        ((In = jt[hi]),
                                        (jt[hi] = jt[hi + 1]),
                                        (jt[hi + 1] = In),
                                        (Si = !1));
                                  for (hi = 0, Zi = jt.length; hi < Zi; hi++)
                                    (Wi = jt[hi]).otherPos = hi;
                                  for (hi = 0, Zi = jt.length; hi < Zi; hi++)
                                    (Wi = jt[hi]).left ||
                                      ((In = Wi.otherPos),
                                      (Wi.otherPos = Wi.otherEvent.otherPos),
                                      (Wi.otherEvent.otherPos = In));
                                  return jt;
                                })(vi),
                                Bn = {},
                                dn = [],
                                en = function () {
                                  if (!Bn[En]) {
                                    var an = dn.length,
                                      Wi = (function (jt, Si, fn) {
                                        var kn = new yt();
                                        if (jt.prevInResult != null) {
                                          var vn = jt.prevInResult,
                                            Yn = vn.outputContourId;
                                          if (vn.resultTransition > 0) {
                                            var Yi = Si[Yn];
                                            if (Yi.holeOf != null) {
                                              var Zn = Yi.holeOf;
                                              (Si[Zn].holeIds.push(fn),
                                                (kn.holeOf = Zn),
                                                (kn.depth = Si[Yn].depth));
                                            } else
                                              (Si[Yn].holeIds.push(fn),
                                                (kn.holeOf = Yn),
                                                (kn.depth = Si[Yn].depth + 1));
                                          } else
                                            ((kn.holeOf = null),
                                              (kn.depth = Si[Yn].depth));
                                        } else
                                          ((kn.holeOf = null), (kn.depth = 0));
                                        return kn;
                                      })(Ni[En], dn, an),
                                      hi = function (jt) {
                                        ((Bn[jt] = !0),
                                          jt < Ni.length &&
                                            Ni[jt] &&
                                            (Ni[jt].outputContourId = an));
                                      },
                                      Zi = En,
                                      In = En;
                                    for (
                                      Wi.points.push(Ni[En].point);
                                      hi(Zi),
                                        hi((Zi = Ni[Zi].otherPos)),
                                        Wi.points.push(Ni[Zi].point),
                                        !(
                                          (Zi = ot(Zi, Ni, Bn, In)) == In ||
                                          Zi >= Ni.length
                                        ) && Ni[Zi];

                                    );
                                    dn.push(Wi);
                                  }
                                };
                              for (En = 0, on = Ni.length; En < on; En++) en();
                              return dn;
                            })(
                              (function (vi, En, on, Ni, Bn, dn) {
                                for (
                                  var en,
                                    an,
                                    Wi,
                                    hi = new a(Ct),
                                    Zi = [],
                                    In = Math.min(Ni[2], Bn[2]);
                                  vi.length !== 0;

                                ) {
                                  var jt = vi.pop();
                                  if (
                                    (Zi.push(jt),
                                    (dn === M && jt.point[0] > In) ||
                                      (dn === k && jt.point[0] > Ni[2]))
                                  )
                                    break;
                                  if (jt.left) {
                                    ((an = en = hi.insert(jt)),
                                      (en =
                                        en !== (Wi = hi.minNode())
                                          ? hi.prev(en)
                                          : null),
                                      (an = hi.next(an)));
                                    var Si = en ? en.key : null;
                                    if (
                                      (j(jt, Si, dn),
                                      an &&
                                        Nt(jt, an.key, vi) === 2 &&
                                        (j(jt, Si, dn), j(an.key, jt, dn)),
                                      en && Nt(en.key, jt, vi) === 2)
                                    ) {
                                      var fn = en;
                                      (j(
                                        Si,
                                        (fn = fn !== Wi ? hi.prev(fn) : null)
                                          ? fn.key
                                          : null,
                                        dn,
                                      ),
                                        j(jt, Si, dn));
                                    }
                                  } else
                                    ((an = en = hi.find((jt = jt.otherEvent))),
                                      en &&
                                        an &&
                                        ((en = en !== Wi ? hi.prev(en) : null),
                                        (an = hi.next(an)),
                                        hi.remove(jt),
                                        an && en && Nt(en.key, an.key, vi)));
                                }
                                return Zi;
                              })(It, 0, 0, xt, _t, $e),
                            ),
                            yi = [],
                            xi = 0;
                          xi < $t.length;
                          xi++
                        ) {
                          var ai = $t[xi];
                          if (ai.isExterior()) {
                            for (
                              var Gi = [ai.points], Qi = 0;
                              Qi < ai.holeIds.length;
                              Qi++
                            )
                              Gi.push($t[ai.holeIds[Qi]].points);
                            yi.push(Gi);
                          }
                        }
                        return yi;
                      }
                      var sn = {
                        UNION: R,
                        DIFFERENCE: k,
                        INTERSECTION: M,
                        XOR: N,
                      };
                      ((i.diff = function (te, se) {
                        return Bi(te, se, k);
                      }),
                        (i.intersection = function (te, se) {
                          return Bi(te, se, M);
                        }),
                        (i.operations = sn),
                        (i.union = function (te, se) {
                          return Bi(te, se, R);
                        }),
                        (i.xor = function (te, se) {
                          return Bi(te, se, N);
                        }),
                        Object.defineProperty(i, "__esModule", { value: !0 }));
                    })(e);
                  })(0, Jv.exports)),
                Jv.exports);
            /**
             * martinez v0.7.4
             * Martinez polygon clipping algorithm, does boolean operation on polygons (multipolygons, polygons with holes etc): intersection, union, difference, xor
             *
             * @author Alex Milevski <info@w8r.name>
             * @license MIT
             * @preserve
             */ function Rm(n, e, i, o) {
              const a = [],
                u =
                  o === 0
                    ? (d, _, v, b, E, A) => {
                        d.push(new ft(A, v + ((A - _) / (b - _)) * (E - v)));
                      }
                    : (d, _, v, b, E, A) => {
                        d.push(new ft(_ + ((A - v) / (E - v)) * (b - _), A));
                      };
              for (const d of n) {
                const _ = [];
                for (const v of d) {
                  if (v.length <= 2) continue;
                  const b = [];
                  for (let M = 0; M < v.length - 1; M++) {
                    const R = v[M].x,
                      k = v[M].y,
                      N = v[M + 1].x,
                      j = v[M + 1].y,
                      H = o === 0 ? R : k,
                      J = o === 0 ? N : j;
                    (H < e
                      ? J > e && u(b, R, k, N, j, e)
                      : H > i
                        ? J < i && u(b, R, k, N, j, i)
                        : b.push(v[M]),
                      J < e && H >= e && u(b, R, k, N, j, e),
                      J > i && H <= i && u(b, R, k, N, j, i));
                  }
                  let E = v[v.length - 1];
                  const A = o === 0 ? E.x : E.y;
                  (A >= e && A <= i && b.push(E),
                    b.length &&
                      ((E = b[b.length - 1]),
                      (b[0].x === E.x && b[0].y === E.y) || b.push(b[0]),
                      _.push(b)));
                }
                _.length && a.push(_);
              }
              return a;
            }
            function CS(n, e) {
              const i = ry(n),
                o = ry([e]),
                a = Qv.intersection(i, o);
              return a == null ? [] : e0(a);
            }
            function PS(n, e) {
              let o = ry(n, 65536);
              for (; e.valid(); e.next()) {
                const [a, u] = e.get(),
                  d = a.x * 65536,
                  _ = a.y * 65536,
                  v = u.x * 65536,
                  b = u.y * 65536,
                  E = v - d,
                  A = b - _,
                  M = Math.hypot(E, A),
                  R = Math.trunc((A / M) * 3),
                  k = -Math.trunc((E / M) * 3);
                o = Qv.diff(o, [
                  [
                    [d, _],
                    [v, b],
                    [v + R, b + k],
                    [d + R, _ + k],
                    [d, _],
                  ],
                ]);
              }
              return e0(o, 1 / 65536);
            }
            function ry(n, e = 1) {
              return [n.map((i) => i.map((o) => [o.x * e, o.y * e]))];
            }
            function e0(n, e = 1) {
              return n.map((i) =>
                i.map((o, a) => {
                  const u = o.map((d) => new ft(d[0] * e, d[1] * e).round());
                  return (a > 0 && u.reverse(), u);
                }),
              );
            }
            class sy {
              constructor(e, i) {
                ((this.layoutVertexArray = new po()),
                  (this.indexArray = new dr()),
                  (this.lineIndexArray = new Ho()),
                  (this.triangleSegments = new Rn()),
                  (this.lineSegments = new Rn()),
                  (this.programConfigurations = new c(e.layers, {
                    zoom: e.zoom,
                    lut: e.lut,
                  })),
                  (this.uploaded = !1),
                  i && (this.elevatedLayoutVertexArray = new Go()));
              }
              update(e, i, o, a, u, d, _, v) {
                this.programConfigurations.updatePaintArrays(
                  e,
                  i,
                  u,
                  o,
                  a,
                  d,
                  _,
                  v,
                );
              }
              isEmpty() {
                return this.layoutVertexArray.length === 0;
              }
              needsUpload() {
                return this.programConfigurations.needsUpload;
              }
              upload(e) {
                (this.uploaded ||
                  ((this.layoutVertexBuffer = e.createVertexBuffer(
                    this.layoutVertexArray,
                    pS.members,
                  )),
                  (this.indexBuffer = e.createIndexBuffer(this.indexArray)),
                  (this.lineIndexBuffer = e.createIndexBuffer(
                    this.lineIndexArray,
                  )),
                  this.elevatedLayoutVertexArray &&
                    this.elevatedLayoutVertexArray.length > 0 &&
                    (this.elevatedLayoutVertexBuffer = e.createVertexBuffer(
                      this.elevatedLayoutVertexArray,
                      mS.members,
                    ))),
                  this.programConfigurations.upload(e),
                  (this.uploaded = !0));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.elevatedLayoutVertexBuffer &&
                    this.elevatedLayoutVertexBuffer.destroy(),
                  this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.lineIndexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.triangleSegments.destroy(),
                  this.lineSegments.destroy());
              }
              populatePaintArrays(e, i, o, a, u, d, _) {
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  e,
                  i,
                  o,
                  a,
                  u,
                  d,
                  void 0,
                  _,
                );
              }
            }
            class oy {
              constructor(e) {
                ((this.zoom = e.zoom),
                  (this.pixelRatio = e.pixelRatio),
                  (this.overscaling = e.overscaling),
                  (this.layers = e.layers),
                  (this.layerIds = this.layers.map((i) => i.fqid)),
                  (this.index = e.index),
                  (this.hasPattern = !1),
                  (this.patternFeatures = []),
                  (this.lut = e.lut),
                  (this.bufferData = new sy(e, !1)),
                  (this.elevationBufferData = new sy(e, !0)),
                  (this.stateDependentLayerIds = this.layers
                    .filter((i) => i.isStateDependent())
                    .map((i) => i.id)),
                  (this.projection = e.projection),
                  (this.elevationMode = this.layers[0].layout.get(
                    "fill-elevation-reference",
                  )),
                  (this.sourceLayerIndex = e.sourceLayerIndex),
                  (this.worldview = e.worldview));
              }
              updateFootprints(e, i) {}
              populate(e, i, o, a) {
                this.hasPattern = iy("fill", this.layers, this.pixelRatio, i);
                const u = this.layers[0].layout.get("fill-sort-key"),
                  d = [];
                for (const {
                  feature: _,
                  id: v,
                  index: b,
                  sourceLayerIndex: E,
                } of e) {
                  const A = this.layers[0]._featureFilter.needGeometry,
                    M = bt(_, A);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new qi(this.zoom, { worldview: this.worldview }),
                      M,
                      o,
                    )
                  )
                    continue;
                  const R = u
                      ? u.evaluate(M, {}, o, i.availableImages)
                      : void 0,
                    k = {
                      id: v,
                      properties: _.properties,
                      type: _.type,
                      sourceLayerIndex: E,
                      index: b,
                      geometry: A ? M.geometry : Et(_, o, a),
                      patterns: {},
                      sortKey: R,
                    };
                  d.push(k);
                }
                u && d.sort((_, v) => _.sortKey - v.sortKey);
                for (const _ of d) {
                  const { geometry: v, index: b, sourceLayerIndex: E } = _;
                  if (this.hasPattern) {
                    const A = ny(
                      "fill",
                      this.layers,
                      _,
                      this.zoom,
                      this.pixelRatio,
                      i,
                    );
                    this.patternFeatures.push(A);
                  } else
                    this.addFeature(
                      _,
                      v,
                      b,
                      o,
                      {},
                      i.availableImages,
                      i.brightness,
                      i.elevationFeatures,
                    );
                  i.featureIndex.insert(e[b].feature, v, b, E, this.index);
                }
              }
              update(e, i, o, a, u, d, _) {
                (this.bufferData.update(e, i, o, a, u, d, _, this.worldview),
                  this.elevationBufferData.update(
                    e,
                    i,
                    o,
                    a,
                    u,
                    d,
                    _,
                    this.worldview,
                  ),
                  this.elevatedStructures &&
                    this.elevatedStructures.update(
                      e,
                      i,
                      o,
                      a,
                      u,
                      d,
                      _,
                      this.worldview,
                    ));
              }
              addFeatures(e, i, o, a, u, d) {
                for (const _ of this.patternFeatures)
                  this.addFeature(
                    _,
                    _.geometry,
                    _.index,
                    i,
                    o,
                    a,
                    d,
                    e.elevationFeatures,
                  );
              }
              isEmpty() {
                return (
                  this.bufferData.isEmpty() &&
                  this.elevationBufferData.isEmpty()
                );
              }
              uploadPending() {
                return (
                  !this.uploaded ||
                  this.bufferData.needsUpload() ||
                  this.elevationBufferData.needsUpload()
                );
              }
              upload(e) {
                (this.bufferData.upload(e),
                  this.elevationBufferData.upload(e),
                  this.elevatedStructures && this.elevatedStructures.upload(e));
              }
              destroy() {
                (this.bufferData.destroy(),
                  this.elevationBufferData.destroy(),
                  this.elevatedStructures && this.elevatedStructures.destroy());
              }
              addFeature(e, i, o, a, u, d = [], _, v) {
                const b = Dm(i, 500);
                (this.elevationMode !== "none"
                  ? this.addElevatedRoadFeature(e, b, a, o, v)
                  : this.addGeometry(b, this.bufferData),
                  this.bufferData.populatePaintArrays(
                    e,
                    o,
                    u,
                    d,
                    a,
                    _,
                    this.worldview,
                  ),
                  this.elevationBufferData.populatePaintArrays(
                    e,
                    o,
                    u,
                    d,
                    a,
                    _,
                    this.worldview,
                  ));
              }
              getUnevaluatedPortalGraph() {
                return this.elevatedStructures
                  ? this.elevatedStructures.unevaluatedPortals
                  : void 0;
              }
              getElevationPolygons() {
                return this.elevatedStructures
                  ? this.elevatedStructures.portalPolygons
                  : void 0;
              }
              setEvaluatedPortalGraph(e, i, o, a, u) {
                this.elevatedStructures &&
                  (this.elevatedStructures.construct(e),
                  this.elevatedStructures.populatePaintArrays(
                    i,
                    o,
                    a,
                    u,
                    this.worldview,
                  ));
              }
              addElevatedRoadFeature(e, i, o, a, u) {
                const d = new Array(),
                  _ = cs.getElevationFeature(e, u);
                if (!_) return void this.addGeometry(i, this.bufferData);
                {
                  const b = this.clipPolygonsToTile(i, 1);
                  b.length > 0 &&
                    d.push({
                      polygons: b,
                      elevationFeature: _,
                      elevationTileID: o,
                    });
                }
                const v = {
                  guardRailEnabled: this.layers[0].layout
                    .get("fill-construct-bridge-guard-rail")
                    .evaluate(e, {}, o),
                  featureIndex: a,
                };
                for (const b of d)
                  if (b.elevationFeature) {
                    if (this.elevationMode === "hd-road-base") {
                      this.elevatedStructures ||
                        (this.elevatedStructures = new Ts(
                          b.elevationTileID,
                          this.layers,
                          this.zoom,
                          this.lut,
                        ));
                      const A = b.elevationFeature.isTunnel();
                      let M = 0;
                      e.properties.hasOwnProperty(cn) &&
                        (M = +e.properties[cn]);
                      for (const R of b.polygons)
                        this.elevatedStructures.addPortalCandidates(
                          b.elevationFeature.id,
                          R,
                          A,
                          b.elevationFeature,
                          M,
                        );
                    }
                    b.elevationFeature.constantHeight == null &&
                      (b.polygons = this.prepareElevatedPolygons(
                        b.polygons,
                        b.elevationFeature,
                        b.elevationTileID,
                      ));
                    const E = new zs(o, b.elevationTileID);
                    this.addElevatedGeometry(
                      b.polygons,
                      E,
                      b.elevationFeature,
                      this.elevationMode === "hd-road-base" ? 0 : 0.05,
                      a,
                      v,
                    );
                  }
              }
              addElevatedGeometry(e, i, o, a, u, d) {
                const _ = {
                    elevation: o,
                    elevationSampler: i,
                    bias: a,
                    index: u,
                    featureInfo: d,
                  },
                  [v, b] = this.addGeometry(e, this.elevationBufferData, _);
                this.elevationBufferData.heightRange == null
                  ? (this.elevationBufferData.heightRange = { min: v, max: b })
                  : ((this.elevationBufferData.heightRange.min = Math.min(
                      this.elevationBufferData.heightRange.min,
                      v,
                    )),
                    (this.elevationBufferData.heightRange.max = Math.max(
                      this.elevationBufferData.heightRange.max,
                      b,
                    )));
              }
              addGeometry(e, i, o) {
                let a = Number.POSITIVE_INFINITY,
                  u = Number.NEGATIVE_INFINITY,
                  d = null;
                o &&
                  ((d = o.elevationSampler.constantElevation(
                    o.elevation,
                    o.bias,
                  )),
                  d != null && ((a = d), (u = d)));
                const _ = (v, b, E) => {
                  if (o != null)
                    if ((b.push(v), d != null))
                      (i.elevatedLayoutVertexArray.emplaceBack(d), E.push(d));
                    else {
                      const A = o.elevationSampler.pointElevation(
                        v,
                        o.elevation,
                        o.bias,
                      );
                      (i.elevatedLayoutVertexArray.emplaceBack(A),
                        E.push(A),
                        (a = Math.min(a, A)),
                        (u = Math.max(u, A)));
                    }
                };
                for (const v of e) {
                  let b = 0;
                  for (const Q of v) b += Q.length;
                  const E = i.triangleSegments.prepareSegment(
                      b,
                      i.layoutVertexArray,
                      i.indexArray,
                    ),
                    A = E.vertexLength,
                    M = [],
                    R = [],
                    k = [],
                    N = [],
                    j = [],
                    H = i.layoutVertexArray.length;
                  for (const Q of v) {
                    if (Q.length === 0) continue;
                    Q !== v[0] && R.push(M.length / 2);
                    const V = i.lineSegments.prepareSegment(
                        Q.length,
                        i.layoutVertexArray,
                        i.lineIndexArray,
                      ),
                      X = V.vertexLength;
                    (o && j.push(i.layoutVertexArray.length - H),
                      _(Q[0], k, N),
                      i.layoutVertexArray.emplaceBack(Q[0].x, Q[0].y),
                      i.lineIndexArray.emplaceBack(X + Q.length - 1, X),
                      M.push(Q[0].x),
                      M.push(Q[0].y));
                    for (let ee = 1; ee < Q.length; ee++)
                      (_(Q[ee], k, N),
                        i.layoutVertexArray.emplaceBack(Q[ee].x, Q[ee].y),
                        i.lineIndexArray.emplaceBack(X + ee - 1, X + ee),
                        M.push(Q[ee].x),
                        M.push(Q[ee].y));
                    ((V.vertexLength += Q.length),
                      (V.primitiveLength += Q.length));
                  }
                  const J = uf(M, R);
                  for (let Q = 0; Q < J.length; Q += 3)
                    i.indexArray.emplaceBack(
                      A + J[Q],
                      A + J[Q + 1],
                      A + J[Q + 2],
                    );
                  if (
                    J.length > 0 &&
                    o &&
                    this.elevationMode === "hd-road-base"
                  ) {
                    const Q = o.elevation.isTunnel(),
                      V = o.elevation.safeArea,
                      X = this.elevatedStructures.addVertices(k, N);
                    this.elevatedStructures.addTriangles(J, X, Q);
                    const ee = j.length;
                    if (ee > 0) {
                      for (let re = 0; re < ee - 1; re++)
                        this.elevatedStructures.addRenderableRing(
                          o.index,
                          j[re] + X,
                          j[re + 1] - j[re],
                          Q,
                          V,
                          o.featureInfo,
                        );
                      this.elevatedStructures.addRenderableRing(
                        o.index,
                        j[ee - 1] + X,
                        k.length - j[ee - 1],
                        Q,
                        V,
                        o.featureInfo,
                      );
                    }
                  }
                  ((E.vertexLength += b), (E.primitiveLength += J.length / 3));
                }
                return [a, u];
              }
              prepareElevatedPolygons(e, i, o) {
                const a = 1 / Ve(o),
                  u = [];
                for (const d of e) {
                  const _ = PS(d, new es(i, a));
                  u.push(..._);
                }
                return u;
              }
              clipPolygonsToTile(e, i) {
                const o = -i,
                  a = -i,
                  u = mt + i,
                  d = mt + i;
                let _ = 0;
                const v = [],
                  b = [];
                for (; _ < e.length; _++) {
                  const M = e[_],
                    R = dd(M);
                  (R.min.x >= o && R.max.x <= u && R.min.y >= a && R.max.y <= d
                    ? v
                    : b
                  ).push(M);
                }
                if (v.length === e.length) return e;
                const E = [
                    new ft(o, a),
                    new ft(u, a),
                    new ft(u, d),
                    new ft(o, d),
                    new ft(o, a),
                  ],
                  A = v;
                for (const M of b) A.push(...CS(M, E));
                return A;
              }
            }
            let t0, i0, n0, r0;
            (Tt(oy, "FillBucket", { omit: ["layers", "patternFeatures"] }),
              Tt(sy, "FillBufferData"),
              Tt(Ts, "ElevatedStructures"));
            class ay {
              constructor(e, i, o, a) {
                if (
                  ((this.triangleCount = i.length / 3),
                  (this.min = new ft(0, 0)),
                  (this.max = new ft(0, 0)),
                  (this.xScale = 0),
                  (this.yScale = 0),
                  (this.cellsX = 0),
                  (this.cellsY = 0),
                  (this.cells = []),
                  (this.payload = []),
                  this.triangleCount === 0 || e.length === 0)
                )
                  return;
                const [u, d] = [e[0].clone(), e[0].clone()];
                for (let A = 1; A < e.length; ++A) {
                  const M = e[A];
                  ((u.x = Math.min(u.x, M.x)),
                    (u.y = Math.min(u.y, M.y)),
                    (d.x = Math.max(d.x, M.x)),
                    (d.y = Math.max(d.y, M.y)));
                }
                if (a) {
                  const A = Math.ceil(Math.max(d.x - u.x, d.y - u.y) / a);
                  o = Math.max(o, A);
                }
                if (o === 0) return;
                ((this.min = u), (this.max = d));
                const _ = this.max.sub(this.min);
                ((_.x = Math.max(_.x, 1)), (_.y = Math.max(_.y, 1)));
                const v = Math.max(_.x, _.y) / o;
                ((this.cellsX = Math.max(1, Math.ceil(_.x / v))),
                  (this.cellsY = Math.max(1, Math.ceil(_.y / v))),
                  (this.xScale = 1 / v),
                  (this.yScale = 1 / v));
                const b = [];
                for (let A = 0; A < this.triangleCount; A++) {
                  const M = e[i[3 * A + 0]].sub(this.min),
                    R = e[i[3 * A + 1]].sub(this.min),
                    k = e[i[3 * A + 2]].sub(this.min),
                    N = Ko(
                      Math.floor(Math.min(M.x, R.x, k.x)),
                      this.xScale,
                      this.cellsX,
                    ),
                    j = Ko(
                      Math.floor(Math.max(M.x, R.x, k.x)),
                      this.xScale,
                      this.cellsX,
                    ),
                    H = Ko(
                      Math.floor(Math.min(M.y, R.y, k.y)),
                      this.yScale,
                      this.cellsY,
                    ),
                    J = Ko(
                      Math.floor(Math.max(M.y, R.y, k.y)),
                      this.yScale,
                      this.cellsY,
                    ),
                    Q = new ft(0, 0),
                    V = new ft(0, 0),
                    X = new ft(0, 0),
                    ee = new ft(0, 0);
                  for (let re = H; re <= J; ++re) {
                    ((Q.y = V.y = re * v), (X.y = ee.y = (re + 1) * v));
                    for (let ve = N; ve <= j; ++ve)
                      ((Q.x = X.x = ve * v),
                        (V.x = ee.x = (ve + 1) * v),
                        (q_(M, R, k, Q, V, ee) || q_(M, R, k, Q, ee, X)) &&
                          b.push({
                            cellIdx: re * this.cellsX + ve,
                            triIdx: A,
                          }));
                  }
                }
                if (b.length === 0) return;
                b.sort((A, M) => A.cellIdx - M.cellIdx || A.triIdx - M.triIdx);
                let E = 0;
                for (; E < b.length; ) {
                  const A = b[E].cellIdx,
                    M = { start: this.payload.length, len: 0 };
                  for (; E < b.length && b[E].cellIdx === A; )
                    (++M.len, this.payload.push(b[E++].triIdx));
                  this.cells[A] = M;
                }
              }
              _lazyInitLookup() {
                (this.lookup ||
                  (this.lookup = new Uint8Array(
                    Math.ceil(this.triangleCount / 8),
                  )),
                  this.lookup.fill(0));
              }
              queryPoint(e, i) {
                if (
                  this.triangleCount === 0 ||
                  this.cells.length === 0 ||
                  e.x > this.max.x ||
                  this.min.x > e.x ||
                  e.y > this.max.y ||
                  this.min.y > e.y
                )
                  return;
                const o = Ko(e.x - this.min.x, this.xScale, this.cellsX),
                  a = Ko(e.y - this.min.y, this.yScale, this.cellsY),
                  u = this.cells[a * this.cellsX + o];
                if (u) {
                  this._lazyInitLookup();
                  for (let d = 0; d < u.len; d++) {
                    const _ = this.payload[u.start + d],
                      v = Math.floor(_ / 8),
                      b = 1 << _ % 8;
                    if (
                      !(this.lookup[v] & b) &&
                      ((this.lookup[v] |= b),
                      i.push(_),
                      i.length === this.triangleCount)
                    )
                      return;
                  }
                }
              }
              query(e, i, o) {
                if (
                  this.triangleCount === 0 ||
                  this.cells.length === 0 ||
                  e.x > this.max.x ||
                  this.min.x > i.x ||
                  e.y > this.max.y ||
                  this.min.y > i.y
                )
                  return;
                this._lazyInitLookup();
                const a = Ko(e.x - this.min.x, this.xScale, this.cellsX),
                  u = Ko(i.x - this.min.x, this.xScale, this.cellsX),
                  d = Ko(e.y - this.min.y, this.yScale, this.cellsY),
                  _ = Ko(i.y - this.min.y, this.yScale, this.cellsY);
                for (let v = d; v <= _; v++)
                  for (let b = a; b <= u; b++) {
                    const E = this.cells[v * this.cellsX + b];
                    if (E)
                      for (let A = 0; A < E.len; A++) {
                        const M = this.payload[E.start + A],
                          R = Math.floor(M / 8),
                          k = 1 << M % 8;
                        if (
                          !(this.lookup[R] & k) &&
                          ((this.lookup[R] |= k),
                          o.push(M),
                          o.length === this.triangleCount)
                        )
                          return;
                      }
                  }
              }
            }
            function Ko(n, e, i) {
              return Math.max(0, Math.min(i - 1, Math.floor(n * e)));
            }
            Tt(ay, "TriangleGridIndex");
            class s0 {
              constructor(e) {
                ((this.zoom = e.zoom),
                  (this.layers = e.layers),
                  (this.layerIds = this.layers.map((i) => i.fqid)),
                  (this.index = e.index),
                  (this.hasPattern = !1),
                  (this.stateDependentLayerIds = this.layers
                    .filter((i) => i.isStateDependent())
                    .map((i) => i.id)),
                  (this.footprints = []),
                  (this.worldview = e.worldview));
              }
              updateFootprints(e, i) {
                for (const o of this.footprints)
                  i.push({ footprint: o, id: e });
              }
              populate(e, i, o, a) {
                const u = [];
                for (const {
                  feature: d,
                  id: _,
                  index: v,
                  sourceLayerIndex: b,
                } of e) {
                  const E = this.layers[0]._featureFilter.needGeometry,
                    A = bt(d, E);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new qi(this.zoom, { worldview: this.worldview }),
                      A,
                      o,
                    )
                  )
                    continue;
                  const M = {
                    id: _,
                    properties: d.properties,
                    type: d.type,
                    sourceLayerIndex: b,
                    index: v,
                    geometry: E ? A.geometry : Et(d, o, a),
                    patterns: {},
                  };
                  u.push(M);
                }
                for (const d of u) {
                  const { geometry: _, index: v, sourceLayerIndex: b } = d;
                  (this.addFeature(
                    d,
                    _,
                    v,
                    o,
                    {},
                    i.availableImages,
                    i.brightness,
                  ),
                    i.featureIndex.insert(e[v].feature, _, v, b, this.index));
                }
              }
              isEmpty() {
                return this.footprints.length === 0;
              }
              uploadPending() {
                return !1;
              }
              upload(e) {}
              update(e, i, o, a, u, d, _) {}
              destroy() {}
              addFeature(e, i, o, a, u, d = [], _) {
                for (const v of Dm(i, 2)) {
                  const b = [],
                    E = [],
                    A = [],
                    M = new ft(1 / 0, 1 / 0),
                    R = new ft(-1 / 0, -1 / 0);
                  for (const j of v)
                    if (j.length !== 0) {
                      j !== v[0] && A.push(E.length / 2);
                      for (let H = 0; H < j.length; H++)
                        (E.push(j[H].x),
                          E.push(j[H].y),
                          b.push(j[H]),
                          (M.x = Math.min(M.x, j[H].x)),
                          (M.y = Math.min(M.y, j[H].y)),
                          (R.x = Math.max(R.x, j[H].x)),
                          (R.y = Math.max(R.y, j[H].y)));
                    }
                  const k = uf(E, A),
                    N = new ay(b, k, 8, 256);
                  this.footprints.push({
                    vertices: b,
                    indices: k,
                    grid: N,
                    min: M,
                    max: R,
                  });
                }
              }
            }
            Tt(s0, "ClipBucket", { omit: ["layers"] });
            const DS = Ai([
                { name: "a_pos_normal_ed", components: 4, type: "Int16" },
              ]),
              RS = Ai([
                { name: "a_pos_end", components: 4, type: "Int16" },
                {
                  name: "a_angular_offset_factor",
                  components: 1,
                  type: "Int16",
                },
              ]),
              zS = Ai([
                { name: "a_centroid_pos", components: 2, type: "Uint16" },
              ]),
              kS = Ai([
                { name: "a_join_normal_inside", components: 3, type: "Int16" },
              ]),
              LS = Ai([
                { name: "a_hidden_by_landmark", components: 1, type: "Uint8" },
              ]),
              OS = Ai([
                { name: "a_pos_3", components: 3, type: "Int16" },
                { name: "a_pos_normal_3", components: 3, type: "Int16" },
              ]),
              { members: FS } = DS,
              zm = Number.MAX_SAFE_INTEGER;
            function o0(n, e, i, o) {
              return (
                n.order < e ||
                n.order === zm ||
                !(n.clipMask & i) ||
                (function (a, u) {
                  return u.length !== 0 && u.find((d) => d === a) === void 0;
                })(o, n.clipScope)
              );
            }
            function km(n, e) {
              return n.x - e.x || n.y - e.y;
            }
            function a0(n, e) {
              return km(n.min, e.min) === 0 && km(n.max, e.max) === 0;
            }
            function ly(n, e) {
              return !(
                n.min.x > e.max.x ||
                n.max.x < e.min.x ||
                n.min.y > e.max.y ||
                n.max.y < e.min.y
              );
            }
            function cy(n, e) {
              if (n.length !== e.length) return !1;
              for (let i = 0; i < n.length; i++)
                if (
                  n[i].sourceId !== e[i].sourceId ||
                  !a0(n[i], e[i]) ||
                  n[i].order !== e[i].order ||
                  n[i].clipMask !== e[i].clipMask ||
                  !to(n[i].clipScope, e[i].clipScope)
                )
                  return !1;
              return !0;
            }
            function l0(n, e, i) {
              const o = 1 / mt,
                a = 1 / (1 << i.canonical.z),
                u = (e.x * o + i.canonical.x) * a + i.wrap,
                d = (e.y * o + i.canonical.y) * a;
              return {
                min: new ft(
                  (n.x * o + i.canonical.x) * a + i.wrap,
                  (n.y * o + i.canonical.y) * a,
                ),
                max: new ft(u, d),
              };
            }
            function BS(n, e, i) {
              const o = 1 << i.canonical.z,
                a = ((e.x - i.wrap) * o - i.canonical.x) * mt,
                u = (e.y * o - i.canonical.y) * mt;
              return {
                min: new ft(
                  ((n.x - i.wrap) * o - i.canonical.x) * mt,
                  (n.y * o - i.canonical.y) * mt,
                ),
                max: new ft(a, u),
              };
            }
            function c0(n, e, i, o, a, u, d) {
              const _ = n.indices,
                v = n.vertices,
                b = [];
              for (let E = o; E < o + a; E += 3) {
                const A = e[i[E + 0] + u],
                  M = e[i[E + 1] + u],
                  R = e[i[E + 2] + u],
                  k = Math.min(A.x, M.x, R.x),
                  N = Math.max(A.x, M.x, R.x),
                  j = Math.min(A.y, M.y, R.y),
                  H = Math.max(A.y, M.y, R.y);
                ((b.length = 0), n.grid.query(new ft(k, j), new ft(N, H), b));
                for (let J = 0; J < b.length; J++) {
                  const Q = b[J];
                  if (
                    q_(
                      v[_[3 * Q + 0]],
                      v[_[3 * Q + 1]],
                      v[_[3 * Q + 2]],
                      A,
                      M,
                      R,
                      d,
                    )
                  )
                    return !0;
                }
              }
              return !1;
            }
            function h0(n, e, i, o) {
              if (!n || !i) return !1;
              let a = n.vertices;
              if (!e.canonical.equals(o.canonical) || e.wrap !== o.wrap) {
                if (i.vertices.length < n.vertices.length)
                  return h0(i, o, n, e);
                const u = e.canonical,
                  d = o.canonical,
                  _ = Math.pow(2, d.z - u.z);
                a = n.vertices.map(
                  (v) =>
                    new ft(
                      (v.x + u.x * mt) * _ - d.x * mt,
                      (v.y + u.y * mt) * _ - d.y * mt,
                    ),
                );
              }
              return c0(i, a, n.indices, 0, n.indices.length, 0, 0);
            }
            function u0(n, e, i, o) {
              const a = Math.pow(2, o.z - i.z);
              return new ft(
                (n + i.x * mt) * a - o.x * mt,
                (e + i.y * mt) * a - o.y * mt,
              );
            }
            function d0(n, e) {
              const i = [];
              e.grid.queryPoint(n, i);
              const o = e.indices,
                a = e.vertices;
              for (let u = 0; u < i.length; u++) {
                const d = i[u];
                if (Gs([a[o[3 * d + 0]], a[o[3 * d + 1]], a[o[3 * d + 2]]], n))
                  return !0;
              }
              return !1;
            }
            const hy = [
              new ft(0, 0),
              new ft(mt, 0),
              new ft(mt, mt),
              new ft(0, mt),
            ];
            function f0(n, e) {
              const i = [];
              let o = [];
              if (!e || n.length < 2) return [n];
              if (n.length === 2) return La(n[0], n[1], hy) ? [n] : [];
              for (let a = 0; a < n.length + 2; a++) {
                const u = n[a % n.length],
                  d = n[(a + 1) % n.length],
                  _ = La(
                    a === 0 ? n[n.length - 1] : n[(a - 1) % n.length],
                    u,
                    hy,
                  ),
                  v = La(u, d, hy),
                  b = _ || v;
                (b && o.push(u),
                  (b && v) ||
                    (o.length > 0 && (o.length > 1 && i.push(o), (o = []))));
              }
              return (o.length > 1 && i.push(o), i);
            }
            const uy = li.VectorTileFeature.types,
              NS = [
                "fill-extrusion-base",
                "fill-extrusion-height",
                "fill-extrusion-color",
                "fill-extrusion-pattern",
                "fill-extrusion-flood-light-wall-radius",
                "fill-extrusion-line-width",
                "fill-extrusion-emissive-strength",
              ],
              VS = ["fill-extrusion-flood-light-ground-radius"],
              US = Math.pow(2, 13),
              jS = Math.pow(2, 15) - 1,
              p0 = new ft(0, 1),
              Nl = 2147483648;
            function gf(n, e, i, o, a, u, d, _) {
              n.emplaceBack(
                (e << 1) + d,
                (i << 1) + u,
                (Math.floor(o * US) << 1) + a,
                Math.round(_),
              );
            }
            function _f(n, e, i) {
              n.emplaceBack(e.x * mt, e.y * mt, i ? 1 : 0);
            }
            function Lm(n, e, i, o, a, u) {
              n.emplaceBack(e.x, e.y, (i.x << 1) + o, (i.y << 1) + a, u);
            }
            function yf(n, e, i) {
              n.emplaceBack(
                e.x,
                e.y,
                e.z,
                i[0] * 16384,
                i[1] * 16384,
                i[2] * 16384,
              );
            }
            class m0 {
              constructor() {
                ((this.vertexOffset = 0),
                  (this.vertexCount = 0),
                  (this.indexOffset = 0),
                  (this.indexCount = 0));
              }
            }
            class g0 {
              constructor() {
                ((this.centroidXY = new ft(0, 0)),
                  (this.vertexArrayOffset = 0),
                  (this.vertexCount = 0),
                  (this.groundVertexArrayOffset = 0),
                  (this.groundVertexCount = 0),
                  (this.flags = 0),
                  (this.footprintSegIdx = -1),
                  (this.footprintSegLen = 0),
                  (this.polygonSegIdx = -1),
                  (this.polygonSegLen = 0),
                  (this.min = new ft(Number.MAX_VALUE, Number.MAX_VALUE)),
                  (this.max = new ft(-Number.MAX_VALUE, -Number.MAX_VALUE)),
                  (this.height = 0));
              }
              span() {
                return new ft(this.max.x - this.min.x, this.max.y - this.min.y);
              }
            }
            class _0 {
              constructor() {
                ((this.acc = new ft(0, 0)),
                  (this.accCount = 0),
                  (this.centroidDataIndex = 0));
              }
              startRing(e, i) {
                e.min.x === Number.MAX_VALUE &&
                  ((e.min.x = e.max.x = i.x), (e.min.y = e.max.y = i.y));
              }
              appendEdge(e, i, o) {
                (this.accCount++, this.acc._add(i));
                let a = !!this.borders;
                (i.x < e.min.x
                  ? ((e.min.x = i.x), (a = !0))
                  : i.x > e.max.x && ((e.max.x = i.x), (a = !0)),
                  i.y < e.min.y
                    ? ((e.min.y = i.y), (a = !0))
                    : i.y > e.max.y && ((e.max.y = i.y), (a = !0)),
                  ((i.x === 0 || i.x === mt) && i.x === o.x) !=
                    ((i.y === 0 || i.y === mt) && i.y === o.y) &&
                    this.processBorderOverlap(i, o),
                  a && this.checkBorderIntersection(i, o));
              }
              checkBorderIntersection(e, i) {
                (i.x < 0 != e.x < 0 &&
                  this.addBorderIntersection(
                    0,
                    Ht(i.y, e.y, (0 - i.x) / (e.x - i.x)),
                  ),
                  i.x > mt != e.x > mt &&
                    this.addBorderIntersection(
                      1,
                      Ht(i.y, e.y, (mt - i.x) / (e.x - i.x)),
                    ),
                  i.y < 0 != e.y < 0 &&
                    this.addBorderIntersection(
                      2,
                      Ht(i.x, e.x, (0 - i.y) / (e.y - i.y)),
                    ),
                  i.y > mt != e.y > mt &&
                    this.addBorderIntersection(
                      3,
                      Ht(i.x, e.x, (mt - i.y) / (e.y - i.y)),
                    ));
              }
              addBorderIntersection(e, i) {
                this.borders ||
                  (this.borders = [
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                    [Number.MAX_VALUE, -Number.MAX_VALUE],
                  ]);
                const o = this.borders[e];
                (i < o[0] && (o[0] = i), i > o[1] && (o[1] = i));
              }
              processBorderOverlap(e, i) {
                if (e.x === i.x) {
                  if (e.y === i.y) return;
                  const o = e.x === 0 ? 0 : 1;
                  (this.addBorderIntersection(o, i.y),
                    this.addBorderIntersection(o, e.y));
                } else {
                  const o = e.y === 0 ? 2 : 3;
                  (this.addBorderIntersection(o, i.x),
                    this.addBorderIntersection(o, e.x));
                }
              }
              centroid() {
                return this.accCount === 0
                  ? new ft(0, 0)
                  : new ft(
                      Math.floor(Math.max(0, this.acc.x) / this.accCount),
                      Math.floor(Math.max(0, this.acc.y) / this.accCount),
                    );
              }
              intersectsCount() {
                return this.borders
                  ? this.borders.reduce(
                      (e, i) => e + +(i[0] !== Number.MAX_VALUE),
                      0,
                    )
                  : 0;
              }
            }
            function y0(n, e) {
              const i = n.add(e)._unit(),
                o = he(n.x * i.x + n.y * i.y, -1, 1);
              var a, u, d;
              return (
                (a = Math.acos(o)),
                (Math.min(4, Math.max(-4, Math.tan(a))) / 4) *
                  jS *
                  ((u = n).x * (d = e).y - u.y * d.x < 0 ? -1 : 1)
              );
            }
            const GS = [
              (n) => n.x < 0,
              (n) => n.x > mt,
              (n) => n.y < 0,
              (n) => n.y > mt,
            ];
            function $S(n, e, i, o) {
              const a = [4];
              if (o === 0) return a;
              i._mult(o);
              const u = n.sub(i),
                d = e.sub(i),
                _ = [n, e, u, d];
              for (let v = 0; v < 4; v++)
                for (const b of _)
                  if (GS[v](b)) {
                    a.push(v);
                    break;
                  }
              return a;
            }
            class x0 {
              constructor(e) {
                ((this.vertexArray = new Al()),
                  (this.indexArray = new dr()),
                  (this.programConfigurations = new c(
                    e.layers,
                    { zoom: e.zoom, lut: e.lut },
                    (i) => VS.includes(i),
                  )),
                  (this._segments = new Rn()),
                  (this.hiddenByLandmarkVertexArray = new _u()),
                  (this._segmentToGroundQuads = {}),
                  (this._segmentToGroundQuads[0] = []),
                  (this._segmentToRegionTriCounts = {}),
                  (this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0]),
                  (this.regionSegments = {}),
                  (this.regionSegments[4] = new Rn()));
              }
              getDefaultSegment() {
                return this.regionSegments[4];
              }
              hasData() {
                return this.vertexArray.length !== 0;
              }
              addData(e, i, o, a = !1) {
                const u = e.length;
                if (u > 2) {
                  let d = Math.max(0, this._segments.get().length - 1);
                  const _ = this._segments._prepareSegment(
                    4 * u,
                    this.vertexArray.length,
                    2 * this._segmentToGroundQuads[d].length,
                  );
                  let v;
                  d !== this._segments.get().length - 1 &&
                    (d++,
                    (this._segmentToGroundQuads[d] = []),
                    (this._segmentToRegionTriCounts[d] = [0, 0, 0, 0, 0]));
                  {
                    const b = e[0],
                      E = e[1];
                    v = y0(
                      b
                        .sub(e[u - 1])
                        ._perp()
                        ._unit(),
                      E.sub(b)._perp()._unit(),
                    );
                  }
                  for (let b = 0; b < u; b++) {
                    const E = b === u - 1 ? 0 : b + 1,
                      A = e[b],
                      M = e[E],
                      R = e[E === u - 1 ? 0 : E + 1],
                      k = M.sub(A)._perp()._unit(),
                      N = y0(k, R.sub(M)._perp()._unit()),
                      j = v,
                      H = N;
                    if (dy(A, M, i) || (a && w0(A, i) && w0(M, i))) {
                      v = N;
                      continue;
                    }
                    const J = _.vertexLength;
                    (Lm(this.vertexArray, A, M, 1, 1, j),
                      Lm(this.vertexArray, A, M, 1, 0, j),
                      Lm(this.vertexArray, A, M, 0, 1, H),
                      Lm(this.vertexArray, A, M, 0, 0, H),
                      (_.vertexLength += 4));
                    const Q = $S(A, M, k, o);
                    for (const V of Q)
                      (this._segmentToGroundQuads[d].push({ id: J, region: V }),
                        (this._segmentToRegionTriCounts[d][V] += 2),
                        (_.primitiveLength += 2));
                    v = N;
                  }
                }
              }
              prepareBorderSegments() {
                if (!this.hasData()) return;
                const e = this._segments.get(),
                  i = e.length;
                for (let o = 0; o < i; o++)
                  this._segmentToGroundQuads[o].sort(
                    (a, u) => a.region - u.region,
                  );
                for (let o = 0; o < i; o++) {
                  const a = this._segmentToGroundQuads[o],
                    u = e[o],
                    d = this._segmentToRegionTriCounts[o];
                  d.reduce((v, b) => v + b, 0);
                  let _ = 0;
                  for (let v = 0; v <= 4; v++) {
                    const b = d[v];
                    if (b !== 0) {
                      let E = this.regionSegments[v];
                      E || (E = this.regionSegments[v] = new Rn());
                      const A = {
                        vertexOffset: u.vertexOffset,
                        primitiveOffset: u.primitiveOffset + _,
                        vertexLength: u.vertexLength,
                        primitiveLength: b,
                      };
                      E.get().push(A);
                    }
                    _ += b;
                  }
                  for (let v = 0; v < a.length; v++) {
                    const b = a[v].id;
                    (this.indexArray.emplaceBack(b, b + 1, b + 3),
                      this.indexArray.emplaceBack(b, b + 3, b + 2));
                  }
                }
                ((this._segmentToGroundQuads = null),
                  (this._segmentToRegionTriCounts = null),
                  this._segments.destroy(),
                  (this._segments = null));
              }
              addPaintPropertiesData(e, i, o, a, u, d, _) {
                this.hasData() &&
                  this.programConfigurations.populatePaintArrays(
                    this.vertexArray.length,
                    e,
                    i,
                    o,
                    a,
                    u,
                    d,
                    void 0,
                    _,
                  );
              }
              upload(e) {
                this.hasData() &&
                  ((this.vertexBuffer = e.createVertexBuffer(
                    this.vertexArray,
                    RS.members,
                  )),
                  (this.indexBuffer = e.createIndexBuffer(this.indexArray)));
              }
              uploadPaintProperties(e) {
                this.hasData() && this.programConfigurations.upload(e);
              }
              update(e, i, o, a, u, d, _, v) {
                this.hasData() &&
                  this.programConfigurations.updatePaintArrays(
                    e,
                    i,
                    o,
                    a,
                    u,
                    d,
                    _,
                    v,
                  );
              }
              updateHiddenByLandmark(e) {
                if (!this.hasData()) return;
                const i = e.groundVertexCount + e.groundVertexArrayOffset;
                if (e.groundVertexCount === 0) return;
                const o = e.flags & Nl ? 1 : 0;
                for (let a = e.groundVertexArrayOffset; a < i; ++a)
                  this.hiddenByLandmarkVertexArray.emplace(a, o);
                this._needsHiddenByLandmarkUpdate = !0;
              }
              uploadHiddenByLandmark(e) {
                this.hasData() &&
                  this._needsHiddenByLandmarkUpdate &&
                  (!this.hiddenByLandmarkVertexBuffer &&
                  this.hiddenByLandmarkVertexArray.length > 0
                    ? (this.hiddenByLandmarkVertexBuffer = e.createVertexBuffer(
                        this.hiddenByLandmarkVertexArray,
                        LS.members,
                        !0,
                      ))
                    : this.hiddenByLandmarkVertexBuffer &&
                      this.hiddenByLandmarkVertexBuffer.updateData(
                        this.hiddenByLandmarkVertexArray,
                      ),
                  (this._needsHiddenByLandmarkUpdate = !1));
              }
              destroy() {
                if (this.vertexBuffer) {
                  (this.vertexBuffer.destroy(),
                    this.indexBuffer.destroy(),
                    this.hiddenByLandmarkVertexBuffer &&
                      this.hiddenByLandmarkVertexBuffer.destroy(),
                    this._segments && this._segments.destroy(),
                    this.programConfigurations.destroy());
                  for (let e = 0; e <= 4; e++) {
                    const i = this.regionSegments[e];
                    i && i.destroy();
                  }
                }
              }
            }
            class Om {
              constructor(e) {
                ((this.zoom = e.zoom),
                  (this.canonical = e.canonical),
                  (this.overscaling = e.overscaling),
                  (this.layers = e.layers),
                  (this.pixelRatio = e.pixelRatio),
                  (this.layerIds = this.layers.map((i) => i.fqid)),
                  (this.index = e.index),
                  (this.hasPattern = !1),
                  (this.edgeRadius = 0),
                  (this.projection = e.projection),
                  (this.activeReplacements = []),
                  (this.replacementUpdateTime = 0),
                  (this.centroidData = []),
                  (this.footprintIndices = new dr()),
                  (this.footprintVertices = new po()),
                  (this.footprintSegments = []),
                  (this.layoutVertexArray = new Il()),
                  (this.centroidVertexArray = new _m()),
                  (this.wallVertexArray = new xm()),
                  (this.indexArray = new dr()),
                  (this.programConfigurations = new c(
                    e.layers,
                    { zoom: e.zoom, lut: e.lut },
                    (i) => NS.includes(i),
                  )),
                  (this.segments = new Rn()),
                  (this.stateDependentLayerIds = this.layers
                    .filter((i) => i.isStateDependent())
                    .map((i) => i.id)),
                  (this.groundEffect = new x0(e)),
                  (this.maxHeight = 0),
                  (this.partLookup = {}),
                  (this.triangleSubSegments = []),
                  (this.polygonSegments = []),
                  (this.worldview = e.worldview));
              }
              updateFootprints(e, i) {}
              populate(e, i, o, a) {
                ((this.features = []),
                  (this.hasPattern = iy(
                    "fill-extrusion",
                    this.layers,
                    this.pixelRatio,
                    i,
                  )),
                  (this.featuresOnBorder = []),
                  (this.borderFeatureIndices = [[], [], [], []]),
                  (this.borderDoneWithNeighborZ = [-1, -1, -1, -1]),
                  (this.selfDEMTileTimestamp = Number.MAX_VALUE),
                  (this.borderDEMTileTimestamp = [
                    Number.MAX_VALUE,
                    Number.MAX_VALUE,
                    Number.MAX_VALUE,
                    Number.MAX_VALUE,
                  ]),
                  (this.tileToMeter = Ve(o)),
                  (this.edgeRadius =
                    this.layers[0].layout.get("fill-extrusion-edge-radius") /
                    this.tileToMeter),
                  (this.wallMode =
                    this.layers[0].paint
                      .get("fill-extrusion-line-width")
                      .constantOr(1) !== 0));
                for (const {
                  feature: u,
                  id: d,
                  index: _,
                  sourceLayerIndex: v,
                } of e) {
                  const b = this.layers[0]._featureFilter.needGeometry,
                    E = bt(u, b);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new qi(this.zoom, { worldview: this.worldview }),
                      E,
                      o,
                    )
                  )
                    continue;
                  const A = {
                      id: d,
                      sourceLayerIndex: v,
                      index: _,
                      geometry: b ? E.geometry : Et(u, o, a),
                      properties: u.properties,
                      type: u.type,
                      patterns: {},
                    },
                    M = this.layoutVertexArray.length,
                    R = uy[A.type] === "Polygon";
                  if (this.hasPattern)
                    this.features.push(
                      ny(
                        "fill-extrusion",
                        this.layers,
                        A,
                        this.zoom,
                        this.pixelRatio,
                        i,
                      ),
                    );
                  else if (this.wallMode)
                    for (const k of A.geometry)
                      for (const N of f0(k, R))
                        this.addFeature(
                          A,
                          [N],
                          _,
                          o,
                          {},
                          i.availableImages,
                          a,
                          i.brightness,
                        );
                  else
                    this.addFeature(
                      A,
                      A.geometry,
                      _,
                      o,
                      {},
                      i.availableImages,
                      a,
                      i.brightness,
                    );
                  i.featureIndex.insert(u, A.geometry, _, v, this.index, M);
                }
                (this.sortBorders(),
                  this.projection.name === "mercator" && this.splitToSubtiles(),
                  this.groundEffect.prepareBorderSegments(),
                  (this.polygonSegments.length = 0));
              }
              addFeatures(e, i, o, a, u, d) {
                for (const _ of this.features) {
                  const v = uy[_.type] === "Polygon",
                    { geometry: b } = _;
                  if (this.wallMode)
                    for (const E of b)
                      for (const A of f0(E, v))
                        this.addFeature(_, [A], _.index, i, o, a, u, d);
                  else this.addFeature(_, b, _.index, i, o, a, u, d);
                }
                (this.sortBorders(),
                  this.projection.name === "mercator" &&
                    this.splitToSubtiles());
              }
              update(e, i, o, a, u, d, _) {
                (this.programConfigurations.updatePaintArrays(
                  e,
                  i,
                  u,
                  o,
                  a,
                  d,
                  _,
                  this.worldview,
                ),
                  this.groundEffect.update(
                    e,
                    i,
                    u,
                    o,
                    a,
                    d,
                    _,
                    this.worldview,
                  ));
              }
              isEmpty() {
                return this.layoutVertexArray.length === 0;
              }
              uploadPending() {
                return (
                  !this.uploaded ||
                  this.programConfigurations.needsUpload ||
                  this.groundEffect.programConfigurations.needsUpload
                );
              }
              upload(e) {
                (this.uploaded ||
                  ((this.layoutVertexBuffer = e.createVertexBuffer(
                    this.layoutVertexArray,
                    FS,
                  )),
                  (this.indexBuffer = e.createIndexBuffer(this.indexArray)),
                  (this.wallVertexBuffer = e.createVertexBuffer(
                    this.wallVertexArray,
                    kS.members,
                  )),
                  this.layoutVertexExtArray &&
                    (this.layoutVertexExtBuffer = e.createVertexBuffer(
                      this.layoutVertexExtArray,
                      OS.members,
                      !0,
                    )),
                  this.groundEffect.upload(e)),
                  this.groundEffect.uploadPaintProperties(e),
                  this.programConfigurations.upload(e),
                  (this.uploaded = !0));
              }
              uploadCentroid(e) {
                (this.groundEffect.uploadHiddenByLandmark(e),
                  this.needsCentroidUpdate &&
                    (!this.centroidVertexBuffer &&
                    this.centroidVertexArray.length > 0
                      ? (this.centroidVertexBuffer = e.createVertexBuffer(
                          this.centroidVertexArray,
                          zS.members,
                          !0,
                        ))
                      : this.centroidVertexBuffer &&
                        this.centroidVertexBuffer.updateData(
                          this.centroidVertexArray,
                        ),
                    (this.needsCentroidUpdate = !1)));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.centroidVertexBuffer &&
                    this.centroidVertexBuffer.destroy(),
                  this.layoutVertexExtBuffer &&
                    this.layoutVertexExtBuffer.destroy(),
                  this.groundEffect.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy());
              }
              addFeature(e, i, o, a, u, d, _, v) {
                const b =
                    this.layers[0].paint
                      .get("fill-extrusion-flood-light-ground-radius")
                      .evaluate(e, {}) / this.tileToMeter,
                  E = [new ft(0, 0), new ft(mt, mt)],
                  A = _.projection,
                  M = A.name === "globe",
                  R = this.wallMode || uy[e.type] === "Polygon",
                  k = new _0();
                k.centroidDataIndex = this.centroidData.length;
                const N = new g0(),
                  j =
                    this.layers[0].paint
                      .get("fill-extrusion-base")
                      .evaluate(e, {}, a) <= 0,
                  H = this.layers[0].paint
                    .get("fill-extrusion-height")
                    .evaluate(e, {}, a);
                let J;
                if (
                  ((N.height = H),
                  (N.vertexArrayOffset = this.layoutVertexArray.length),
                  (N.groundVertexArrayOffset =
                    this.groundEffect.vertexArray.length),
                  M &&
                    !this.layoutVertexExtArray &&
                    (this.layoutVertexExtArray = new pu()),
                  this.wallMode)
                ) {
                  if (M)
                    return void ri(
                      "Non zero fill-extrusion-line-width is not yet supported on globe.",
                    );
                  if (i.length !== 1) return;
                  ((J = (function (be) {
                    const Me =
                      be[0].x === be[be.length - 1].x &&
                      be[0].y === be[be.length - 1].y;
                    (function (yt) {
                      let ot = 0;
                      const Jt = yt.length;
                      for (let At = 0; At < Jt; At++)
                        ot +=
                          (yt[(At + 1) % Jt].x - yt[At].x) *
                          (yt[(At + 1) % Jt].y + yt[At].y);
                      return ot >= 0;
                    })(be) || (be = be.reverse());
                    const it = { geometry: [], joinNormals: [], indices: [] },
                      Xe = [],
                      tt = [],
                      nt = [];
                    let Ge = be.length;
                    for (; Ge >= 2 && be[Ge - 1].equals(be[Ge - 2]); ) Ge--;
                    if (Ge < (Me ? 3 : 2)) return it;
                    let Je,
                      Ne,
                      je,
                      at,
                      ct,
                      Nt = 0;
                    for (; Nt < Ge - 1 && be[Nt].equals(be[Nt + 1]); ) Nt++;
                    Me &&
                      ((Je = be[Ge - 2]),
                      (ct = be[Nt].sub(Je)._unit()._perp()));
                    for (let yt = Nt; yt < Ge; yt++) {
                      if (
                        ((je =
                          yt === Ge - 1
                            ? Me
                              ? be[Nt + 1]
                              : void 0
                            : be[yt + 1]),
                        je && be[yt].equals(je))
                      )
                        continue;
                      (ct && (at = ct),
                        Je && (Ne = Je),
                        (Je = be[yt]),
                        (ct = je ? je.sub(Je)._unit()._perp() : at),
                        (at = at || ct));
                      let ot = at.add(ct);
                      (ot.x === 0 && ot.y === 0) || ot._unit();
                      const Jt = ot.x * ct.x + ot.y * ct.y,
                        At = Jt !== 0 ? 1 / Jt : 1 / 0,
                        Dt = at.x * ct.y - at.y * ct.x > 0;
                      let Wt = "miter";
                      const ni = 2;
                      (Wt === "miter" && At > ni && (Wt = "bevel"),
                        Wt === "bevel" &&
                          (At > 100 && (Wt = "flipbevel"),
                          At < ni && (Wt = "miter")));
                      const ii = (di, oi, fi, Bi) => {
                        const sn = new ft(di.x, di.y),
                          te = new ft(di.x, di.y);
                        ((sn.x += oi.x * Bi),
                          (sn.y += oi.y * Bi),
                          (te.x -= oi.x * Math.max(fi, 1)),
                          (te.y -= oi.y * Math.max(fi, 1)),
                          nt.push(oi),
                          Xe.push(sn),
                          tt.push(te));
                      };
                      if (Wt === "miter") (ot._mult(At), ii(Je, ot, 0, 0));
                      else if (Wt === "flipbevel")
                        ((ot = ct.mult(-1)),
                          ii(Je, ot, 0, 0),
                          ii(Je, ot.mult(-1), 0, 0));
                      else {
                        const di = -Math.sqrt(At * At - 1),
                          oi = Dt ? di : 0,
                          fi = Dt ? 0 : di;
                        (Ne && ii(Je, at, oi, fi), je && ii(Je, ct, oi, fi));
                      }
                    }
                    ((it.geometry = [...Xe, ...tt.reverse(), Xe[0]]),
                      (it.joinNormals = [
                        ...nt,
                        ...nt.reverse(),
                        nt[nt.length - 1],
                      ]));
                    const Ct = it.geometry.length - 1;
                    for (let yt = 0; yt < Ct / 2; yt++)
                      if (yt + 1 < Ct / 2) {
                        let ot = yt,
                          Jt = yt + 1,
                          At = Ct - 1 - yt,
                          Dt = Ct - 2 - yt;
                        ((ot = ot === 0 ? Ct - 1 : ot - 1),
                          (Jt = Jt === 0 ? Ct - 1 : Jt - 1),
                          (At = At === 0 ? Ct - 1 : At - 1),
                          (Dt = Dt === 0 ? Ct - 1 : Dt - 1),
                          it.indices.push(At),
                          it.indices.push(Jt),
                          it.indices.push(ot),
                          it.indices.push(At),
                          it.indices.push(Dt),
                          it.indices.push(Jt));
                      }
                    return it;
                  })(i[0])),
                    (i = [J.geometry]));
                }
                const Q = (be, Me) =>
                    be < (Me.length - 1) / 2 || be === Me.length - 1,
                  V = this.wallMode ? [i] : Dm(i, 500);
                for (let be = V.length - 1; be >= 0; be--) {
                  const Me = V[be];
                  (Me.length === 0 ||
                    (X = Me[0]).every((Ue) => Ue.x <= 0) ||
                    X.every((Ue) => Ue.x >= mt) ||
                    X.every((Ue) => Ue.y <= 0) ||
                    X.every((Ue) => Ue.y >= mt)) &&
                    V.splice(be, 1);
                }
                var X;
                let ee;
                if (M) ee = I0(V, E, a);
                else {
                  ee = [];
                  for (const be of V) ee.push({ polygon: be, bounds: E });
                }
                const re = R ? this.edgeRadius : 0,
                  ve = re > 0 && this.zoom < 17,
                  ge = (be, Me) => {
                    if (be.length === 0) return !1;
                    const Ue = be[be.length - 1];
                    return Me.x === Ue.x && Me.y === Ue.y;
                  };
                for (const { polygon: be, bounds: Me } of ee) {
                  let Ue = 0,
                    it = 0;
                  for (const Ge of be)
                    (R && !Ge[0].equals(Ge[Ge.length - 1]) && Ge.push(Ge[0]),
                      (it += R ? Ge.length - 1 : Ge.length));
                  const Xe = this.segments.prepareSegment(
                    (R ? 5 : 4) * it,
                    this.layoutVertexArray,
                    this.indexArray,
                  );
                  (N.footprintSegIdx < 0 &&
                    (N.footprintSegIdx = this.footprintSegments.length),
                    N.polygonSegIdx < 0 &&
                      (N.polygonSegIdx = this.polygonSegments.length));
                  const tt = {
                      triangleArrayOffset: this.indexArray.length,
                      triangleCount: 0,
                      triangleSegIdx: this.segments.segments.length - 1,
                    },
                    nt = new m0();
                  if (
                    ((nt.vertexOffset = this.footprintVertices.length),
                    (nt.indexOffset = 3 * this.footprintIndices.length),
                    (nt.ringIndices = []),
                    R)
                  ) {
                    const Ge = [],
                      Je = [];
                    Ue = Xe.vertexLength;
                    for (let je = 0; je < be.length; je++) {
                      const at = be[je];
                      at.length && je !== 0 && Je.push(Ge.length / 2);
                      const ct = [];
                      let Nt, Ct;
                      ((Nt = at[1].sub(at[0])._perp()._unit()),
                        nt.ringIndices.push(at.length - 1));
                      for (let yt = 1; yt < at.length; yt++) {
                        const ot = at[yt],
                          Jt = at[yt === at.length - 1 ? 1 : yt + 1],
                          At = ot.clone();
                        if (re) {
                          Ct = Jt.sub(ot)._perp()._unit();
                          const Dt = Nt.add(Ct)._unit(),
                            Wt =
                              re * Math.min(4, 1 / (Nt.x * Dt.x + Nt.y * Dt.y));
                          ((At.x += Wt * Dt.x),
                            (At.y += Wt * Dt.y),
                            (At.x = Math.round(At.x)),
                            (At.y = Math.round(At.y)),
                            (Nt = Ct));
                        }
                        if (
                          (!j || (re !== 0 && !ve) || ge(ct, At) || ct.push(At),
                          gf(this.layoutVertexArray, At.x, At.y, 0, 0, 1, 1, 0),
                          this.wallMode)
                        ) {
                          const Dt = Q(yt, at);
                          _f(this.wallVertexArray, J.joinNormals[yt], !Dt);
                        }
                        (Xe.vertexLength++,
                          this.footprintVertices.emplaceBack(ot.x, ot.y),
                          Ge.push(ot.x, ot.y),
                          M &&
                            yf(
                              this.layoutVertexExtArray,
                              A.projectTilePoint(At.x, At.y, a),
                              A.upVector(a, At.x, At.y),
                            ));
                      }
                      j &&
                        (re === 0 || ve) &&
                        (ct.length !== 0 && ge(ct, ct[0]) && ct.pop(),
                        this.groundEffect.addData(ct, Me, b));
                    }
                    const Ne = this.wallMode ? J.indices : uf(Ge, Je);
                    for (let je = 0; je < Ne.length; je += 3)
                      (this.footprintIndices.emplaceBack(
                        nt.vertexOffset + Ne[je + 0],
                        nt.vertexOffset + Ne[je + 1],
                        nt.vertexOffset + Ne[je + 2],
                      ),
                        this.indexArray.emplaceBack(
                          Ue + Ne[je],
                          Ue + Ne[je + 2],
                          Ue + Ne[je + 1],
                        ),
                        Xe.primitiveLength++);
                    ((nt.indexCount += Ne.length),
                      (nt.vertexCount +=
                        this.footprintVertices.length - nt.vertexOffset));
                  }
                  for (let Ge = 0; Ge < be.length; Ge++) {
                    const Je = be[Ge];
                    k.startRing(N, Je[0]);
                    let Ne =
                        Je.length > 4 && T0(Je[Je.length - 2], Je[0], Je[1]),
                      je = re ? HS(Je[Je.length - 2], Je[0], Je[1], re) : 0;
                    const at = [];
                    let ct, Nt, Ct;
                    Nt = Je[1].sub(Je[0])._perp()._unit();
                    let yt = !0;
                    for (let ot = 1, Jt = 0; ot < Je.length; ot++) {
                      let At = Je[ot - 1],
                        Dt = Je[ot];
                      const Wt = Je[ot === Je.length - 1 ? 1 : ot + 1];
                      if ((k.appendEdge(N, Dt, At), dy(Dt, At, Me))) {
                        re && ((Nt = Wt.sub(Dt)._perp()._unit()), (yt = !yt));
                        continue;
                      }
                      const ni = Dt.sub(At)._perp(),
                        ii = ni.x / (Math.abs(ni.x) + Math.abs(ni.y)),
                        di = ni.y > 0 ? 1 : 0,
                        oi = At.dist(Dt);
                      if ((Jt + oi > 32768 && (Jt = 0), re)) {
                        Ct = Wt.sub(Dt)._perp()._unit();
                        let te = b0(At, Dt, Wt, v0(Nt, Ct), re);
                        isNaN(te) && (te = 0);
                        const se = Dt.sub(At)._unit();
                        ((At = At.add(se.mult(je))._round()),
                          (Dt = Dt.add(se.mult(-te))._round()),
                          (je = te),
                          (Nt = Ct),
                          j &&
                            this.zoom >= 17 &&
                            (ge(at, At) || at.push(At),
                            ge(at, Dt) || at.push(Dt)));
                      }
                      const fi = Xe.vertexLength,
                        Bi = Je.length > 4 && T0(At, Dt, Wt);
                      let sn = S0(Jt, Ne, yt);
                      if (
                        (gf(
                          this.layoutVertexArray,
                          At.x,
                          At.y,
                          ii,
                          di,
                          0,
                          0,
                          sn,
                        ),
                        gf(
                          this.layoutVertexArray,
                          At.x,
                          At.y,
                          ii,
                          di,
                          0,
                          1,
                          sn,
                        ),
                        this.wallMode)
                      ) {
                        const te = Q(ot - 1, Je),
                          se = J.joinNormals[ot - 1];
                        (_f(this.wallVertexArray, se, te),
                          _f(this.wallVertexArray, se, te));
                      }
                      if (
                        ((Jt += oi),
                        (sn = S0(Jt, Bi, !yt)),
                        (Ne = Bi),
                        gf(
                          this.layoutVertexArray,
                          Dt.x,
                          Dt.y,
                          ii,
                          di,
                          0,
                          0,
                          sn,
                        ),
                        gf(
                          this.layoutVertexArray,
                          Dt.x,
                          Dt.y,
                          ii,
                          di,
                          0,
                          1,
                          sn,
                        ),
                        this.wallMode)
                      ) {
                        const te = Q(ot, Je),
                          se = J.joinNormals[ot];
                        (_f(this.wallVertexArray, se, te),
                          _f(this.wallVertexArray, se, te));
                      }
                      if (
                        ((Xe.vertexLength += 4),
                        this.indexArray.emplaceBack(fi + 0, fi + 1, fi + 2),
                        this.indexArray.emplaceBack(fi + 1, fi + 3, fi + 2),
                        (Xe.primitiveLength += 2),
                        re)
                      ) {
                        const te = Ue + (ot === 1 ? Je.length - 2 : ot - 2),
                          se = ot === 1 ? Ue : te + 1;
                        if (
                          (this.indexArray.emplaceBack(fi + 1, te, fi + 3),
                          this.indexArray.emplaceBack(te, se, fi + 3),
                          (Xe.primitiveLength += 2),
                          ct === void 0 && (ct = fi),
                          !dy(Wt, Je[ot], Me))
                        ) {
                          const $e =
                            ot === Je.length - 1 ? ct : Xe.vertexLength;
                          (this.indexArray.emplaceBack(fi + 2, fi + 3, $e),
                            this.indexArray.emplaceBack(fi + 3, $e + 1, $e),
                            this.indexArray.emplaceBack(fi + 3, se, $e + 1),
                            (Xe.primitiveLength += 3));
                        }
                        yt = !yt;
                      }
                      if (M) {
                        const te = this.layoutVertexExtArray,
                          se = A.projectTilePoint(At.x, At.y, a),
                          $e = A.projectTilePoint(Dt.x, Dt.y, a),
                          ut = A.upVector(a, At.x, At.y),
                          xt = A.upVector(a, Dt.x, Dt.y);
                        (yf(te, se, ut),
                          yf(te, se, ut),
                          yf(te, $e, xt),
                          yf(te, $e, xt));
                      }
                    }
                    (R && (Ue += Je.length - 1),
                      j &&
                        re &&
                        this.zoom >= 17 &&
                        (at.length !== 0 && ge(at, at[0]) && at.pop(),
                        this.groundEffect.addData(at, Me, b, re > 0)));
                  }
                  (this.footprintSegments.push(nt),
                    (tt.triangleCount =
                      this.indexArray.length - tt.triangleArrayOffset),
                    this.polygonSegments.push(tt),
                    ++N.footprintSegLen,
                    ++N.polygonSegLen);
                }
                if (
                  ((N.vertexCount =
                    this.layoutVertexArray.length - N.vertexArrayOffset),
                  (N.groundVertexCount =
                    this.groundEffect.vertexArray.length -
                    N.groundVertexArrayOffset),
                  N.vertexCount !== 0)
                ) {
                  if (
                    ((N.centroidXY = k.borders
                      ? p0
                      : this.encodeCentroid(k, N)),
                    this.centroidData.push(N),
                    k.borders)
                  ) {
                    this.featuresOnBorder.push(k);
                    const be = this.featuresOnBorder.length - 1;
                    for (let Me = 0; Me < k.borders.length; Me++)
                      k.borders[Me][0] !== Number.MAX_VALUE &&
                        this.borderFeatureIndices[Me].push(be);
                  }
                  (this.programConfigurations.populatePaintArrays(
                    this.layoutVertexArray.length,
                    e,
                    o,
                    u,
                    d,
                    a,
                    v,
                    void 0,
                    this.worldview,
                  ),
                    this.groundEffect.addPaintPropertiesData(
                      e,
                      o,
                      u,
                      d,
                      a,
                      v,
                      this.worldview,
                    ),
                    (this.maxHeight = Math.max(this.maxHeight, H)));
                }
              }
              sortBorders() {
                for (let e = 0; e < this.borderFeatureIndices.length; e++)
                  this.borderFeatureIndices[e].sort(
                    (i, o) =>
                      this.featuresOnBorder[i].borders[e][0] -
                      this.featuresOnBorder[o].borders[e][0],
                  );
              }
              splitToSubtiles() {
                const e = [];
                for (let _ = 0; _ < this.centroidData.length; _++) {
                  const v = this.centroidData[_],
                    b = +(v.min.y + v.max.y > mt),
                    E = 2 * b + (+(v.min.x + v.max.x > mt) ^ b);
                  for (let A = 0; A < v.polygonSegLen; A++) {
                    const M = v.polygonSegIdx + A;
                    e.push({
                      centroidIdx: _,
                      subtile: E,
                      polygonSegmentIdx: M,
                      triangleSegmentIdx:
                        this.polygonSegments[M].triangleSegIdx,
                    });
                  }
                }
                const i = new dr();
                e.sort((_, v) =>
                  _.triangleSegmentIdx === v.triangleSegmentIdx
                    ? _.subtile - v.subtile
                    : _.triangleSegmentIdx - v.triangleSegmentIdx,
                );
                let o = 0,
                  a = 0,
                  u = 0;
                for (const _ of e) {
                  if (_.triangleSegmentIdx !== o) break;
                  u++;
                }
                const d = e.length;
                for (; a !== e.length; ) {
                  o = e[a].triangleSegmentIdx;
                  let _ = 0,
                    v = a,
                    b = a;
                  for (let E = v; E < u && e[E].subtile === _; E++) b++;
                  for (; v !== u; ) {
                    const E = e[v];
                    _ = E.subtile;
                    const A = this.centroidData[E.centroidIdx].min.clone(),
                      M = this.centroidData[E.centroidIdx].max.clone(),
                      R = {
                        vertexOffset: this.segments.segments[o].vertexOffset,
                        primitiveOffset: i.length,
                        vertexLength: this.segments.segments[o].vertexLength,
                        primitiveLength: 0,
                        sortKey: void 0,
                        vaos: {},
                      };
                    for (let k = v; k < b; k++) {
                      const N = e[k],
                        j = this.polygonSegments[N.polygonSegmentIdx],
                        H = this.centroidData[N.centroidIdx].min,
                        J = this.centroidData[N.centroidIdx].max,
                        Q = this.indexArray.uint16;
                      for (
                        let V = j.triangleArrayOffset;
                        V < j.triangleArrayOffset + j.triangleCount;
                        V++
                      )
                        i.emplaceBack(Q[3 * V], Q[3 * V + 1], Q[3 * V + 2]);
                      ((R.primitiveLength += j.triangleCount),
                        (A.x = Math.min(A.x, H.x)),
                        (A.y = Math.min(A.y, H.y)),
                        (M.x = Math.max(M.x, J.x)),
                        (M.y = Math.max(M.y, J.y)));
                    }
                    (R.primitiveLength > 0 &&
                      this.triangleSubSegments.push({
                        segment: R,
                        min: A,
                        max: M,
                      }),
                      (v = b));
                    for (let k = v; k < u && e[k].subtile === e[v].subtile; k++)
                      b++;
                  }
                  a = u;
                  for (
                    let E = a;
                    E < d &&
                    e[E].triangleSegmentIdx === e[a].triangleSegmentIdx;
                    E++
                  )
                    u++;
                }
                (i._trim(), (this.indexArray = i));
              }
              getVisibleSegments(e, i, o) {
                const a = new Rn();
                if (this.wallMode) {
                  for (const N of this.triangleSubSegments)
                    a.segments.push(N.segment);
                  return a;
                }
                let u = 0,
                  d = 0;
                const _ = 1 << e.canonical.z;
                if (i) {
                  const N = i.getMinMaxForTile(e);
                  N && ((u = N.min), (d = N.max));
                }
                d += this.maxHeight;
                const v = e.toUnwrapped();
                let b;
                const E = [v.canonical.x / _ + v.wrap, v.canonical.y / _],
                  A = [
                    (v.canonical.x + 1) / _ + v.wrap,
                    (v.canonical.y + 1) / _,
                  ],
                  M = (N, j, H) => [
                    N[0] * (1 - H[0]) + j[0] * H[0],
                    N[1] * (1 - H[1]) + j[1] * H[1],
                  ],
                  R = [],
                  k = [];
                for (const N of this.triangleSubSegments) {
                  ((R[0] = N.min.x / mt),
                    (R[1] = N.min.y / mt),
                    (k[0] = N.max.x / mt),
                    (k[1] = N.max.y / mt));
                  const j = M(E, A, R),
                    H = M(E, A, k);
                  if (
                    new Ci([j[0], j[1], u], [H[0], H[1], d]).intersectsPrecise(
                      o,
                    ) === 0
                  ) {
                    b && (a.segments.push(b), (b = void 0));
                    continue;
                  }
                  const J = N.segment;
                  (b &&
                    b.vertexOffset !== J.vertexOffset &&
                    (a.segments.push(b), (b = void 0)),
                    b
                      ? ((b.vertexLength += J.vertexLength),
                        (b.primitiveLength += J.primitiveLength))
                      : (b = {
                          vertexOffset: J.vertexOffset,
                          primitiveLength: J.primitiveLength,
                          vertexLength: J.vertexLength,
                          primitiveOffset: J.primitiveOffset,
                          sortKey: void 0,
                          vaos: {},
                        }));
                }
                return (b && a.segments.push(b), a);
              }
              encodeCentroid(e, i) {
                const o = e.centroid(),
                  a = i.span(),
                  u = Math.min(7, Math.round((a.x * this.tileToMeter) / 10)),
                  d = Math.min(7, Math.round((a.y * this.tileToMeter) / 10));
                return new ft(
                  (he(o.x, 1, mt - 1) << 3) | u,
                  (he(o.y, 1, mt - 1) << 3) | d,
                );
              }
              encodeBorderCentroid(e) {
                if (!e.borders) return new ft(0, 0);
                const i = e.borders,
                  o = Number.MAX_VALUE;
                if (i[0][0] !== o || i[1][0] !== o) {
                  const a = i[0][0] !== o ? 0 : 1;
                  return new ft(
                    6 | (i[0][0] !== o ? 0 : 65528),
                    (((i[a][0] + i[a][1]) / 2) << 3) | 6,
                  );
                }
                {
                  const a = i[2][0] !== o ? 2 : 3;
                  return new ft(
                    (((i[a][0] + i[a][1]) / 2) << 3) | 6,
                    6 | (i[2][0] !== o ? 0 : 65528),
                  );
                }
              }
              showCentroid(e) {
                const i = this.centroidData[e.centroidDataIndex];
                ((i.flags &= Nl),
                  (i.centroidXY.x = 0),
                  (i.centroidXY.y = 0),
                  this.writeCentroidToBuffer(i));
              }
              writeCentroidToBuffer(e) {
                this.groundEffect.updateHiddenByLandmark(e);
                const i = e.vertexArrayOffset,
                  o = e.vertexCount + e.vertexArrayOffset,
                  a = e.flags & Nl ? p0 : e.centroidXY,
                  u = this.centroidVertexArray.geta_centroid_pos0(i);
                if (
                  this.centroidVertexArray.geta_centroid_pos1(i) !== a.y ||
                  u !== a.x
                ) {
                  for (let d = i; d < o; ++d)
                    this.centroidVertexArray.emplace(d, a.x, a.y);
                  this.needsCentroidUpdate = !0;
                }
              }
              createCentroidsBuffer() {
                (this.centroidVertexArray.resize(this.layoutVertexArray.length),
                  this.groundEffect.hiddenByLandmarkVertexArray.resize(
                    this.groundEffect.vertexArray.length,
                  ));
                for (const e of this.centroidData)
                  this.writeCentroidToBuffer(e);
              }
              updateReplacement(e, i, o) {
                if (i.updateTime === this.replacementUpdateTime) return;
                this.replacementUpdateTime = i.updateTime;
                const a = i.getReplacementRegionsForTile(e.toUnwrapped());
                if (cy(this.activeReplacements, a)) return;
                if (
                  ((this.activeReplacements = a),
                  this.centroidVertexArray.length === 0)
                )
                  this.createCentroidsBuffer();
                else for (const d of this.centroidData) d.flags &= 2147483647;
                const u = [];
                for (const d of this.activeReplacements) {
                  if (d.order < o) continue;
                  const _ = Math.max(
                    1,
                    Math.pow(2, d.footprintTileId.canonical.z - e.canonical.z),
                  );
                  for (const v of this.centroidData)
                    if (
                      !(
                        v.flags & Nl ||
                        d.min.x > v.max.x ||
                        v.min.x > d.max.x ||
                        d.min.y > v.max.y ||
                        v.min.y > d.max.y
                      )
                    )
                      for (let b = 0; b < v.footprintSegLen; b++) {
                        const E = this.footprintSegments[v.footprintSegIdx + b];
                        if (
                          ((u.length = 0),
                          WS(
                            this.footprintVertices,
                            E.vertexOffset,
                            E.vertexCount,
                            d.footprintTileId.canonical,
                            e.canonical,
                            u,
                          ),
                          c0(
                            d.footprint,
                            u,
                            this.footprintIndices.uint16,
                            E.indexOffset,
                            E.indexCount,
                            -E.vertexOffset,
                            -_,
                          ))
                        ) {
                          v.flags |= Nl;
                          break;
                        }
                      }
                }
                for (const d of this.centroidData)
                  this.writeCentroidToBuffer(d);
                this.borderDoneWithNeighborZ = [-1, -1, -1, -1];
              }
              footprintContainsPoint(e, i, o) {
                let a = !1;
                for (let u = 0; u < o.footprintSegLen; u++) {
                  const d = this.footprintSegments[o.footprintSegIdx + u];
                  let _ = 0;
                  for (const v of d.ringIndices) {
                    for (let b = _, E = v + _ - 1; b < v + _; E = b++) {
                      const A =
                          this.footprintVertices.int16[
                            2 * (b + d.vertexOffset) + 0
                          ],
                        M =
                          this.footprintVertices.int16[
                            2 * (b + d.vertexOffset) + 1
                          ],
                        R =
                          this.footprintVertices.int16[
                            2 * (E + d.vertexOffset) + 1
                          ];
                      M > i != R > i &&
                        e <
                          ((this.footprintVertices.int16[
                            2 * (E + d.vertexOffset) + 0
                          ] -
                            A) *
                            (i - M)) /
                            (R - M) +
                            A &&
                        (a = !a);
                    }
                    _ = v;
                  }
                }
                return a;
              }
              getHeightAtTileCoord(e, i) {
                let o = Number.NEGATIVE_INFINITY,
                  a = !0;
                const u = 4 * (e + mt) * mt + (i + mt);
                if (this.partLookup.hasOwnProperty(u)) {
                  const d = this.partLookup[u];
                  return d
                    ? { height: d.height, hidden: !!(d.flags & Nl) }
                    : void 0;
                }
                for (const d of this.centroidData)
                  e > d.max.x ||
                    d.min.x > e ||
                    i > d.max.y ||
                    d.min.y > i ||
                    (this.footprintContainsPoint(e, i, d) &&
                      d &&
                      d.height > o &&
                      ((o = d.height),
                      (this.partLookup[u] = d),
                      (a = !!(d.flags & Nl))));
                if (o !== Number.NEGATIVE_INFINITY)
                  return { height: o, hidden: a };
                this.partLookup[u] = void 0;
              }
            }
            function v0(n, e) {
              const i = n.add(e)._unit();
              return n.x * i.x + n.y * i.y;
            }
            function HS(n, e, i, o) {
              const a = e.sub(n)._perp()._unit(),
                u = i.sub(e)._perp()._unit();
              return b0(n, e, i, v0(a, u), o);
            }
            function b0(n, e, i, o, a) {
              const u = Math.sqrt(1 - o * o);
              return Math.min(n.dist(e) / 3, e.dist(i) / 3, (a * u) / o);
            }
            function dy(n, e, i) {
              return (
                (n.x < i[0].x && e.x < i[0].x) ||
                (n.x > i[1].x && e.x > i[1].x) ||
                (n.y < i[0].y && e.y < i[0].y) ||
                (n.y > i[1].y && e.y > i[1].y)
              );
            }
            function w0(n, e) {
              return (
                n.x < e[0].x || n.x > e[1].x || n.y < e[0].y || n.y > e[1].y
              );
            }
            function T0(n, e, i) {
              if (
                n.x < 0 ||
                n.x >= mt ||
                e.x < 0 ||
                e.x >= mt ||
                i.x < 0 ||
                i.x >= mt
              )
                return !1;
              const o = i.sub(e),
                a = o.perp(),
                u = n.sub(e);
              return (
                (o.x * u.x + o.y * u.y) /
                  Math.sqrt((o.x * o.x + o.y * o.y) * (u.x * u.x + u.y * u.y)) >
                  -0.866 && a.x * u.x + a.y * u.y < 0
              );
            }
            function S0(n, e, i) {
              const o = e ? 2 | n : -3 & n;
              return i ? 1 | o : -2 & o;
            }
            function E0() {
              const n = Math.PI / 32,
                e = Math.tan(n),
                i = $;
              return i * Math.sqrt(1 + 2 * e * e) - i;
            }
            function I0(n, e, i) {
              const o = 1 << i.z,
                a = _e(i.x / o),
                u = _e((i.x + 1) / o),
                d = De(i.y / o),
                _ = De((i.y + 1) / o);
              return (function (v, b, E, A, M = 0, R) {
                const k = [];
                if (!v.length || !E || !A) return k;
                const N = (ee, re) => {
                    for (const ve of ee) k.push({ polygon: ve, bounds: re });
                  },
                  j = Math.ceil(Math.log2(E)),
                  H = Math.ceil(Math.log2(A)),
                  J = j - H,
                  Q = [];
                for (let ee = 0; ee < Math.abs(J); ee++) Q.push(J > 0 ? 0 : 1);
                for (let ee = 0; ee < Math.min(j, H); ee++)
                  (Q.push(0), Q.push(1));
                let V = v;
                if (
                  ((V = Rm(V, b[0].y - M, b[1].y + M, 1)),
                  (V = Rm(V, b[0].x - M, b[1].x + M, 0)),
                  !V.length)
                )
                  return k;
                const X = [];
                for (
                  Q.length
                    ? X.push({ polygons: V, bounds: b, depth: 0 })
                    : N(V, b);
                  X.length;

                ) {
                  const ee = X.pop(),
                    re = ee.depth,
                    ve = Q[re],
                    ge = ee.bounds[0],
                    be = ee.bounds[1],
                    Me = ve === 0 ? ge.x : ge.y,
                    Ue = ve === 0 ? be.x : be.y,
                    it = R ? R(ve, Me, Ue) : 0.5 * (Me + Ue),
                    Xe = Rm(ee.polygons, Me - M, it + M, ve),
                    tt = Rm(ee.polygons, it - M, Ue + M, ve);
                  if (Xe.length) {
                    const nt = [
                      ge,
                      new ft(ve === 0 ? it : be.x, ve === 1 ? it : be.y),
                    ];
                    Q.length > re + 1
                      ? X.push({ polygons: Xe, bounds: nt, depth: re + 1 })
                      : N(Xe, nt);
                  }
                  if (tt.length) {
                    const nt = [
                      new ft(ve === 0 ? it : ge.x, ve === 1 ? it : ge.y),
                      be,
                    ];
                    Q.length > re + 1
                      ? X.push({ polygons: tt, bounds: nt, depth: re + 1 })
                      : N(tt, nt);
                  }
                }
                return k;
              })(
                n,
                e,
                Math.ceil((u - a) / 11.25),
                Math.ceil((d - _) / 11.25),
                1,
                (v, b, E) => {
                  if (v === 0) return 0.5 * (b + E);
                  {
                    const A = De((i.y + b / mt) / o);
                    return (
                      (le(0.5 * (De((i.y + E / mt) / o) + A)) * o - i.y) * mt
                    );
                  }
                },
              );
            }
            function WS(n, e, i, o, a, u) {
              const d = Math.pow(2, o.z - a.z);
              for (let _ = 0; _ < i; _++) {
                let v = n.int16[2 * (_ + e) + 0],
                  b = n.int16[2 * (_ + e) + 1];
                ((v = (v + a.x * mt) * d - o.x * mt),
                  (b = (b + a.y * mt) * d - o.y * mt),
                  u.push(new ft(v, b)));
              }
            }
            let A0, M0;
            (Tt(Om, "FillExtrusionBucket", { omit: ["layers", "features"] }),
              Tt(g0, "PartData"),
              Tt(m0, "FootprintSegment"),
              Tt(_0, "BorderCentroidData"),
              Tt(x0, "GroundEffect"));
            class nh extends ft {
              constructor(e, i, o) {
                (super(e, i), (this.z = o));
              }
            }
            class C0 extends nh {
              constructor(e, i, o, a) {
                (super(e, i, o), (this.w = a));
              }
            }
            function P0(n, e, i, o) {
              const a = i === "x" ? "y" : "x",
                u = (o - n[i]) / (e[i] - n[i]);
              ((n[a] = Math.round(n[a] + (e[a] - n[a]) * u)),
                (n[i] = o),
                n.hasOwnProperty("z") && (n.z = Ht(n.z, e.z, u)),
                n.hasOwnProperty("w") && (n.w = Ht(n.w, e.w, u)));
            }
            function D0(n, e, i, o) {
              const a = i,
                u = o;
              for (const d of ["x", "y"]) {
                let _ = n,
                  v = e;
                (_[d] >= v[d] && ((_ = e), (v = n)),
                  _[d] < a && v[d] > a && P0(_, v, d, a),
                  _[d] < u && v[d] > u && P0(v, _, d, u));
              }
            }
            function Fm(n, e, i, o, a, u) {
              const d = [];
              for (let _ = 0; _ < n.length; _++) {
                const v = n[_];
                let b;
                const E = d.length;
                let A = 0;
                for (let M = 0; M < v.length - 1; M++) {
                  let R = v[M],
                    k = v[M + 1],
                    N = 0;
                  const j = A;
                  let H, J;
                  (u &&
                    ((N = Math.hypot(k.x - R.x, k.y - R.y)),
                    (A += N),
                    (H = R),
                    (J = k)),
                    (R.x < e && k.x < e) ||
                      (R.x < e
                        ? (R = new ft(
                            e,
                            R.y + ((e - R.x) / (k.x - R.x)) * (k.y - R.y),
                          )._round())
                        : k.x < e &&
                          (k = new ft(
                            e,
                            R.y + ((e - R.x) / (k.x - R.x)) * (k.y - R.y),
                          )._round()),
                      (R.y < i && k.y < i) ||
                        (R.y < i
                          ? (R = new ft(
                              R.x + ((i - R.y) / (k.y - R.y)) * (k.x - R.x),
                              i,
                            )._round())
                          : k.y < i &&
                            (k = new ft(
                              R.x + ((i - R.y) / (k.y - R.y)) * (k.x - R.x),
                              i,
                            )._round()),
                        (R.x >= o && k.x >= o) ||
                          (R.x >= o
                            ? (R = new ft(
                                o,
                                R.y + ((o - R.x) / (k.x - R.x)) * (k.y - R.y),
                              )._round())
                            : k.x >= o &&
                              (k = new ft(
                                o,
                                R.y + ((o - R.x) / (k.x - R.x)) * (k.y - R.y),
                              )._round()),
                          (R.y >= a && k.y >= a) ||
                            (R.y >= a
                              ? (R = new ft(
                                  R.x + ((a - R.y) / (k.y - R.y)) * (k.x - R.x),
                                  a,
                                )._round())
                              : k.y >= a &&
                                (k = new ft(
                                  R.x + ((a - R.y) / (k.y - R.y)) * (k.x - R.x),
                                  a,
                                )._round()),
                            (b && R.equals(b[b.length - 1])) ||
                              ((b = [R]),
                              d.push(b),
                              u &&
                                u.push({
                                  progress: {
                                    min: j + R0(H, J, R) * N,
                                    max: 1,
                                  },
                                  parentIndex: _,
                                  prevPoint: H,
                                  nextPoint: J,
                                })),
                            b.push(k),
                            u &&
                              ((u[u.length - 1].progress.max =
                                j + R0(H, J, k) * N),
                              (u[u.length - 1].nextPoint = J)))))));
                }
                if (u && A > 0)
                  for (let M = E; M < d.length; M++)
                    ((u[M].progress.min /= A), (u[M].progress.max /= A));
              }
              return d;
            }
            function qS(n, e, i, o, a) {
              if (n.length < 2) return void o.push(n);
              const u = [];
              for (; e.valid(); ) {
                const [b, E] = e.get();
                for (let A = 0; A < n.length - 1; A++) {
                  const M = n[A],
                    R = n[A + 1],
                    k = lf(M, R, b, E);
                  if (k) {
                    const [N] = k,
                      j = new ft(Ht(M.x, R.x, N), Ht(M.y, R.y, N));
                    u.push({ t: A + N, distance: 0, point: j });
                  }
                }
                e.next();
              }
              if (u.length === 0) return void o.push(n);
              u.sort((b, E) => b.t - E.t);
              let d = 0,
                _ = 0,
                v = [];
              for (o.push(v); d !== n.length; ) {
                if (_ === u.length) {
                  for (; d !== n.length; )
                    ((v.length !== 0 && v[v.length - 1].equals(n[d])) ||
                      v.push(n[d]),
                      d++);
                  break;
                }
                u[_].t <= d
                  ? ((v.length !== 0 && v[v.length - 1].equals(u[_].point)) ||
                      v.push(u[_].point),
                    Math.trunc(u[_].t),
                    _++)
                  : ((v.length !== 0 && v[v.length - 1].equals(n[d])) ||
                      v.push(n[d]),
                    d++);
              }
            }
            function R0(n, e, i) {
              return n.x !== e.x
                ? (i.x - n.x) / (e.x - n.x)
                : n.y !== e.y
                  ? (i.y - n.y) / (e.y - n.y)
                  : 0;
            }
            function xf(n, e) {
              return n.x * e.x + n.y * e.y;
            }
            function z0(n, e) {
              if (n.length === 1) {
                let i = 0;
                const o = e[i++];
                let a;
                for (; !a || o.equals(a); )
                  if (((a = e[i++]), !a)) return 1 / 0;
                for (; i < e.length; i++) {
                  const u = e[i],
                    d = n[0],
                    _ = a.sub(o),
                    v = u.sub(o),
                    b = d.sub(o),
                    E = xf(_, _),
                    A = xf(_, v),
                    M = xf(v, v),
                    R = xf(b, _),
                    k = xf(b, v),
                    N = E * M - A * A,
                    j = (M * R - A * k) / N,
                    H = (E * k - A * R) / N,
                    J = o.z * (1 - j - H) + a.z * j + u.z * H;
                  if (isFinite(J)) return J;
                }
                return 1 / 0;
              }
              {
                let i = 1 / 0;
                for (const o of e) i = Math.min(i, o.z);
                return i;
              }
            }
            function k0(n, e, i, o, a, u, d, _) {
              const v = d * a.getElevationAt(n, e, !0, !0),
                b = u[0] !== 0,
                E = b
                  ? u[1] === 0
                    ? d * (u[0] / 7 - 450)
                    : d *
                      (function (A, M, R) {
                        const k = Math.floor(M[0] / 8),
                          N = Math.floor(M[1] / 8),
                          j = 10 * (M[0] - 8 * k),
                          H = 10 * (M[1] - 8 * N),
                          J = A.getElevationAt(k, N, !0, !0),
                          Q = A.getMeterToDEM(R),
                          V = Math.floor(0.5 * (j * Q - 1)),
                          X = Math.floor(0.5 * (H * Q - 1)),
                          ee = A.tileCoordToPixel(k, N),
                          re = 2 * V + 1,
                          ve = 2 * X + 1,
                          ge = (function (tt, nt, Ge, Je, Ne) {
                            return [
                              tt.getElevationAtPixel(nt, Ge, !0),
                              tt.getElevationAtPixel(nt + Ne, Ge, !0),
                              tt.getElevationAtPixel(nt, Ge + Ne, !0),
                              tt.getElevationAtPixel(nt + Je, Ge + Ne, !0),
                            ];
                          })(A, ee.x - V, ee.y - X, re, ve),
                          be = Math.abs(ge[0] - ge[1]),
                          Me = Math.abs(ge[2] - ge[3]),
                          Ue =
                            Math.abs(ge[0] - ge[2]) + Math.abs(ge[1] - ge[3]),
                          it = Math.min(0.25, (0.5 * Q * (be + Me)) / re),
                          Xe = Math.min(0.25, (0.5 * Q * Ue) / ve);
                        return J + Math.max(it * j, Xe * H);
                      })(a, u, _)
                  : v;
              return {
                base: v + (i === 0 ? -1 : i),
                top: b ? Math.max(E + o, v + i + 2) : v + o,
              };
            }
            class ZS {
              constructor(e) {
                ((this._callback = e),
                  (this._triggered = !1),
                  typeof MessageChannel < "u" &&
                    ((this._channel = new MessageChannel()),
                    (this._channel.port2.onmessage = () => {
                      ((this._triggered = !1), this._callback());
                    })));
              }
              trigger() {
                this._triggered ||
                  ((this._triggered = !0),
                  this._channel
                    ? this._channel.port1.postMessage(!0)
                    : setTimeout(() => {
                        ((this._triggered = !1), this._callback());
                      }, 0));
              }
              remove() {
                ((this._channel = void 0), (this._callback = () => {}));
              }
            }
            class XS {
              constructor() {
                ((this.tasks = {}),
                  (this.taskQueue = []),
                  Pt(["process"], this),
                  (this.invoker = new ZS(this.process)),
                  (this.nextId = 0));
              }
              add(e, i) {
                const o = this.nextId++,
                  a = (function ({ type: u, isSymbolTile: d, zoom: _ }) {
                    return (
                      (_ = _ || 0),
                      u === "message"
                        ? 0
                        : u !== "maybePrepare" || d
                          ? u !== "parseTile" || d
                            ? u === "parseTile" && d
                              ? 300 - _
                              : u === "maybePrepare" && d
                                ? 400 - _
                                : 500
                            : 200 - _
                          : 100 - _
                    );
                  })(i);
                if (a === 0) {
                  try {
                    e();
                  } finally {
                  }
                  return null;
                }
                return (
                  (this.tasks[o] = { fn: e, metadata: i, priority: a, id: o }),
                  this.taskQueue.push(o),
                  this.invoker.trigger(),
                  {
                    cancel: () => {
                      delete this.tasks[o];
                    },
                  }
                );
              }
              process() {
                try {
                  if (
                    ((this.taskQueue = this.taskQueue.filter(
                      (o) => !!this.tasks[o],
                    )),
                    !this.taskQueue.length)
                  )
                    return;
                  const e = this.pick();
                  if (e === null) return;
                  const i = this.tasks[e];
                  if (
                    (delete this.tasks[e],
                    this.taskQueue.length && this.invoker.trigger(),
                    !i)
                  )
                    return;
                  i.fn();
                } finally {
                }
              }
              pick() {
                let e = null,
                  i = 1 / 0;
                for (let a = 0; a < this.taskQueue.length; a++) {
                  const u = this.tasks[this.taskQueue[a]];
                  u.priority < i && ((i = u.priority), (e = a));
                }
                if (e === null) return null;
                const o = this.taskQueue[e];
                return (this.taskQueue.splice(e, 1), o);
              }
              remove() {
                this.invoker.remove();
              }
            }
            class L0 {
              constructor(e, i, o) {
                ((this.target = e),
                  (this.parent = i),
                  (this.mapId = o),
                  (this.callbacks = {}),
                  (this.cancelCallbacks = {}),
                  Pt(["receive"], this),
                  this.target.addEventListener("message", this.receive, !1),
                  (this.scheduler = new XS()));
              }
              send(e, i, o, a, u = !1, d) {
                const _ = Math.round(1e18 * Math.random())
                  .toString(36)
                  .substring(0, 10);
                o && ((o.metadata = d), (this.callbacks[_] = o));
                const v = new Set();
                return (
                  this.target.postMessage(
                    {
                      id: _,
                      type: e,
                      hasCallback: !!o,
                      targetMapId: a,
                      mustQueue: u,
                      sourceMapId: this.mapId,
                      data: No(i, v),
                    },
                    v,
                  ),
                  {
                    cancel: () => {
                      (o && delete this.callbacks[_],
                        this.target.postMessage({
                          id: _,
                          type: "<cancel>",
                          targetMapId: a,
                          sourceMapId: this.mapId,
                        }));
                    },
                  }
                );
              }
              receive(e) {
                const i = e.data;
                if (!i) return;
                const o = i.id;
                if (o && (!i.targetMapId || this.mapId === i.targetMapId))
                  if (i.type === "<cancel>") {
                    const a = this.cancelCallbacks[o];
                    (delete this.cancelCallbacks[o], a && a.cancel());
                  } else if (i.mustQueue || Ui(self)) {
                    const a = this.callbacks[o],
                      u = this.scheduler.add(
                        () => this.processTask(o, i),
                        (a && a.metadata) || { type: "message" },
                      );
                    u && (this.cancelCallbacks[o] = u);
                  } else this.processTask(o, i);
              }
              processTask(e, i) {
                if ((delete this.cancelCallbacks[e], i.type === "<response>")) {
                  const o = this.callbacks[e];
                  (delete this.callbacks[e],
                    o && (i.error ? o(Vo(i.error)) : o(null, Vo(i.data))));
                } else {
                  const o = new Set(),
                    a = i.hasCallback
                      ? (d, _) => {
                          this.target.postMessage(
                            {
                              id: e,
                              type: "<response>",
                              sourceMapId: this.mapId,
                              error: d ? No(d) : null,
                              data: No(_, o),
                            },
                            o,
                          );
                        }
                      : () => {},
                    u = Vo(i.data);
                  if (this.parent[i.type])
                    this.parent[i.type](i.sourceMapId, u, a);
                  else if (this.parent.getWorkerSource) {
                    const d = i.type.split("."),
                      { source: _, scope: v } = u;
                    this.parent
                      .getWorkerSource(i.sourceMapId, d[0], _, v)
                      [d[1]](u, a);
                  } else a(new Error(`Could not find function ${i.type}`));
                }
              }
              remove() {
                (this.scheduler.remove(),
                  this.target.removeEventListener("message", this.receive, !1));
              }
            }
            var vf = { workerUrl: "", workerClass: null, workerParams: void 0 };
            const fy = "mapboxgl_preloaded_worker_pool";
            class rh {
              constructor() {
                this.active = {};
              }
              acquire(e, i = rh.workerCount) {
                if (!this.workers)
                  for (this.workers = []; this.workers.length < i; )
                    this.workers.push(
                      vf.workerClass != null
                        ? new vf.workerClass()
                        : new self.Worker(vf.workerUrl, vf.workerParams),
                    );
                return ((this.active[e] = !0), this.workers.slice());
              }
              release(e) {
                (delete this.active[e],
                  this.workers &&
                    this.numActive() === 0 &&
                    (this.workers.forEach((i) => {
                      i.terminate();
                    }),
                    (this.workers = null)));
              }
              isPreloaded() {
                return !!this.active[fy];
              }
              numActive() {
                return Object.keys(this.active).length;
              }
            }
            rh.workerCount = 2;
            class Cu {
              constructor(e, i, o = "Worker", a = rh.workerCount) {
                ((this.workerPool = e),
                  (this.actors = []),
                  (this.currentActor = 0),
                  (this.id = Be()));
                const u = this.workerPool.acquire(this.id, a);
                for (let d = 0; d < u.length; d++) {
                  const _ = new Cu.Actor(u[d], i, this.id);
                  ((_.name = `${o} ${d}`), this.actors.push(_));
                }
                ((this.ready = !1),
                  this.broadcast("checkIfReady", null, () => {
                    this.ready = !0;
                  }));
              }
              broadcast(e, i, o) {
                Ee(
                  this.actors,
                  (a, u) => {
                    a.send(e, i, u);
                  },
                  (o = o || function () {}),
                );
              }
              getActor() {
                return (
                  (this.currentActor =
                    (this.currentActor + 1) % this.actors.length),
                  this.actors[this.currentActor]
                );
              }
              remove() {
                (this.actors.forEach((e) => {
                  e.remove();
                }),
                  (this.actors = []),
                  this.workerPool.release(this.id));
              }
            }
            let bf, py;
            function Bm() {
              return (bf || (bf = new rh()), bf);
            }
            Cu.Actor = L0;
            class YS {
              constructor(e) {
                this.module = e;
              }
              createIntArray(e) {
                const i = new Int32Array(e),
                  o = this.module.malloc(i.length * i.BYTES_PER_ELEMENT);
                return (this.module.heap32.set(i, o / i.BYTES_PER_ELEMENT), o);
              }
              createFloatArray(e) {
                const i = new Float32Array(e),
                  o = this.module.malloc(i.length * i.BYTES_PER_ELEMENT);
                return (this.module.heapF32.set(i, o / i.BYTES_PER_ELEMENT), o);
              }
              createStringBuffer(e) {
                const i = this.module.malloc(e.length + 1);
                for (let o = 0; o < e.length; ++o)
                  this.module.heapU8[i + o] = e.charCodeAt(o);
                return ((this.module.heapU8[i + e.length] = 0), i);
              }
              readStringBuffer(e) {
                let i = "";
                for (; this.module.heapU8[e] !== 0; )
                  ((i += String.fromCharCode(this.module.heapU8[e])), ++e);
                return i;
              }
              setStyle(e) {
                const i = e.entranceColorRgb,
                  o = e.facadeGlazingColorRgb,
                  a = e.roofColorRgb,
                  u = e.wallColorRgb,
                  d = e.normalScale;
                this.module.setStyle(
                  i[0],
                  i[1],
                  i[2],
                  o[0],
                  o[1],
                  o[2],
                  a[0],
                  a[1],
                  a[2],
                  u[0],
                  u[1],
                  u[2],
                  d[0],
                  d[1],
                  d[2],
                  e.tileToMeters,
                );
              }
              setAOOptions(e, i) {
                this.module.setAOOptions(e ? 1 : 0, i);
              }
              setMetricOptions(e, i) {
                this.module.setMetricOptions(e ? 1 : 0, i);
              }
              setFacadeOptions(e, i, o) {
                this.module.setFacadeOptions(e, i, o);
              }
              generateMesh(e, i) {
                for (const _ of e) {
                  const v = this.createStringBuffer(_.roofType),
                    b = [0],
                    E = [];
                  for (const R of _.coordinates)
                    if (Array.isArray(R)) {
                      for (const k of R) (E.push(k.x), E.push(k.y));
                      b.push(E.length);
                    }
                  const A = this.createIntArray(b),
                    M = this.createFloatArray(E);
                  (this.module.addFeature(
                    _.id,
                    _.sourceId,
                    _.minHeight,
                    _.height,
                    v,
                    _.roofType.length,
                    M,
                    A,
                    b.length - 1,
                  ),
                    this.module.free(v),
                    this.module.free(A),
                    this.module.free(M));
                }
                for (const _ of i) {
                  let v;
                  v = _.entrances ? JSON.parse(_.entrances) : [];
                  const b = this.createFloatArray(v),
                    E = [];
                  for (const M of _.coordinates) (E.push(M.x), E.push(M.y));
                  const A = this.createFloatArray(E);
                  (this.module.addFacade(
                    _.sourceId,
                    _.crossPerc,
                    _.distanceToRoad,
                    b,
                    v.length,
                    A,
                    E.length,
                  ),
                    this.module.free(b),
                    this.module.free(A));
                }
                if (!this.module.generateMesh()) {
                  const _ = this.module.getLastError();
                  return this.readStringBuffer(_);
                }
                const o = this.module.getMeshCount(),
                  a = new Array(o);
                for (let _ = 0; _ < o; _++) {
                  const v = this.module.getPositionsPtr(_),
                    b = this.module.getPositionsLength(_),
                    E = new Float32Array(this.module.heapF32.buffer, v, b),
                    A = this.module.getNormalsPtr(_),
                    M = this.module.getNormalsLength(_),
                    R = new Float32Array(this.module.heapF32.buffer, A, M),
                    k = this.module.getColorsPtr(_),
                    N = this.module.getColorsLength(_),
                    j = new Uint8Array(this.module.heapU8.buffer, k, N),
                    H = this.module.getAOPtr(_),
                    J = this.module.getAOLength(_),
                    Q = new Float32Array(this.module.heapF32.buffer, H, J),
                    V = this.module.getIndicesPtr(_),
                    X = this.module.getIndicesLength(_),
                    ee = new Int32Array(this.module.heap32.buffer, V, X),
                    re = this.module.getBuildingPart(_),
                    ve = this.readStringBuffer(re);
                  a[_] = {
                    positions: E,
                    normals: R,
                    colors: j,
                    ao: Q,
                    indices: ee,
                    buildingPart: ve,
                  };
                }
                const u = this.module.getRingCount(),
                  d = [];
                for (let _ = 0; _ < u; _++) {
                  const v = this.module.getRingPtr(_),
                    b = this.module.getRingLength(_),
                    E = new Float32Array(this.module.heapF32.buffer, v, b);
                  d.push(E);
                }
                return { meshes: a, modifiedPolygonRings: d };
              }
            }
            let wf,
              my,
              _o,
              Pu,
              gy,
              Du = null,
              Ru = null,
              O0 = null,
              _y = null;
            function F0() {
              return Ui(self) && self.worker.dracoUrl
                ? self.worker.dracoUrl
                : my || hr.DRACO_URL;
            }
            function B0() {
              if (Ui(self) && self.worker.meshoptUrl)
                return self.worker.meshoptUrl;
              if (Pu) return Pu;
              const n = new Uint8Array([
                0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0,
                5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0,
                252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11,
              ]);
              if (typeof WebAssembly != "object")
                throw new Error(
                  "WebAssembly not supported, cannot instantiate meshoptimizer",
                );
              return (
                (Pu = WebAssembly.validate(n)
                  ? hr.MESHOPT_SIMD_URL
                  : hr.MESHOPT_URL),
                Pu
              );
            }
            const Nm = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array,
              },
              KS = {
                5120: "DT_INT8",
                5121: "DT_UINT8",
                5122: "DT_INT16",
                5123: "DT_UINT16",
                5125: "DT_UINT32",
                5126: "DT_FLOAT32",
              },
              Tf = {
                SCALAR: 1,
                VEC2: 2,
                VEC3: 3,
                VEC4: 4,
                MAT2: 4,
                MAT3: 9,
                MAT4: 16,
              };
            function N0(n, e, i) {
              const o = i.json.bufferViews.length,
                a = i.buffers.length;
              ((e.bufferView = o),
                (i.json.bufferViews[o] = {
                  buffer: a,
                  byteLength: n.byteLength,
                }),
                (i.buffers[a] = n));
            }
            const yy = "KHR_draco_mesh_compression";
            function JS(n, e) {
              const i = n.extensions && n.extensions[yy];
              if (!i) return;
              const o = new _o.Decoder(),
                a = G0(e, i.bufferView),
                u = new _o.Mesh();
              if (!o.DecodeArrayToMesh(a, a.byteLength, u))
                throw new Error("Failed to decode Draco mesh");
              const d = e.json.accessors[n.indices],
                _ = Nm[d.componentType],
                v = d.count * _.BYTES_PER_ELEMENT,
                b = _o._malloc(v);
              (_ === Uint16Array
                ? o.GetTrianglesUInt16Array(u, v, b)
                : o.GetTrianglesUInt32Array(u, v, b),
                N0(_o.memory.buffer.slice(b, b + v), d, e),
                _o._free(b));
              for (const E of Object.keys(i.attributes)) {
                const A = o.GetAttributeByUniqueId(u, i.attributes[E]),
                  M = e.json.accessors[n.attributes[E]],
                  R = KS[M.componentType],
                  k =
                    M.count *
                    Tf[M.type] *
                    Nm[M.componentType].BYTES_PER_ELEMENT,
                  N = _o._malloc(k);
                (o.GetAttributeDataArrayForAllPoints(u, A, _o[R], k, N),
                  N0(_o.memory.buffer.slice(N, N + k), M, e),
                  _o._free(N));
              }
              (o.destroy(), u.destroy(), delete n.extensions[yy]);
            }
            const Vm = "EXT_meshopt_compression";
            function QS(n, e) {
              if (!n.extensions || !n.extensions[Vm]) return;
              const i = n.extensions[Vm],
                o = new Uint8Array(
                  e.buffers[i.buffer],
                  i.byteOffset || 0,
                  i.byteLength || 0,
                ),
                a = new Uint8Array(i.count * i.byteStride);
              (gy.decodeGltfBuffer(
                a,
                i.count,
                i.byteStride,
                o,
                i.mode,
                i.filter,
              ),
                (n.buffer = e.buffers.length),
                (n.byteOffset = 0),
                (e.buffers[n.buffer] = a.buffer),
                delete n.extensions[Vm]);
            }
            const V0 = 1179937895,
              U0 = new TextDecoder("utf8");
            function j0(n, e) {
              return new URL(n, e).href;
            }
            function eE(n, e, i, o) {
              return fetch(j0(n.uri, o))
                .then((a) => a.arrayBuffer())
                .then((a) => {
                  e.buffers[i] = a;
                });
            }
            function G0(n, e) {
              const i = n.json.bufferViews[e];
              return new Uint8Array(
                n.buffers[i.buffer],
                i.byteOffset || 0,
                i.byteLength,
              );
            }
            function tE(n, e, i, o) {
              if (n.uri) {
                const a = j0(n.uri, o);
                return fetch(a)
                  .then((u) => u.blob())
                  .then((u) => createImageBitmap(u))
                  .then((u) => {
                    e.images[i] = u;
                  });
              }
              if (n.bufferView !== void 0) {
                const a = G0(e, n.bufferView),
                  u = new Blob([a], { type: n.mimeType });
                return createImageBitmap(u).then((d) => {
                  e.images[i] = d;
                });
              }
            }
            function $0(n, e = 0, i) {
              const o = { json: null, images: [], buffers: [] };
              if (new Uint32Array(n, e, 1)[0] === V0) {
                const E = new Uint32Array(n, e);
                let A = 2;
                const M = (E[A++] >> 2) - 3,
                  R = E[A++] >> 2;
                if (
                  (A++,
                  (o.json = JSON.parse(U0.decode(E.subarray(A, A + R)))),
                  (A += R),
                  A < M)
                ) {
                  const k = E[A++];
                  A++;
                  const N = e + (A << 2);
                  o.buffers[0] = n.slice(N, N + k);
                }
              } else o.json = JSON.parse(U0.decode(new Uint8Array(n, e)));
              const {
                buffers: a,
                images: u,
                meshes: d,
                extensionsUsed: _,
                bufferViews: v,
              } = o.json;
              let b = Promise.resolve();
              if (a) {
                const E = [];
                for (let A = 0; A < a.length; A++) {
                  const M = a[A];
                  M.uri
                    ? E.push(eE(M, o, A, i))
                    : o.buffers[A] || (o.buffers[A] = null);
                }
                b = Promise.all(E);
              }
              return b.then(() => {
                const E = [],
                  A = _ && _.includes(yy),
                  M = _ && _.includes(Vm);
                if (
                  (A &&
                    E.push(
                      (function () {
                        if (!_o)
                          return (
                            wf ??
                            ((wf = (function (R) {
                              let k,
                                N = null;
                              function j() {
                                k = new Uint8Array(N.buffer);
                              }
                              function H() {
                                throw new Error("Unexpected Draco error.");
                              }
                              const J = {
                                a: {
                                  a: H,
                                  d: function (Q, V, X) {
                                    return k.copyWithin(Q, V, V + X);
                                  },
                                  c: function (Q) {
                                    const V = k.length,
                                      X = Math.max(Q >>> 0, Math.ceil(1.2 * V)),
                                      ee = Math.ceil((X - V) / 65536);
                                    try {
                                      return (N.grow(ee), j(), !0);
                                    } catch {
                                      return !1;
                                    }
                                  },
                                  b: H,
                                },
                              };
                              return (
                                WebAssembly.instantiateStreaming
                                  ? WebAssembly.instantiateStreaming(R, J)
                                  : R.then((Q) => Q.arrayBuffer()).then((Q) =>
                                      WebAssembly.instantiate(Q, J),
                                    )
                              ).then((Q) => {
                                const {
                                  Rb: V,
                                  Qb: X,
                                  P: ee,
                                  T: re,
                                  X: ve,
                                  Ja: ge,
                                  La: be,
                                  Qa: Me,
                                  Va: Ue,
                                  Wa: it,
                                  eb: Xe,
                                  jb: tt,
                                  f: nt,
                                  e: Ge,
                                  yb: Je,
                                  zb: Ne,
                                  Ab: je,
                                  Bb: at,
                                  Db: ct,
                                  Gb: Nt,
                                } = Q.instance.exports;
                                N = Ge;
                                const Ct = (() => {
                                  let yt = 0,
                                    ot = 0,
                                    Jt = 0,
                                    At = 0;
                                  return (Dt) => {
                                    (Jt &&
                                      (V(At), V(yt), (ot += Jt), (Jt = yt = 0)),
                                      yt || ((ot += 128), (yt = X(ot))));
                                    const Wt = (Dt.length + 7) & -8;
                                    let ni = yt;
                                    Wt >= ot && ((Jt = Wt), (ni = At = X(Wt)));
                                    for (let ii = 0; ii < Dt.length; ii++)
                                      k[ni + ii] = Dt[ii];
                                    return ni;
                                  };
                                })();
                                return (
                                  j(),
                                  nt(),
                                  {
                                    memory: Ge,
                                    _free: V,
                                    _malloc: X,
                                    Mesh: class {
                                      constructor() {
                                        this.ptr = ee();
                                      }
                                      destroy() {
                                        re(this.ptr);
                                      }
                                    },
                                    Decoder: class {
                                      constructor() {
                                        this.ptr = ge();
                                      }
                                      destroy() {
                                        tt(this.ptr);
                                      }
                                      DecodeArrayToMesh(yt, ot, Jt) {
                                        const At = Ct(yt),
                                          Dt = be(this.ptr, At, ot, Jt.ptr);
                                        return !!ve(Dt);
                                      }
                                      GetAttributeByUniqueId(yt, ot) {
                                        return {
                                          ptr: Me(this.ptr, yt.ptr, ot),
                                        };
                                      }
                                      GetTrianglesUInt16Array(yt, ot, Jt) {
                                        Ue(this.ptr, yt.ptr, ot, Jt);
                                      }
                                      GetTrianglesUInt32Array(yt, ot, Jt) {
                                        it(this.ptr, yt.ptr, ot, Jt);
                                      }
                                      GetAttributeDataArrayForAllPoints(
                                        yt,
                                        ot,
                                        Jt,
                                        At,
                                        Dt,
                                      ) {
                                        Xe(
                                          this.ptr,
                                          yt.ptr,
                                          ot.ptr,
                                          Jt,
                                          At,
                                          Dt,
                                        );
                                      }
                                    },
                                    DT_INT8: Je(),
                                    DT_UINT8: Ne(),
                                    DT_INT16: je(),
                                    DT_UINT16: at(),
                                    DT_UINT32: ct(),
                                    DT_FLOAT32: Nt(),
                                  }
                                );
                              });
                            })(fetch(F0()))),
                            wf.then((R) => {
                              ((_o = R), (wf = void 0));
                            }))
                          );
                      })(),
                    ),
                  M &&
                    E.push(
                      (function () {
                        if (gy) return;
                        const R = (function (k) {
                          let N;
                          const j = WebAssembly.instantiateStreaming(
                              k,
                              {},
                            ).then((Q) => {
                              ((N = Q.instance), N.exports.__wasm_call_ctors());
                            }),
                            H = {
                              NONE: "",
                              OCTAHEDRAL: "meshopt_decodeFilterOct",
                              QUATERNION: "meshopt_decodeFilterQuat",
                              EXPONENTIAL: "meshopt_decodeFilterExp",
                            },
                            J = {
                              ATTRIBUTES: "meshopt_decodeVertexBuffer",
                              TRIANGLES: "meshopt_decodeIndexBuffer",
                              INDICES: "meshopt_decodeIndexSequence",
                            };
                          return {
                            ready: j,
                            supported: !0,
                            decodeGltfBuffer(Q, V, X, ee, re, ve) {
                              (function (ge, be, Me, Ue, it, Xe, tt) {
                                const nt = ge.exports.sbrk,
                                  Ge = (Ue + 3) & -4,
                                  Je = nt(Ge * it),
                                  Ne = nt(Xe.length),
                                  je = new Uint8Array(ge.exports.memory.buffer);
                                je.set(Xe, Ne);
                                const at = be(Je, Ue, it, Ne, Xe.length);
                                if (
                                  (at === 0 && tt && tt(Je, Ge, it),
                                  Me.set(je.subarray(Je, Je + Ue * it)),
                                  nt(Je - nt(0)),
                                  at !== 0)
                                )
                                  throw new Error(
                                    `Malformed buffer data: ${at}`,
                                  );
                              })(
                                N,
                                N.exports[J[re]],
                                Q,
                                V,
                                X,
                                ee,
                                N.exports[H[ve]],
                              );
                            },
                          };
                        })(fetch(B0()));
                        return R.ready.then(() => {
                          gy = R;
                        });
                      })(),
                    ),
                  u)
                )
                  for (let R = 0; R < u.length; R++) E.push(tE(u[R], o, R, i));
                return (E.length ? Promise.all(E) : Promise.resolve()).then(
                  () => {
                    if (A && d)
                      for (const { primitives: R } of d)
                        for (const k of R) JS(k, o);
                    if (M && d && v) for (const R of v) QS(R, o);
                    return o;
                  },
                );
              });
            }
            class H0 {
              constructor(e) {
                ((this.layers = e.layers),
                  (this.layerIds = this.layers.map((i) => i.fqid)),
                  (this.hasPattern = !1),
                  (this.worldview = e.worldview));
              }
              updateFootprints(e, i) {}
              prepare() {
                return (function () {
                  if (_y != null || O0 != null) return null;
                  if (Ru != null) return Ru;
                  const e = fetch(hr.BUILDING_GEN_URL);
                  return (
                    (Ru = (function (i) {
                      let o, a, u, d;
                      function _() {
                        ((o = new Uint8Array(d.buffer)),
                          (a = new Int32Array(d.buffer)),
                          (u = new Float32Array(d.buffer)));
                      }
                      function v() {
                        throw new Error("Unexpected BuildingGen error.");
                      }
                      const b = () => {},
                        E = {
                          a: {
                            a: v,
                            f: function (A) {
                              const M = o.length,
                                R = Math.max(A >>> 0, Math.ceil(1.2 * M)),
                                k = Math.ceil((R - M) / 65536);
                              try {
                                return (d.grow(k), _(), !0);
                              } catch {
                                return !1;
                              }
                            },
                            g: v,
                            b,
                            c: b,
                            d: b,
                            e: b,
                          },
                        };
                      return (
                        WebAssembly.instantiateStreaming
                          ? WebAssembly.instantiateStreaming(i, E)
                          : i
                              .then((A) => A.arrayBuffer())
                              .then((A) => WebAssembly.instantiate(A, E))
                      ).then((A) => {
                        const M = A.instance.exports;
                        return (
                          (0, M.g)(),
                          (d = M.f),
                          _(),
                          new YS({
                            setStyle: M.h,
                            setAOOptions: M.i,
                            setMetricOptions: M.j,
                            setFacadeOptions: M.k,
                            addFeature: M.l,
                            addFacade: M.m,
                            generateMesh: M.n,
                            getLastError: M.o,
                            getMeshCount: M.p,
                            getPositionsPtr: M.q,
                            getPositionsLength: M.r,
                            getNormalsPtr: M.s,
                            getNormalsLength: M.t,
                            getColorsPtr: M.u,
                            getColorsLength: M.v,
                            getAOPtr: M.w,
                            getAOLength: M.x,
                            getIndicesPtr: M.y,
                            getIndicesLength: M.z,
                            getBuildingPart: M.A,
                            getRingCount: M.B,
                            getRingPtr: M.C,
                            getRingLength: M.D,
                            free: M.E,
                            malloc: M.F,
                            heapU8: o,
                            heap32: a,
                            heapF32: u,
                          })
                        );
                      });
                    })(e)
                      .then((i) => ((Ru = null), (_y = i), _y))
                      .catch((i) => {
                        (ri("Could not load building-gen"),
                          (Ru = null),
                          (O0 = i));
                      })),
                    Ru
                  );
                })();
              }
              populate(e, i, o, a) {}
              update(e, i, o, a, u, d, _) {}
              isEmpty() {
                return !1;
              }
              uploadPending() {
                return !1;
              }
              upload(e) {}
              destroy() {}
              getHeightAtTileCoord(e, i) {
                return { height: Number.NEGATIVE_INFINITY, hidden: !0 };
              }
            }
            let W0, q0;
            Tt(H0, "BuildingBucket", { omit: ["layers"] });
            const iE = Ai(
                [
                  { name: "a_pos_normal", components: 2, type: "Int16" },
                  { name: "a_data", components: 4, type: "Uint8" },
                  { name: "a_linesofar", components: 1, type: "Float32" },
                ],
                4,
              ),
              nE = Ai(
                [{ name: "a_z_offset_width", components: 3, type: "Float32" }],
                4,
              ),
              { members: rE } = iE,
              sE = Ai([{ name: "a_packed", components: 3, type: "Float32" }]),
              { members: oE } = sE,
              aE = Ai([
                { name: "a_pattern_data", components: 3, type: "Float32" },
              ]),
              { members: lE } = aE;
            class Z0 {
              constructor(e, i) {
                ((this.width = e),
                  (this.height = i),
                  (this.nextRow = 0),
                  (this.image = new Bl({ width: e, height: i })),
                  (this.positions = {}),
                  (this.uploaded = !1));
              }
              getDash(e, i) {
                const o = this.getKey(e, i);
                return this.positions[o];
              }
              trim() {
                const e = this.width,
                  i = (this.height = dt(this.nextRow));
                this.image.resize({ width: e, height: i });
              }
              getKey(e, i) {
                return e.join(",") + i;
              }
              getDashRanges(e, i, o) {
                const a = [];
                let u = e.length % 2 == 1 ? -e[e.length - 1] * o : 0,
                  d = e[0] * o,
                  _ = !0;
                a.push({
                  left: u,
                  right: d,
                  isDash: _,
                  zeroLength: e[0] === 0,
                });
                let v = e[0];
                for (let b = 1; b < e.length; b++) {
                  _ = !_;
                  const E = e[b];
                  ((u = v * o),
                    (v += E),
                    (d = v * o),
                    a.push({
                      left: u,
                      right: d,
                      isDash: _,
                      zeroLength: E === 0,
                    }));
                }
                return a;
              }
              addRoundDash(e, i, o) {
                const a = i / 2;
                for (let u = -o; u <= o; u++) {
                  const d = this.width * (this.nextRow + o + u);
                  let _ = 0,
                    v = e[_];
                  for (let b = 0; b < this.width; b++) {
                    b / v.right > 1 && (v = e[++_]);
                    const E = Math.abs(b - v.left),
                      A = Math.abs(b - v.right),
                      M = Math.min(E, A);
                    let R;
                    const k = (u / o) * (a + 1);
                    if (v.isDash) {
                      const N = a - Math.abs(k);
                      R = Math.sqrt(M * M + N * N);
                    } else R = a - Math.sqrt(M * M + k * k);
                    this.image.data[d + b] = Math.max(
                      0,
                      Math.min(255, R + 128),
                    );
                  }
                }
              }
              addRegularDash(e, i) {
                for (let v = e.length - 1; v >= 0; --v) {
                  const b = e[v],
                    E = e[v + 1];
                  b.zeroLength
                    ? e.splice(v, 1)
                    : E &&
                      E.isDash === b.isDash &&
                      ((E.left = b.left), e.splice(v, 1));
                }
                const o = e[0],
                  a = e[e.length - 1];
                o.isDash === a.isDash &&
                  ((o.left = a.left - this.width),
                  (a.right = o.right + this.width));
                const u = this.width * this.nextRow;
                let d = 0,
                  _ = e[d];
                for (let v = 0; v < this.width; v++) {
                  v / _.right > 1 && (_ = e[++d]);
                  const b = Math.abs(v - _.left),
                    E = Math.abs(v - _.right),
                    A = Math.min(b, E);
                  this.image.data[u + v] = Math.max(
                    0,
                    Math.min(255, (_.isDash ? A : -A) + i + 128),
                  );
                }
              }
              addDash(e, i) {
                const o = this.getKey(e, i);
                if (this.positions[o]) return this.positions[o];
                const a = i === "round",
                  u = a ? 7 : 0,
                  d = 2 * u + 1;
                if (this.nextRow + d > this.height)
                  return (ri("LineAtlas out of space"), null);
                e.length === 0 && e.push(1);
                let _ = 0;
                for (let E = 0; E < e.length; E++)
                  (e[E] < 0 &&
                    (ri(
                      "Negative value is found in line dasharray, replacing values with 0",
                    ),
                    (e[E] = 0)),
                    (_ += e[E]));
                if (_ !== 0) {
                  const E = this.width / _,
                    A = this.getDashRanges(e, this.width, E);
                  a
                    ? this.addRoundDash(A, E, u)
                    : this.addRegularDash(A, i === "square" ? 0.5 * E : 0);
                }
                const v = this.nextRow + u;
                this.nextRow += d;
                const b = { tl: [v, u], br: [_, 0] };
                return ((this.positions[o] = b), b);
              }
            }
            Tt(Z0, "LineAtlas");
            const cE = li.VectorTileFeature.types,
              hE = Math.cos((Math.PI / 180) * 37.5),
              uE = Math.cos((Math.PI / 180) * 5);
            class xy {
              constructor(e) {
                ((this.evaluationGlobals = { zoom: 0, lineProgress: void 0 }),
                  (this.elevationType = "none"),
                  (this.zoom = e.zoom),
                  (this.evaluationGlobals.zoom = this.zoom),
                  (this.overscaling = e.overscaling),
                  (this.pixelRatio = e.pixelRatio),
                  (this.layers = e.layers),
                  (this.layerIds = this.layers.map((i) => i.fqid)),
                  (this.index = e.index),
                  (this.projection = e.projection),
                  (this.hasPattern = !1),
                  (this.hasCrossSlope = !1),
                  (this.patternFeatures = []),
                  (this.lineClipsArray = []),
                  (this.gradients = {}),
                  this.layers.forEach((i) => {
                    this.gradients[i.id] = {};
                  }),
                  (this.layoutVertexArray = new qd()),
                  (this.layoutVertexArray2 = new Vs()),
                  (this.patternVertexArray = new Vs()),
                  (this.indexArray = new dr()),
                  (this.programConfigurations = new c(e.layers, {
                    zoom: e.zoom,
                    lut: e.lut,
                  })),
                  (this.segments = new Rn()),
                  (this.maxLineLength = 0),
                  (this.zOffsetVertexArray = new Vs()),
                  (this.stateDependentLayerIds = this.layers
                    .filter((i) => i.isStateDependent())
                    .map((i) => i.id)),
                  (this.tessellationStep = e.tessellationStep
                    ? e.tessellationStep
                    : mt / 64),
                  (this.worldview = e.worldview));
              }
              updateFootprints(e, i) {}
              populate(e, i, o, a) {
                this.hasPattern = iy("line", this.layers, this.pixelRatio, i);
                const u = this.layers[0].layout.get("line-sort-key");
                this.tileToMeter = Ve(o);
                const d = this.layers[0].layout.get("line-elevation-reference");
                if (d === "hd-road-markup") this.elevationType = "road";
                else {
                  const M = this.layers[0].layout.get("line-z-offset"),
                    R = M.isConstant() && !M.constantOr(0);
                  ((this.elevationType =
                    d !== "sea" && d !== "ground" && R ? "none" : "offset"),
                    this.elevationType === "offset" &&
                      d === "none" &&
                      ri(
                        `line-elevation-reference: ground is used for the layer ${this.layerIds[0]} because non-zero line-z-offset value was found.`,
                      ));
                }
                const _ = this.layers[0].layout.get("line-cross-slope");
                this.hasCrossSlope =
                  this.elevationType === "offset" && _ !== void 0;
                const v = [];
                for (const {
                  feature: M,
                  id: R,
                  index: k,
                  sourceLayerIndex: N,
                } of e) {
                  const j = this.layers[0]._featureFilter.needGeometry,
                    H = bt(M, j);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new qi(this.zoom, { worldview: this.worldview }),
                      H,
                      o,
                    )
                  )
                    continue;
                  const J = u ? u.evaluate(H, {}, o) : void 0,
                    Q = {
                      id: R,
                      properties: M.properties,
                      type: M.type,
                      sourceLayerIndex: N,
                      index: k,
                      geometry: j ? H.geometry : Et(M, o, a),
                      patterns: {},
                      sortKey: J,
                    };
                  v.push(Q);
                }
                u && v.sort((M, R) => M.sortKey - R.sortKey);
                const { lineAtlas: b, featureIndex: E } = i,
                  A = this.addConstantDashes(b);
                for (const M of v) {
                  const { geometry: R, index: k, sourceLayerIndex: N } = M;
                  if ((A && this.addFeatureDashes(M, b), this.hasPattern)) {
                    const j = ny(
                      "line",
                      this.layers,
                      M,
                      this.zoom,
                      this.pixelRatio,
                      i,
                    );
                    this.patternFeatures.push(j);
                  } else
                    this.addFeature(
                      M,
                      R,
                      k,
                      o,
                      b.positions,
                      i.availableImages,
                      i.brightness,
                      i.elevationFeatures,
                    );
                  E.insert(e[k].feature, R, k, N, this.index);
                }
              }
              addConstantDashes(e) {
                let i = !1;
                for (const o of this.layers) {
                  const a = o.paint.get("line-dasharray").value,
                    u = o.layout.get("line-cap").value;
                  if (a.kind !== "constant" || u.kind !== "constant") i = !0;
                  else {
                    const d = u.value,
                      _ = a.value;
                    if (!_) continue;
                    e.addDash(_, d);
                  }
                }
                return i;
              }
              addFeatureDashes(e, i) {
                const o = this.zoom;
                for (const a of this.layers) {
                  const u = a.paint.get("line-dasharray").value,
                    d = a.layout.get("line-cap").value;
                  if (u.kind === "constant" && d.kind === "constant") continue;
                  let _, v;
                  if (u.kind === "constant") {
                    if (((_ = u.value), !_)) continue;
                  } else _ = u.evaluate({ zoom: o }, e);
                  ((v =
                    d.kind === "constant"
                      ? d.value
                      : d.evaluate({ zoom: o }, e)),
                    i.addDash(_, v),
                    (e.patterns[a.id] = [i.getKey(_, v)]));
                }
              }
              update(e, i, o, a, u, d, _, v) {
                this.programConfigurations.updatePaintArrays(
                  e,
                  i,
                  u,
                  o,
                  a,
                  d,
                  _,
                  v,
                );
              }
              addFeatures(e, i, o, a, u, d) {
                for (const _ of this.patternFeatures)
                  this.addFeature(_, _.geometry, _.index, i, o, a, d);
              }
              isEmpty() {
                return this.layoutVertexArray.length === 0;
              }
              uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
              }
              upload(e) {
                (this.uploaded ||
                  (this.layoutVertexArray2.length !== 0 &&
                    (this.layoutVertexBuffer2 = e.createVertexBuffer(
                      this.layoutVertexArray2,
                      oE,
                    )),
                  this.patternVertexArray.length !== 0 &&
                    (this.patternVertexBuffer = e.createVertexBuffer(
                      this.patternVertexArray,
                      lE,
                    )),
                  !this.zOffsetVertexBuffer &&
                    this.zOffsetVertexArray.length > 0 &&
                    (this.zOffsetVertexBuffer = e.createVertexBuffer(
                      this.zOffsetVertexArray,
                      nE.members,
                      !0,
                    )),
                  (this.layoutVertexBuffer = e.createVertexBuffer(
                    this.layoutVertexArray,
                    rE,
                  )),
                  (this.indexBuffer = e.createIndexBuffer(this.indexArray))),
                  this.programConfigurations.upload(e),
                  (this.uploaded = !0));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.zOffsetVertexBuffer &&
                    this.zOffsetVertexBuffer.destroy(),
                  this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy());
              }
              lineFeatureClips(e) {
                if (
                  e.properties &&
                  e.properties.hasOwnProperty("mapbox_clip_start") &&
                  e.properties.hasOwnProperty("mapbox_clip_end")
                )
                  return {
                    start: +e.properties.mapbox_clip_start,
                    end: +e.properties.mapbox_clip_end,
                  };
              }
              addFeature(e, i, o, a, u, d, _, v) {
                const b = this.layers[0].layout,
                  E = b.get("line-join").evaluate(e, {}),
                  A = b.get("line-cap").evaluate(e, {}),
                  M = b.get("line-miter-limit"),
                  R = b.get("line-round-limit");
                ((this.lineClips = this.lineFeatureClips(e)),
                  (this.lineFeature = e),
                  (this.zOffsetValue = b.get("line-z-offset").value));
                const k = this.layers[0].paint.get("line-width").value;
                if (
                  (k.kind !== "constant" &&
                    k.isLineProgressConstant === !1 &&
                    (this.variableWidthValue = k),
                  this.elevationType === "road")
                ) {
                  const N = this.layoutVertexArray.length;
                  if (!this.addElevatedRoadFeature(e, i, a, v, E, A, M, R)) {
                    const [j, H] = this.clipRuntimeLinesToTile(i, 1);
                    for (let J = 0; J < j.length; J++) {
                      const Q = j[J],
                        V = H[J],
                        X = {
                          progress: {
                            min: V.progress.min,
                            max: V.progress.max,
                          },
                          nextDir: this.computeSegNextDir(V, Q),
                          prevDir: this.computeSegPrevDir(V, Q),
                        };
                      this.addLine(Q, e, a, E, A, M, R, X);
                    }
                    this.fillNonElevatedRoadSegment(N);
                  }
                } else for (const N of i) this.addLine(N, e, a, E, A, M, R);
                this.programConfigurations.populatePaintArrays(
                  this.layoutVertexArray.length,
                  e,
                  o,
                  u,
                  d,
                  a,
                  _,
                  void 0,
                  this.worldview,
                );
              }
              computeSegNextDir(e, i) {
                return e.nextPoint.sub(i.at(-2)).unit();
              }
              computeSegPrevDir(e, i) {
                return i[1].sub(e.prevPoint).unit();
              }
              clipLinesToTile(e, i) {
                return Fm(e, -i, -i, mt + i, mt + i);
              }
              clipRuntimeLinesToTile(e, i) {
                const o = [];
                return [Fm(e, -i, -i, mt + i, mt + i, o), o];
              }
              addElevatedRoadFeature(e, i, o, a, u, d, _, v) {
                const b = [],
                  E = cs.getElevationFeature(e, a);
                if (E) {
                  const A = this.clipLinesToTile(i, 1),
                    M = this.prepareElevatedLines(A, E, o);
                  for (const R of M)
                    b.push({
                      geometry: R,
                      elevation: E,
                      elevationTileID: o,
                      segment: {
                        progress: { min: 0, max: 1 },
                        nextDir: void 0,
                        prevDir: void 0,
                      },
                    });
                }
                if (b.length === 0) return !1;
                for (const A of b) {
                  const M = this.layoutVertexArray.length;
                  this.addLine(A.geometry, e, o, u, d, _, v);
                  const R = new zs(o, A.elevationTileID);
                  if (A.elevation)
                    for (let k = M; k < this.layoutVertexArray.length; k++) {
                      const N = new ft(
                          this.layoutVertexArray.int16[6 * k] >> 1,
                          this.layoutVertexArray.int16[6 * k + 1] >> 1,
                        ),
                        j = R.pointElevation(N, A.elevation, 0.05);
                      (this.updateHeightRange(j),
                        this.zOffsetVertexArray.emplaceBack(j, 0, 0));
                    }
                  else this.fillNonElevatedRoadSegment(M);
                }
                return !0;
              }
              prepareElevatedLines(e, i, o) {
                if (i.constantHeight != null) return e;
                const a = [],
                  u = 1 / Ve(o);
                for (const d of e) qS(d, new es(i, u), 0, a);
                return a;
              }
              fillNonElevatedRoadSegment(e) {
                for (let i = e; i < this.layoutVertexArray.length; i++)
                  this.zOffsetVertexArray.emplaceBack(0, 0, 0);
              }
              updateHeightRange(e) {
                this.heightRange
                  ? ((this.heightRange.min = Math.min(this.heightRange.min, e)),
                    (this.heightRange.max = Math.max(this.heightRange.max, e)))
                  : (this.heightRange = { min: e, max: e });
              }
              addLine(e, i, o, a, u, d, _, v) {
                ((this.distance = 0),
                  (this.prevDistance = 0),
                  (this.scaledDistance = 0),
                  (this.totalDistance = 0),
                  (this.totalFeatureLength = 0),
                  (this.lineSoFar = 0),
                  (this.currentVertex = void 0));
                const b = a === "none";
                ((this.patternJoinNone = this.hasPattern && b),
                  (this.segmentStart = 0),
                  (this.segmentStartf32 = 0),
                  (this.segmentPoints = []));
                const E = v && v.progress.min > 0,
                  A = v && v.progress.max < 1;
                if (this.lineClips) {
                  let ve = {
                      min: this.lineClips.start,
                      max: this.lineClips.end,
                    },
                    ge = 1;
                  if (v) {
                    const Ue = this.lineClips.end - this.lineClips.start;
                    ((ve = (function (it, Xe, tt) {
                      return {
                        min: sc(it.min, Xe, tt),
                        max: sc(it.max, Xe, tt),
                      };
                    })(v.progress, { min: 0, max: 1 }, ve)),
                      Ue > 0 && (ge = (ve.max - ve.min) / Ue));
                  }
                  const be = +i.properties.mapbox_clip_feature_len,
                    Me = +i.properties.mapbox_clip_seg_len;
                  if (Number.isNaN(be) || Number.isNaN(Me)) {
                    for (let it = 0; it < e.length - 1; it++)
                      this.totalDistance += e[it].dist(e[it + 1]);
                    const Ue = this.totalDistance / (ve.max - ve.min);
                    ((this.totalFeatureLength = Number.isFinite(Ue) ? Ue : 0),
                      (this.lineClips.start = ve.min),
                      (this.lineClips.end = ve.max),
                      (this.maxLineLength = Math.max(
                        this.maxLineLength,
                        this.totalDistance,
                      )));
                  } else
                    ((this.totalFeatureLength = be),
                      (this.distance = Me * ge),
                      (this.lineClips.start = ve.min),
                      (this.lineClips.end = ve.max),
                      (this.maxLineLength = Math.max(
                        this.maxLineLength,
                        this.distance,
                      )));
                  (this.lineClipsArray.push(this.lineClips),
                    this.updateScaledDistance());
                }
                const M = cE[i.type] === "Polygon";
                let R = e.length;
                for (; R >= 2 && e[R - 1].equals(e[R - 2]); ) R--;
                let k = 0;
                for (; k < R - 1 && e[k].equals(e[k + 1]); ) k++;
                if (R < (M ? 3 : 2)) return;
                a === "bevel" && (d = 1.05);
                const N = this.segments.prepareSegment(
                  10 * R,
                  this.layoutVertexArray,
                  this.indexArray,
                );
                let j, H, J, Q, V, X, ee, re;
                (v && v.prevDir && (X = v.prevDir.perp()),
                  v && v.nextDir && (ee = v.nextDir.perp()),
                  (this.e1 = this.e2 = -1),
                  M && ((j = e[R - 2]), (V = e[k].sub(j)._unit()._perp())));
                for (let ve = k; ve < R; ve++) {
                  if (
                    ((J = ve === R - 1 ? (M ? e[k + 1] : void 0) : e[ve + 1]),
                    J && e[ve].equals(J))
                  )
                    continue;
                  (V && (Q = V),
                    j && (H = j),
                    (j = e[ve]),
                    (re = this.evaluateLineProgressFeatures(H ? H.dist(j) : 0)),
                    (V = J ? J.sub(j)._unit()._perp() : Q),
                    (Q = Q || V));
                  const ge = H && J;
                  let be = ge ? a : M || b ? "butt" : u;
                  const Me = Q.x * V.x + Q.y * V.y;
                  if (b) {
                    const Ne = function (je) {
                      if (je.patternJoinNone) {
                        const at = je.segmentPoints.length / 2,
                          ct = je.lineSoFar - je.segmentStart;
                        for (let Nt = 0; Nt < at; ++Nt) {
                          const Ct = je.segmentPoints[2 * Nt + 1],
                            yt =
                              Math.round(je.segmentPoints[2 * Nt]) +
                              0.5 +
                              0.25 * Ct;
                          (je.patternVertexArray.emplaceBack(
                            yt,
                            ct,
                            je.segmentStart,
                          ),
                            je.patternVertexArray.emplaceBack(
                              yt,
                              ct,
                              je.segmentStart,
                            ));
                        }
                        je.segmentPoints.length = 0;
                      }
                      je.e1 = je.e2 = -1;
                    };
                    if (ge && Me < uE) {
                      (this.updateDistance(H, j),
                        this.addCurrentVertex(j, Q, 1, 1, N, re),
                        Ne(this),
                        this.addCurrentVertex(j, V, -1, -1, N, re));
                      continue;
                    }
                    if (H) {
                      if (!J) {
                        (this.updateDistance(H, j),
                          this.addCurrentVertex(j, Q, 1, 1, N, re),
                          Ne(this));
                        continue;
                      }
                      be = "miter";
                    }
                  }
                  let Ue = Q.add(V);
                  (Ue.x === 0 && Ue.y === 0) || Ue._unit();
                  const it = Ue.x * V.x + Ue.y * V.y,
                    Xe = it !== 0 ? 1 / it : 1 / 0,
                    tt = 2 * Math.sqrt(2 - 2 * it),
                    nt = it < hE && H && J,
                    Ge = Q.x * V.y - Q.y * V.x > 0,
                    Je =
                      this.overscaling <= 16
                        ? (15 * mt) / (512 * this.overscaling)
                        : 0;
                  if (ge && be === "round") {
                    if (Xe < _) be = "miter";
                    else if (Xe <= 2) {
                      const Ne = vy(j, -10, mt + 10);
                      be =
                        this.elevationType === "offset" &&
                        (Ne || this.hasCrossSlope)
                          ? "miter"
                          : "fakeround";
                    }
                  }
                  if (
                    (be === "miter" && Xe > d && (be = "bevel"),
                    be === "bevel" &&
                      (Xe > 2 && (be = "flipbevel"), Xe < d && (be = "miter")),
                    H && !(be === "miter" && nt) && this.updateDistance(H, j),
                    be === "miter")
                  )
                    if (nt) {
                      const Ne = j.dist(H);
                      if (Ne > 2 * Je) {
                        const at = j.sub(
                          j
                            .sub(H)
                            ._mult(Je / Ne)
                            ._round(),
                        );
                        (this.updateDistance(H, at),
                          this.addCurrentVertex(at, Q, 0, 0, N, re),
                          (H = at));
                      }
                      (this.updateDistance(H, j),
                        Ue._mult(Xe),
                        this.addCurrentVertex(j, Ue, 0, 0, N, re));
                      const je = j.dist(J);
                      if (je > 2 * Je) {
                        const at = j.add(
                          J.sub(j)
                            ._mult(Je / je)
                            ._round(),
                        );
                        (this.updateDistance(j, at),
                          this.addCurrentVertex(at, V, 0, 0, N, re),
                          (j = at));
                      }
                    } else
                      (Ue._mult(Xe), this.addCurrentVertex(j, Ue, 0, 0, N, re));
                  else if (be === "flipbevel") {
                    if (Xe > 100) Ue = V.mult(-1);
                    else {
                      const Ne = (Xe * Q.add(V).mag()) / Q.sub(V).mag();
                      Ue._perp()._mult(Ne * (Ge ? -1 : 1));
                    }
                    (this.addCurrentVertex(j, Ue, 0, 0, N, re),
                      this.addCurrentVertex(j, Ue.mult(-1), 0, 0, N, re));
                  } else if (be === "bevel" || be === "fakeround") {
                    re != null &&
                      H &&
                      this.addCurrentVertex(j, ee || Q, -1, -1, N, re);
                    const Ne = j.dist(H) <= 2 * Je && be !== "bevel",
                      je = Ue.mult(Ge ? 1 : -1);
                    je._mult(Xe);
                    const at = V.mult(Ge ? -1 : 1),
                      ct = Q.mult(Ge ? -1 : 1),
                      Nt = this.evaluateLineProgressFeatures(this.distance);
                    if (
                      (re == null &&
                        (this.addHalfVertex(j, je.x, je.y, !1, !Ge, 0, N, Nt),
                        Ne ||
                          this.addHalfVertex(
                            j,
                            je.x + 2 * ct.x,
                            je.y + 2 * ct.y,
                            !1,
                            Ge,
                            0,
                            N,
                            Nt,
                          )),
                      be === "fakeround")
                    ) {
                      const Ct = Math.round((180 * tt) / Math.PI / 20);
                      this.addHalfVertex(j, ct.x, ct.y, !1, Ge, 0, N, Nt);
                      for (let yt = 0; yt < Ct; yt++) {
                        let ot = yt / Ct;
                        if (ot !== 0.5) {
                          const At = ot - 0.5;
                          ot +=
                            ot *
                            At *
                            (ot - 1) *
                            ((1.0904 +
                              Me * (Me * (3.55645 - 1.43519 * Me) - 3.2452)) *
                              At *
                              At +
                              (0.848013 + Me * (0.215638 * Me - 1.06021)));
                        }
                        const Jt = at.sub(ct)._mult(ot)._add(ct)._unit();
                        this.addHalfVertex(j, Jt.x, Jt.y, !1, Ge, 0, N, Nt);
                      }
                      this.addHalfVertex(j, at.x, at.y, !1, Ge, 0, N, Nt);
                    }
                    (Ne ||
                      re != null ||
                      this.addHalfVertex(
                        j,
                        je.x + 2 * at.x,
                        je.y + 2 * at.y,
                        !1,
                        Ge,
                        0,
                        N,
                        Nt,
                      ),
                      re != null &&
                        J &&
                        this.addCurrentVertex(j, X || V, 1, 1, N, re));
                  } else if (be === "butt")
                    this.addCurrentVertex(j, Ue, 0, 0, N, re);
                  else if (be === "square") {
                    if (!H) {
                      const Ne = E ? 0 : -1;
                      this.addCurrentVertex(j, Ue, Ne, Ne, N, re);
                    }
                    if ((this.addCurrentVertex(j, Ue, 0, 0, N, re), H)) {
                      const Ne = A ? 0 : 1;
                      this.addCurrentVertex(j, Ue, Ne, Ne, N, re);
                    }
                  } else if (be === "round") {
                    if (H) {
                      const Ne = !ge && ee ? ee : Q;
                      (this.addCurrentVertex(j, Ne, 0, 0, N, re),
                        (!ge && A) ||
                          this.addCurrentVertex(j, Ne, 1, 1, N, re, !0));
                    }
                    if (J) {
                      const Ne = !ge && X ? X : V;
                      ((!ge && E) ||
                        this.addCurrentVertex(j, Ne, -1, -1, N, re, !0),
                        this.addCurrentVertex(j, Ne, 0, 0, N, re));
                    }
                  }
                }
              }
              addVerticesTo(e, i, o, a, u, d, _, v, b, E) {
                const A = ((i.w - e.w) / this.tessellationStep) | 0;
                let M = 0;
                const R = this.scaledDistance;
                if (A > 1) {
                  this.lineSoFar = e.w;
                  const N = (i.x - e.x) / A,
                    j = (i.y - e.y) / A,
                    H = (i.z - e.z) / A,
                    J = (i.w - e.w) / A;
                  for (let Q = 1; Q < A; ++Q) {
                    ((e.x += N),
                      (e.y += j),
                      (e.z += H),
                      (this.lineSoFar += J),
                      (M += J));
                    const V = this.evaluateLineProgressFeatures(
                      this.prevDistance + M,
                    );
                    ((this.scaledDistance =
                      (this.prevDistance + M) / this.totalDistance),
                      this.addHalfVertex(e, o, a, E, !1, _, b, V),
                      this.addHalfVertex(e, u, d, E, !0, -v, b, V));
                  }
                }
                ((this.lineSoFar = i.w), (this.scaledDistance = R));
                const k = this.evaluateLineProgressFeatures(this.distance);
                (this.addHalfVertex(i, o, a, E, !1, _, b, k),
                  this.addHalfVertex(i, u, d, E, !0, -v, b, k));
              }
              evaluateLineProgressFeatures(e) {
                if (!this.variableWidthValue && this.elevationType !== "offset")
                  return null;
                ((this.evaluationGlobals.lineProgress = 0),
                  this.lineClips
                    ? (this.evaluationGlobals.lineProgress = Math.min(
                        1,
                        (this.totalFeatureLength * this.lineClips.start + e) /
                          this.totalFeatureLength,
                      ))
                    : ri(
                        `line-progress evaluation for ${this.layerIds[0]} requires enabling 'lineMetrics' for the source.`,
                      ));
                let i = 0;
                return (
                  this.variableWidthValue &&
                    this.variableWidthValue.kind !== "constant" &&
                    (i =
                      this.variableWidthValue.evaluate(
                        this.evaluationGlobals,
                        this.lineFeature,
                      ) || 0),
                  this.elevationType !== "offset"
                    ? { zOffset: 0, variableWidth: i }
                    : this.zOffsetValue.kind === "constant"
                      ? { zOffset: this.zOffsetValue.value, variableWidth: i }
                      : {
                          zOffset:
                            this.zOffsetValue.evaluate(
                              this.evaluationGlobals,
                              this.lineFeature,
                            ) || 0,
                          variableWidth: i,
                        }
                );
              }
              addCurrentVertex(e, i, o, a, u, d, _ = !1) {
                const v = i.x + i.y * o,
                  b = i.y - i.x * o,
                  E = i.y * a - i.x,
                  A = -i.y - i.x * a;
                if (d != null) {
                  const M = this.elevationType === "offset",
                    R = -10,
                    k = mt + 10,
                    N = d.zOffset,
                    j = new C0(e.x, e.y, N, this.lineSoFar),
                    H = !!M && vy(e, R, k),
                    J = this.lineSoFar,
                    Q = this.distance;
                  if (this.currentVertex)
                    if (H) {
                      const V = this.currentVertexIsOutside,
                        X = this.currentVertex,
                        ee = new C0(e.x, e.y, N, this.lineSoFar);
                      if ((D0(X, ee, R, k), !vy(ee, R, k))) {
                        if (V) {
                          ((this.e1 = this.e2 = -1),
                            (this.distance -= X.dist(j)),
                            (this.lineSoFar = X.w));
                          const re = this.evaluateLineProgressFeatures(
                            X.w -
                              this.totalFeatureLength *
                                (this.lineClips ? this.lineClips.start : 0),
                          );
                          (this.addHalfVertex(X, v, b, _, !1, o, u, re),
                            this.addHalfVertex(X, E, A, _, !0, -a, u, re),
                            (this.prevDistance = this.distance));
                        }
                        ((this.distance = this.prevDistance + X.dist(ee)),
                          (this.scaledDistance =
                            this.distance / this.totalDistance),
                          this.addVerticesTo(X, ee, v, b, E, A, o, a, u, _),
                          (this.distance = Q),
                          (this.scaledDistance =
                            this.distance / this.totalDistance));
                      }
                    } else {
                      const V = this.currentVertex;
                      if (this.currentVertexIsOutside) {
                        (D0(V, j, R, k),
                          (this.e1 = this.e2 = -1),
                          (this.distance -= V.dist(j)),
                          (this.scaledDistance =
                            this.distance / this.totalDistance),
                          (this.lineSoFar = V.w));
                        const X = this.evaluateLineProgressFeatures(
                          V.w -
                            this.totalFeatureLength *
                              (this.lineClips ? this.lineClips.start : 0),
                        );
                        (this.addHalfVertex(V, v, b, _, !1, o, u, X),
                          this.addHalfVertex(V, E, A, _, !0, -a, u, X),
                          (this.prevDistance = this.distance),
                          (this.distance = Q),
                          (this.scaledDistance =
                            this.distance / this.totalDistance));
                      }
                      this.addVerticesTo(V, j, v, b, E, A, o, a, u, _);
                    }
                  else
                    H ||
                      (this.addHalfVertex(e, v, b, _, !1, o, u, d),
                      this.addHalfVertex(e, E, A, _, !0, -a, u, d));
                  ((this.currentVertex = j),
                    (this.currentVertexIsOutside = H),
                    (this.lineSoFar = J));
                } else
                  (this.addHalfVertex(e, v, b, _, !1, o, u, d),
                    this.addHalfVertex(e, E, A, _, !0, -a, u, d));
              }
              addHalfVertex({ x: e, y: i }, o, a, u, d, _, v, b) {
                if (
                  (this.patternJoinNone &&
                    (this.segmentPoints.length === 0 &&
                      ((this.segmentStart = this.lineSoFar),
                      (this.segmentStartf32 = Math.fround(this.lineSoFar))),
                    d ||
                      this.segmentPoints.push(
                        this.lineSoFar - this.segmentStart,
                        _,
                      )),
                  this.layoutVertexArray.emplaceBack(
                    (e << 1) + (u ? 1 : 0),
                    (i << 1) + (d ? 1 : 0),
                    Math.round(63 * o) + 128,
                    Math.round(63 * a) + 128,
                    1 + (_ === 0 ? 0 : _ < 0 ? -1 : 1),
                    0,
                    this.lineSoFar - this.segmentStartf32,
                  ),
                  this.lineClips)
                ) {
                  const A = Ht(
                    this.lineClips.start,
                    this.lineClips.end,
                    this.scaledDistance,
                  );
                  this.layoutVertexArray2.emplaceBack(
                    this.scaledDistance,
                    this.lineClipsArray.length,
                    A,
                  );
                }
                const E = v.vertexLength++;
                (this.e1 >= 0 &&
                  this.e2 >= 0 &&
                  (this.indexArray.emplaceBack(this.e1, this.e2, E),
                  v.primitiveLength++),
                  d ? (this.e2 = E) : (this.e1 = E),
                  b != null &&
                    this.zOffsetVertexArray.emplaceBack(
                      b.zOffset,
                      b.variableWidth,
                      b.variableWidth,
                    ));
              }
              updateScaledDistance() {
                this.lineClips
                  ? ((this.scaledDistance = this.distance / this.totalDistance),
                    (this.lineSoFar =
                      this.totalFeatureLength * this.lineClips.start +
                      this.distance))
                  : (this.lineSoFar = this.distance);
              }
              updateDistance(e, i) {
                ((this.prevDistance = this.distance),
                  (this.distance += e.dist(i)),
                  this.updateScaledDistance());
              }
            }
            function vy(n, e, i) {
              return n.x < e || n.x > i || n.y < e || n.y > i;
            }
            let X0, Y0;
            function K0(n, e, i) {
              return (
                e * (mt / (n.tileSize * Math.pow(2, i - n.tileID.overscaledZ)))
              );
            }
            Tt(xy, "LineBucket", {
              omit: [
                "layers",
                "patternFeatures",
                "currentVertex",
                "currentVertexIsOutside",
              ],
            });
            const J0 = (n, e, i) => (1 - i) * n + i * e;
            function Q0(n, e) {
              return 1 / K0(n, 1, e.tileZoom);
            }
            function eb(n, e, i, o) {
              return n.translatePosMatrix(
                o || e.tileID.projMatrix,
                e,
                i.paint.get("line-translate"),
                i.paint.get("line-translate-anchor"),
              );
            }
            const tb = (n) => {
              const e = [];
              (ib(n) && e.push("RENDER_LINE_DASH"),
                n.paint.get("line-gradient") && e.push("RENDER_LINE_GRADIENT"));
              const i = n.paint.get("line-trim-offset");
              ((i[0] === 0 && i[1] === 0) || e.push("RENDER_LINE_TRIM_OFFSET"),
                n.paint.get("line-border-width").constantOr(1) !== 0 &&
                  e.push("RENDER_LINE_BORDER"));
              const o =
                  n.layout.get("line-join").constantOr("miter") === "none",
                a = !!n.paint.get("line-pattern").constantOr(1);
              return (o && a && e.push("LINE_JOIN_NONE"), e);
            };
            function ib(n) {
              const e = n.paint.get("line-dasharray").value;
              return e.value || e.kind !== "constant";
            }
            let by;
            const nb = () =>
              by ||
              ((by = {
                layout:
                  X0 ||
                  (X0 = new Cn({
                    "line-cap": new vt(Pe.layout_line["line-cap"]),
                    "line-join": new vt(Pe.layout_line["line-join"]),
                    "line-miter-limit": new st(
                      Pe.layout_line["line-miter-limit"],
                    ),
                    "line-round-limit": new st(
                      Pe.layout_line["line-round-limit"],
                    ),
                    "line-sort-key": new vt(Pe.layout_line["line-sort-key"]),
                    "line-z-offset": new vt(Pe.layout_line["line-z-offset"]),
                    "line-elevation-reference": new st(
                      Pe.layout_line["line-elevation-reference"],
                    ),
                    "line-cross-slope": new st(
                      Pe.layout_line["line-cross-slope"],
                    ),
                    visibility: new st(Pe.layout_line.visibility),
                    "line-width-unit": new st(
                      Pe.layout_line["line-width-unit"],
                    ),
                  })),
                paint:
                  Y0 ||
                  (Y0 = new Cn({
                    "line-opacity": new vt(Pe.paint_line["line-opacity"]),
                    "line-color": new vt(Pe.paint_line["line-color"]),
                    "line-translate": new st(Pe.paint_line["line-translate"]),
                    "line-translate-anchor": new st(
                      Pe.paint_line["line-translate-anchor"],
                    ),
                    "line-width": new vt(Pe.paint_line["line-width"]),
                    "line-gap-width": new vt(Pe.paint_line["line-gap-width"]),
                    "line-offset": new vt(Pe.paint_line["line-offset"]),
                    "line-blur": new vt(Pe.paint_line["line-blur"]),
                    "line-dasharray": new vt(Pe.paint_line["line-dasharray"]),
                    "line-pattern": new vt(Pe.paint_line["line-pattern"]),
                    "line-pattern-cross-fade": new st(
                      Pe.paint_line["line-pattern-cross-fade"],
                    ),
                    "line-gradient": new Ra(Pe.paint_line["line-gradient"]),
                    "line-trim-offset": new st(
                      Pe.paint_line["line-trim-offset"],
                    ),
                    "line-trim-fade-range": new st(
                      Pe.paint_line["line-trim-fade-range"],
                    ),
                    "line-trim-color": new st(Pe.paint_line["line-trim-color"]),
                    "line-emissive-strength": new st(
                      Pe.paint_line["line-emissive-strength"],
                    ),
                    "line-border-width": new vt(
                      Pe.paint_line["line-border-width"],
                    ),
                    "line-border-color": new vt(
                      Pe.paint_line["line-border-color"],
                    ),
                    "line-occlusion-opacity": new st(
                      Pe.paint_line["line-occlusion-opacity"],
                    ),
                    "line-color-use-theme": new vt({
                      type: "string",
                      default: "default",
                      "property-type": "data-driven",
                    }),
                    "line-gradient-use-theme": new vt({
                      type: "string",
                      default: "default",
                      "property-type": "data-driven",
                    }),
                    "line-trim-color-use-theme": new vt({
                      type: "string",
                      default: "default",
                      "property-type": "data-driven",
                    }),
                    "line-border-color-use-theme": new vt({
                      type: "string",
                      default: "default",
                      "property-type": "data-driven",
                    }),
                  })),
              }),
              by);
            class dE extends vt {
              possiblyEvaluate(e, i) {
                return (
                  (i = new qi(Math.floor(i.zoom), {
                    now: i.now,
                    fadeDuration: i.fadeDuration,
                    transition: i.transition,
                    worldview: i.worldview,
                  })),
                  super.possiblyEvaluate(e, i)
                );
              }
              evaluate(e, i, o, a) {
                return (
                  (i = Le({}, i, { zoom: Math.floor(i.zoom) })),
                  super.evaluate(e, i, o, a)
                );
              }
            }
            let Sf;
            function rb(n, e) {
              return e > 0 ? e + 2 * n : n;
            }
            const fE = Ai(
                [
                  { name: "a_pos_offset", components: 4, type: "Int16" },
                  { name: "a_tex_size", components: 4, type: "Uint16" },
                  { name: "a_pixeloffset", components: 4, type: "Int16" },
                ],
                4,
              ),
              pE = Ai(
                [
                  { name: "a_globe_anchor", components: 3, type: "Int16" },
                  { name: "a_globe_normal", components: 3, type: "Float32" },
                ],
                4,
              ),
              mE = Ai(
                [{ name: "a_projected_pos", components: 4, type: "Float32" }],
                4,
              );
            Ai([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
            const gE = Ai(
                [{ name: "a_auto_z_offset", components: 1, type: "Float32" }],
                4,
              ),
              _E = Ai([
                { name: "a_x_axis", components: 3, type: "Float32" },
                { name: "a_y_axis", components: 3, type: "Float32" },
              ]),
              yE = Ai([{ name: "a_texb", components: 2, type: "Uint16" }]),
              xE = Ai([
                { name: "a_placed", components: 2, type: "Uint8" },
                { name: "a_shift", components: 2, type: "Float32" },
                {
                  name: "a_elevation_from_sea",
                  components: 2,
                  type: "Float32",
                },
              ]),
              vE = Ai([
                { name: "a_size_scale", components: 1, type: "Float32" },
                { name: "a_padding", components: 2, type: "Float32" },
                { name: "a_auto_z_offset", components: 1, type: "Float32" },
              ]);
            Ai([
              { type: "Int16", name: "projectedAnchorX" },
              { type: "Int16", name: "projectedAnchorY" },
              { type: "Int16", name: "projectedAnchorZ" },
              { type: "Int16", name: "tileAnchorX" },
              { type: "Int16", name: "tileAnchorY" },
              { type: "Float32", name: "x1" },
              { type: "Float32", name: "y1" },
              { type: "Float32", name: "x2" },
              { type: "Float32", name: "y2" },
              { type: "Int16", name: "padding" },
              { type: "Uint32", name: "featureIndex" },
              { type: "Uint16", name: "sourceLayerIndex" },
              { type: "Uint16", name: "bucketIndex" },
            ]);
            const sb = Ai(
                [
                  { name: "a_pos", components: 3, type: "Int16" },
                  { name: "a_anchor_pos", components: 2, type: "Int16" },
                  { name: "a_extrude", components: 2, type: "Int16" },
                ],
                4,
              ),
              bE = Ai(
                [
                  { name: "a_pos_2f", components: 2, type: "Float32" },
                  { name: "a_radius", components: 1, type: "Float32" },
                  { name: "a_flags", components: 2, type: "Int16" },
                ],
                4,
              );
            (Ai([{ name: "triangle", components: 3, type: "Uint16" }]),
              Ai([
                { type: "Int16", name: "projectedAnchorX" },
                { type: "Int16", name: "projectedAnchorY" },
                { type: "Int16", name: "projectedAnchorZ" },
                { type: "Float32", name: "tileAnchorX" },
                { type: "Float32", name: "tileAnchorY" },
                { type: "Uint16", name: "glyphStartIndex" },
                { type: "Uint16", name: "numGlyphs" },
                { type: "Uint32", name: "vertexStartIndex" },
                { type: "Uint32", name: "lineStartIndex" },
                { type: "Uint32", name: "lineLength" },
                { type: "Uint16", name: "segment" },
                { type: "Uint16", name: "lowerSize" },
                { type: "Uint16", name: "upperSize" },
                { type: "Float32", name: "lineOffsetX" },
                { type: "Float32", name: "lineOffsetY" },
                { type: "Uint8", name: "writingMode" },
                { type: "Uint8", name: "placedOrientation" },
                { type: "Uint8", name: "hidden" },
                { type: "Uint32", name: "crossTileID" },
                { type: "Int16", name: "associatedIconIndex" },
                { type: "Uint8", name: "flipState" },
              ]),
              Ai([
                { type: "Float32", name: "tileAnchorX" },
                { type: "Float32", name: "tileAnchorY" },
                { type: "Int16", name: "projectedAnchorX" },
                { type: "Int16", name: "projectedAnchorY" },
                { type: "Int16", name: "projectedAnchorZ" },
                { type: "Int16", name: "rightJustifiedTextSymbolIndex" },
                { type: "Int16", name: "centerJustifiedTextSymbolIndex" },
                { type: "Int16", name: "leftJustifiedTextSymbolIndex" },
                { type: "Int16", name: "verticalPlacedTextSymbolIndex" },
                { type: "Int16", name: "placedIconSymbolIndex" },
                { type: "Int16", name: "verticalPlacedIconSymbolIndex" },
                { type: "Uint16", name: "key" },
                { type: "Uint16", name: "textBoxStartIndex" },
                { type: "Uint16", name: "textBoxEndIndex" },
                { type: "Uint16", name: "verticalTextBoxStartIndex" },
                { type: "Uint16", name: "verticalTextBoxEndIndex" },
                { type: "Uint16", name: "iconBoxStartIndex" },
                { type: "Uint16", name: "iconBoxEndIndex" },
                { type: "Uint16", name: "verticalIconBoxStartIndex" },
                { type: "Uint16", name: "verticalIconBoxEndIndex" },
                { type: "Uint16", name: "featureIndex" },
                { type: "Uint16", name: "numHorizontalGlyphVertices" },
                { type: "Uint16", name: "numVerticalGlyphVertices" },
                { type: "Uint16", name: "numIconVertices" },
                { type: "Uint16", name: "numVerticalIconVertices" },
                { type: "Uint16", name: "useRuntimeCollisionCircles" },
                { type: "Uint32", name: "crossTileID" },
                { type: "Float32", components: 2, name: "textOffset" },
                { type: "Float32", name: "collisionCircleDiameter" },
                { type: "Float32", name: "zOffset" },
                { type: "Uint8", name: "hasIconTextFit" },
                { type: "Uint16", name: "elevationFeatureIndex" },
              ]),
              Ai([{ type: "Float32", name: "offsetX" }]),
              Ai([
                { type: "Int16", name: "x" },
                { type: "Int16", name: "y" },
              ]));
            var cr = 24;
            function wE(n, e, i) {
              return (
                n.sections.forEach((o) => {
                  o.text = (function (a, u, d) {
                    const _ = u.layout.get("text-transform").evaluate(d, {});
                    return (
                      _ === "uppercase"
                        ? (a = a.toLocaleUpperCase())
                        : _ === "lowercase" && (a = a.toLocaleLowerCase()),
                      fo.applyArabicShaping && (a = fo.applyArabicShaping(a)),
                      a
                    );
                  })(o.text, e, i);
                }),
                n
              );
            }
            const Ef = {
              "!": "",
              "#": "",
              $: "",
              "%": "",
              "&": "",
              "(": "",
              ")": "",
              "*": "",
              "+": "",
              ",": "",
              "-": "",
              ".": "",
              "/": "",
              ":": "",
              ";": "",
              "<": "",
              "=": "",
              ">": "",
              "?": "",
              "@": "",
              "[": "",
              "\\": "",
              "]": "",
              "^": "",
              _: "",
              "`": "",
              "{": "",
              "|": "",
              "}": "",
              "~": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
              "": "",
            };
            function TE(n) {
              return (
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === ""
              );
            }
            function SE(n) {
              return (
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === "" ||
                n === ""
              );
            }
            var ob,
              wy,
              ab,
              Ty = {};
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ function EE() {
              return (
                ob ||
                  ((ob = 1),
                  (Ty.read = function (n, e, i, o, a) {
                    var u,
                      d,
                      _ = 8 * a - o - 1,
                      v = (1 << _) - 1,
                      b = v >> 1,
                      E = -7,
                      A = i ? a - 1 : 0,
                      M = i ? -1 : 1,
                      R = n[e + A];
                    for (
                      A += M, u = R & ((1 << -E) - 1), R >>= -E, E += _;
                      E > 0;
                      u = 256 * u + n[e + A], A += M, E -= 8
                    );
                    for (
                      d = u & ((1 << -E) - 1), u >>= -E, E += o;
                      E > 0;
                      d = 256 * d + n[e + A], A += M, E -= 8
                    );
                    if (u === 0) u = 1 - b;
                    else {
                      if (u === v) return d ? NaN : (1 / 0) * (R ? -1 : 1);
                      ((d += Math.pow(2, o)), (u -= b));
                    }
                    return (R ? -1 : 1) * d * Math.pow(2, u - o);
                  }),
                  (Ty.write = function (n, e, i, o, a, u) {
                    var d,
                      _,
                      v,
                      b = 8 * u - a - 1,
                      E = (1 << b) - 1,
                      A = E >> 1,
                      M = a === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                      R = o ? 0 : u - 1,
                      k = o ? 1 : -1,
                      N = e < 0 || (e === 0 && 1 / e < 0) ? 1 : 0;
                    for (
                      e = Math.abs(e),
                        isNaN(e) || e === 1 / 0
                          ? ((_ = isNaN(e) ? 1 : 0), (d = E))
                          : ((d = Math.floor(Math.log(e) / Math.LN2)),
                            e * (v = Math.pow(2, -d)) < 1 && (d--, (v *= 2)),
                            (e += d + A >= 1 ? M / v : M * Math.pow(2, 1 - A)) *
                              v >=
                              2 && (d++, (v /= 2)),
                            d + A >= E
                              ? ((_ = 0), (d = E))
                              : d + A >= 1
                                ? ((_ = (e * v - 1) * Math.pow(2, a)), (d += A))
                                : ((_ =
                                    e * Math.pow(2, A - 1) * Math.pow(2, a)),
                                  (d = 0)));
                      a >= 8;
                      n[i + R] = 255 & _, R += k, _ /= 256, a -= 8
                    );
                    for (
                      d = (d << a) | _, b += a;
                      b > 0;
                      n[i + R] = 255 & d, R += k, d /= 256, b -= 8
                    );
                    n[i + R - k] |= 128 * N;
                  })),
                Ty
              );
            }
            function lb() {
              if (ab) return wy;
              ((ab = 1), (wy = e));
              var n = EE();
              function e(V) {
                ((this.buf =
                  ArrayBuffer.isView && ArrayBuffer.isView(V)
                    ? V
                    : new Uint8Array(V || 0)),
                  (this.pos = 0),
                  (this.type = 0),
                  (this.length = this.buf.length));
              }
              ((e.Varint = 0), (e.Fixed64 = 1), (e.Bytes = 2), (e.Fixed32 = 5));
              var i = 4294967296,
                o = 1 / i,
                a = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
              function u(V) {
                return V.type === e.Bytes ? V.readVarint() + V.pos : V.pos + 1;
              }
              function d(V, X, ee) {
                return ee
                  ? 4294967296 * X + (V >>> 0)
                  : 4294967296 * (X >>> 0) + (V >>> 0);
              }
              function _(V, X, ee) {
                var re =
                  X <= 16383
                    ? 1
                    : X <= 2097151
                      ? 2
                      : X <= 268435455
                        ? 3
                        : Math.floor(Math.log(X) / (7 * Math.LN2));
                ee.realloc(re);
                for (var ve = ee.pos - 1; ve >= V; ve--)
                  ee.buf[ve + re] = ee.buf[ve];
              }
              function v(V, X) {
                for (var ee = 0; ee < V.length; ee++) X.writeVarint(V[ee]);
              }
              function b(V, X) {
                for (var ee = 0; ee < V.length; ee++) X.writeSVarint(V[ee]);
              }
              function E(V, X) {
                for (var ee = 0; ee < V.length; ee++) X.writeFloat(V[ee]);
              }
              function A(V, X) {
                for (var ee = 0; ee < V.length; ee++) X.writeDouble(V[ee]);
              }
              function M(V, X) {
                for (var ee = 0; ee < V.length; ee++) X.writeBoolean(V[ee]);
              }
              function R(V, X) {
                for (var ee = 0; ee < V.length; ee++) X.writeFixed32(V[ee]);
              }
              function k(V, X) {
                for (var ee = 0; ee < V.length; ee++) X.writeSFixed32(V[ee]);
              }
              function N(V, X) {
                for (var ee = 0; ee < V.length; ee++) X.writeFixed64(V[ee]);
              }
              function j(V, X) {
                for (var ee = 0; ee < V.length; ee++) X.writeSFixed64(V[ee]);
              }
              function H(V, X) {
                return (
                  (V[X] | (V[X + 1] << 8) | (V[X + 2] << 16)) +
                  16777216 * V[X + 3]
                );
              }
              function J(V, X, ee) {
                ((V[ee] = X),
                  (V[ee + 1] = X >>> 8),
                  (V[ee + 2] = X >>> 16),
                  (V[ee + 3] = X >>> 24));
              }
              function Q(V, X) {
                return (
                  (V[X] | (V[X + 1] << 8) | (V[X + 2] << 16)) + (V[X + 3] << 24)
                );
              }
              return (
                (e.prototype = {
                  destroy: function () {
                    this.buf = null;
                  },
                  readFields: function (V, X, ee) {
                    for (ee = ee || this.length; this.pos < ee; ) {
                      var re = this.readVarint(),
                        ve = re >> 3,
                        ge = this.pos;
                      ((this.type = 7 & re),
                        V(ve, X, this),
                        this.pos === ge && this.skip(re));
                    }
                    return X;
                  },
                  readMessage: function (V, X) {
                    return this.readFields(V, X, this.readVarint() + this.pos);
                  },
                  readFixed32: function () {
                    var V = H(this.buf, this.pos);
                    return ((this.pos += 4), V);
                  },
                  readSFixed32: function () {
                    var V = Q(this.buf, this.pos);
                    return ((this.pos += 4), V);
                  },
                  readFixed64: function () {
                    var V =
                      H(this.buf, this.pos) + H(this.buf, this.pos + 4) * i;
                    return ((this.pos += 8), V);
                  },
                  readSFixed64: function () {
                    var V =
                      H(this.buf, this.pos) + Q(this.buf, this.pos + 4) * i;
                    return ((this.pos += 8), V);
                  },
                  readFloat: function () {
                    var V = n.read(this.buf, this.pos, !0, 23, 4);
                    return ((this.pos += 4), V);
                  },
                  readDouble: function () {
                    var V = n.read(this.buf, this.pos, !0, 52, 8);
                    return ((this.pos += 8), V);
                  },
                  readVarint: function (V) {
                    var X,
                      ee,
                      re = this.buf;
                    return (
                      (X = 127 & (ee = re[this.pos++])),
                      ee < 128
                        ? X
                        : ((X |= (127 & (ee = re[this.pos++])) << 7),
                          ee < 128
                            ? X
                            : ((X |= (127 & (ee = re[this.pos++])) << 14),
                              ee < 128
                                ? X
                                : ((X |= (127 & (ee = re[this.pos++])) << 21),
                                  ee < 128
                                    ? X
                                    : (function (ve, ge, be) {
                                        var Me,
                                          Ue,
                                          it = be.buf;
                                        if (
                                          ((Me =
                                            (112 & (Ue = it[be.pos++])) >> 4),
                                          Ue < 128 ||
                                            ((Me |=
                                              (127 & (Ue = it[be.pos++])) << 3),
                                            Ue < 128) ||
                                            ((Me |=
                                              (127 & (Ue = it[be.pos++])) <<
                                              10),
                                            Ue < 128) ||
                                            ((Me |=
                                              (127 & (Ue = it[be.pos++])) <<
                                              17),
                                            Ue < 128) ||
                                            ((Me |=
                                              (127 & (Ue = it[be.pos++])) <<
                                              24),
                                            Ue < 128) ||
                                            ((Me |=
                                              (1 & (Ue = it[be.pos++])) << 31),
                                            Ue < 128))
                                        )
                                          return d(ve, Me, ge);
                                        throw new Error(
                                          "Expected varint not more than 10 bytes",
                                        );
                                      })(
                                        (X |= (15 & (ee = re[this.pos])) << 28),
                                        V,
                                        this,
                                      ))))
                    );
                  },
                  readVarint64: function () {
                    return this.readVarint(!0);
                  },
                  readSVarint: function () {
                    var V = this.readVarint();
                    return V % 2 == 1 ? (V + 1) / -2 : V / 2;
                  },
                  readBoolean: function () {
                    return !!this.readVarint();
                  },
                  readString: function () {
                    var V = this.readVarint() + this.pos,
                      X = this.pos;
                    return (
                      (this.pos = V),
                      V - X >= 12 && a
                        ? (function (ee, re, ve) {
                            return a.decode(ee.subarray(re, ve));
                          })(this.buf, X, V)
                        : (function (ee, re, ve) {
                            for (var ge = "", be = re; be < ve; ) {
                              var Me,
                                Ue,
                                it,
                                Xe = ee[be],
                                tt = null,
                                nt =
                                  Xe > 239
                                    ? 4
                                    : Xe > 223
                                      ? 3
                                      : Xe > 191
                                        ? 2
                                        : 1;
                              if (be + nt > ve) break;
                              (nt === 1
                                ? Xe < 128 && (tt = Xe)
                                : nt === 2
                                  ? (192 & (Me = ee[be + 1])) == 128 &&
                                    (tt = ((31 & Xe) << 6) | (63 & Me)) <=
                                      127 &&
                                    (tt = null)
                                  : nt === 3
                                    ? ((Ue = ee[be + 2]),
                                      (192 & (Me = ee[be + 1])) == 128 &&
                                        (192 & Ue) == 128 &&
                                        ((tt =
                                          ((15 & Xe) << 12) |
                                          ((63 & Me) << 6) |
                                          (63 & Ue)) <= 2047 ||
                                          (tt >= 55296 && tt <= 57343)) &&
                                        (tt = null))
                                    : nt === 4 &&
                                      ((Ue = ee[be + 2]),
                                      (it = ee[be + 3]),
                                      (192 & (Me = ee[be + 1])) == 128 &&
                                        (192 & Ue) == 128 &&
                                        (192 & it) == 128 &&
                                        ((tt =
                                          ((15 & Xe) << 18) |
                                          ((63 & Me) << 12) |
                                          ((63 & Ue) << 6) |
                                          (63 & it)) <= 65535 ||
                                          tt >= 1114112) &&
                                        (tt = null)),
                                tt === null
                                  ? ((tt = 65533), (nt = 1))
                                  : tt > 65535 &&
                                    ((tt -= 65536),
                                    (ge += String.fromCharCode(
                                      ((tt >>> 10) & 1023) | 55296,
                                    )),
                                    (tt = 56320 | (1023 & tt))),
                                (ge += String.fromCharCode(tt)),
                                (be += nt));
                            }
                            return ge;
                          })(this.buf, X, V)
                    );
                  },
                  readBytes: function () {
                    var V = this.readVarint() + this.pos,
                      X = this.buf.subarray(this.pos, V);
                    return ((this.pos = V), X);
                  },
                  readPackedVarint: function (V, X) {
                    if (this.type !== e.Bytes)
                      return V.push(this.readVarint(X));
                    var ee = u(this);
                    for (V = V || []; this.pos < ee; )
                      V.push(this.readVarint(X));
                    return V;
                  },
                  readPackedSVarint: function (V) {
                    if (this.type !== e.Bytes)
                      return V.push(this.readSVarint());
                    var X = u(this);
                    for (V = V || []; this.pos < X; )
                      V.push(this.readSVarint());
                    return V;
                  },
                  readPackedBoolean: function (V) {
                    if (this.type !== e.Bytes)
                      return V.push(this.readBoolean());
                    var X = u(this);
                    for (V = V || []; this.pos < X; )
                      V.push(this.readBoolean());
                    return V;
                  },
                  readPackedFloat: function (V) {
                    if (this.type !== e.Bytes) return V.push(this.readFloat());
                    var X = u(this);
                    for (V = V || []; this.pos < X; ) V.push(this.readFloat());
                    return V;
                  },
                  readPackedDouble: function (V) {
                    if (this.type !== e.Bytes) return V.push(this.readDouble());
                    var X = u(this);
                    for (V = V || []; this.pos < X; ) V.push(this.readDouble());
                    return V;
                  },
                  readPackedFixed32: function (V) {
                    if (this.type !== e.Bytes)
                      return V.push(this.readFixed32());
                    var X = u(this);
                    for (V = V || []; this.pos < X; )
                      V.push(this.readFixed32());
                    return V;
                  },
                  readPackedSFixed32: function (V) {
                    if (this.type !== e.Bytes)
                      return V.push(this.readSFixed32());
                    var X = u(this);
                    for (V = V || []; this.pos < X; )
                      V.push(this.readSFixed32());
                    return V;
                  },
                  readPackedFixed64: function (V) {
                    if (this.type !== e.Bytes)
                      return V.push(this.readFixed64());
                    var X = u(this);
                    for (V = V || []; this.pos < X; )
                      V.push(this.readFixed64());
                    return V;
                  },
                  readPackedSFixed64: function (V) {
                    if (this.type !== e.Bytes)
                      return V.push(this.readSFixed64());
                    var X = u(this);
                    for (V = V || []; this.pos < X; )
                      V.push(this.readSFixed64());
                    return V;
                  },
                  skip: function (V) {
                    var X = 7 & V;
                    if (X === e.Varint) for (; this.buf[this.pos++] > 127; );
                    else if (X === e.Bytes)
                      this.pos = this.readVarint() + this.pos;
                    else if (X === e.Fixed32) this.pos += 4;
                    else {
                      if (X !== e.Fixed64)
                        throw new Error("Unimplemented type: " + X);
                      this.pos += 8;
                    }
                  },
                  writeTag: function (V, X) {
                    this.writeVarint((V << 3) | X);
                  },
                  realloc: function (V) {
                    for (var X = this.length || 16; X < this.pos + V; ) X *= 2;
                    if (X !== this.length) {
                      var ee = new Uint8Array(X);
                      (ee.set(this.buf), (this.buf = ee), (this.length = X));
                    }
                  },
                  finish: function () {
                    return (
                      (this.length = this.pos),
                      (this.pos = 0),
                      this.buf.subarray(0, this.length)
                    );
                  },
                  writeFixed32: function (V) {
                    (this.realloc(4),
                      J(this.buf, V, this.pos),
                      (this.pos += 4));
                  },
                  writeSFixed32: function (V) {
                    (this.realloc(4),
                      J(this.buf, V, this.pos),
                      (this.pos += 4));
                  },
                  writeFixed64: function (V) {
                    (this.realloc(8),
                      J(this.buf, -1 & V, this.pos),
                      J(this.buf, Math.floor(V * o), this.pos + 4),
                      (this.pos += 8));
                  },
                  writeSFixed64: function (V) {
                    (this.realloc(8),
                      J(this.buf, -1 & V, this.pos),
                      J(this.buf, Math.floor(V * o), this.pos + 4),
                      (this.pos += 8));
                  },
                  writeVarint: function (V) {
                    (V = +V || 0) > 268435455 || V < 0
                      ? (function (X, ee) {
                          var re, ve;
                          if (
                            (X >= 0
                              ? ((re = X % 4294967296 | 0),
                                (ve = (X / 4294967296) | 0))
                              : ((ve = ~(-X / 4294967296)),
                                4294967295 ^ (re = ~(-X % 4294967296))
                                  ? (re = (re + 1) | 0)
                                  : ((re = 0), (ve = (ve + 1) | 0))),
                            X >= 18446744073709552e3 ||
                              X < -18446744073709552e3)
                          )
                            throw new Error(
                              "Given varint doesn't fit into 10 bytes",
                            );
                          (ee.realloc(10),
                            (function (ge, be, Me) {
                              ((Me.buf[Me.pos++] = (127 & ge) | 128),
                                (ge >>>= 7),
                                (Me.buf[Me.pos++] = (127 & ge) | 128),
                                (ge >>>= 7),
                                (Me.buf[Me.pos++] = (127 & ge) | 128),
                                (ge >>>= 7),
                                (Me.buf[Me.pos++] = (127 & ge) | 128),
                                (Me.buf[Me.pos] = 127 & (ge >>>= 7)));
                            })(re, 0, ee),
                            (function (ge, be) {
                              var Me = (7 & ge) << 4;
                              ((be.buf[be.pos++] |=
                                Me | ((ge >>>= 3) ? 128 : 0)),
                                ge &&
                                  ((be.buf[be.pos++] =
                                    (127 & ge) | ((ge >>>= 7) ? 128 : 0)),
                                  ge &&
                                    ((be.buf[be.pos++] =
                                      (127 & ge) | ((ge >>>= 7) ? 128 : 0)),
                                    ge &&
                                      ((be.buf[be.pos++] =
                                        (127 & ge) | ((ge >>>= 7) ? 128 : 0)),
                                      ge &&
                                        ((be.buf[be.pos++] =
                                          (127 & ge) | ((ge >>>= 7) ? 128 : 0)),
                                        ge &&
                                          (be.buf[be.pos++] = 127 & ge))))));
                            })(ve, ee));
                        })(V, this)
                      : (this.realloc(4),
                        (this.buf[this.pos++] =
                          (127 & V) | (V > 127 ? 128 : 0)),
                        V <= 127 ||
                          ((this.buf[this.pos++] =
                            (127 & (V >>>= 7)) | (V > 127 ? 128 : 0)),
                          V <= 127 ||
                            ((this.buf[this.pos++] =
                              (127 & (V >>>= 7)) | (V > 127 ? 128 : 0)),
                            V <= 127 ||
                              (this.buf[this.pos++] = (V >>> 7) & 127))));
                  },
                  writeSVarint: function (V) {
                    this.writeVarint(V < 0 ? 2 * -V - 1 : 2 * V);
                  },
                  writeBoolean: function (V) {
                    this.writeVarint(!!V);
                  },
                  writeString: function (V) {
                    ((V = String(V)), this.realloc(4 * V.length), this.pos++);
                    var X = this.pos;
                    this.pos = (function (re, ve, ge) {
                      for (var be, Me, Ue = 0; Ue < ve.length; Ue++) {
                        if ((be = ve.charCodeAt(Ue)) > 55295 && be < 57344) {
                          if (!Me) {
                            be > 56319 || Ue + 1 === ve.length
                              ? ((re[ge++] = 239),
                                (re[ge++] = 191),
                                (re[ge++] = 189))
                              : (Me = be);
                            continue;
                          }
                          if (be < 56320) {
                            ((re[ge++] = 239),
                              (re[ge++] = 191),
                              (re[ge++] = 189),
                              (Me = be));
                            continue;
                          }
                          ((be = ((Me - 55296) << 10) | (be - 56320) | 65536),
                            (Me = null));
                        } else
                          Me &&
                            ((re[ge++] = 239),
                            (re[ge++] = 191),
                            (re[ge++] = 189),
                            (Me = null));
                        be < 128
                          ? (re[ge++] = be)
                          : (be < 2048
                              ? (re[ge++] = (be >> 6) | 192)
                              : (be < 65536
                                  ? (re[ge++] = (be >> 12) | 224)
                                  : ((re[ge++] = (be >> 18) | 240),
                                    (re[ge++] = ((be >> 12) & 63) | 128)),
                                (re[ge++] = ((be >> 6) & 63) | 128)),
                            (re[ge++] = (63 & be) | 128));
                      }
                      return ge;
                    })(this.buf, V, this.pos);
                    var ee = this.pos - X;
                    (ee >= 128 && _(X, ee, this),
                      (this.pos = X - 1),
                      this.writeVarint(ee),
                      (this.pos += ee));
                  },
                  writeFloat: function (V) {
                    (this.realloc(4),
                      n.write(this.buf, V, this.pos, !0, 23, 4),
                      (this.pos += 4));
                  },
                  writeDouble: function (V) {
                    (this.realloc(8),
                      n.write(this.buf, V, this.pos, !0, 52, 8),
                      (this.pos += 8));
                  },
                  writeBytes: function (V) {
                    var X = V.length;
                    (this.writeVarint(X), this.realloc(X));
                    for (var ee = 0; ee < X; ee++) this.buf[this.pos++] = V[ee];
                  },
                  writeRawMessage: function (V, X) {
                    this.pos++;
                    var ee = this.pos;
                    V(X, this);
                    var re = this.pos - ee;
                    (re >= 128 && _(ee, re, this),
                      (this.pos = ee - 1),
                      this.writeVarint(re),
                      (this.pos += re));
                  },
                  writeMessage: function (V, X, ee) {
                    (this.writeTag(V, e.Bytes), this.writeRawMessage(X, ee));
                  },
                  writePackedVarint: function (V, X) {
                    X.length && this.writeMessage(V, v, X);
                  },
                  writePackedSVarint: function (V, X) {
                    X.length && this.writeMessage(V, b, X);
                  },
                  writePackedBoolean: function (V, X) {
                    X.length && this.writeMessage(V, M, X);
                  },
                  writePackedFloat: function (V, X) {
                    X.length && this.writeMessage(V, E, X);
                  },
                  writePackedDouble: function (V, X) {
                    X.length && this.writeMessage(V, A, X);
                  },
                  writePackedFixed32: function (V, X) {
                    X.length && this.writeMessage(V, R, X);
                  },
                  writePackedSFixed32: function (V, X) {
                    X.length && this.writeMessage(V, k, X);
                  },
                  writePackedFixed64: function (V, X) {
                    X.length && this.writeMessage(V, N, X);
                  },
                  writePackedSFixed64: function (V, X) {
                    X.length && this.writeMessage(V, j, X);
                  },
                  writeBytesField: function (V, X) {
                    (this.writeTag(V, e.Bytes), this.writeBytes(X));
                  },
                  writeFixed32Field: function (V, X) {
                    (this.writeTag(V, e.Fixed32), this.writeFixed32(X));
                  },
                  writeSFixed32Field: function (V, X) {
                    (this.writeTag(V, e.Fixed32), this.writeSFixed32(X));
                  },
                  writeFixed64Field: function (V, X) {
                    (this.writeTag(V, e.Fixed64), this.writeFixed64(X));
                  },
                  writeSFixed64Field: function (V, X) {
                    (this.writeTag(V, e.Fixed64), this.writeSFixed64(X));
                  },
                  writeVarintField: function (V, X) {
                    (this.writeTag(V, e.Varint), this.writeVarint(X));
                  },
                  writeSVarintField: function (V, X) {
                    (this.writeTag(V, e.Varint), this.writeSVarint(X));
                  },
                  writeStringField: function (V, X) {
                    (this.writeTag(V, e.Bytes), this.writeString(X));
                  },
                  writeFloatField: function (V, X) {
                    (this.writeTag(V, e.Fixed32), this.writeFloat(X));
                  },
                  writeDoubleField: function (V, X) {
                    (this.writeTag(V, e.Fixed64), this.writeDouble(X));
                  },
                  writeBooleanField: function (V, X) {
                    this.writeVarintField(V, !!X);
                  },
                }),
                wy
              );
            }
            var Um = Co(lb());
            const Sy = 3;
            function IE(n, e, i) {
              ((e.glyphs = []), n === 1 && i.readMessage(AE, e));
            }
            function AE(n, e, i) {
              if (n === 3) {
                const {
                  id: o,
                  bitmap: a,
                  width: u,
                  height: d,
                  left: _,
                  top: v,
                  advance: b,
                } = i.readMessage(ME, {});
                e.glyphs.push({
                  id: o,
                  bitmap: new Bl({ width: u + 2 * Sy, height: d + 2 * Sy }, a),
                  metrics: { width: u, height: d, left: _, top: v, advance: b },
                });
              } else
                n === 4
                  ? (e.ascender = i.readSVarint())
                  : n === 5 && (e.descender = i.readSVarint());
            }
            function ME(n, e, i) {
              n === 1
                ? (e.id = i.readVarint())
                : n === 2
                  ? (e.bitmap = i.readBytes())
                  : n === 3
                    ? (e.width = i.readVarint())
                    : n === 4
                      ? (e.height = i.readVarint())
                      : n === 5
                        ? (e.left = i.readSVarint())
                        : n === 6
                          ? (e.top = i.readSVarint())
                          : n === 7 && (e.advance = i.readVarint());
            }
            const CE = Sy,
              hs = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
            class If {
              constructor() {
                ((this.scale = 1), (this.fontStack = ""), (this.image = null));
              }
              static forText(e, i) {
                const o = new If();
                return ((o.scale = e || 1), (o.fontStack = i), o);
              }
              static forImage(e) {
                const i = new If();
                return ((i.image = e), i);
              }
            }
            class zu {
              constructor() {
                ((this.text = ""),
                  (this.sectionIndex = []),
                  (this.sections = []),
                  (this.imageSectionID = null));
              }
              static fromFeature(e, i, o) {
                const a = new zu();
                for (let u = 0; u < e.sections.length; u++) {
                  const d = e.sections[u];
                  d.image ? a.addImageSection(d, o) : a.addTextSection(d, i);
                }
                return a;
              }
              length() {
                return this.text.length;
              }
              getSection(e) {
                return this.sections[this.sectionIndex[e]];
              }
              getSections() {
                return this.sections;
              }
              getSectionIndex(e) {
                return this.sectionIndex[e];
              }
              getCodePoint(e) {
                return this.text.codePointAt(e);
              }
              verticalizePunctuation(e) {
                this.text = (function (i, o) {
                  let a = "";
                  for (let u = 0; u < i.length; u++) {
                    const d = i.charCodeAt(u + 1) || null,
                      _ = i.charCodeAt(u - 1) || null;
                    a +=
                      (!o &&
                        ((d && Qp(d) && !Ef[i[u + 1]]) ||
                          (_ && Qp(_) && !Ef[i[u - 1]]))) ||
                      !Ef[i[u]]
                        ? i[u]
                        : Ef[i[u]];
                  }
                  return a;
                })(this.text, e);
              }
              trim() {
                let e = 0;
                for (
                  let o = 0;
                  o < this.text.length && jm[this.text.charCodeAt(o)];
                  o++
                )
                  e++;
                let i = this.text.length;
                for (
                  let o = this.text.length - 1;
                  o >= 0 && o >= e && jm[this.text.charCodeAt(o)];
                  o--
                )
                  i--;
                ((this.text = this.text.substring(e, i)),
                  (this.sectionIndex = this.sectionIndex.slice(e, i)));
              }
              substring(e, i) {
                const o = new zu();
                return (
                  (o.text = this.text.substring(e, i)),
                  (o.sectionIndex = this.sectionIndex.slice(e, i)),
                  (o.sections = this.sections),
                  o
                );
              }
              toString() {
                return this.text;
              }
              getMaxScale() {
                return this.sectionIndex.reduce(
                  (e, i) => Math.max(e, this.sections[i].scale),
                  0,
                );
              }
              addTextSection(e, i) {
                ((this.text += e.text),
                  this.sections.push(If.forText(e.scale, e.fontStack || i)));
                const o = this.sections.length - 1;
                for (let a = 0; a < e.text.length; ++a)
                  this.sectionIndex.push(o);
              }
              addImageSection(e, i) {
                const o = e.image ? e.image.getPrimary() : null;
                if (!o)
                  return void ri(
                    "Can't add FormattedSection with an empty image.",
                  );
                o.scaleSelf(i);
                const a = this.getNextImageSectionCharCode();
                a
                  ? ((this.text += String.fromCodePoint(a)),
                    this.sections.push(If.forImage(o)),
                    this.sectionIndex.push(this.sections.length - 1))
                  : ri("Reached maximum number of images 6401");
              }
              getNextImageSectionCharCode() {
                return this.imageSectionID
                  ? this.imageSectionID >= 63743
                    ? null
                    : ++this.imageSectionID
                  : ((this.imageSectionID = 57344), this.imageSectionID);
              }
            }
            function Ey(n, e, i, o, a, u, d, _, v, b, E, A, M, R, k, N = 1) {
              const j = zu.fromFeature(n, a, N);
              A === hs.vertical && j.verticalizePunctuation(M);
              let H = [];
              const J = (function (re, ve, ge, be, Me, Ue) {
                  if (!re) return [];
                  const it = [],
                    Xe = (function (Je, Ne, je, at, ct, Nt) {
                      let Ct = 0;
                      for (let yt = 0; yt < Je.length(); yt++) {
                        const ot = Je.getSection(yt);
                        Ct += cb(Je.getCodePoint(yt), ot, at, ct, Ne, Nt);
                      }
                      return Ct / Math.max(1, Math.ceil(Ct / je));
                    })(re, ve, ge, be, Me, Ue),
                    tt = re.text.indexOf("") >= 0;
                  let nt = 0;
                  for (let Je = 0; Je < re.length(); Je++) {
                    const Ne = re.getSection(Je),
                      je = re.getCodePoint(Je);
                    if (
                      (jm[je] || (nt += cb(je, Ne, be, Me, ve, Ue)),
                      Je < re.length() - 1)
                    ) {
                      const at = !(
                        (Ge = je) < 11904 ||
                        !(
                          Ut["Bopomofo Extended"](Ge) ||
                          Ut.Bopomofo(Ge) ||
                          Ut["CJK Compatibility Forms"](Ge) ||
                          Ut["CJK Compatibility Ideographs"](Ge) ||
                          Ut["CJK Compatibility"](Ge) ||
                          Ut["CJK Radicals Supplement"](Ge) ||
                          Ut["CJK Strokes"](Ge) ||
                          Ut["CJK Symbols and Punctuation"](Ge) ||
                          Ut["CJK Unified Ideographs Extension A"](Ge) ||
                          Ut["CJK Unified Ideographs"](Ge) ||
                          Ut["Enclosed CJK Letters and Months"](Ge) ||
                          Ut["Halfwidth and Fullwidth Forms"](Ge) ||
                          Ut.Hiragana(Ge) ||
                          Ut["Ideographic Description Characters"](Ge) ||
                          Ut["Kangxi Radicals"](Ge) ||
                          Ut["Katakana Phonetic Extensions"](Ge) ||
                          Ut.Katakana(Ge) ||
                          Ut["Vertical Forms"](Ge) ||
                          Ut["Yi Radicals"](Ge) ||
                          Ut["Yi Syllables"](Ge)
                        )
                      );
                      (PE[je] || at || Ne.image) &&
                        it.push(
                          ub(
                            Je + 1,
                            nt,
                            Xe,
                            it,
                            DE(je, re.getCodePoint(Je + 1), at && tt),
                            !1,
                          ),
                        );
                    }
                  }
                  var Ge;
                  return db(ub(re.length(), nt, Xe, it, 0, !0));
                })(j, b, u, e, o, R),
                {
                  processBidirectionalText: Q,
                  processStyledBidirectionalText: V,
                } = fo;
              if (Q && j.sections.length === 1) {
                const re = Q(j.toString(), J);
                for (const ve of re) {
                  const ge = new zu();
                  ((ge.text = ve), (ge.sections = j.sections));
                  for (let be = 0; be < ve.length; be++)
                    ge.sectionIndex.push(0);
                  H.push(ge);
                }
              } else if (V) {
                const re = V(j.text, j.sectionIndex, J);
                for (const ve of re) {
                  const ge = new zu();
                  ((ge.text = ve[0]),
                    (ge.sectionIndex = ve[1]),
                    (ge.sections = j.sections),
                    H.push(ge));
                }
              } else
                H = (function (re, ve) {
                  const ge = [],
                    be = re.text;
                  let Me = 0;
                  for (const Ue of ve)
                    (ge.push(re.substring(Me, Ue)), (Me = Ue));
                  return (
                    Me < be.length && ge.push(re.substring(Me, be.length)),
                    ge
                  );
                })(j, J);
              const X = [],
                ee = {
                  positionedLines: X,
                  text: j.toString(),
                  top: E[1],
                  bottom: E[1],
                  left: E[0],
                  right: E[0],
                  writingMode: A,
                  iconsInText: !1,
                  verticalizable: !1,
                  hasBaseline: !1,
                };
              if (
                ((function (re, ve, ge, be, Me, Ue, it, Xe, tt, nt, Ge, Je) {
                  let Ne = 0,
                    je = 0,
                    at = 0;
                  const ct = Xe === "right" ? 1 : Xe === "left" ? 0 : 0.5;
                  let Nt = !1;
                  for (const Dt of Me) {
                    const Wt = Dt.getSections();
                    for (const ni of Wt) {
                      if (ni.image) continue;
                      const ii = ve[ni.fontStack];
                      if (
                        ii &&
                        ((Nt =
                          ii.ascender !== void 0 && ii.descender !== void 0),
                        !Nt)
                      )
                        break;
                    }
                    if (!Nt) break;
                  }
                  let Ct = 0;
                  for (const Dt of Me) {
                    Dt.trim();
                    const Wt = Dt.getMaxScale(),
                      ni = (Wt - 1) * cr,
                      ii = { positionedGlyphs: [], lineOffset: 0 };
                    re.positionedLines[Ct] = ii;
                    const di = ii.positionedGlyphs;
                    let oi = 0;
                    if (!Dt.length()) {
                      ((je += Ue), ++Ct);
                      continue;
                    }
                    let fi = 0,
                      Bi = 0;
                    for (let te = 0; te < Dt.length(); te++) {
                      const se = Dt.getSection(te),
                        $e = Dt.getSectionIndex(te),
                        ut = Dt.getCodePoint(te);
                      let xt = se.scale,
                        _t = null,
                        It = null,
                        $t = null,
                        yi = cr,
                        xi = 0;
                      tt === hs.vertical &&
                        ((yt = ut) === 12312 ||
                          yt === 12313 ||
                          yt === 12316 ||
                          yt === 12540 ||
                          yt === 12448) &&
                        (tt = hs.horizontal);
                      const ai = !(
                        tt === hs.horizontal ||
                        (!Ge && !Nd(ut)) ||
                        (Ge && (jm[ut] || F_(ut)))
                      );
                      if (se.image) {
                        const Gi = be.get(se.image.toString());
                        if (!Gi) continue;
                        (($t = se.image),
                          (re.iconsInText = re.iconsInText || !0),
                          (It = Gi.paddedRect));
                        const Qi = Gi.displaySize;
                        ((xt = (xt * cr) / Je),
                          (_t = {
                            width: Qi[0],
                            height: Qi[1],
                            left: 0,
                            top: -3,
                            advance: ai ? Qi[1] : Qi[0],
                            localGlyph: !1,
                          }),
                          (xi = Nt
                            ? -_t.height * xt
                            : Wt * cr - 17 - Qi[1] * xt),
                          (yi = _t.advance));
                        const vi = (ai ? Qi[0] : Qi[1]) * xt - cr * Wt;
                        vi > 0 && vi > oi && (oi = vi);
                      } else {
                        const Gi = ge[se.fontStack];
                        if (!Gi) continue;
                        Gi[ut] && (It = Gi[ut]);
                        const Qi = ve[se.fontStack];
                        if (!Qi) continue;
                        const vi = Qi.glyphs[ut];
                        if (!vi) continue;
                        if (
                          ((_t = vi.metrics), (yi = ut !== 8203 ? cr : 0), Nt)
                        ) {
                          const En =
                              Qi.ascender !== void 0
                                ? Math.abs(Qi.ascender)
                                : 0,
                            on =
                              Qi.descender !== void 0
                                ? Math.abs(Qi.descender)
                                : 0,
                            Ni = (En + on) * xt;
                          (fi < Ni && ((fi = Ni), (Bi = ((En - on) / 2) * xt)),
                            (xi = -En * xt));
                        } else xi = (Wt - xt) * cr - 17;
                      }
                      ai
                        ? ((re.verticalizable = !0),
                          di.push({
                            glyph: ut,
                            image: $t,
                            x: Ne,
                            y: je + xi,
                            vertical: ai,
                            scale: xt,
                            localGlyph: _t.localGlyph,
                            fontStack: se.fontStack,
                            sectionIndex: $e,
                            metrics: _t,
                            rect: It,
                          }),
                          (Ne += yi * xt + nt))
                        : (di.push({
                            glyph: ut,
                            image: $t,
                            x: Ne,
                            y: je + xi,
                            vertical: ai,
                            scale: xt,
                            localGlyph: _t.localGlyph,
                            fontStack: se.fontStack,
                            sectionIndex: $e,
                            metrics: _t,
                            rect: It,
                          }),
                          (Ne += _t.advance * xt + nt));
                    }
                    (di.length !== 0 &&
                      ((at = Math.max(Ne - nt, at)),
                      Nt
                        ? fb(di, ct, oi, Bi, (Ue * Wt) / 2)
                        : fb(di, ct, oi, 0, Ue / 2)),
                      (Ne = 0));
                    const sn = Ue * Wt + oi;
                    ((ii.lineOffset = Math.max(oi, ni)), (je += sn), ++Ct);
                  }
                  var yt;
                  const ot = je,
                    { horizontalAlign: Jt, verticalAlign: At } = Iy(it);
                  ((function (Dt, Wt, ni, ii, di, oi) {
                    const fi = (Wt - ni) * di,
                      Bi = -oi * ii;
                    for (const sn of Dt)
                      for (const te of sn.positionedGlyphs)
                        ((te.x += fi), (te.y += Bi));
                  })(re.positionedLines, ct, Jt, At, at, ot),
                    (re.top += -At * ot),
                    (re.bottom = re.top + ot),
                    (re.left += -Jt * at),
                    (re.right = re.left + at),
                    (re.hasBaseline = Nt));
                })(ee, e, i, o, H, d, _, v, A, b, M, k),
                !(function (re) {
                  for (const ve of re)
                    if (ve.positionedGlyphs.length !== 0) return !1;
                  return !0;
                })(X))
              )
                return ee;
            }
            const jm = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 },
              PE = {
                10: !0,
                32: !0,
                38: !0,
                40: !0,
                41: !0,
                43: !0,
                45: !0,
                47: !0,
                173: !0,
                183: !0,
                8203: !0,
                8208: !0,
                8211: !0,
                8231: !0,
              };
            function cb(n, e, i, o, a, u) {
              if (e.image) {
                const d = o.get(e.image.toString());
                return d ? (d.displaySize[0] * e.scale * cr) / u + a : 0;
              }
              {
                const d = i[e.fontStack],
                  _ = d && d.glyphs[n];
                return _ ? _.metrics.advance * e.scale + a : 0;
              }
            }
            function hb(n, e, i, o) {
              const a = Math.pow(n - e, 2);
              return o ? (n < e ? a / 2 : 2 * a) : a + Math.abs(i) * i;
            }
            function DE(n, e, i) {
              let o = 0;
              return (
                n === 10 && (o -= 1e4),
                i && (o += 150),
                (n !== 40 && n !== 65288) || (o += 50),
                (e !== 41 && e !== 65289) || (o += 50),
                o
              );
            }
            function ub(n, e, i, o, a, u) {
              let d = null,
                _ = hb(e, i, a, u);
              for (const v of o) {
                const b = hb(e - v.x, i, a, u) + v.badness;
                b <= _ && ((d = v), (_ = b));
              }
              return { index: n, x: e, priorBreak: d, badness: _ };
            }
            function db(n) {
              return n ? db(n.priorBreak).concat(n.index) : [];
            }
            function Iy(n) {
              let e = 0.5,
                i = 0.5;
              switch (n) {
                case "right":
                case "top-right":
                case "bottom-right":
                  e = 1;
                  break;
                case "left":
                case "top-left":
                case "bottom-left":
                  e = 0;
              }
              switch (n) {
                case "bottom":
                case "bottom-right":
                case "bottom-left":
                  i = 1;
                  break;
                case "top":
                case "top-right":
                case "top-left":
                  i = 0;
              }
              return { horizontalAlign: e, verticalAlign: i };
            }
            function fb(n, e, i, o, a) {
              if (!(e || i || o || a)) return;
              const u = n.length - 1,
                d = n[u],
                _ = (d.x + d.metrics.advance * d.scale) * e;
              for (let v = 0; v <= u; v++)
                ((n[v].x -= _), (n[v].y += i + o + a));
            }
            function pb(n) {
              return (
                n.imagePrimary !== void 0 &&
                n.top !== void 0 &&
                n.bottom !== void 0 &&
                n.left !== void 0 &&
                n.right !== void 0
              );
            }
            function RE(n, e, i, o) {
              const { horizontalAlign: a, verticalAlign: u } = Iy(o),
                d = i[0] - n.displaySize[0] * a,
                _ = i[1] - n.displaySize[1] * u;
              return {
                imagePrimary: n,
                imageSecondary: e,
                top: _,
                bottom: _ + n.displaySize[1],
                left: d,
                right: d + n.displaySize[0],
              };
            }
            function mb(n, e, i, o, a, u) {
              const d = n.imagePrimary;
              let _;
              if (d.content) {
                const j = d.content,
                  H = d.pixelRatio || 1;
                _ = [
                  j[0] / H,
                  j[1] / H,
                  d.displaySize[0] - j[2] / H,
                  d.displaySize[1] - j[3] / H,
                ];
              }
              const v = e.left * u,
                b = e.right * u;
              let E, A, M, R;
              i === "width" || i === "both"
                ? ((R = a[0] + v - o[3]), (A = a[0] + b + o[1]))
                : ((R = a[0] + (v + b - d.displaySize[0]) / 2),
                  (A = R + d.displaySize[0]));
              const k = e.top * u,
                N = e.bottom * u;
              return (
                i === "height" || i === "both"
                  ? ((E = a[1] + k - o[0]), (M = a[1] + N + o[2]))
                  : ((E = a[1] + (k + N - d.displaySize[1]) / 2),
                    (M = E + d.displaySize[1])),
                {
                  imagePrimary: d,
                  imageSecondary: void 0,
                  top: E,
                  right: A,
                  bottom: M,
                  left: R,
                  collisionPadding: _,
                }
              );
            }
            function gb(n) {
              return !n.imagePrimary.stretchX;
            }
            function _b(n) {
              return !n.imagePrimary.stretchY;
            }
            function yb(n) {
              return { width: n.right - n.left, height: n.bottom - n.top };
            }
            const Jo = 128;
            function xb(n, e, i) {
              const { expression: o } = e;
              if (o.kind === "constant")
                return {
                  kind: "constant",
                  layoutSize: o.evaluate(new qi(n + 1, { worldview: i })),
                };
              if (o.kind === "source") return { kind: "source" };
              {
                const { zoomStops: a, interpolationType: u } = o;
                let d = 0;
                for (; d < a.length && a[d] <= n; ) d++;
                d = Math.max(0, d - 1);
                let _ = d;
                for (; _ < a.length && a[_] < n + 1; ) _++;
                _ = Math.min(a.length - 1, _);
                const v = a[d],
                  b = a[_];
                return o.kind === "composite"
                  ? {
                      kind: "composite",
                      minZoom: v,
                      maxZoom: b,
                      interpolationType: u,
                    }
                  : {
                      kind: "camera",
                      minZoom: v,
                      maxZoom: b,
                      minSize: o.evaluate(new qi(v, { worldview: i })),
                      maxSize: o.evaluate(new qi(b, { worldview: i })),
                      interpolationType: u,
                    };
              }
            }
            function Ay(
              n,
              { uSize: e, uSizeT: i },
              { lowerSize: o, upperSize: a },
            ) {
              return n.kind === "source"
                ? o / Jo
                : n.kind === "composite"
                  ? Ht(o / Jo, a / Jo, i)
                  : e;
            }
            function Af(n, e, i = 1) {
              let o = 0,
                a = 0;
              if (n.kind === "constant") a = n.layoutSize * i;
              else if (n.kind !== "source") {
                const { interpolationType: u, minZoom: d, maxZoom: _ } = n,
                  v = u ? he(ls.interpolationFactor(u, e, d, _), 0, 1) : 0;
                n.kind === "camera"
                  ? (a = Ht(n.minSize, n.maxSize, v) * i)
                  : (o = v * i);
              }
              return { uSizeT: o, uSize: a };
            }
            class Fa extends ft {
              constructor(e, i, o, a, u) {
                (super(e, i),
                  (this.angle = a),
                  (this.z = o),
                  u !== void 0 && (this.segment = u));
              }
              clone() {
                return new Fa(this.x, this.y, this.z, this.angle, this.segment);
              }
            }
            function vb(n, e, i, o, a) {
              if (e.segment === void 0) return !0;
              let u = e,
                d = e.segment + 1,
                _ = 0;
              for (; _ > -i / 2; ) {
                if ((d--, d < 0)) return !1;
                ((_ -= n[d].dist(u)), (u = n[d]));
              }
              ((_ += n[d].dist(n[d + 1])), d++);
              const v = [];
              let b = 0;
              for (; _ < i / 2; ) {
                const E = n[d],
                  A = n[d + 1];
                if (!A) return !1;
                let M = n[d - 1].angleTo(E) - E.angleTo(A);
                for (
                  M = Math.abs(((M + 3 * Math.PI) % (2 * Math.PI)) - Math.PI),
                    v.push({ distance: _, angleDelta: M }),
                    b += M;
                  _ - v[0].distance > o;

                )
                  b -= v.shift().angleDelta;
                if (b > a) return !1;
                (d++, (_ += E.dist(A)));
              }
              return !0;
            }
            function bb(n) {
              let e = 0;
              for (let i = 0; i < n.length - 1; i++) e += n[i].dist(n[i + 1]);
              return e;
            }
            function wb(n, e, i) {
              return n ? 0.6 * e * i : 0;
            }
            function Tb(n, e) {
              return Math.max(
                n ? n.right - n.left : 0,
                e ? e.right - e.left : 0,
              );
            }
            function zE(n, e, i, o, a, u) {
              const d = wb(i, a, u),
                _ = Tb(i, o) * u;
              let v = 0;
              const b = bb(n) / 2;
              for (let E = 0; E < n.length - 1; E++) {
                const A = n[E],
                  M = n[E + 1],
                  R = A.dist(M);
                if (v + R > b) {
                  const k = (b - v) / R,
                    N = Ht(A.x, M.x, k),
                    j = Ht(A.y, M.y, k),
                    H = new Fa(N, j, 0, M.angleTo(A), E);
                  return !d || vb(n, H, _, d, e) ? H : void 0;
                }
                v += R;
              }
            }
            function kE(n, e, i, o, a, u, d, _, v) {
              const b = wb(o, u, d),
                E = Tb(o, a),
                A = E * d,
                M =
                  n[0].x === 0 || n[0].x === v || n[0].y === 0 || n[0].y === v;
              return (
                e - A < e / 4 && (e = A + e / 4),
                Sb(
                  n,
                  M ? ((e / 2) * _) % e : ((E / 2 + 2 * u) * d * _) % e,
                  e,
                  b,
                  i,
                  A,
                  M,
                  !1,
                  v,
                )
              );
            }
            function Sb(n, e, i, o, a, u, d, _, v) {
              const b = u / 2,
                E = bb(n);
              let A = 0,
                M = e - i,
                R = [];
              for (let k = 0; k < n.length - 1; k++) {
                const N = n[k],
                  j = n[k + 1],
                  H = N.dist(j),
                  J = j.angleTo(N);
                for (; M + i < A + H; ) {
                  M += i;
                  const Q = (M - A) / H,
                    V = Ht(N.x, j.x, Q),
                    X = Ht(N.y, j.y, Q);
                  if (
                    V >= 0 &&
                    V < v &&
                    X >= 0 &&
                    X < v &&
                    M - b >= 0 &&
                    M + b <= E
                  ) {
                    const ee = new Fa(V, X, 0, J, k);
                    (o && !vb(n, ee, u, o, a)) || R.push(ee);
                  }
                }
                A += H;
              }
              return (
                _ || R.length || d || (R = Sb(n, A / 2, i, o, a, u, d, !0, v)),
                R
              );
            }
            function Eb(n) {
              let e = 0,
                i = 0;
              for (const d of n) ((e += d.w * d.h), (i = Math.max(i, d.w)));
              n.sort((d, _) => _.h - d.h);
              const o = [
                {
                  x: 0,
                  y: 0,
                  w: Math.max(Math.ceil(Math.sqrt(e / 0.95)), i),
                  h: 1 / 0,
                },
              ];
              let a = 0,
                u = 0;
              for (const d of n)
                for (let _ = o.length - 1; _ >= 0; _--) {
                  const v = o[_];
                  if (!(d.w > v.w || d.h > v.h)) {
                    if (
                      ((d.x = v.x),
                      (d.y = v.y),
                      (u = Math.max(u, d.y + d.h)),
                      (a = Math.max(a, d.x + d.w)),
                      d.w === v.w && d.h === v.h)
                    ) {
                      const b = o.pop();
                      _ < o.length && (o[_] = b);
                    } else
                      d.h === v.h
                        ? ((v.x += d.w), (v.w -= d.w))
                        : d.w === v.w
                          ? ((v.y += d.h), (v.h -= d.h))
                          : (o.push({
                              x: v.x + d.w,
                              y: v.y,
                              w: v.w - d.w,
                              h: d.h,
                            }),
                            (v.y += d.h),
                            (v.h -= d.h));
                    break;
                  }
                }
              return { w: a, h: u, fill: e / (a * u) || 0 };
            }
            Tt(Fa, "Anchor");
            const sh = 1;
            class Mf {
              static getImagePositionScale(e, i, o) {
                if (i && e && e.options && e.options.transform) {
                  const a = e.options.transform;
                  return { x: a.a, y: a.d };
                }
                return { x: o, y: o };
              }
              constructor(e, i, o, a) {
                this.paddedRect = e;
                const {
                  pixelRatio: u,
                  version: d,
                  stretchX: _,
                  stretchY: v,
                  content: b,
                  sdf: E,
                  usvg: A,
                } = i;
                ((this.pixelRatio = u),
                  (this.stretchX = _),
                  (this.stretchY = v),
                  (this.content = b),
                  (this.version = d),
                  (this.padding = o),
                  (this.sdf = E),
                  (this.usvg = A),
                  (this.scale = Mf.getImagePositionScale(a, A, u)));
              }
              get tl() {
                return [
                  this.paddedRect.x + this.padding,
                  this.paddedRect.y + this.padding,
                ];
              }
              get br() {
                return [
                  this.paddedRect.x + this.paddedRect.w - this.padding,
                  this.paddedRect.y + this.paddedRect.h - this.padding,
                ];
              }
              get displaySize() {
                return [
                  (this.paddedRect.w - 2 * this.padding) / this.scale.x,
                  (this.paddedRect.h - 2 * this.padding) / this.scale.y,
                ];
              }
            }
            function My(n, e, i) {
              const o = oo.parse(n),
                a = (function (u, d, _ = [1, 1]) {
                  return {
                    x: 0,
                    y: 0,
                    w: (u.data ? u.data.width : u.width * _[0]) + 2 * d,
                    h: (u.data ? u.data.height : u.height * _[1]) + 2 * d,
                  };
                })(e, i, [o.options.transform.a, o.options.transform.d]);
              return {
                bin: a,
                imagePosition: new Mf(a, e, i, o),
                imageVariant: o,
              };
            }
            class Ib {
              constructor(e, i, o) {
                const a = new Map(),
                  u = new Map();
                this.haveRenderCallbacks = [];
                const d = [];
                (this.addImages(e, a, sh, d), this.addImages(i, u, 2, d));
                const { w: _, h: v } = Eb(d),
                  b = new xr({ width: _ || 1, height: v || 1 });
                for (const [E, A] of e.entries()) {
                  const M = a.get(E).paddedRect;
                  xr.copy(
                    A.data,
                    b,
                    { x: 0, y: 0 },
                    { x: M.x + sh, y: M.y + sh },
                    A.data,
                    o,
                    A.sdf,
                  );
                }
                for (const [E, A] of i.entries()) {
                  const M = u.get(E),
                    R = M.paddedRect;
                  let k = M.padding;
                  const N = R.x + k,
                    j = R.y + k,
                    H = A.data.width,
                    J = A.data.height;
                  ((k = k > 1 ? k - 1 : k),
                    xr.copy(
                      A.data,
                      b,
                      { x: 0, y: 0 },
                      { x: N, y: j },
                      A.data,
                      o,
                    ),
                    xr.copy(
                      A.data,
                      b,
                      { x: 0, y: J - k },
                      { x: N, y: j - k },
                      { width: H, height: k },
                      o,
                    ),
                    xr.copy(
                      A.data,
                      b,
                      { x: 0, y: 0 },
                      { x: N, y: j + J },
                      { width: H, height: k },
                      o,
                    ),
                    xr.copy(
                      A.data,
                      b,
                      { x: H - k, y: 0 },
                      { x: N - k, y: j },
                      { width: k, height: J },
                      o,
                    ),
                    xr.copy(
                      A.data,
                      b,
                      { x: 0, y: 0 },
                      { x: N + H, y: j },
                      { width: k, height: J },
                      o,
                    ),
                    xr.copy(
                      A.data,
                      b,
                      { x: H - k, y: J - k },
                      { x: N - k, y: j - k },
                      { width: k, height: k },
                      o,
                    ),
                    xr.copy(
                      A.data,
                      b,
                      { x: 0, y: J - k },
                      { x: N + H, y: j - k },
                      { width: k, height: k },
                      o,
                    ),
                    xr.copy(
                      A.data,
                      b,
                      { x: 0, y: 0 },
                      { x: N + H, y: j + J },
                      { width: k, height: k },
                      o,
                    ),
                    xr.copy(
                      A.data,
                      b,
                      { x: H - k, y: 0 },
                      { x: N - k, y: j + J },
                      { width: k, height: k },
                      o,
                    ));
                }
                ((this.lut = o),
                  (this.image = b),
                  (this.iconPositions = a),
                  (this.patternPositions = u));
              }
              addImages(e, i, o, a) {
                for (const [u, d] of e.entries()) {
                  const {
                    bin: _,
                    imagePosition: v,
                    imageVariant: b,
                  } = My(u, d, o);
                  (i.set(u, v),
                    a.push(_),
                    d.hasRenderCallback && this.haveRenderCallbacks.push(b.id));
                }
              }
              patchUpdatedImages(e, i, o) {
                ((this.haveRenderCallbacks = this.haveRenderCallbacks.filter(
                  (a) => e.hasImage(a, o),
                )),
                  e.dispatchRenderCallbacks(this.haveRenderCallbacks, o));
                for (const a of e.getUpdatedImages(o)) {
                  for (const u of this.iconPositions.keys()) {
                    const d = oo.parse(u);
                    if (Kr.isEqual(d.id, a)) {
                      const _ = e.getImage(a, o);
                      this.patchUpdatedImage(this.iconPositions.get(u), _, i);
                    }
                  }
                  for (const u of this.patternPositions.keys()) {
                    const d = oo.parse(u);
                    if (Kr.isEqual(d.id, a)) {
                      const _ = e.getImage(a, o);
                      this.patchUpdatedImage(
                        this.patternPositions.get(u),
                        _,
                        i,
                      );
                    }
                  }
                }
              }
              patchUpdatedImage(e, i, o) {
                if (!e || !i || e.version === i.version) return;
                e.version = i.version;
                const [a, u] = e.tl,
                  d = e.sdf;
                if (this.lut || d) {
                  const _ = { width: i.data.width, height: i.data.height },
                    v = new xr(_);
                  (xr.copy(
                    i.data,
                    v,
                    { x: 0, y: 0 },
                    { x: 0, y: 0 },
                    _,
                    this.lut,
                    d,
                  ),
                    o.update(v, { position: { x: a, y: u } }));
                } else o.update(i.data, { position: { x: a, y: u } });
              }
            }
            (Tt(Mf, "ImagePosition"), Tt(Ib, "ImageAtlas"));
            const Gm = 1e20;
            function Ab(n, e, i, o, a, u, d, _, v) {
              for (let b = e; b < e + o; b++) Mb(n, i * u + b, u, a, d, _, v);
              for (let b = i; b < i + a; b++) Mb(n, b * u + e, 1, o, d, _, v);
            }
            function Mb(n, e, i, o, a, u, d) {
              ((u[0] = 0), (d[0] = -1e20), (d[1] = Gm), (a[0] = n[e]));
              for (let _ = 1, v = 0, b = 0; _ < o; _++) {
                a[_] = n[e + _ * i];
                const E = _ * _;
                do {
                  const A = u[v];
                  b = (a[_] - a[A] + E - A * A) / (_ - A) / 2;
                } while (b <= d[v] && --v > -1);
                (v++, (u[v] = _), (d[v] = b), (d[v + 1] = Gm));
              }
              for (let _ = 0, v = 0; _ < o; _++) {
                for (; d[v + 1] < _; ) v++;
                const b = u[v],
                  E = _ - b;
                n[e + _ * i] = a[b] + E * E;
              }
            }
            const yo = 2,
              Cy = { none: 0, ideographs: 1, all: 2 };
            class ku {
              constructor(e, i, o) {
                ((this.requestManager = e),
                  (this.localGlyphMode = i),
                  (this.localFontFamily = o),
                  (this.urls = {}),
                  (this.entries = {}),
                  (this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} }));
              }
              setURL(e, i) {
                this.urls[i] = e;
              }
              getGlyphs(e, i, o) {
                const a = [],
                  u = this.urls[i] || hr.GLYPHS_URL;
                for (const d in e)
                  for (const _ of e[d]) a.push({ stack: d, id: _ });
                Ee(
                  a,
                  ({ stack: d, id: _ }, v) => {
                    let b = this.entries[d];
                    b ||
                      (b = this.entries[d] =
                        {
                          glyphs: {},
                          requests: {},
                          ranges: {},
                          ascender: void 0,
                          descender: void 0,
                        });
                    let E = b.glyphs[_];
                    if (E !== void 0)
                      return void v(null, { stack: d, id: _, glyph: E });
                    if (((E = this._tinySDF(b, d, _)), E))
                      return (
                        (b.glyphs[_] = E),
                        void v(null, { stack: d, id: _, glyph: E })
                      );
                    const A = Math.floor(_ / 256);
                    if (256 * A > 65535)
                      return (
                        ri("glyphs > 65535 not supported"),
                        void v(null, { stack: d, id: _, glyph: E })
                      );
                    if (b.ranges[A])
                      return void v(null, { stack: d, id: _, glyph: E });
                    let M = b.requests[A];
                    (M ||
                      ((M = b.requests[A] = []),
                      ku.loadGlyphRange(
                        d,
                        A,
                        u,
                        this.requestManager,
                        (R, k) => {
                          if (k) {
                            ((b.ascender = k.ascender),
                              (b.descender = k.descender));
                            for (const N in k.glyphs)
                              this._doesCharSupportLocalGlyph(+N) ||
                                (b.glyphs[+N] = k.glyphs[+N]);
                            b.ranges[A] = !0;
                          }
                          for (const N of M) N(R, k);
                          delete b.requests[A];
                        },
                      )),
                      M.push((R, k) => {
                        R
                          ? v(R)
                          : k &&
                            v(null, {
                              stack: d,
                              id: _,
                              glyph: k.glyphs[_] || null,
                            });
                      }));
                  },
                  (d, _) => {
                    if (d) o(d);
                    else if (_) {
                      const v = {};
                      for (const { stack: b, id: E, glyph: A } of _)
                        (v[b] === void 0 && (v[b] = {}),
                          v[b].glyphs === void 0 && (v[b].glyphs = {}),
                          (v[b].glyphs[E] = A && {
                            id: A.id,
                            bitmap: A.bitmap.clone(),
                            metrics: A.metrics,
                          }),
                          (v[b].ascender = this.entries[b].ascender),
                          (v[b].descender = this.entries[b].descender));
                      o(null, v);
                    }
                  },
                );
              }
              _doesCharSupportLocalGlyph(e) {
                return (
                  this.localGlyphMode !== Cy.none &&
                  (this.localGlyphMode === Cy.all
                    ? !!this.localFontFamily
                    : !!this.localFontFamily &&
                      (Ut["CJK Unified Ideographs"](e) ||
                        Ut["Hangul Syllables"](e) ||
                        Ut.Hiragana(e) ||
                        Ut.Katakana(e) ||
                        Ut["CJK Symbols and Punctuation"](e) ||
                        Ut["CJK Unified Ideographs Extension A"](e) ||
                        Ut["CJK Unified Ideographs Extension B"](e) ||
                        Ut.Osage(e)))
                );
              }
              _tinySDF(e, i, o) {
                const a = this.localFontFamily;
                if (!a || !this._doesCharSupportLocalGlyph(o)) return;
                let u = e.tinySDF;
                if (!u) {
                  let N = "400";
                  (/bold/i.test(i)
                    ? (N = "900")
                    : /medium/i.test(i)
                      ? (N = "500")
                      : /light/i.test(i) && (N = "200"),
                    (u = e.tinySDF =
                      new ku.TinySDF({
                        fontFamily: a,
                        fontWeight: N,
                        fontSize: 24 * yo,
                        buffer: 3 * yo,
                        radius: 8 * yo,
                      })),
                    (u.fontWeight = N));
                }
                if (this.localGlyphs[u.fontWeight][o])
                  return this.localGlyphs[u.fontWeight][o];
                const d = String.fromCodePoint(o),
                  {
                    data: _,
                    width: v,
                    height: b,
                    glyphWidth: E,
                    glyphHeight: A,
                    glyphLeft: M,
                    glyphTop: R,
                    glyphAdvance: k,
                  } = u.draw(d);
                return (this.localGlyphs[u.fontWeight][o] = {
                  id: o,
                  bitmap: new Bl({ width: v, height: b }, _),
                  metrics: {
                    width: E / yo,
                    height: A / yo,
                    left: M / yo,
                    top: R / yo - 27,
                    advance: k / yo,
                    localGlyph: !0,
                  },
                });
              }
            }
            ((ku.loadGlyphRange = function (n, e, i, o, a) {
              const u = 256 * e,
                d = u + 255,
                _ = o.transformRequest(
                  o
                    .normalizeGlyphsURL(i)
                    .replace("{fontstack}", n)
                    .replace("{range}", `${u}-${d}`),
                  dc.Glyphs,
                );
              fc(_, (v, b) => {
                if (v) a(v);
                else if (b) {
                  const E = {},
                    A = (function (M) {
                      return new Um(M).readFields(IE, {});
                    })(b);
                  for (const M of A.glyphs) E[M.id] = M;
                  a(null, {
                    glyphs: E,
                    ascender: A.ascender,
                    descender: A.descender,
                  });
                }
              });
            }),
              (ku.TinySDF = class {
                constructor({
                  fontSize: n = 24,
                  buffer: e = 3,
                  radius: i = 8,
                  cutoff: o = 0.25,
                  fontFamily: a = "sans-serif",
                  fontWeight: u = "normal",
                  fontStyle: d = "normal",
                } = {}) {
                  ((this.buffer = e), (this.cutoff = o), (this.radius = i));
                  const _ = (this.size = n + 4 * e),
                    v = this._createCanvas(_),
                    b = (this.ctx = v.getContext("2d", {
                      willReadFrequently: !0,
                    }));
                  ((b.font = `${d} ${u} ${n}px ${a}`),
                    (b.textBaseline = "alphabetic"),
                    (b.textAlign = "left"),
                    (b.fillStyle = "black"),
                    (this.gridOuter = new Float64Array(_ * _)),
                    (this.gridInner = new Float64Array(_ * _)),
                    (this.f = new Float64Array(_)),
                    (this.z = new Float64Array(_ + 1)),
                    (this.v = new Uint16Array(_)));
                }
                _createCanvas(n) {
                  const e = document.createElement("canvas");
                  return ((e.width = e.height = n), e);
                }
                draw(n) {
                  const {
                      width: e,
                      actualBoundingBoxAscent: i,
                      actualBoundingBoxDescent: o,
                      actualBoundingBoxLeft: a,
                      actualBoundingBoxRight: u,
                    } = this.ctx.measureText(n),
                    d = Math.ceil(i),
                    _ = Math.max(
                      0,
                      Math.min(this.size - this.buffer, Math.ceil(u - a)),
                    ),
                    v = Math.min(this.size - this.buffer, d + Math.ceil(o)),
                    b = _ + 2 * this.buffer,
                    E = v + 2 * this.buffer,
                    A = Math.max(b * E, 0),
                    M = new Uint8ClampedArray(A),
                    R = {
                      data: M,
                      width: b,
                      height: E,
                      glyphWidth: _,
                      glyphHeight: v,
                      glyphTop: d,
                      glyphLeft: 0,
                      glyphAdvance: e,
                    };
                  if (_ === 0 || v === 0) return R;
                  const {
                    ctx: k,
                    buffer: N,
                    gridInner: j,
                    gridOuter: H,
                  } = this;
                  (k.clearRect(N, N, _, v), k.fillText(n, N, N + d));
                  const J = k.getImageData(N, N, _, v);
                  (H.fill(Gm, 0, A), j.fill(0, 0, A));
                  for (let Q = 0; Q < v; Q++)
                    for (let V = 0; V < _; V++) {
                      const X = J.data[4 * (Q * _ + V) + 3] / 255;
                      if (X === 0) continue;
                      const ee = (Q + N) * b + V + N;
                      if (X === 1) ((H[ee] = 0), (j[ee] = Gm));
                      else {
                        const re = 0.5 - X;
                        ((H[ee] = re > 0 ? re * re : 0),
                          (j[ee] = re < 0 ? re * re : 0));
                      }
                    }
                  (Ab(H, 0, 0, b, E, b, this.f, this.v, this.z),
                    Ab(j, N, N, _, v, b, this.f, this.v, this.z));
                  for (let Q = 0; Q < A; Q++) {
                    const V = Math.sqrt(H[Q]) - Math.sqrt(j[Q]);
                    M[Q] = Math.round(
                      255 - 255 * (V / this.radius + this.cutoff),
                    );
                  }
                  return R;
                }
              }));
            const oh = sh;
            function Cb(n, e) {
              return n + e[1] - e[0];
            }
            function Pb(n, e, i, o, a = 1) {
              const u = [],
                d = n.imagePrimary,
                _ = d.pixelRatio,
                v = d.paddedRect.w - 2 * oh,
                b = d.paddedRect.h - 2 * oh,
                E = (n.right - n.left) * a,
                A = (n.bottom - n.top) * a,
                M = d.stretchX || [[0, v]],
                R = d.stretchY || [[0, b]],
                k = M.reduce(Cb, 0),
                N = R.reduce(Cb, 0),
                j = v - k,
                H = b - N;
              let J = 0,
                Q = k,
                V = 0,
                X = N,
                ee = 0,
                re = j,
                ve = 0,
                ge = H;
              if (d.content && o) {
                const Me = d.content;
                ((J = $m(M, 0, Me[0])),
                  (V = $m(R, 0, Me[1])),
                  (Q = $m(M, Me[0], Me[2])),
                  (X = $m(R, Me[1], Me[3])),
                  (ee = Me[0] - J),
                  (ve = Me[1] - V),
                  (re = Me[2] - Me[0] - Q),
                  (ge = Me[3] - Me[1] - X));
              }
              const be = (Me, Ue, it, Xe) => {
                const tt = Hm(Me.stretch - J, Q, E, n.left * a),
                  nt = Wm(Me.fixed - ee, re, Me.stretch, k),
                  Ge = Hm(Ue.stretch - V, X, A, n.top * a),
                  Je = Wm(Ue.fixed - ve, ge, Ue.stretch, N),
                  Ne = Hm(it.stretch - J, Q, E, n.left * a),
                  je = Wm(it.fixed - ee, re, it.stretch, k),
                  at = Hm(Xe.stretch - V, X, A, n.top * a),
                  ct = Wm(Xe.fixed - ve, ge, Xe.stretch, N),
                  Nt = new ft(tt, Ge),
                  Ct = new ft(Ne, Ge),
                  yt = new ft(Ne, at),
                  ot = new ft(tt, at),
                  Jt = new ft(nt / _, Je / _),
                  At = new ft(je / _, ct / _),
                  Dt = (e * Math.PI) / 180;
                if (Dt) {
                  const fi = Math.sin(Dt),
                    Bi = Math.cos(Dt),
                    sn = [Bi, -fi, fi, Bi];
                  (Nt._matMult(sn),
                    Ct._matMult(sn),
                    ot._matMult(sn),
                    yt._matMult(sn));
                }
                const Wt = Me.stretch + Me.fixed,
                  ni = it.stretch + it.fixed,
                  ii = Ue.stretch + Ue.fixed,
                  di = Xe.stretch + Xe.fixed,
                  oi = n.imageSecondary;
                return {
                  tl: Nt,
                  tr: Ct,
                  bl: ot,
                  br: yt,
                  texPrimary: {
                    x: d.paddedRect.x + oh + Wt,
                    y: d.paddedRect.y + oh + ii,
                    w: ni - Wt,
                    h: di - ii,
                  },
                  texSecondary: oi
                    ? {
                        x: oi.paddedRect.x + oh + Wt,
                        y: oi.paddedRect.y + oh + ii,
                        w: ni - Wt,
                        h: di - ii,
                      }
                    : void 0,
                  writingMode: void 0,
                  glyphOffset: [0, 0],
                  sectionIndex: 0,
                  pixelOffsetTL: Jt,
                  pixelOffsetBR: At,
                  minFontScaleX: re / _ / E,
                  minFontScaleY: ge / _ / A,
                  isSDF: i,
                };
              };
              if (o && (d.stretchX || d.stretchY)) {
                const Me = Db(M, j, k),
                  Ue = Db(R, H, N);
                for (let it = 0; it < Me.length - 1; it++) {
                  const Xe = Me[it],
                    tt = Me[it + 1];
                  for (let nt = 0; nt < Ue.length - 1; nt++)
                    u.push(be(Xe, Ue[nt], tt, Ue[nt + 1]));
                }
              } else
                u.push(
                  be(
                    { fixed: 0, stretch: -1 },
                    { fixed: 0, stretch: -1 },
                    { fixed: 0, stretch: v + 1 },
                    { fixed: 0, stretch: b + 1 },
                  ),
                );
              return u;
            }
            function $m(n, e, i) {
              let o = 0;
              for (const a of n)
                o +=
                  Math.max(e, Math.min(i, a[1])) -
                  Math.max(e, Math.min(i, a[0]));
              return o;
            }
            function Db(n, e, i) {
              const o = [{ fixed: -1, stretch: 0 }];
              for (const [a, u] of n) {
                const d = o[o.length - 1];
                (o.push({ fixed: a - d.stretch, stretch: d.stretch }),
                  o.push({
                    fixed: a - d.stretch,
                    stretch: d.stretch + (u - a),
                  }));
              }
              return (o.push({ fixed: e + oh, stretch: i }), o);
            }
            function Hm(n, e, i, o) {
              return (n / e) * i + o;
            }
            function Wm(n, e, i, o) {
              return n - (e * i) / o;
            }
            function LE(n, e, i, o) {
              const a = e + n.positionedLines[o].lineOffset;
              return o === 0
                ? i + a / 2
                : i + (a + (e + n.positionedLines[o - 1].lineOffset)) / 2;
            }
            function OE(n, e = 1, i = !1) {
              let o = 1 / 0,
                a = 1 / 0,
                u = -1 / 0,
                d = -1 / 0;
              const _ = n[0];
              for (let R = 0; R < _.length; R++) {
                const k = _[R];
                ((!R || k.x < o) && (o = k.x),
                  (!R || k.y < a) && (a = k.y),
                  (!R || k.x > u) && (u = k.x),
                  (!R || k.y > d) && (d = k.y));
              }
              const v = Math.min(u - o, d - a);
              let b = v / 2;
              const E = new Uh([], FE);
              if (v === 0) return new ft(o, a);
              for (let R = o; R < u; R += v)
                for (let k = a; k < d; k += v)
                  E.push(new Lu(R + b, k + b, b, n));
              let A = (function (R) {
                  let k = 0,
                    N = 0,
                    j = 0;
                  const H = R[0];
                  for (let J = 0, Q = H.length, V = Q - 1; J < Q; V = J++) {
                    const X = H[J],
                      ee = H[V],
                      re = X.x * ee.y - ee.x * X.y;
                    ((N += (X.x + ee.x) * re),
                      (j += (X.y + ee.y) * re),
                      (k += 3 * re));
                  }
                  return new Lu(N / k, j / k, 0, R);
                })(n),
                M = E.length;
              for (; E.length; ) {
                const R = E.pop();
                ((R.d > A.d || !A.d) &&
                  ((A = R),
                  i &&
                    console.log(
                      "found best %d after %d probes",
                      Math.round(1e4 * R.d) / 1e4,
                      M,
                    )),
                  R.max - A.d <= e ||
                    ((b = R.h / 2),
                    E.push(new Lu(R.p.x - b, R.p.y - b, b, n)),
                    E.push(new Lu(R.p.x + b, R.p.y - b, b, n)),
                    E.push(new Lu(R.p.x - b, R.p.y + b, b, n)),
                    E.push(new Lu(R.p.x + b, R.p.y + b, b, n)),
                    (M += 4)));
              }
              return (
                i &&
                  (console.log(`num probes: ${M}`),
                  console.log(`best distance: ${A.d}`)),
                A.p
              );
            }
            function FE(n, e) {
              return e.max - n.max;
            }
            class Lu {
              constructor(e, i, o, a) {
                ((this.p = new ft(e, i)),
                  (this.h = o),
                  (this.d = (function (u, d) {
                    let _ = !1,
                      v = 1 / 0;
                    for (let b = 0; b < d.length; b++) {
                      const E = d[b];
                      for (let A = 0, M = E.length, R = M - 1; A < M; R = A++) {
                        const k = E[A],
                          N = E[R];
                        (k.y > u.y != N.y > u.y &&
                          u.x <
                            ((N.x - k.x) * (u.y - k.y)) / (N.y - k.y) + k.x &&
                          (_ = !_),
                          (v = Math.min(v, Su(u, k, N))));
                      }
                    }
                    return (_ ? 1 : -1) * Math.sqrt(v);
                  })(this.p, a)),
                  (this.max = this.d + this.h * Math.SQRT2));
              }
            }
            const BE = Object.keys,
              Py = Number.POSITIVE_INFINITY,
              NE = Math.sqrt(2);
            function Rb(n, [e, i]) {
              let o = 0,
                a = 0;
              if (i === Py) {
                e < 0 && (e = 0);
                const u = e / NE;
                switch (n) {
                  case "top-right":
                  case "top-left":
                    a = u - 7;
                    break;
                  case "bottom-right":
                  case "bottom-left":
                    a = 7 - u;
                    break;
                  case "bottom":
                    a = 7 - e;
                    break;
                  case "top":
                    a = e - 7;
                }
                switch (n) {
                  case "top-right":
                  case "bottom-right":
                    o = -u;
                    break;
                  case "top-left":
                  case "bottom-left":
                    o = u;
                    break;
                  case "left":
                    o = e;
                    break;
                  case "right":
                    o = -e;
                }
              } else {
                switch (((e = Math.abs(e)), (i = Math.abs(i)), n)) {
                  case "top-right":
                  case "top-left":
                  case "top":
                    a = i - 7;
                    break;
                  case "bottom-right":
                  case "bottom-left":
                  case "bottom":
                    a = 7 - i;
                }
                switch (n) {
                  case "top-right":
                  case "bottom-right":
                  case "right":
                    o = -e;
                    break;
                  case "top-left":
                  case "bottom-left":
                  case "left":
                    o = e;
                }
              }
              return [o, a];
            }
            function qm(n, e, i, o, a, u, d, _, v) {
              if (!e || !e.usvg) return;
              const b = yb(o),
                E = yb(a),
                A =
                  (u !== "both" && u !== "width") || !gb(o)
                    ? 1
                    : E.width / b.width,
                M =
                  (u !== "both" && u !== "height") || !_b(o)
                    ? 1
                    : E.height / b.height;
              i.scaleSelf(A, M);
              const R = i.toString();
              (d.set(R, i), _.set(R, e));
              const { imagePosition: k } = My(R, e, sh);
              v.set(R, k);
            }
            function zb(n, e, i, o, a, u, d, _, v) {
              if (!n) return;
              const b = (function (E, A, M, R, k, N) {
                if (E.kind === "camera") return E.maxSize;
                if (E.kind === "composite") {
                  const j = A.possiblyEvaluate(
                      new qi(E.maxZoom, { worldview: N }),
                      M,
                    ).evaluate(k, {}, M),
                    H = A.possiblyEvaluate(
                      new qi(E.minZoom, { worldview: N }),
                      M,
                    ).evaluate(k, {}, M);
                  return Math.max(j, H);
                }
                return A.possiblyEvaluate(new qi(R, { worldview: N })).evaluate(
                  k,
                  {},
                  M,
                );
              })(e, i, o, a, u, v);
              return n.scaleSelf(b * _ * d);
            }
            function kb(n, e, i, o, a, u, d, _, v) {
              return {
                iconPrimary: zb(n.getPrimary(), e, i, o, a, u, d, _, v),
                iconSecondary: zb(n.getSecondary(), e, i, o, a, u, d, _, v),
              };
            }
            function VE(n, e, i) {
              if (!e) return;
              const o = i.get(n.toString()),
                a = i.get(e.toString());
              a &&
                ((o.paddedRect.w === a.paddedRect.w &&
                  o.paddedRect.h === a.paddedRect.h) ||
                  ri(
                    `Mismatch in icon variant sizes: ${n.toString()} and ${e.toString()}`,
                  ),
                o.usvg !== a.usvg &&
                  ri(
                    `Mismatch in icon variant image types: ${n.id} and ${e.id}`,
                  ));
            }
            function Lb(n, e, i, o) {
              if (!n) return;
              const a = e.get(i.toString());
              if (((n.imagePrimary = a), o)) {
                const u = e.get(o.toString());
                n.imageSecondary = u;
              }
            }
            function UE(n, e) {
              for (const i in n.horizontal) Ob(n.horizontal[i], e);
              Ob(n.vertical, e);
            }
            function Ob(n, e) {
              if (n) {
                for (const i of n.positionedLines)
                  for (const o of i.positionedGlyphs)
                    if (o.image !== null) {
                      const a = o.image.toString();
                      o.rect = e.get(a).paddedRect;
                    }
              }
            }
            function Dy(n) {
              switch (n) {
                case "right":
                case "top-right":
                case "bottom-right":
                  return "right";
                case "left":
                case "top-left":
                case "bottom-left":
                  return "left";
              }
              return "center";
            }
            function jE(n, e, i, o, a, u, d, _, v) {
              const b = Ry(u.horizontal) || u.vertical,
                E = i.get("icon-text-fit-padding").evaluate(o, {}, a);
              let A,
                M = e;
              return (
                e &&
                  v !== "none" &&
                  (n.allowVerticalPlacement &&
                    u.vertical &&
                    (A = mb(e, u.vertical, v, E, _, d)),
                  b && (M = mb(e, b, v, E, _, d))),
                { defaultShapedIcon: M, verticallyShapedIcon: A }
              );
            }
            function GE(
              n,
              e,
              i,
              o,
              a,
              u,
              d,
              _,
              v,
              b,
              E,
              A,
              M,
              R,
              k,
              N,
              j,
              H,
              J,
              Q,
            ) {
              let V = d.textMaxSize.evaluate(e, {}, M);
              V === void 0
                ? (V = _ * d.textScaleFactor)
                : (V *= d.textScaleFactor);
              const X = n.layers[0].layout,
                ee = Ry(i.horizontal) || i.vertical,
                re = R.name === "globe",
                ve = cr,
                ge = (n.tilePixelRatio * V) / ve,
                be =
                  ((nt = n.overscaling),
                  n.zoom > 18 && nt > 2 && (nt >>= 1),
                  Math.max(mt / (512 * nt), 1) * X.get("symbol-spacing")),
                Me = X.get("text-padding") * n.tilePixelRatio,
                Ue = X.get("icon-padding") * n.tilePixelRatio,
                it = Mi(X.get("text-max-angle")),
                Xe =
                  X.get("icon-rotation-alignment") === "map" && Q !== "point",
                tt = be / 2;
              var nt;
              n.hasAnyIconTextFit === !1 &&
                j !== "none" &&
                (n.hasAnyIconTextFit = !0);
              const Ge = e.properties ? +e.properties[gi] : null,
                Je =
                  Ge && n.elevationFeatureIdToIndex
                    ? n.elevationFeatureIdToIndex.get(Ge)
                    : 65535,
                Ne = (je, at, ct) => {
                  if (at.x < 0 || at.x >= mt || at.y < 0 || at.y >= mt) return;
                  let Nt = null;
                  if (re) {
                    const {
                      x: Ct,
                      y: yt,
                      z: ot,
                    } = R.projectTilePoint(at.x, at.y, ct);
                    Nt = {
                      anchor: new Fa(Ct, yt, ot, 0, void 0),
                      up: R.upVector(ct, at.x, at.y),
                    };
                  }
                  (function (
                    Ct,
                    yt,
                    ot,
                    Jt,
                    At,
                    Dt,
                    Wt,
                    ni,
                    ii,
                    di,
                    oi,
                    fi,
                    Bi,
                    sn,
                    te,
                    se,
                    $e,
                    ut,
                    xt,
                    _t,
                    It,
                    $t,
                    yi,
                    xi,
                    ai,
                    Gi,
                    Qi,
                    vi,
                    En,
                  ) {
                    const on = Ct.addToLineVertexArray(yt, Jt);
                    let Ni,
                      Bn,
                      dn,
                      en,
                      an,
                      Wi,
                      hi,
                      Zi = 0,
                      In = 0,
                      jt = 0,
                      Si = 0,
                      fn = -1,
                      kn = -1;
                    const vn = {};
                    let Yn = mc("");
                    const Yi = ot ? ot.anchor : yt,
                      Zn = vi !== "none";
                    let ts = 0,
                      vr = 0;
                    if (
                      ii._unevaluatedLayout.getValue("text-radial-offset") ===
                      void 0
                    ) {
                      const Kn = ii.layout
                        .get("text-offset")
                        .evaluate(It, {}, ai);
                      ((ts = Kn[0] * cr), (vr = Kn[1] * cr));
                    } else
                      ((ts =
                        ii.layout
                          .get("text-radial-offset")
                          .evaluate(It, {}, ai) * cr),
                        (vr = Py));
                    if (Ct.allowVerticalPlacement && At.vertical) {
                      const Kn = At.vertical;
                      if (te) ((Wi = zy(Kn)), ni && (hi = zy(ni)));
                      else {
                        const tr =
                          ii.layout.get("text-rotate").evaluate(It, {}, ai) +
                          90;
                        ((dn = Zm(di, Yi, yt, oi, fi, Bi, Kn, sn, tr, se)),
                          ni && (en = Zm(di, Yi, yt, oi, fi, Bi, ni, ut, tr)));
                      }
                    }
                    if (Dt) {
                      const Kn = Ct.iconSizeData,
                        tr = ii.layout.get("icon-rotate").evaluate(It, {}, ai),
                        br = Pb(Dt, tr, yi, Zn, $t.iconScaleFactor),
                        Or = ni
                          ? Pb(ni, tr, yi, Zn, $t.iconScaleFactor)
                          : void 0;
                      ((Bn = Zm(di, Yi, yt, oi, fi, Bi, Dt, ut, tr, null)),
                        (Zi = 4 * br.length));
                      let Ar = null;
                      (Kn.kind === "source"
                        ? ((Ar = [
                            Jo *
                              ii.layout.get("icon-size").evaluate(It, {}, ai) *
                              $t.iconScaleFactor,
                          ]),
                          Ar[0] > Vl &&
                            ri(
                              `${Ct.layerIds[0]}: Value for "icon-size" is >= ${Cf}. Reduce your "icon-size".`,
                            ))
                        : Kn.kind === "composite" &&
                          ((Ar = [
                            Jo *
                              $t.compositeIconSizes[0].evaluate(It, {}, ai) *
                              $t.iconScaleFactor,
                            Jo *
                              $t.compositeIconSizes[1].evaluate(It, {}, ai) *
                              $t.iconScaleFactor,
                          ]),
                          (Ar[0] > Vl || Ar[1] > Vl) &&
                            ri(
                              `${Ct.layerIds[0]}: Value for "icon-size" is >= ${Cf}. Reduce your "icon-size".`,
                            )),
                        Ct.addSymbols(
                          Ct.icon,
                          br,
                          Ar,
                          _t,
                          xt,
                          It,
                          void 0,
                          ot,
                          yt,
                          on.lineStartIndex,
                          on.lineLength,
                          -1,
                          xi,
                          ai,
                          Gi,
                          Qi,
                        ),
                        (fn = Ct.icon.placedSymbolArray.length - 1),
                        Or &&
                          ((In = 4 * Or.length),
                          Ct.addSymbols(
                            Ct.icon,
                            Or,
                            Ar,
                            _t,
                            xt,
                            It,
                            hs.vertical,
                            ot,
                            yt,
                            on.lineStartIndex,
                            on.lineLength,
                            -1,
                            xi,
                            ai,
                            Gi,
                            Qi,
                          ),
                          (kn = Ct.icon.placedSymbolArray.length - 1)));
                    }
                    for (const Kn in At.horizontal) {
                      const tr = Kn,
                        br = At.horizontal[tr];
                      Ni ||
                        ((Yn = mc(br.text)),
                        te
                          ? (an = zy(br))
                          : (Ni = Zm(
                              di,
                              Yi,
                              yt,
                              oi,
                              fi,
                              Bi,
                              br,
                              sn,
                              ii.layout.get("text-rotate").evaluate(It, {}, ai),
                              se,
                            )));
                      const Or = br.positionedLines.length === 1;
                      if (
                        ((jt += Fb(
                          Ct,
                          ot,
                          yt,
                          br,
                          Wt,
                          ii,
                          te,
                          It,
                          se,
                          on,
                          At.vertical ? hs.horizontal : hs.horizontalOnly,
                          Or ? BE(At.horizontal) : [tr],
                          vn,
                          fn,
                          $t,
                          xi,
                          ai,
                          Gi,
                        )),
                        Or)
                      )
                        break;
                    }
                    At.vertical &&
                      (Si += Fb(
                        Ct,
                        ot,
                        yt,
                        At.vertical,
                        Wt,
                        ii,
                        te,
                        It,
                        se,
                        on,
                        hs.vertical,
                        ["vertical"],
                        vn,
                        kn,
                        $t,
                        xi,
                        ai,
                        Gi,
                      ));
                    let pr = -1;
                    const is = (Kn, tr) => (Kn ? Math.max(Kn, tr) : tr);
                    ((pr = is(an, pr)), (pr = is(Wi, pr)), (pr = is(hi, pr)));
                    const Qo = pr > -1 ? 1 : 0;
                    (Ct.glyphOffsetArray.length >= 65535 &&
                      ri(
                        "Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907",
                      ),
                      It.sortKey !== void 0 &&
                        Ct.addToSortKeyRanges(
                          Ct.symbolInstances.length,
                          It.sortKey,
                        ),
                      Ct.symbolInstances.emplaceBack(
                        yt.x,
                        yt.y,
                        Yi.x,
                        Yi.y,
                        Yi.z,
                        vn.right >= 0 ? vn.right : -1,
                        vn.center >= 0 ? vn.center : -1,
                        vn.left >= 0 ? vn.left : -1,
                        vn.vertical >= 0 ? vn.vertical : -1,
                        fn,
                        kn,
                        Yn,
                        Ni !== void 0 ? Ni : Ct.collisionBoxArray.length,
                        Ni !== void 0 ? Ni + 1 : Ct.collisionBoxArray.length,
                        dn !== void 0 ? dn : Ct.collisionBoxArray.length,
                        dn !== void 0 ? dn + 1 : Ct.collisionBoxArray.length,
                        Bn !== void 0 ? Bn : Ct.collisionBoxArray.length,
                        Bn !== void 0 ? Bn + 1 : Ct.collisionBoxArray.length,
                        en || Ct.collisionBoxArray.length,
                        en ? en + 1 : Ct.collisionBoxArray.length,
                        oi,
                        jt,
                        Si,
                        Zi,
                        In,
                        Qo,
                        0,
                        ts,
                        vr,
                        pr,
                        0,
                        Zn ? 1 : 0,
                        En,
                      ));
                  })(
                    n,
                    at,
                    Nt,
                    je,
                    i,
                    o,
                    u,
                    a,
                    n.layers[0],
                    n.collisionBoxArray,
                    e.index,
                    e.sourceLayerIndex,
                    n.index,
                    Me,
                    J,
                    b,
                    0,
                    Ue,
                    Xe,
                    H,
                    e,
                    d,
                    E,
                    A,
                    M,
                    k,
                    N,
                    j,
                    Je,
                  );
                };
              if (Q === "line")
                for (const je of Fm(e.geometry, 0, 0, mt, mt)) {
                  const at = kE(
                    je,
                    be,
                    it,
                    i.vertical || ee,
                    o,
                    ve,
                    ge,
                    n.overscaling,
                    mt,
                  );
                  for (const ct of at)
                    (ee && $E(n, ee.text, tt, ct)) || Ne(je, ct, M);
                }
              else if (Q === "line-center") {
                for (const je of e.geometry)
                  if (je.length > 1) {
                    const at = zE(je, it, i.vertical || ee, o, ve, ge);
                    at && Ne(je, at, M);
                  }
              } else if (e.type === "Polygon")
                for (const je of Dm(e.geometry, 0)) {
                  const at = OE(je, 16);
                  Ne(je[0], new Fa(at.x, at.y, 0, 0, void 0), M);
                }
              else if (e.type === "LineString")
                for (const je of e.geometry)
                  Ne(je, new Fa(je[0].x, je[0].y, 0, 0, void 0), M);
              else if (e.type === "Point")
                for (const je of e.geometry)
                  for (const at of je)
                    Ne([at], new Fa(at.x, at.y, 0, 0, void 0), M);
            }
            const Cf = 255,
              Vl = Cf * Jo;
            function Fb(n, e, i, o, a, u, d, _, v, b, E, A, M, R, k, N, j, H) {
              const J = (function (X, ee, re, ve, ge, be, Me, Ue) {
                  const it = [];
                  if (ee.positionedLines.length === 0) return it;
                  const Xe =
                      (ve.layout.get("text-rotate").evaluate(be, {}) *
                        Math.PI) /
                      180,
                    tt = (function (je) {
                      const at = je[0],
                        ct = je[1],
                        Nt = at * ct;
                      return Nt > 0
                        ? [at, -ct]
                        : Nt < 0
                          ? [-at, ct]
                          : at === 0
                            ? [ct, at]
                            : [ct, -at];
                    })(re);
                  let nt = Math.abs(ee.top - ee.bottom);
                  for (const je of ee.positionedLines) nt -= je.lineOffset;
                  const Ge = ee.positionedLines.length,
                    Je = nt / Ge;
                  let Ne = ee.top - re[1];
                  for (let je = 0; je < Ge; ++je) {
                    const at = ee.positionedLines[je];
                    Ne = LE(ee, Je, Ne, je);
                    for (const ct of at.positionedGlyphs) {
                      if (!ct.rect) continue;
                      const Nt = ct.rect || {};
                      let Ct = CE + 1,
                        yt = !0,
                        ot = 1,
                        Jt = 0;
                      if (ct.image) {
                        const It = Me.get(ct.image.toString());
                        if (!It) continue;
                        if (It.sdf) {
                          ri(
                            "SDF images are not supported in formatted text and will be ignored.",
                          );
                          continue;
                        }
                        ((yt = !1), (ot = It.pixelRatio), (Ct = sh / ot));
                      }
                      const At = (ge || Ue) && ct.vertical,
                        Dt = (ct.metrics.advance * ct.scale) / 2,
                        Wt = ct.metrics,
                        ni = ct.rect;
                      if (ni === null) continue;
                      Ue &&
                        ee.verticalizable &&
                        (Jt = ct.image
                          ? Dt - (ct.metrics.width * ct.scale) / 2
                          : 0);
                      const ii = ge ? [ct.x + Dt, ct.y] : [0, 0];
                      let di = [0, 0],
                        oi = [0, 0],
                        fi = !1;
                      ge ||
                        (At
                          ? ((oi = [ct.x + Dt + tt[0], ct.y + tt[1] - Jt]),
                            (fi = !0))
                          : (di = [ct.x + Dt + re[0], ct.y + re[1] - Jt]));
                      const Bi =
                          (ni.w * ct.scale) / (ot * (ct.localGlyph ? yo : 1)),
                        sn =
                          (ni.h * ct.scale) / (ot * (ct.localGlyph ? yo : 1));
                      let te, se, $e, ut;
                      if (At) {
                        const It = ct.y - Ne,
                          $t = new ft(-Dt, Dt - It),
                          yi = -Math.PI / 2,
                          xi = new ft(...oi);
                        ((te = new ft(-Dt + di[0], di[1])),
                          te._rotateAround(yi, $t)._add(xi),
                          (te.x += -It + Dt),
                          (te.y -= (Wt.left - Ct) * ct.scale));
                        const ai = ct.image
                            ? Wt.advance * ct.scale
                            : cr * ct.scale,
                          Gi = String.fromCodePoint(ct.glyph);
                        (TE(Gi)
                          ? (te.x += (1 - Ct) * ct.scale)
                          : SE(Gi)
                            ? (te.x +=
                                ai -
                                Wt.height * ct.scale +
                                (-Ct - 1) * ct.scale)
                            : (te.x +=
                                ct.image ||
                                (Wt.width + 2 * Ct === ni.w &&
                                  Wt.height + 2 * Ct === ni.h)
                                  ? (ai - sn) / 2
                                  : (ai - (Wt.height + 2 * Ct) * ct.scale) / 2),
                          (se = new ft(te.x, te.y - Bi)),
                          ($e = new ft(te.x + sn, te.y)),
                          (ut = new ft(te.x + sn, te.y - Bi)));
                      } else {
                        const It = (Wt.left - Ct) * ct.scale - Dt + di[0],
                          $t = (-Wt.top - Ct) * ct.scale + di[1],
                          yi = It + Bi,
                          xi = $t + sn;
                        ((te = new ft(It, $t)),
                          (se = new ft(yi, $t)),
                          ($e = new ft(It, xi)),
                          (ut = new ft(yi, xi)));
                      }
                      if (Xe) {
                        let It;
                        ((It = ge
                          ? new ft(0, 0)
                          : fi
                            ? new ft(tt[0], tt[1])
                            : new ft(re[0], re[1])),
                          te._rotateAround(Xe, It),
                          se._rotateAround(Xe, It),
                          $e._rotateAround(Xe, It),
                          ut._rotateAround(Xe, It));
                      }
                      const xt = new ft(0, 0),
                        _t = new ft(0, 0);
                      it.push({
                        tl: te,
                        tr: se,
                        bl: $e,
                        br: ut,
                        texPrimary: Nt,
                        texSecondary: void 0,
                        writingMode: ee.writingMode,
                        glyphOffset: ii,
                        sectionIndex: ct.sectionIndex,
                        isSDF: yt,
                        pixelOffsetTL: xt,
                        pixelOffsetBR: _t,
                        minFontScaleX: 0,
                        minFontScaleY: 0,
                      });
                    }
                  }
                  return it;
                })(0, o, v, u, d, _, a, n.allowVerticalPlacement),
                Q = n.textSizeData;
              let V = null;
              (Q.kind === "source"
                ? ((V = [
                    Jo *
                      u.layout.get("text-size").evaluate(_, {}, j) *
                      k.textScaleFactor,
                  ]),
                  V[0] > Vl &&
                    ri(
                      `${n.layerIds[0]}: Value for "text-size" is >= ${Cf}. Reduce your "text-size".`,
                    ))
                : Q.kind === "composite" &&
                  ((V = [
                    Jo *
                      k.compositeTextSizes[0].evaluate(_, {}, j) *
                      k.textScaleFactor,
                    Jo *
                      k.compositeTextSizes[1].evaluate(_, {}, j) *
                      k.textScaleFactor,
                  ]),
                  (V[0] > Vl || V[1] > Vl) &&
                    ri(
                      `${n.layerIds[0]}: Value for "text-size" is >= ${Cf}. Reduce your "text-size".`,
                    )),
                n.addSymbols(
                  n.text,
                  J,
                  V,
                  v,
                  d,
                  _,
                  E,
                  e,
                  i,
                  b.lineStartIndex,
                  b.lineLength,
                  R,
                  N,
                  j,
                  H,
                  !1,
                ));
              for (const X of A) M[X] = n.text.placedSymbolArray.length - 1;
              return 4 * J.length;
            }
            function Ry(n) {
              for (const e in n) return n[e];
              return null;
            }
            function Zm(n, e, i, o, a, u, d, _, v, b) {
              let E = d.top,
                A = d.bottom,
                M = d.left,
                R = d.right;
              if (pb(d) && d.collisionPadding) {
                const k = d.collisionPadding;
                ((M -= k[0]), (E -= k[1]), (R += k[2]), (A += k[3]));
              }
              if (v) {
                const k = new ft(M, E),
                  N = new ft(R, E),
                  j = new ft(M, A),
                  H = new ft(R, A),
                  J = Mi(v);
                let Q = new ft(0, 0);
                (b && (Q = new ft(b[0], b[1])),
                  k._rotateAround(J, Q),
                  N._rotateAround(J, Q),
                  j._rotateAround(J, Q),
                  H._rotateAround(J, Q),
                  (M = Math.min(k.x, N.x, j.x, H.x)),
                  (R = Math.max(k.x, N.x, j.x, H.x)),
                  (E = Math.min(k.y, N.y, j.y, H.y)),
                  (A = Math.max(k.y, N.y, j.y, H.y)));
              }
              return (
                n.emplaceBack(e.x, e.y, e.z, i.x, i.y, M, E, R, A, _, o, a, u),
                n.length - 1
              );
            }
            function zy(n) {
              pb(n) &&
                n.collisionPadding &&
                ((n.top -= n.collisionPadding[1]),
                (n.bottom += n.collisionPadding[3]));
              const e = n.bottom - n.top;
              return e > 0 ? Math.max(10, e) : null;
            }
            function $E(n, e, i, o) {
              const a = n.compareText;
              if (e in a) {
                const u = a[e];
                for (let d = u.length - 1; d >= 0; d--)
                  if (o.dist(u[d]) < i) return !0;
              } else a[e] = [];
              return (a[e].push(o), !1);
            }
            function Bb(n, e) {
              const i = n.fovAboveCenter,
                o = n.elevation ? n.elevation.getMinElevationBelowMSL() * e : 0,
                a =
                  (n._camera.position[2] * n.worldSize - o) /
                  Math.cos(n._pitch),
                u =
                  (Math.sin(i) * a) /
                  Math.sin(Math.max(Math.PI / 2 - n._pitch - i, 0.01));
              let d = Math.sin(n._pitch) * u + a;
              const _ = a * (1 / n._horizonShift);
              if (!n.elevation || n.elevation.exaggeration() === 0) {
                let v = Math.max(n.zoom - 17, 0);
                (n.isOrthographic && (v /= 10), (d *= 1 + v));
              }
              return Math.min(1.01 * d, _);
            }
            function Pf(n, e) {
              if (!e.isReprojectedInTileSpace)
                return {
                  scale: 1 << n.z,
                  x: n.x,
                  y: n.y,
                  x2: n.x + 1,
                  y2: n.y + 1,
                  projection: e,
                };
              const i = Math.pow(2, -n.z),
                o = n.x * i,
                a = (n.x + 1) * i,
                u = n.y * i,
                d = (n.y + 1) * i,
                _ = _e(o),
                v = _e(a),
                b = De(u),
                E = De(d),
                A = e.project(_, b),
                M = e.project(v, b),
                R = e.project(v, E),
                k = e.project(_, E);
              let N = Math.min(A.x, M.x, R.x, k.x),
                j = Math.min(A.y, M.y, R.y, k.y),
                H = Math.max(A.x, M.x, R.x, k.x),
                J = Math.max(A.y, M.y, R.y, k.y);
              const Q = i / 16;
              function V(ee, re, ve, ge, be, Me) {
                const Ue = (ve + be) / 2,
                  it = (ge + Me) / 2,
                  Xe = e.project(_e(Ue), De(it)),
                  tt = Math.max(0, N - Xe.x, j - Xe.y, Xe.x - H, Xe.y - J);
                ((N = Math.min(N, Xe.x)),
                  (H = Math.max(H, Xe.x)),
                  (j = Math.min(j, Xe.y)),
                  (J = Math.max(J, Xe.y)),
                  tt > Q &&
                    (V(ee, Xe, ve, ge, Ue, it), V(Xe, re, Ue, it, be, Me)));
              }
              (V(A, M, o, u, a, u),
                V(M, R, a, u, a, d),
                V(R, k, a, d, o, d),
                V(k, A, o, d, o, u),
                (N -= Q),
                (j -= Q),
                (H += Q),
                (J += Q));
              const X = 1 / Math.max(H - N, J - j);
              return {
                scale: X,
                x: N * X,
                y: j * X,
                x2: H * X,
                y2: J * X,
                projection: e,
              };
            }
            function Nb(n, { x: e, y: i }, o = 0) {
              return new ft(
                ((e - o) * n.scale - n.x) * mt,
                (i * n.scale - n.y) * mt,
              );
            }
            const HE = xe(new Float32Array(16));
            class Ul {
              constructor(e) {
                ((this.spec = e),
                  (this.name = e.name),
                  (this.wrap = !1),
                  (this.requiresDraping = !1),
                  (this.supportsWorldCopies = !1),
                  (this.supportsTerrain = !1),
                  (this.supportsFog = !1),
                  (this.supportsFreeCamera = !1),
                  (this.zAxisUnit = "meters"),
                  (this.isReprojectedInTileSpace = !0),
                  (this.unsupportedLayers = ["custom"]),
                  (this.center = [0, 0]),
                  (this.range = [3.5, 7]));
              }
              project(e, i) {
                return { x: 0, y: 0, z: 0 };
              }
              unproject(e, i) {
                return new Y(0, 0);
              }
              projectTilePoint(e, i, o) {
                return { x: e, y: i, z: 0 };
              }
              locationPoint(e, i, o, a = !0) {
                return e._coordinatePoint(e.locationCoordinate(i, o), a);
              }
              pixelsPerMeter(e, i) {
                return me(1, e) * i;
              }
              pixelSpaceConversion(e, i, o) {
                return 1;
              }
              farthestPixelDistance(e) {
                return Bb(e, e.pixelsPerMeter);
              }
              pointCoordinate(e, i, o, a) {
                const u = e.horizonLineFromTop(!1),
                  d = new ft(i, Math.max(u, o));
                return e.rayIntersectionCoordinate(
                  e.pointRayIntersection(d, a),
                );
              }
              pointCoordinate3D(e, i, o) {
                const a = new ft(i, o);
                if (e.elevation) return e.elevation.pointCoordinate(a);
                {
                  const u = this.pointCoordinate(e, a.x, a.y, 0);
                  return [u.x, u.y, u.z];
                }
              }
              isPointAboveHorizon(e, i) {
                if (e.elevation && e.elevation.visibleDemTiles.length)
                  return !this.pointCoordinate3D(e, i.x, i.y);
                const o = e.horizonLineFromTop();
                return i.y < o;
              }
              createInversionMatrix(e, i) {
                return HE;
              }
              createTileMatrix(e, i, o) {
                let a, u, d;
                const _ = o.canonical,
                  v = xe(new Float64Array(16));
                if (this.isReprojectedInTileSpace) {
                  const b = Pf(_, this);
                  ((a = 1),
                    (u = b.x + o.wrap * b.scale),
                    (d = b.y),
                    gt(v, v, [a / b.scale, a / b.scale, e.pixelsPerMeter / i]));
                } else
                  ((a = i / e.zoomScale(_.z)),
                    (u = (_.x + Math.pow(2, _.z) * o.wrap) * a),
                    (d = _.y * a));
                return (Qe(v, v, [u, d, 0]), gt(v, v, [a / mt, a / mt, 1]), v);
              }
              upVector(e, i, o) {
                return [0, 0, 1];
              }
              upVectorScale(e, i, o) {
                return { metersToTile: 1 };
              }
            }
            class WE extends Ul {
              constructor(e) {
                (super(e),
                  (this.range = [4, 7]),
                  (this.center = e.center || [-96, 37.5]));
                const [i, o] = (this.parallels = e.parallels || [29.5, 45.5]),
                  a = Math.sin(Mi(i));
                ((this.n = (a + Math.sin(Mi(o))) / 2),
                  (this.c = 1 + a * (2 * this.n - a)),
                  (this.r0 = Math.sqrt(this.c) / this.n));
              }
              project(e, i) {
                const { n: o, c: a, r0: u } = this,
                  d = Mi(e - this.center[0]),
                  _ = Mi(i),
                  v = Math.sqrt(a - 2 * o * Math.sin(_)) / o;
                return {
                  x: v * Math.sin(d * o),
                  y: v * Math.cos(d * o) - u,
                  z: 0,
                };
              }
              unproject(e, i) {
                const { n: o, c: a, r0: u } = this,
                  d = u + i;
                let _ = Math.atan2(e, Math.abs(d)) * Math.sign(d);
                d * o < 0 && (_ -= Math.PI * Math.sign(e) * Math.sign(d));
                const v = Mi(this.center[0]) * o;
                _ = ke(_, -Math.PI - v, Math.PI - v);
                const b = he(Fe(_ / o) + this.center[0], -180, 180),
                  E = Math.asin(
                    he((a - (e * e + d * d) * o * o) / (2 * o), -1, 1),
                  ),
                  A = he(Fe(E), -85.051129, He);
                return new Y(b, A);
              }
            }
            const Df = 1.340264,
              Rf = -0.081106,
              zf = 893e-6,
              kf = 0.003796,
              Xm = Math.sqrt(3) / 2;
            class qE extends Ul {
              project(e, i) {
                ((i = (i / 180) * Math.PI), (e = (e / 180) * Math.PI));
                const o = Math.asin(Xm * Math.sin(i)),
                  a = o * o,
                  u = a * a * a;
                return {
                  x:
                    0.5 *
                    ((e * Math.cos(o)) /
                      (Xm * (Df + 3 * Rf * a + u * (7 * zf + 9 * kf * a))) /
                      Math.PI +
                      0.5),
                  y:
                    1 -
                    0.5 *
                      ((o * (Df + Rf * a + u * (zf + kf * a))) / Math.PI + 1),
                  z: 0,
                };
              }
              unproject(e, i) {
                e = (2 * e - 0.5) * Math.PI;
                let o = (i = (2 * (1 - i) - 1) * Math.PI),
                  a = o * o,
                  u = a * a * a;
                for (
                  let E, A, M, R = 0;
                  R < 12 &&
                  ((A = o * (Df + Rf * a + u * (zf + kf * a)) - i),
                  (M = Df + 3 * Rf * a + u * (7 * zf + 9 * kf * a)),
                  (E = A / M),
                  (o = he(o - E, -Math.PI / 3, Math.PI / 3)),
                  (a = o * o),
                  (u = a * a * a),
                  !(Math.abs(E) < 1e-12));
                  ++R
                );
                const d =
                    (Xm * e * (Df + 3 * Rf * a + u * (7 * zf + 9 * kf * a))) /
                    Math.cos(o),
                  _ = Math.asin(Math.sin(o) / Xm),
                  v = he((180 * d) / Math.PI, -180, 180),
                  b = he((180 * _) / Math.PI, -85.051129, He);
                return new Y(v, b);
              }
            }
            class ZE extends Ul {
              constructor(e) {
                (super(e), (this.wrap = !0), (this.supportsWorldCopies = !0));
              }
              project(e, i) {
                return { x: 0.5 + e / 360, y: 0.5 - i / 360, z: 0 };
              }
              unproject(e, i) {
                const o = 360 * (e - 0.5),
                  a = he(360 * (0.5 - i), -85.051129, He);
                return new Y(o, a);
              }
            }
            const Ou = Math.PI / 2;
            function Ym(n) {
              return Math.tan((Ou + n) / 2);
            }
            class XE extends Ul {
              constructor(e) {
                (super(e), (this.center = e.center || [0, 30]));
                const [i, o] = (this.parallels = e.parallels || [30, 30]);
                let a = Mi(i),
                  u = Mi(o);
                ((this.southernCenter = a + u < 0),
                  this.southernCenter && ((a = -a), (u = -u)));
                const d = Math.cos(a),
                  _ = Ym(a);
                ((this.n =
                  a === u
                    ? Math.sin(a)
                    : Math.log(d / Math.cos(u)) / Math.log(Ym(u) / _)),
                  (this.f = (d * Math.pow(Ym(a), this.n)) / this.n));
              }
              project(e, i) {
                ((i = Mi(i)),
                  this.southernCenter && (i = -i),
                  (e = Mi(e - this.center[0])));
                const o = 1e-6,
                  { n: a, f: u } = this;
                u > 0
                  ? i < -Ou + o && (i = -Ou + o)
                  : i > Ou - o && (i = Ou - o);
                const d = u / Math.pow(Ym(i), a);
                let _ = d * Math.sin(a * e),
                  v = u - d * Math.cos(a * e);
                return (
                  (_ = 0.5 * (_ / Math.PI + 0.5)),
                  (v = 0.5 * (v / Math.PI + 0.5)),
                  { x: _, y: this.southernCenter ? v : 1 - v, z: 0 }
                );
              }
              unproject(e, i) {
                ((e = (2 * e - 0.5) * Math.PI),
                  this.southernCenter && (i = 1 - i),
                  (i = (2 * (1 - i) - 0.5) * Math.PI));
                const { n: o, f: a } = this,
                  u = a - i,
                  d = Math.sign(u),
                  _ = Math.sign(o) * Math.sqrt(e * e + u * u);
                let v = Math.atan2(e, Math.abs(u)) * d;
                u * o < 0 && (v -= Math.PI * Math.sign(e) * d);
                const b = he(Fe(v / o) + this.center[0], -180, 180),
                  E = he(
                    Fe(2 * Math.atan(Math.pow(a / _, 1 / o)) - Ou),
                    -85.051129,
                    He,
                  );
                return new Y(b, this.southernCenter ? -E : E);
              }
            }
            class Vb extends Ul {
              constructor(e) {
                (super(e),
                  (this.wrap = !0),
                  (this.supportsWorldCopies = !0),
                  (this.supportsTerrain = !0),
                  (this.supportsFog = !0),
                  (this.supportsFreeCamera = !0),
                  (this.isReprojectedInTileSpace = !1),
                  (this.unsupportedLayers = []),
                  (this.range = null));
              }
              project(e, i) {
                return { x: ce(e), y: le(i), z: 0 };
              }
              unproject(e, i) {
                const o = _e(e),
                  a = De(i);
                return new Y(o, a);
              }
            }
            const Ub = Mi(He);
            class YE extends Ul {
              project(e, i) {
                const o = (i = Mi(i)) * i,
                  a = o * o;
                return {
                  x:
                    0.5 *
                    (((e = Mi(e)) *
                      (0.8707 -
                        0.131979 * o +
                        a * (a * (0.003971 * o - 0.001529 * a) - 0.013791))) /
                      Math.PI +
                      0.5),
                  y:
                    1 -
                    0.5 *
                      ((i *
                        (1.007226 +
                          o *
                            (0.015085 +
                              a * (0.028874 * o - 0.044475 - 0.005916 * a)))) /
                        Math.PI +
                        1),
                  z: 0,
                };
              }
              unproject(e, i) {
                e = (2 * e - 0.5) * Math.PI;
                let o = (i = (2 * (1 - i) - 1) * Math.PI),
                  a = 25,
                  u = 0,
                  d = o * o;
                do {
                  d = o * o;
                  const b = d * d;
                  ((u =
                    (o *
                      (1.007226 +
                        d *
                          (0.015085 +
                            b * (0.028874 * d - 0.044475 - 0.005916 * b))) -
                      i) /
                    (1.007226 +
                      d *
                        (0.045255 +
                          b * (0.259866 * d - 0.311325 - 0.005916 * 11 * b)))),
                    (o = he(o - u, -Ub, Ub)));
                } while (Math.abs(u) > 1e-6 && --a > 0);
                d = o * o;
                const _ = he(
                    Fe(
                      e /
                        (0.8707 +
                          d *
                            (d *
                              (d * d * d * (0.003971 - 0.001529 * d) -
                                0.013791) -
                              0.131979)),
                    ),
                    -180,
                    180,
                  ),
                  v = Fe(o);
                return new Y(_, v);
              }
            }
            const jb = Mi(He);
            class KE extends Ul {
              project(e, i) {
                ((i = Mi(i)), (e = Mi(e)));
                const o = Math.cos(i),
                  a = 2 / Math.PI,
                  u = Math.acos(o * Math.cos(e / 2)),
                  d = Math.sin(u) / u,
                  _ = 0.5 * (e * a + (2 * o * Math.sin(e / 2)) / d) || 0,
                  v = 0.5 * (i + Math.sin(i) / d) || 0;
                return {
                  x: 0.5 * (_ / Math.PI + 0.5),
                  y: 1 - 0.5 * (v / Math.PI + 1),
                  z: 0,
                };
              }
              unproject(e, i) {
                let o = (e = (2 * e - 0.5) * Math.PI),
                  a = (i = (2 * (1 - i) - 1) * Math.PI),
                  u = 25;
                const d = 1e-6;
                let _ = 0,
                  v = 0;
                do {
                  const b = Math.cos(a),
                    E = Math.sin(a),
                    A = 2 * E * b,
                    M = E * E,
                    R = b * b,
                    k = Math.cos(o / 2),
                    N = Math.sin(o / 2),
                    j = 2 * k * N,
                    H = N * N,
                    J = 1 - R * k * k,
                    Q = J ? 1 / J : 0,
                    V = J ? Math.acos(b * k) * Math.sqrt(1 / J) : 0,
                    X = 0.5 * (2 * V * b * N + (2 * o) / Math.PI) - e,
                    ee = 0.5 * (V * E + a) - i,
                    re = 0.5 * Q * (R * H + V * b * k * M) + 1 / Math.PI,
                    ve = Q * ((j * A) / 4 - V * E * N),
                    ge = 0.125 * Q * (A * N - V * E * R * j),
                    be = 0.5 * Q * (M * k + V * H * b) + 0.5,
                    Me = ve * ge - be * re;
                  ((_ = (ee * ve - X * be) / Me),
                    (v = (X * ge - ee * re) / Me),
                    (o = he(o - _, -Math.PI, Math.PI)),
                    (a = he(a - v, -jb, jb)));
                } while ((Math.abs(_) > d || Math.abs(v) > d) && --u > 0);
                return new Y(Fe(o), Fe(a));
              }
            }
            class Gb extends Ul {
              constructor(e) {
                (super(e),
                  (this.center = e.center || [0, 0]),
                  (this.parallels = e.parallels || [0, 0]),
                  (this.cosPhi = Math.max(
                    0.01,
                    Math.cos(Mi(this.parallels[0])),
                  )),
                  (this.scale =
                    1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi))),
                  (this.wrap = !0),
                  (this.supportsWorldCopies = !0));
              }
              project(e, i) {
                const { scale: o, cosPhi: a } = this;
                return {
                  x: Mi(e) * a * o + 0.5,
                  y: (-Math.sin(Mi(i)) / a) * o + 0.5,
                  z: 0,
                };
              }
              unproject(e, i) {
                const { scale: o, cosPhi: a } = this,
                  u = -(i - 0.5) / o,
                  d = he(Fe((e - 0.5) / o) / a, -180, 180),
                  _ = Math.asin(he(u * a, -1, 1)),
                  v = he(Fe(_), -85.051129, He);
                return new Y(d, v);
              }
            }
            class JE extends Vb {
              constructor(e) {
                (super(e),
                  (this.requiresDraping = !0),
                  (this.supportsWorldCopies = !1),
                  (this.supportsFog = !0),
                  (this.zAxisUnit = "pixels"),
                  (this.unsupportedLayers = ["debug"]),
                  (this.range = [3, 5]));
              }
              projectTilePoint(e, i, o) {
                const a = cf(e, i, o);
                return (mn(a, a, Mm(Yo(o))), { x: a[0], y: a[1], z: a[2] });
              }
              locationPoint(e, i, o) {
                const a = U(i.lat, i.lng),
                  u = tn([], a),
                  d = o
                    ? e._centerAltitude + o
                    : e.elevation
                      ? e.elevation.getAtPointOrZero(
                          e.locationCoordinate(i),
                          e._centerAltitude,
                        )
                      : e._centerAltitude;
                _r(a, a, u, me(1, 0) * mt * d);
                const _ = xe(new Float64Array(16));
                return (
                  Ae(_, e.pixelMatrix, e.globeMatrix),
                  mn(a, a, _),
                  new ft(a[0], a[1])
                );
              }
              pixelsPerMeter(e, i) {
                return me(1, 0) * i;
              }
              pixelSpaceConversion(e, i, o) {
                const a = me(1, e) * i,
                  u = Ht(me(1, 45) * i, a, o);
                return this.pixelsPerMeter(e, i) / u;
              }
              createTileMatrix(e, i, o) {
                const a = Y_(Yo(o.canonical));
                return Ae(new Float64Array(16), e.globeMatrix, a);
              }
              createInversionMatrix(e, i) {
                const { center: o } = e,
                  a = Mm(Yo(i));
                return (
                  Mt(a, a, Mi(o.lng)),
                  Rt(a, a, Mi(o.lat)),
                  gt(a, a, [
                    e._pixelsPerMercatorPixel,
                    e._pixelsPerMercatorPixel,
                    1,
                  ]),
                  Float32Array.from(a)
                );
              }
              pointCoordinate(e, i, o, a) {
                return Ev(e, i, o, !0) || new Te(0, 0);
              }
              pointCoordinate3D(e, i, o) {
                const a = this.pointCoordinate(e, i, o, 0);
                return [a.x, a.y, a.z];
              }
              isPointAboveHorizon(e, i) {
                return !Ev(e, i.x, i.y, !1);
              }
              farthestPixelDistance(e) {
                const i = (function (a, u) {
                    const d = a.cameraToCenterDistance,
                      _ = a._centerAltitude * u,
                      v = a._camera,
                      b = a._camera.forward(),
                      E = ei([], Vi([], b, -d), [0, 0, _]),
                      A = a.worldSize / (2 * Math.PI),
                      M = [0, 0, -A],
                      R = a.width / a.height,
                      k = Math.tan(a.fovAboveCenter),
                      N = Vi([], v.up(), k),
                      j = Vi([], v.right(), k * R),
                      H = tn([], ei([], ei([], b, N), j)),
                      J = [];
                    let Q;
                    if (new hn(E, H).closestPointOnSphere(M, A, J)) {
                      const V = ei([], J, M),
                        X = Gn([], V, E);
                      Q = Math.cos(a.fovAboveCenter) * Ri(X);
                    } else {
                      const V = Gn([], E, M),
                        X = Gn([], M, E);
                      tn(X, X);
                      const ee = Ri(V) - A;
                      Q = Math.sqrt(ee * (ee + 2 * A));
                      const re = Math.acos(Q / (A + ee)) - Math.acos(wn(b, X));
                      Q *= Math.cos(re);
                    }
                    return 1.01 * Q;
                  })(e, this.pixelsPerMeter(e.center.lat, e.worldSize)),
                  o = Fl(e.zoom);
                if (o > 0) {
                  const a = Bb(e, me(1, e.center.lat) * e.worldSize),
                    u = e.worldSize / (2 * Math.PI),
                    d = (Math.max(e.width, e.height) / e.worldSize) * Math.PI;
                  return Ht(i, a + u * (1 - Math.cos(d)), Math.pow(o, 10));
                }
                return i;
              }
              upVector(e, i, o) {
                return cf(i, o, e, 1);
              }
              upVectorScale(e) {
                return { metersToTile: Em(Am(Yo(e))) };
              }
            }
            function $b(n) {
              const e = n.parallels,
                i = !!e && Math.abs(e[0] + e[1]) < 0.01;
              switch (n.name) {
                case "mercator":
                  return new Vb(n);
                case "equirectangular":
                  return new ZE(n);
                case "naturalEarth":
                  return new YE(n);
                case "equalEarth":
                  return new qE(n);
                case "winkelTripel":
                  return new KE(n);
                case "albers":
                  return i ? new Gb(n) : new WE(n);
                case "lambertConformalConic":
                  return i ? new Gb(n) : new XE(n);
                case "globe":
                  return new JE(n);
              }
              throw new Error(`Invalid projection name: ${n.name}`);
            }
            const QE = li.VectorTileFeature.types,
              eI = [
                {
                  name: "a_fade_opacity",
                  components: 1,
                  type: "Uint8",
                  offset: 0,
                },
              ];
            function Km(n, e, i, o, a, u, d, _, v, b, E, A, M) {
              const R = _ ? Math.min(Vl, Math.round(_[0])) : 0,
                k = _ ? Math.min(Vl, Math.round(_[1])) : 0;
              n.emplaceBack(
                e,
                i,
                Math.round(32 * o),
                Math.round(32 * a),
                u,
                d,
                (R << 1) + (v ? 1 : 0),
                k,
                16 * b,
                16 * E,
                256 * A,
                256 * M,
              );
            }
            function Jm(n, e, i) {
              n.emplaceBack(e, i);
            }
            function Qm(n, e, i, o, a, u, d) {
              n.emplaceBack(e, i, o, a, u, d);
            }
            const eg = (n, e, i, o) => {
              for (let a = 0; a < e; a++)
                n.emplaceBack(i[0], i[1], i[2], o[0], o[1], o[2]);
            };
            function tg(n, e, i, o, a) {
              (n.emplaceBack(e, i, o, a),
                n.emplaceBack(e, i, o, a),
                n.emplaceBack(e, i, o, a),
                n.emplaceBack(e, i, o, a));
            }
            function tI(n) {
              for (const e of n.sections) if (N_(e.text)) return !0;
              return !1;
            }
            class ky {
              constructor(e) {
                ((this.layoutVertexArray = new Ml()),
                  (this.indexArray = new dr()),
                  (this.programConfigurations = e),
                  (this.segments = new Rn()),
                  (this.dynamicLayoutVertexArray = new ur()),
                  (this.opacityVertexArray = new Pl()),
                  (this.placedSymbolArray = new um()),
                  (this.iconTransitioningVertexArray = new Ho()),
                  (this.globeExtVertexArray = new Cl()),
                  (this.zOffsetVertexArray = new Go()),
                  (this.orientationVertexArray = new Kd()));
              }
              isEmpty() {
                return (
                  this.layoutVertexArray.length === 0 &&
                  this.indexArray.length === 0 &&
                  this.dynamicLayoutVertexArray.length === 0 &&
                  this.opacityVertexArray.length === 0 &&
                  this.iconTransitioningVertexArray.length === 0
                );
              }
              upload(e, i, o, a, u) {
                this.isEmpty() ||
                  (o &&
                    ((this.layoutVertexBuffer = e.createVertexBuffer(
                      this.layoutVertexArray,
                      fE.members,
                    )),
                    (this.indexBuffer = e.createIndexBuffer(
                      this.indexArray,
                      i,
                    )),
                    (this.dynamicLayoutVertexBuffer = e.createVertexBuffer(
                      this.dynamicLayoutVertexArray,
                      mE.members,
                      !0,
                    )),
                    (this.opacityVertexBuffer = e.createVertexBuffer(
                      this.opacityVertexArray,
                      eI,
                      !0,
                    )),
                    this.iconTransitioningVertexArray.length > 0 &&
                      (this.iconTransitioningVertexBuffer =
                        e.createVertexBuffer(
                          this.iconTransitioningVertexArray,
                          yE.members,
                          !0,
                        )),
                    this.globeExtVertexArray.length > 0 &&
                      (this.globeExtVertexBuffer = e.createVertexBuffer(
                        this.globeExtVertexArray,
                        pE.members,
                        !0,
                      )),
                    !this.zOffsetVertexBuffer &&
                      (this.zOffsetVertexArray.length > 0 || u) &&
                      (this.zOffsetVertexBuffer = e.createVertexBuffer(
                        this.zOffsetVertexArray,
                        gE.members,
                        !0,
                      )),
                    !this.orientationVertexBuffer &&
                      this.orientationVertexArray &&
                      this.orientationVertexArray.length > 0 &&
                      (this.orientationVertexBuffer = e.createVertexBuffer(
                        this.orientationVertexArray,
                        _E.members,
                        !0,
                      )),
                    (this.opacityVertexBuffer.itemSize = 1)),
                  (o || a) && this.programConfigurations.upload(e));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.programConfigurations.destroy(),
                  this.segments.destroy(),
                  this.dynamicLayoutVertexBuffer.destroy(),
                  this.opacityVertexBuffer.destroy(),
                  this.iconTransitioningVertexBuffer &&
                    this.iconTransitioningVertexBuffer.destroy(),
                  this.globeExtVertexBuffer &&
                    this.globeExtVertexBuffer.destroy(),
                  this.zOffsetVertexBuffer &&
                    this.zOffsetVertexBuffer.destroy(),
                  this.orientationVertexBuffer &&
                    this.orientationVertexBuffer.destroy());
              }
            }
            Tt(ky, "SymbolBuffers");
            class Ly {
              constructor(e, i, o) {
                ((this.layoutVertexArray = new e()),
                  (this.layoutAttributes = i),
                  (this.indexArray = new o()),
                  (this.segments = new Rn()),
                  (this.collisionVertexArray = new jc()),
                  (this.collisionVertexArrayExt = new ur()));
              }
              upload(e) {
                ((this.layoutVertexBuffer = e.createVertexBuffer(
                  this.layoutVertexArray,
                  this.layoutAttributes,
                )),
                  (this.indexBuffer = e.createIndexBuffer(this.indexArray)),
                  (this.collisionVertexBuffer = e.createVertexBuffer(
                    this.collisionVertexArray,
                    xE.members,
                    !0,
                  )),
                  (this.collisionVertexBufferExt = e.createVertexBuffer(
                    this.collisionVertexArrayExt,
                    vE.members,
                    !0,
                  )));
              }
              destroy() {
                this.layoutVertexBuffer &&
                  (this.layoutVertexBuffer.destroy(),
                  this.indexBuffer.destroy(),
                  this.segments.destroy(),
                  this.collisionVertexBuffer.destroy(),
                  this.collisionVertexBufferExt.destroy());
              }
            }
            Tt(Ly, "CollisionBuffers");
            class ig {
              constructor(e) {
                ((this.collisionBoxArray = e.collisionBoxArray),
                  (this.zoom = e.zoom),
                  (this.lut = e.lut),
                  (this.overscaling = e.overscaling),
                  (this.layers = e.layers),
                  (this.layerIds = this.layers.map((d) => d.fqid)),
                  (this.index = e.index),
                  (this.pixelRatio = e.pixelRatio),
                  (this.sourceLayerIndex = e.sourceLayerIndex),
                  (this.hasPattern = !1),
                  (this.hasRTLText = !1),
                  (this.fullyClipped = !1),
                  (this.hasAnyIconTextFit = !1),
                  (this.sortKeyRanges = []),
                  (this.collisionCircleArray = []),
                  (this.placementInvProjMatrix = xe([])),
                  (this.placementViewportMatrix = xe([])));
                const i = this.layers[0]._unevaluatedLayout._values;
                ((this.worldview = e.worldview),
                  (this.textSizeData = xb(
                    this.zoom,
                    i["text-size"],
                    this.worldview,
                  )),
                  (this.iconSizeData = xb(
                    this.zoom,
                    i["icon-size"],
                    this.worldview,
                  )));
                const o = this.layers[0].layout,
                  a = o.get("symbol-sort-key"),
                  u = o.get("symbol-z-order");
                ((this.canOverlap =
                  o.get("text-allow-overlap") ||
                  o.get("icon-allow-overlap") ||
                  o.get("text-ignore-placement") ||
                  o.get("icon-ignore-placement")),
                  (this.sortFeaturesByKey =
                    u !== "viewport-y" && a.constantOr(1) !== void 0),
                  (this.sortFeaturesByY =
                    (u === "viewport-y" ||
                      (u === "auto" && !this.sortFeaturesByKey)) &&
                    this.canOverlap),
                  (this.writingModes = o
                    .get("text-writing-mode")
                    .map((d) => hs[d])),
                  (this.stateDependentLayerIds = this.layers
                    .filter((d) => d.isStateDependent())
                    .map((d) => d.id)),
                  (this.sourceID = e.sourceID),
                  (this.projection = e.projection),
                  (this.hasAnyZOffset = !1),
                  (this.zOffsetSortDirty = !1),
                  (this.zOffsetBuffersNeedUpload = !1),
                  (this.elevationType = "none"),
                  (this.elevationStateComplete = !1),
                  (this.activeReplacements = []),
                  (this.replacementUpdateTime = 0));
              }
              createArrays() {
                ((this.text = new ky(
                  new c(
                    this.layers,
                    { zoom: this.zoom, lut: this.lut },
                    (e) => e.startsWith("text") || e.startsWith("symbol"),
                  ),
                )),
                  (this.icon = new ky(
                    new c(
                      this.layers,
                      { zoom: this.zoom, lut: this.lut },
                      (e) => e.startsWith("icon") || e.startsWith("symbol"),
                    ),
                  )),
                  (this.glyphOffsetArray = new tf()),
                  (this.lineVertexArray = new pm()),
                  (this.symbolInstances = new fm()));
              }
              calculateGlyphDependencies(e, i, o, a, u) {
                for (const d of e) {
                  const _ = d.codePointAt(0);
                  if (_ === void 0) break;
                  if (((i[_] = !0), a && u && _ <= 65535)) {
                    const v = Ef[d];
                    v && (i[v.charCodeAt(0)] = !0);
                  }
                }
              }
              updateFootprints(e, i) {}
              updateReplacement(e, i) {
                if (i.updateTime === this.replacementUpdateTime) return !1;
                this.replacementUpdateTime = i.updateTime;
                const o = i.getReplacementRegionsForTile(e.toUnwrapped(), !0);
                return (
                  !cy(this.activeReplacements, o) &&
                  ((this.activeReplacements = o), !0)
                );
              }
              populate(e, i, o, a) {
                const u = this.layers[0],
                  d = u.layout,
                  _ = this.projection.name === "globe",
                  v = d.get("text-font"),
                  b = d.get("text-field"),
                  E = d.get("icon-image"),
                  [A, M] = d.get("icon-size-scale-range"),
                  R = he(i.scaleFactor || 1, A, M),
                  k =
                    (b.value.kind !== "constant" ||
                      (b.value.value instanceof Rr &&
                        !b.value.value.isEmpty()) ||
                      b.value.value.toString().length > 0) &&
                    (v.value.kind !== "constant" || v.value.value.length > 0),
                  N =
                    E.value.kind !== "constant" ||
                    !!E.value.value ||
                    Object.keys(E.parameters).length > 0,
                  j = d.get("symbol-sort-key");
                if (((this.features = []), !k && !N)) return;
                const H = i.iconDependencies,
                  J = i.glyphDependencies,
                  Q = i.availableImages,
                  V = new qi(this.zoom, { worldview: this.worldview });
                for (const {
                  feature: X,
                  id: ee,
                  index: re,
                  sourceLayerIndex: ve,
                } of e) {
                  const ge = u._featureFilter.needGeometry,
                    be = bt(X, ge);
                  if (!u._featureFilter.filter(V, be, o)) continue;
                  if (
                    (ge || (be.geometry = Et(X, o, a)),
                    _ && X.type !== 1 && o.z <= 5)
                  ) {
                    const tt = be.geometry,
                      nt = 0.98078528056,
                      Ge = (Je, Ne) =>
                        wn(cf(Je.x, Je.y, o, 1), cf(Ne.x, Ne.y, o, 1)) < nt;
                    for (let Je = 0; Je < tt.length; Je++)
                      tt[Je] = ht(tt[Je], Ge);
                  }
                  let Me, Ue;
                  if (k) {
                    const tt = u.getValueAndResolveTokens(
                        "text-field",
                        be,
                        o,
                        Q,
                      ),
                      nt = Rr.factory(tt);
                    (tI(nt) && (this.hasRTLText = !0),
                      (!this.hasRTLText ||
                        Tl() === "unavailable" ||
                        (this.hasRTLText && fo.isParsed())) &&
                        (Me = wE(nt, u, be)));
                  }
                  if (N) {
                    const tt = u.getValueAndResolveTokens(
                      "icon-image",
                      be,
                      o,
                      Q,
                    );
                    Ue = typeof tt == "string" ? Gr.build(tt) : tt;
                  }
                  if (!Me && !Ue) continue;
                  const it = this.sortFeaturesByKey
                      ? j.evaluate(be, {}, o)
                      : void 0,
                    Xe = {
                      id: ee,
                      text: Me,
                      icon: Ue,
                      index: re,
                      sourceLayerIndex: ve,
                      geometry: be.geometry,
                      properties: X.properties,
                      type: QE[X.type],
                      sortKey: it,
                    };
                  if ((this.features.push(Xe), Ue)) {
                    const tt = this.layers[0]._unevaluatedLayout._values,
                      { iconPrimary: nt, iconSecondary: Ge } = kb(
                        Ue,
                        this.iconSizeData,
                        tt["icon-size"],
                        o,
                        this.zoom,
                        Xe,
                        this.pixelRatio,
                        R,
                        this.worldview,
                      ),
                      Je = nt.id.toString();
                    if (
                      (H.has(Je) ? H.get(Je).push(nt) : H.set(Je, [nt]), Ge)
                    ) {
                      const Ne = Ge.id.toString();
                      H.has(Ne) ? H.get(Ne).push(Ge) : H.set(Ne, [Ge]);
                    }
                  }
                  if (Me) {
                    const tt = v.evaluate(be, {}, o).join(","),
                      nt =
                        d.get("text-rotation-alignment") === "map" &&
                        d.get("symbol-placement") !== "point";
                    this.allowVerticalPlacement =
                      this.writingModes &&
                      this.writingModes.indexOf(hs.vertical) >= 0;
                    for (const Ge of Me.sections)
                      if (Ge.image) {
                        const Je = Ge.image
                            .getPrimary()
                            .scaleSelf(this.pixelRatio),
                          Ne = Je.id.toString(),
                          je = H.get(Ne) || [];
                        (je.push(Je), H.set(Ne, je));
                      } else {
                        const Je = Oc(Me.toString()),
                          Ne = Ge.fontStack || tt,
                          je = (J[Ne] = J[Ne] || {});
                        this.calculateGlyphDependencies(
                          Ge.text,
                          je,
                          nt,
                          this.allowVerticalPlacement,
                          Je,
                        );
                      }
                  }
                }
                if (
                  (d.get("symbol-placement") === "line" &&
                    (this.features = (function (X) {
                      const ee = {},
                        re = {},
                        ve = [];
                      let ge = 0;
                      function be(Xe) {
                        (ve.push(X[Xe]), ge++);
                      }
                      function Me(Xe, tt, nt) {
                        const Ge = re[Xe];
                        return (
                          delete re[Xe],
                          (re[tt] = Ge),
                          ve[Ge].geometry[0].pop(),
                          (ve[Ge].geometry[0] = ve[Ge].geometry[0].concat(
                            nt[0],
                          )),
                          Ge
                        );
                      }
                      function Ue(Xe, tt, nt) {
                        const Ge = ee[tt];
                        return (
                          delete ee[tt],
                          (ee[Xe] = Ge),
                          ve[Ge].geometry[0].shift(),
                          (ve[Ge].geometry[0] = nt[0].concat(
                            ve[Ge].geometry[0],
                          )),
                          Ge
                        );
                      }
                      function it(Xe, tt, nt) {
                        const Ge = nt ? tt[0][tt[0].length - 1] : tt[0][0];
                        return `${Xe}:${Ge.x}:${Ge.y}`;
                      }
                      for (let Xe = 0; Xe < X.length; Xe++) {
                        const tt = X[Xe],
                          nt = tt.geometry,
                          Ge = tt.text ? tt.text.toString() : null;
                        if (!Ge) {
                          be(Xe);
                          continue;
                        }
                        const Je = it(Ge, nt),
                          Ne = it(Ge, nt, !0);
                        if (Je in re && Ne in ee && re[Je] !== ee[Ne]) {
                          const je = Ue(Je, Ne, nt),
                            at = Me(Je, Ne, ve[je].geometry);
                          (delete ee[Je],
                            delete re[Ne],
                            (re[it(Ge, ve[at].geometry, !0)] = at),
                            (ve[je].geometry = null));
                        } else
                          Je in re
                            ? Me(Je, Ne, nt)
                            : Ne in ee
                              ? Ue(Je, Ne, nt)
                              : (be(Xe), (ee[Je] = ge - 1), (re[Ne] = ge - 1));
                      }
                      return ve.filter((Xe) => Xe.geometry);
                    })(this.features)),
                  d.get("symbol-elevation-reference") === "hd-road-markup")
                ) {
                  if (((this.elevationType = "road"), i.elevationFeatures)) {
                    !this.elevationFeatures &&
                      i.elevationFeatures.length > 0 &&
                      ((this.elevationFeatures = []),
                      (this.elevationFeatureIdToIndex = new Map()));
                    for (const X of i.elevationFeatures)
                      (this.elevationFeatureIdToIndex.set(
                        X.id,
                        this.elevationFeatures.length,
                      ),
                        this.elevationFeatures.push(X));
                  }
                } else
                  d.get("symbol-z-elevate") && (this.elevationType = "offset");
                (this.elevationType !== "none" &&
                  (this.zOffsetBuffersNeedUpload = !0),
                  this.sortFeaturesByKey &&
                    this.features.sort((X, ee) => X.sortKey - ee.sortKey));
              }
              update(e, i, o, a, u, d, _) {
                (this.text.programConfigurations.updatePaintArrays(
                  e,
                  i,
                  u,
                  o,
                  a,
                  d,
                  _,
                  this.worldview,
                ),
                  this.icon.programConfigurations.updatePaintArrays(
                    e,
                    i,
                    u,
                    o,
                    a,
                    d,
                    _,
                    this.worldview,
                  ));
              }
              updateRoadElevation(e) {
                if (
                  this.elevationType !== "road" ||
                  !this.elevationFeatures ||
                  this.elevationStateComplete
                )
                  return;
                ((this.elevationStateComplete = !0), (this.hasAnyZOffset = !1));
                let i = !1;
                const o = Ve(e),
                  a = 1 / o;
                let u = !1,
                  d = !1;
                for (let _ = 0; _ < this.symbolInstances.length; _++) {
                  const v = this.symbolInstances.get(_),
                    b = wi(1, 0, 0),
                    E = wi(0, 1, 0),
                    {
                      numHorizontalGlyphVertices: A,
                      numVerticalGlyphVertices: M,
                      numIconVertices: R,
                      numVerticalIconVertices: k,
                    } = v,
                    N = A > 0 || M > 0,
                    j = R > 0,
                    H = this.elevationFeatures[v.elevationFeatureIndex];
                  if (H) {
                    const J = new ft(v.tileAnchorX, v.tileAnchorY),
                      Q = 0.075 + H.pointElevation(J);
                    v.zOffset !== Q && ((i = !0), (v.zOffset = Q));
                    const V = H.computeSlopeNormal(J, a),
                      X = Ja(Zr(), wi(0, 0, 1), V);
                    (Qs(b, b, X),
                      Qs(E, E, X),
                      (b[2] *= o),
                      (E[2] *= o),
                      (b[0] === 1 &&
                        b[1] === 0 &&
                        b[2] === 0 &&
                        E[0] === 0 &&
                        E[1] === 1 &&
                        E[2] === 0) ||
                        ((u = u || N), (d = d || j)));
                  }
                  if (
                    (N &&
                      (eg(this.text.orientationVertexArray, A, b, E),
                      eg(this.text.orientationVertexArray, M, b, E)),
                    j)
                  ) {
                    const {
                      placedIconSymbolIndex: J,
                      verticalPlacedIconSymbolIndex: Q,
                    } = v;
                    (J >= 0 && eg(this.icon.orientationVertexArray, R, b, E),
                      Q >= 0 && eg(this.icon.orientationVertexArray, k, b, E));
                  }
                }
                (u || (this.text.orientationVertexArray = void 0),
                  d || (this.icon.orientationVertexArray = void 0),
                  i &&
                    ((this.zOffsetBuffersNeedUpload = !0),
                    (this.zOffsetSortDirty = !0)));
              }
              updateZOffset() {
                const e = (u, d, _) => {
                    ((o += d), o > u.length && u.resize(o));
                    for (let v = -d; v < 0; v++) u.emplace(v + o, _);
                  },
                  i = (u, d, _) => {
                    ((a += d), a > u.length && u.resize(a));
                    for (let v = -d; v < 0; v++) u.emplace(v + a, _);
                  };
                if (!this.zOffsetBuffersNeedUpload) return;
                this.zOffsetBuffersNeedUpload = !1;
                let o = 0,
                  a = 0;
                for (let u = 0; u < this.symbolInstances.length; u++) {
                  const d = this.symbolInstances.get(u),
                    {
                      numHorizontalGlyphVertices: _,
                      numVerticalGlyphVertices: v,
                      numIconVertices: b,
                    } = d,
                    E = d.zOffset,
                    A = b > 0;
                  if (
                    ((_ > 0 || v > 0) &&
                      (e(this.text.zOffsetVertexArray, _, E),
                      e(this.text.zOffsetVertexArray, v, E)),
                    A)
                  ) {
                    const {
                      placedIconSymbolIndex: M,
                      verticalPlacedIconSymbolIndex: R,
                    } = d;
                    (M >= 0 && i(this.icon.zOffsetVertexArray, b, E),
                      R >= 0 &&
                        i(
                          this.icon.zOffsetVertexArray,
                          d.numVerticalIconVertices,
                          E,
                        ));
                  }
                }
                (this.text.zOffsetVertexBuffer &&
                  this.text.zOffsetVertexBuffer.updateData(
                    this.text.zOffsetVertexArray,
                  ),
                  this.icon.zOffsetVertexBuffer &&
                    this.icon.zOffsetVertexBuffer.updateData(
                      this.icon.zOffsetVertexArray,
                    ));
              }
              isEmpty() {
                return this.symbolInstances.length === 0 && !this.hasRTLText;
              }
              uploadPending() {
                return (
                  !this.uploaded ||
                  this.text.programConfigurations.needsUpload ||
                  this.icon.programConfigurations.needsUpload
                );
              }
              upload(e) {
                (!this.uploaded &&
                  this.hasDebugData() &&
                  (this.textCollisionBox.upload(e),
                  this.iconCollisionBox.upload(e)),
                  this.text.upload(
                    e,
                    this.sortFeaturesByY,
                    !this.uploaded,
                    this.text.programConfigurations.needsUpload,
                    this.zOffsetBuffersNeedUpload,
                  ),
                  this.icon.upload(
                    e,
                    this.sortFeaturesByY,
                    !this.uploaded,
                    this.icon.programConfigurations.needsUpload,
                    this.zOffsetBuffersNeedUpload,
                  ),
                  (this.uploaded = !0));
              }
              destroyDebugData() {
                (this.textCollisionBox.destroy(),
                  this.iconCollisionBox.destroy());
              }
              getProjection() {
                return (
                  this.projectionInstance ||
                    (this.projectionInstance = $b(this.projection)),
                  this.projectionInstance
                );
              }
              destroy() {
                (this.text.destroy(),
                  this.icon.destroy(),
                  this.hasDebugData() && this.destroyDebugData());
              }
              addToLineVertexArray(e, i) {
                const o = this.lineVertexArray.length;
                if (e.segment !== void 0)
                  for (const { x: a, y: u } of i)
                    this.lineVertexArray.emplaceBack(a, u);
                return {
                  lineStartIndex: o,
                  lineLength: this.lineVertexArray.length - o,
                };
              }
              addSymbols(e, i, o, a, u, d, _, v, b, E, A, M, R, k, N, j) {
                const H = e.indexArray,
                  J = e.layoutVertexArray,
                  Q = e.globeExtVertexArray,
                  V = e.segments.prepareSegment(
                    4 * i.length,
                    J,
                    H,
                    this.canOverlap ? d.sortKey : void 0,
                  ),
                  X = this.glyphOffsetArray.length,
                  ee = V.vertexLength,
                  re =
                    this.allowVerticalPlacement && _ === hs.vertical
                      ? Math.PI / 2
                      : 0,
                  ve = d.text && d.text.sections;
                for (let be = 0; be < i.length; be++) {
                  const {
                      tl: Me,
                      tr: Ue,
                      bl: it,
                      br: Xe,
                      texPrimary: tt,
                      texSecondary: nt,
                      pixelOffsetTL: Ge,
                      pixelOffsetBR: Je,
                      minFontScaleX: Ne,
                      minFontScaleY: je,
                      glyphOffset: at,
                      isSDF: ct,
                      sectionIndex: Nt,
                    } = i[be],
                    Ct = V.vertexLength,
                    yt = at[1];
                  if (
                    (Km(
                      J,
                      b.x,
                      b.y,
                      Me.x,
                      yt + Me.y,
                      tt.x,
                      tt.y,
                      o,
                      ct,
                      Ge.x,
                      Ge.y,
                      Ne,
                      je,
                    ),
                    Km(
                      J,
                      b.x,
                      b.y,
                      Ue.x,
                      yt + Ue.y,
                      tt.x + tt.w,
                      tt.y,
                      o,
                      ct,
                      Je.x,
                      Ge.y,
                      Ne,
                      je,
                    ),
                    Km(
                      J,
                      b.x,
                      b.y,
                      it.x,
                      yt + it.y,
                      tt.x,
                      tt.y + tt.h,
                      o,
                      ct,
                      Ge.x,
                      Je.y,
                      Ne,
                      je,
                    ),
                    Km(
                      J,
                      b.x,
                      b.y,
                      Xe.x,
                      yt + Xe.y,
                      tt.x + tt.w,
                      tt.y + tt.h,
                      o,
                      ct,
                      Je.x,
                      Je.y,
                      Ne,
                      je,
                    ),
                    v)
                  ) {
                    const { x: ot, y: Jt, z: At } = v.anchor,
                      [Dt, Wt, ni] = v.up;
                    (Qm(Q, ot, Jt, At, Dt, Wt, ni),
                      Qm(Q, ot, Jt, At, Dt, Wt, ni),
                      Qm(Q, ot, Jt, At, Dt, Wt, ni),
                      Qm(Q, ot, Jt, At, Dt, Wt, ni),
                      tg(e.dynamicLayoutVertexArray, ot, Jt, At, re));
                  } else tg(e.dynamicLayoutVertexArray, b.x, b.y, b.z, re);
                  if (j) {
                    const ot = nt || tt;
                    (Jm(e.iconTransitioningVertexArray, ot.x, ot.y),
                      Jm(e.iconTransitioningVertexArray, ot.x + ot.w, ot.y),
                      Jm(e.iconTransitioningVertexArray, ot.x, ot.y + ot.h),
                      Jm(
                        e.iconTransitioningVertexArray,
                        ot.x + ot.w,
                        ot.y + ot.h,
                      ));
                  }
                  (H.emplaceBack(Ct, Ct + 1, Ct + 2),
                    H.emplaceBack(Ct + 1, Ct + 2, Ct + 3),
                    (V.vertexLength += 4),
                    (V.primitiveLength += 2),
                    this.glyphOffsetArray.emplaceBack(at[0]),
                    (be !== i.length - 1 && Nt === i[be + 1].sectionIndex) ||
                      e.programConfigurations.populatePaintArrays(
                        J.length,
                        d,
                        d.index,
                        {},
                        R,
                        k,
                        N,
                        ve && ve[Nt],
                        this.worldview,
                      ));
                }
                const ge = v ? v.anchor : b;
                e.placedSymbolArray.emplaceBack(
                  ge.x,
                  ge.y,
                  ge.z,
                  b.x,
                  b.y,
                  X,
                  this.glyphOffsetArray.length - X,
                  ee,
                  E,
                  A,
                  b.segment,
                  o ? o[0] : 0,
                  o ? o[1] : 0,
                  a[0],
                  a[1],
                  _,
                  0,
                  0,
                  0,
                  M,
                  0,
                );
              }
              _commitLayoutVertex(e, i, o, a, u, d, _) {
                e.emplaceBack(i, o, a, u, d, Math.round(_.x), Math.round(_.y));
              }
              _addCollisionDebugVertices(e, i, o, a, u, d, _) {
                const v = o.segments.prepareSegment(
                    4,
                    o.layoutVertexArray,
                    o.indexArray,
                  ),
                  b = v.vertexLength,
                  E = _.tileAnchorX,
                  A = _.tileAnchorY;
                for (let R = 0; R < 4; R++)
                  o.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0);
                (this._commitDebugCollisionVertexUpdate(
                  o.collisionVertexArrayExt,
                  i,
                  e.padding,
                  _.zOffset,
                ),
                  this._commitLayoutVertex(
                    o.layoutVertexArray,
                    a,
                    u,
                    d,
                    E,
                    A,
                    new ft(e.x1, e.y1),
                  ),
                  this._commitLayoutVertex(
                    o.layoutVertexArray,
                    a,
                    u,
                    d,
                    E,
                    A,
                    new ft(e.x2, e.y1),
                  ),
                  this._commitLayoutVertex(
                    o.layoutVertexArray,
                    a,
                    u,
                    d,
                    E,
                    A,
                    new ft(e.x2, e.y2),
                  ),
                  this._commitLayoutVertex(
                    o.layoutVertexArray,
                    a,
                    u,
                    d,
                    E,
                    A,
                    new ft(e.x1, e.y2),
                  ),
                  (v.vertexLength += 4));
                const M = o.indexArray;
                (M.emplaceBack(b, b + 1),
                  M.emplaceBack(b + 1, b + 2),
                  M.emplaceBack(b + 2, b + 3),
                  M.emplaceBack(b + 3, b),
                  (v.primitiveLength += 4));
              }
              _addTextDebugCollisionBoxes(e, i, o, a, u, d) {
                for (let _ = a; _ < u; _++) {
                  const v = o.get(_),
                    b = this.getSymbolInstanceTextSize(e, d, i, _);
                  this._addCollisionDebugVertices(
                    v,
                    b,
                    this.textCollisionBox,
                    v.projectedAnchorX,
                    v.projectedAnchorY,
                    v.projectedAnchorZ,
                    d,
                  );
                }
              }
              _addIconDebugCollisionBoxes(e, i, o, a, u, d) {
                for (let _ = a; _ < u; _++) {
                  const v = o.get(_),
                    b = this.getSymbolInstanceIconSize(
                      e,
                      i,
                      d.placedIconSymbolIndex,
                    );
                  this._addCollisionDebugVertices(
                    v,
                    b,
                    this.iconCollisionBox,
                    v.projectedAnchorX,
                    v.projectedAnchorY,
                    v.projectedAnchorZ,
                    d,
                  );
                }
              }
              generateCollisionDebugBuffers(e, i, o) {
                (this.hasDebugData() && this.destroyDebugData(),
                  (this.textCollisionBox = new Ly(mu, sb.members, Ho)),
                  (this.iconCollisionBox = new Ly(mu, sb.members, Ho)));
                const a = Af(this.iconSizeData, e),
                  u = Af(this.textSizeData, e, o);
                for (let d = 0; d < this.symbolInstances.length; d++) {
                  const _ = this.symbolInstances.get(d);
                  (this._addTextDebugCollisionBoxes(
                    u,
                    e,
                    i,
                    _.textBoxStartIndex,
                    _.textBoxEndIndex,
                    _,
                  ),
                    this._addTextDebugCollisionBoxes(
                      u,
                      e,
                      i,
                      _.verticalTextBoxStartIndex,
                      _.verticalTextBoxEndIndex,
                      _,
                    ),
                    this._addIconDebugCollisionBoxes(
                      a,
                      e,
                      i,
                      _.iconBoxStartIndex,
                      _.iconBoxEndIndex,
                      _,
                    ),
                    this._addIconDebugCollisionBoxes(
                      a,
                      e,
                      i,
                      _.verticalIconBoxStartIndex,
                      _.verticalIconBoxEndIndex,
                      _,
                    ));
                }
              }
              getSymbolInstanceTextSize(e, i, o, a) {
                const u = this.text.placedSymbolArray.get(
                    i.rightJustifiedTextSymbolIndex >= 0
                      ? i.rightJustifiedTextSymbolIndex
                      : i.centerJustifiedTextSymbolIndex >= 0
                        ? i.centerJustifiedTextSymbolIndex
                        : i.leftJustifiedTextSymbolIndex >= 0
                          ? i.leftJustifiedTextSymbolIndex
                          : i.verticalPlacedTextSymbolIndex >= 0
                            ? i.verticalPlacedTextSymbolIndex
                            : a,
                  ),
                  d = Ay(this.textSizeData, e, u) / cr;
                return this.tilePixelRatio * d;
              }
              getSymbolInstanceIconSize(e, i, o) {
                const a = this.icon.placedSymbolArray.get(o),
                  u = Ay(this.iconSizeData, e, a);
                return this.tilePixelRatio * u;
              }
              _commitDebugCollisionVertexUpdate(e, i, o, a) {
                (e.emplaceBack(i, -o, -o, a),
                  e.emplaceBack(i, o, -o, a),
                  e.emplaceBack(i, o, o, a),
                  e.emplaceBack(i, -o, o, a));
              }
              _updateTextDebugCollisionBoxes(e, i, o, a, u, d, _) {
                for (let v = a; v < u; v++) {
                  const b = o.get(v),
                    E = this.getSymbolInstanceTextSize(e, d, i, v);
                  this._commitDebugCollisionVertexUpdate(
                    this.textCollisionBox.collisionVertexArrayExt,
                    E,
                    b.padding,
                    d.zOffset,
                  );
                }
              }
              _updateIconDebugCollisionBoxes(e, i, o, a, u, d, _) {
                for (let v = a; v < u; v++) {
                  const b = o.get(v),
                    E = this.getSymbolInstanceIconSize(
                      e,
                      i,
                      d.placedIconSymbolIndex,
                    );
                  this._commitDebugCollisionVertexUpdate(
                    this.iconCollisionBox.collisionVertexArrayExt,
                    E,
                    b.padding,
                    d.zOffset,
                  );
                }
              }
              updateCollisionDebugBuffers(e, i, o, a) {
                if (!this.hasDebugData()) return;
                (this.hasTextCollisionBoxData() &&
                  this.textCollisionBox.collisionVertexArrayExt.clear(),
                  this.hasIconCollisionBoxData() &&
                    this.iconCollisionBox.collisionVertexArrayExt.clear());
                const u = Af(this.iconSizeData, e, a),
                  d = Af(this.textSizeData, e, o);
                for (let _ = 0; _ < this.symbolInstances.length; _++) {
                  const v = this.symbolInstances.get(_);
                  (this._updateTextDebugCollisionBoxes(
                    d,
                    e,
                    i,
                    v.textBoxStartIndex,
                    v.textBoxEndIndex,
                    v,
                    o,
                  ),
                    this._updateTextDebugCollisionBoxes(
                      d,
                      e,
                      i,
                      v.verticalTextBoxStartIndex,
                      v.verticalTextBoxEndIndex,
                      v,
                      o,
                    ),
                    this._updateIconDebugCollisionBoxes(
                      u,
                      e,
                      i,
                      v.iconBoxStartIndex,
                      v.iconBoxEndIndex,
                      v,
                      a,
                    ),
                    this._updateIconDebugCollisionBoxes(
                      u,
                      e,
                      i,
                      v.verticalIconBoxStartIndex,
                      v.verticalIconBoxEndIndex,
                      v,
                      a,
                    ));
                }
                (this.hasTextCollisionBoxData() &&
                  this.textCollisionBox.collisionVertexBufferExt &&
                  this.textCollisionBox.collisionVertexBufferExt.updateData(
                    this.textCollisionBox.collisionVertexArrayExt,
                  ),
                  this.hasIconCollisionBoxData() &&
                    this.iconCollisionBox.collisionVertexBufferExt &&
                    this.iconCollisionBox.collisionVertexBufferExt.updateData(
                      this.iconCollisionBox.collisionVertexArrayExt,
                    ));
              }
              _deserializeCollisionBoxesForSymbol(e, i, o, a, u, d, _, v, b) {
                const E = {};
                if (i < o) {
                  const {
                    x1: A,
                    y1: M,
                    x2: R,
                    y2: k,
                    padding: N,
                    projectedAnchorX: j,
                    projectedAnchorY: H,
                    projectedAnchorZ: J,
                    tileAnchorX: Q,
                    tileAnchorY: V,
                    featureIndex: X,
                  } = e.get(i);
                  ((E.textBox = {
                    x1: A,
                    y1: M,
                    x2: R,
                    y2: k,
                    padding: N,
                    projectedAnchorX: j,
                    projectedAnchorY: H,
                    projectedAnchorZ: J,
                    tileAnchorX: Q,
                    tileAnchorY: V,
                  }),
                    (E.textFeatureIndex = X));
                }
                if (a < u) {
                  const {
                    x1: A,
                    y1: M,
                    x2: R,
                    y2: k,
                    padding: N,
                    projectedAnchorX: j,
                    projectedAnchorY: H,
                    projectedAnchorZ: J,
                    tileAnchorX: Q,
                    tileAnchorY: V,
                    featureIndex: X,
                  } = e.get(a);
                  ((E.verticalTextBox = {
                    x1: A,
                    y1: M,
                    x2: R,
                    y2: k,
                    padding: N,
                    projectedAnchorX: j,
                    projectedAnchorY: H,
                    projectedAnchorZ: J,
                    tileAnchorX: Q,
                    tileAnchorY: V,
                  }),
                    (E.verticalTextFeatureIndex = X));
                }
                if (d < _) {
                  const {
                    x1: A,
                    y1: M,
                    x2: R,
                    y2: k,
                    padding: N,
                    projectedAnchorX: j,
                    projectedAnchorY: H,
                    projectedAnchorZ: J,
                    tileAnchorX: Q,
                    tileAnchorY: V,
                    featureIndex: X,
                  } = e.get(d);
                  ((E.iconBox = {
                    x1: A,
                    y1: M,
                    x2: R,
                    y2: k,
                    padding: N,
                    projectedAnchorX: j,
                    projectedAnchorY: H,
                    projectedAnchorZ: J,
                    tileAnchorX: Q,
                    tileAnchorY: V,
                  }),
                    (E.iconFeatureIndex = X));
                }
                if (v < b) {
                  const {
                    x1: A,
                    y1: M,
                    x2: R,
                    y2: k,
                    padding: N,
                    projectedAnchorX: j,
                    projectedAnchorY: H,
                    projectedAnchorZ: J,
                    tileAnchorX: Q,
                    tileAnchorY: V,
                    featureIndex: X,
                  } = e.get(v);
                  ((E.verticalIconBox = {
                    x1: A,
                    y1: M,
                    x2: R,
                    y2: k,
                    padding: N,
                    projectedAnchorX: j,
                    projectedAnchorY: H,
                    projectedAnchorZ: J,
                    tileAnchorX: Q,
                    tileAnchorY: V,
                  }),
                    (E.verticalIconFeatureIndex = X));
                }
                return E;
              }
              deserializeCollisionBoxes(e) {
                this.collisionArrays = [];
                for (let i = 0; i < this.symbolInstances.length; i++) {
                  const o = this.symbolInstances.get(i);
                  this.collisionArrays.push(
                    this._deserializeCollisionBoxesForSymbol(
                      e,
                      o.textBoxStartIndex,
                      o.textBoxEndIndex,
                      o.verticalTextBoxStartIndex,
                      o.verticalTextBoxEndIndex,
                      o.iconBoxStartIndex,
                      o.iconBoxEndIndex,
                      o.verticalIconBoxStartIndex,
                      o.verticalIconBoxEndIndex,
                    ),
                  );
                }
              }
              hasTextData() {
                return this.text.segments.get().length > 0;
              }
              hasIconData() {
                return this.icon.segments.get().length > 0;
              }
              hasDebugData() {
                return this.textCollisionBox && this.iconCollisionBox;
              }
              hasTextCollisionBoxData() {
                return (
                  this.hasDebugData() &&
                  this.textCollisionBox.segments.get().length > 0
                );
              }
              hasIconCollisionBoxData() {
                return (
                  this.hasDebugData() &&
                  this.iconCollisionBox.segments.get().length > 0
                );
              }
              hasIconTextFit() {
                return this.hasAnyIconTextFit;
              }
              addIndicesForPlacedSymbol(e, i) {
                const o = e.placedSymbolArray.get(i),
                  a = o.vertexStartIndex + 4 * o.numGlyphs;
                for (let u = o.vertexStartIndex; u < a; u += 4)
                  (e.indexArray.emplaceBack(u, u + 1, u + 2),
                    e.indexArray.emplaceBack(u + 1, u + 2, u + 3));
              }
              getSortedSymbolIndexes(e) {
                if (
                  this.sortedAngle === e &&
                  this.symbolInstanceIndexes !== void 0
                )
                  return this.symbolInstanceIndexes;
                const i = Math.sin(e),
                  o = Math.cos(e),
                  a = [],
                  u = [],
                  d = [];
                for (let _ = 0; _ < this.symbolInstances.length; ++_) {
                  d.push(_);
                  const v = this.symbolInstances.get(_);
                  (a.push(
                    0 | Math.round(i * v.tileAnchorX + o * v.tileAnchorY),
                  ),
                    u.push(v.featureIndex));
                }
                return (d.sort((_, v) => a[_] - a[v] || u[v] - u[_]), d);
              }
              getSortedIndexesByZOffset() {
                if (!this.zOffsetSortDirty)
                  return this.symbolInstanceIndexesSortedZOffset;
                if (!this.symbolInstanceIndexesSortedZOffset) {
                  this.symbolInstanceIndexesSortedZOffset = [];
                  for (let e = 0; e < this.symbolInstances.length; ++e)
                    this.symbolInstanceIndexesSortedZOffset.push(e);
                }
                return (
                  (this.zOffsetSortDirty = !1),
                  this.symbolInstanceIndexesSortedZOffset.sort(
                    (e, i) =>
                      this.symbolInstances.get(i).zOffset -
                      this.symbolInstances.get(e).zOffset,
                  )
                );
              }
              addToSortKeyRanges(e, i) {
                const o = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                o && o.sortKey === i
                  ? (o.symbolInstanceEnd = e + 1)
                  : this.sortKeyRanges.push({
                      sortKey: i,
                      symbolInstanceStart: e,
                      symbolInstanceEnd: e + 1,
                    });
              }
              sortFeatures(e) {
                if (
                  this.sortFeaturesByY &&
                  this.sortedAngle !== e &&
                  !(
                    this.text.segments.get().length > 1 ||
                    this.icon.segments.get().length > 1
                  )
                ) {
                  ((this.symbolInstanceIndexes =
                    this.getSortedSymbolIndexes(e)),
                    (this.sortedAngle = e),
                    this.text.indexArray.clear(),
                    this.icon.indexArray.clear(),
                    (this.featureSortOrder = []));
                  for (const i of this.symbolInstanceIndexes) {
                    const o = this.symbolInstances.get(i);
                    this.featureSortOrder.push(o.featureIndex);
                    const {
                      rightJustifiedTextSymbolIndex: a,
                      centerJustifiedTextSymbolIndex: u,
                      leftJustifiedTextSymbolIndex: d,
                      verticalPlacedTextSymbolIndex: _,
                      placedIconSymbolIndex: v,
                      verticalPlacedIconSymbolIndex: b,
                    } = o;
                    (a >= 0 && this.addIndicesForPlacedSymbol(this.text, a),
                      u >= 0 &&
                        u !== a &&
                        this.addIndicesForPlacedSymbol(this.text, u),
                      d >= 0 &&
                        d !== u &&
                        d !== a &&
                        this.addIndicesForPlacedSymbol(this.text, d),
                      _ >= 0 && this.addIndicesForPlacedSymbol(this.text, _),
                      v >= 0 && this.addIndicesForPlacedSymbol(this.icon, v),
                      b >= 0 && this.addIndicesForPlacedSymbol(this.icon, b));
                  }
                  (this.text.indexBuffer &&
                    this.text.indexBuffer.updateData(this.text.indexArray),
                    this.icon.indexBuffer &&
                      this.icon.indexBuffer.updateData(this.icon.indexArray));
                }
              }
            }
            let Hb, Wb, Oy;
            (Tt(ig, "SymbolBucket", {
              omit: ["layers", "collisionBoxArray", "features", "compareText"],
            }),
              (ig.addDynamicAttributes = tg));
            class qb {
              constructor(e) {
                ((this.type = e.property.overrides
                  ? e.property.overrides.runtimeType
                  : sl),
                  (this.defaultValue = e));
              }
              evaluate(e) {
                if (e.formattedSection) {
                  const i = this.defaultValue.property.overrides;
                  if (i && i.hasOverride(e.formattedSection))
                    return i.getOverride(e.formattedSection);
                }
                return e.feature && e.featureState
                  ? this.defaultValue.evaluate(e.feature, e.featureState)
                  : this.defaultValue.property.specification.default;
              }
              eachChild(e) {
                this.defaultValue.isConstant() ||
                  e(this.defaultValue.value._styleExpression.expression);
              }
              outputDefined() {
                return !1;
              }
              serialize() {
                return null;
              }
            }
            Tt(qb, "FormatSectionOverride", { omit: ["defaultValue"] });
            const Fy = () =>
              Oy ||
              ((Oy = {
                layout:
                  Hb ||
                  (Hb = new Cn({
                    "symbol-placement": new st(
                      Pe.layout_symbol["symbol-placement"],
                    ),
                    "symbol-spacing": new st(
                      Pe.layout_symbol["symbol-spacing"],
                    ),
                    "symbol-avoid-edges": new st(
                      Pe.layout_symbol["symbol-avoid-edges"],
                    ),
                    "symbol-sort-key": new vt(
                      Pe.layout_symbol["symbol-sort-key"],
                    ),
                    "symbol-z-order": new st(
                      Pe.layout_symbol["symbol-z-order"],
                    ),
                    "symbol-z-elevate": new st(
                      Pe.layout_symbol["symbol-z-elevate"],
                    ),
                    "symbol-elevation-reference": new st(
                      Pe.layout_symbol["symbol-elevation-reference"],
                    ),
                    "icon-allow-overlap": new st(
                      Pe.layout_symbol["icon-allow-overlap"],
                    ),
                    "icon-ignore-placement": new st(
                      Pe.layout_symbol["icon-ignore-placement"],
                    ),
                    "icon-optional": new st(Pe.layout_symbol["icon-optional"]),
                    "icon-rotation-alignment": new st(
                      Pe.layout_symbol["icon-rotation-alignment"],
                    ),
                    "icon-size": new vt(Pe.layout_symbol["icon-size"]),
                    "icon-size-scale-range": new st(
                      Pe.layout_symbol["icon-size-scale-range"],
                    ),
                    "icon-text-fit": new vt(Pe.layout_symbol["icon-text-fit"]),
                    "icon-text-fit-padding": new vt(
                      Pe.layout_symbol["icon-text-fit-padding"],
                    ),
                    "icon-image": new vt(Pe.layout_symbol["icon-image"]),
                    "icon-rotate": new vt(Pe.layout_symbol["icon-rotate"]),
                    "icon-padding": new st(Pe.layout_symbol["icon-padding"]),
                    "icon-keep-upright": new st(
                      Pe.layout_symbol["icon-keep-upright"],
                    ),
                    "icon-offset": new vt(Pe.layout_symbol["icon-offset"]),
                    "icon-anchor": new vt(Pe.layout_symbol["icon-anchor"]),
                    "icon-pitch-alignment": new st(
                      Pe.layout_symbol["icon-pitch-alignment"],
                    ),
                    "text-pitch-alignment": new st(
                      Pe.layout_symbol["text-pitch-alignment"],
                    ),
                    "text-rotation-alignment": new st(
                      Pe.layout_symbol["text-rotation-alignment"],
                    ),
                    "text-field": new vt(Pe.layout_symbol["text-field"]),
                    "text-font": new vt(Pe.layout_symbol["text-font"]),
                    "text-size": new vt(Pe.layout_symbol["text-size"]),
                    "text-size-scale-range": new st(
                      Pe.layout_symbol["text-size-scale-range"],
                    ),
                    "text-max-width": new vt(
                      Pe.layout_symbol["text-max-width"],
                    ),
                    "text-line-height": new vt(
                      Pe.layout_symbol["text-line-height"],
                    ),
                    "text-letter-spacing": new vt(
                      Pe.layout_symbol["text-letter-spacing"],
                    ),
                    "text-justify": new vt(Pe.layout_symbol["text-justify"]),
                    "text-radial-offset": new vt(
                      Pe.layout_symbol["text-radial-offset"],
                    ),
                    "text-variable-anchor": new st(
                      Pe.layout_symbol["text-variable-anchor"],
                    ),
                    "text-anchor": new vt(Pe.layout_symbol["text-anchor"]),
                    "text-max-angle": new st(
                      Pe.layout_symbol["text-max-angle"],
                    ),
                    "text-writing-mode": new st(
                      Pe.layout_symbol["text-writing-mode"],
                    ),
                    "text-rotate": new vt(Pe.layout_symbol["text-rotate"]),
                    "text-padding": new st(Pe.layout_symbol["text-padding"]),
                    "text-keep-upright": new st(
                      Pe.layout_symbol["text-keep-upright"],
                    ),
                    "text-transform": new vt(
                      Pe.layout_symbol["text-transform"],
                    ),
                    "text-offset": new vt(Pe.layout_symbol["text-offset"]),
                    "text-allow-overlap": new st(
                      Pe.layout_symbol["text-allow-overlap"],
                    ),
                    "text-ignore-placement": new st(
                      Pe.layout_symbol["text-ignore-placement"],
                    ),
                    "text-optional": new st(Pe.layout_symbol["text-optional"]),
                    visibility: new st(Pe.layout_symbol.visibility),
                  })),
                paint:
                  Wb ||
                  (Wb = new Cn({
                    "icon-opacity": new vt(Pe.paint_symbol["icon-opacity"]),
                    "icon-occlusion-opacity": new vt(
                      Pe.paint_symbol["icon-occlusion-opacity"],
                    ),
                    "icon-emissive-strength": new vt(
                      Pe.paint_symbol["icon-emissive-strength"],
                    ),
                    "text-emissive-strength": new vt(
                      Pe.paint_symbol["text-emissive-strength"],
                    ),
                    "icon-color": new vt(Pe.paint_symbol["icon-color"]),
                    "icon-halo-color": new vt(
                      Pe.paint_symbol["icon-halo-color"],
                    ),
                    "icon-halo-width": new vt(
                      Pe.paint_symbol["icon-halo-width"],
                    ),
                    "icon-halo-blur": new vt(Pe.paint_symbol["icon-halo-blur"]),
                    "icon-translate": new st(Pe.paint_symbol["icon-translate"]),
                    "icon-translate-anchor": new st(
                      Pe.paint_symbol["icon-translate-anchor"],
                    ),
                    "icon-image-cross-fade": new st(
                      Pe.paint_symbol["icon-image-cross-fade"],
                    ),
                    "text-opacity": new vt(Pe.paint_symbol["text-opacity"]),
                    "text-occlusion-opacity": new vt(
                      Pe.paint_symbol["text-occlusion-opacity"],
                    ),
                    "text-color": new vt(Pe.paint_symbol["text-color"], {
                      runtimeType: Jr,
                      getOverride: (n) => n.textColor,
                      hasOverride: (n) => !!n.textColor,
                    }),
                    "text-halo-color": new vt(
                      Pe.paint_symbol["text-halo-color"],
                    ),
                    "text-halo-width": new vt(
                      Pe.paint_symbol["text-halo-width"],
                    ),
                    "text-halo-blur": new vt(Pe.paint_symbol["text-halo-blur"]),
                    "text-translate": new st(Pe.paint_symbol["text-translate"]),
                    "text-translate-anchor": new st(
                      Pe.paint_symbol["text-translate-anchor"],
                    ),
                    "icon-color-saturation": new st(
                      Pe.paint_symbol["icon-color-saturation"],
                    ),
                    "icon-color-contrast": new st(
                      Pe.paint_symbol["icon-color-contrast"],
                    ),
                    "icon-color-brightness-min": new st(
                      Pe.paint_symbol["icon-color-brightness-min"],
                    ),
                    "icon-color-brightness-max": new st(
                      Pe.paint_symbol["icon-color-brightness-max"],
                    ),
                    "symbol-z-offset": new vt(
                      Pe.paint_symbol["symbol-z-offset"],
                    ),
                    "icon-color-use-theme": new vt({
                      type: "string",
                      default: "default",
                      "property-type": "data-driven",
                    }),
                    "icon-halo-color-use-theme": new vt({
                      type: "string",
                      default: "default",
                      "property-type": "data-driven",
                    }),
                    "text-color-use-theme": new vt({
                      type: "string",
                      default: "default",
                      "property-type": "data-driven",
                    }),
                    "text-halo-color-use-theme": new vt({
                      type: "string",
                      default: "default",
                      "property-type": "data-driven",
                    }),
                  })),
              }),
              Oy);
            class ng extends Ir {
              constructor(e, i, o, a) {
                (super(e, Fy(), i, o, a),
                  (this._colorAdjustmentMatrix = xe([])),
                  (this.hasInitialOcclusionOpacityProperties =
                    e.paint !== void 0 &&
                    ("icon-occlusion-opacity" in e.paint ||
                      "text-occlusion-opacity" in e.paint)));
              }
              recalculate(e, i) {
                (super.recalculate(e, i),
                  this.layout.get("icon-rotation-alignment") === "auto" &&
                    (this.layout._values["icon-rotation-alignment"] =
                      this.layout.get("symbol-placement") !== "point"
                        ? "map"
                        : "viewport"),
                  this.layout.get("text-rotation-alignment") === "auto" &&
                    (this.layout._values["text-rotation-alignment"] =
                      this.layout.get("symbol-placement") !== "point"
                        ? "map"
                        : "viewport"),
                  this.layout.get("text-pitch-alignment") === "auto" &&
                    (this.layout._values["text-pitch-alignment"] =
                      this.layout.get("text-rotation-alignment")),
                  this.layout.get("icon-pitch-alignment") === "auto" &&
                    (this.layout._values["icon-pitch-alignment"] =
                      this.layout.get("icon-rotation-alignment")));
                const o = this.layout.get("text-writing-mode");
                if (o) {
                  const a = [];
                  for (const u of o) a.indexOf(u) < 0 && a.push(u);
                  this.layout._values["text-writing-mode"] = a;
                } else
                  this.layout._values["text-writing-mode"] =
                    this.layout.get("symbol-placement") === "point"
                      ? ["horizontal"]
                      : ["horizontal", "vertical"];
                this._setPaintOverrides();
              }
              getColorAdjustmentMatrix(e, i, o, a) {
                return (
                  (this._saturation === e &&
                    this._contrast === i &&
                    this._brightnessMin === o &&
                    this._brightnessMax === a) ||
                    ((this._colorAdjustmentMatrix = (function (u, d, _, v) {
                      ((u = Tr(u)), (d = Ur(d)));
                      const b = Ie(),
                        E = u / 3,
                        A = 1 - 2 * E,
                        M = [A, E, E, 0, E, A, E, 0, E, E, A, 0, 0, 0, 0, 1],
                        R = 0.5 - 0.5 * d,
                        k = v - _;
                      return (
                        Ae(
                          b,
                          [k, 0, 0, 0, 0, k, 0, 0, 0, 0, k, 0, _, _, _, 1],
                          [d, 0, 0, 0, 0, d, 0, 0, 0, 0, d, 0, R, R, R, 1],
                        ),
                        Ae(b, b, M),
                        b
                      );
                    })(e, i, o, a)),
                    (this._saturation = e),
                    (this._contrast = i),
                    (this._brightnessMin = o),
                    (this._brightnessMax = a)),
                  this._colorAdjustmentMatrix
                );
              }
              getValueAndResolveTokens(e, i, o, a) {
                const u = this.layout.get(e).evaluate(i, {}, o, a),
                  d = this._unevaluatedLayout._values[e];
                return d.isDataDriven() || su(d.value) || !u
                  ? u
                  : (function (_, v) {
                      return v.replace(/{([^{}]+)}/g, (b, E) =>
                        E in _ ? String(_[E]) : "",
                      );
                    })(i.properties, u);
              }
              createBucket(e) {
                return new ig(e);
              }
              queryRadius() {
                return 0;
              }
              queryIntersectsFeature() {
                return !1;
              }
              _setPaintOverrides() {
                for (const e of Fy().paint.overridableProperties) {
                  if (!ng.hasPaintOverride(this.layout, e)) continue;
                  const i = this.paint.get(e),
                    o = new qb(i),
                    a = new vl(
                      o,
                      i.property.specification,
                      this.scope,
                      this.options,
                    );
                  let u = null;
                  ((u =
                    i.value.kind === "constant" || i.value.kind === "source"
                      ? new kc("source", a)
                      : new Lc(
                          "composite",
                          a,
                          i.value.zoomStops,
                          i.value.interpolationType,
                        )),
                    (this.paint._values[e] = new Sl(
                      i.property,
                      u,
                      i.parameters,
                    )));
                }
              }
              _handleOverridablePaintPropertyUpdate(e, i, o) {
                return (
                  !(!this.layout || i.isDataDriven() || o.isDataDriven()) &&
                  ng.hasPaintOverride(this.layout, e)
                );
              }
              static hasPaintOverride(e, i) {
                const o = e.get("text-field"),
                  a = Fy().paint.properties[i];
                let u = !1;
                const d = (_) => {
                  for (const v of _)
                    if (a.overrides && a.overrides.hasOverride(v))
                      return void (u = !0);
                };
                if (o.value.kind === "constant" && o.value.value instanceof Rr)
                  d(o.value.value.sections);
                else if (o.value.kind === "source") {
                  const _ = (b) => {
                      u ||
                        (b instanceof Yt && wt(b.value) === _c
                          ? d(b.value.sections)
                          : b instanceof al
                            ? d(b.sections)
                            : b.eachChild(_));
                    },
                    v = o.value;
                  v._styleExpression && _(v._styleExpression.expression);
                }
                return u;
              }
              getProgramIds() {
                return ["symbol"];
              }
              getDefaultProgramParams(e, i, o) {
                return {
                  config: new kl(this, { zoom: i, lut: o }),
                  overrideFog: !1,
                };
              }
              hasElevation() {
                return (
                  this.layout &&
                  this.layout.get("symbol-elevation-reference") ===
                    "hd-road-markup"
                );
              }
            }
            let Zb, Xb, Yb, Kb;
            var By = Ai([
              { name: "a_pos", type: "Int16", components: 2 },
              { name: "a_texture_pos", type: "Int16", components: 2 },
            ]);
            function Ny(n) {
              switch (n) {
                case WebGL2RenderingContext.RGBA8:
                  return WebGL2RenderingContext.RGBA;
                case WebGL2RenderingContext.DEPTH_COMPONENT16:
                  return WebGL2RenderingContext.DEPTH_COMPONENT;
                case WebGL2RenderingContext.DEPTH24_STENCIL8:
                  return WebGL2RenderingContext.DEPTH_STENCIL;
                case WebGL2RenderingContext.R8:
                case WebGL2RenderingContext.R32F:
                  return WebGL2RenderingContext.RED;
              }
            }
            function Vy(n) {
              switch (n) {
                case WebGL2RenderingContext.RGBA8:
                  return WebGL2RenderingContext.UNSIGNED_BYTE;
                case WebGL2RenderingContext.DEPTH_COMPONENT16:
                  return WebGL2RenderingContext.UNSIGNED_SHORT;
                case WebGL2RenderingContext.DEPTH24_STENCIL8:
                  return WebGL2RenderingContext.UNSIGNED_INT_24_8;
                case WebGL2RenderingContext.R8:
                  return WebGL2RenderingContext.UNSIGNED_BYTE;
                case WebGL2RenderingContext.R32F:
                  return WebGL2RenderingContext.FLOAT;
              }
            }
            class Uy {
              constructor(e, i, o, a) {
                ((this.context = e),
                  (this.format = o),
                  (this.useMipmap = a && a.useMipmap),
                  (this.texture = e.gl.createTexture()),
                  this.update(i, { premultiply: a && a.premultiply }));
              }
              update(e, i) {
                const o =
                    e && e instanceof HTMLVideoElement && e.width === 0
                      ? e.videoWidth
                      : e.width,
                  a =
                    e && e instanceof HTMLVideoElement && e.height === 0
                      ? e.videoHeight
                      : e.height,
                  { context: u } = this,
                  { gl: d } = u,
                  { x: _, y: v } =
                    i && i.position ? i.position : { x: 0, y: 0 },
                  b = _ + o,
                  E = v + a;
                (!this.size ||
                  (this.size[0] === b && this.size[1] === E) ||
                  (d.bindTexture(d.TEXTURE_2D, null),
                  d.deleteTexture(this.texture),
                  (this.texture = d.createTexture()),
                  (this.size = null)),
                  d.bindTexture(d.TEXTURE_2D, this.texture),
                  u.pixelStoreUnpackFlipY.set(!1),
                  u.pixelStoreUnpack.set(1),
                  u.pixelStoreUnpackPremultiplyAlpha.set(
                    this.format === d.RGBA8 && (!i || i.premultiply !== !1),
                  ));
                const A =
                  e instanceof HTMLImageElement ||
                  e instanceof HTMLCanvasElement ||
                  e instanceof HTMLVideoElement ||
                  e instanceof ImageData ||
                  (ImageBitmap && e instanceof ImageBitmap);
                if (!this.size && b > 0 && E > 0) {
                  const M = this.useMipmap
                    ? Math.floor(Math.log2(Math.max(b, E))) + 1
                    : 1;
                  (d.texStorage2D(d.TEXTURE_2D, M, this.format, b, E),
                    (this.size = [b, E]));
                }
                if (this.size)
                  if (A)
                    d.texSubImage2D(
                      d.TEXTURE_2D,
                      0,
                      _,
                      v,
                      Ny(this.format),
                      Vy(this.format),
                      e,
                    );
                  else {
                    const M = e.data;
                    M &&
                      d.texSubImage2D(
                        d.TEXTURE_2D,
                        0,
                        _,
                        v,
                        o,
                        a,
                        Ny(this.format),
                        Vy(this.format),
                        M,
                      );
                  }
                this.useMipmap && d.generateMipmap(d.TEXTURE_2D);
              }
              bind(e, i, o = !1) {
                const { context: a } = this,
                  { gl: u } = a;
                (u.bindTexture(u.TEXTURE_2D, this.texture),
                  e !== this.minFilter &&
                    (u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, e),
                    u.texParameteri(
                      u.TEXTURE_2D,
                      u.TEXTURE_MIN_FILTER,
                      this.useMipmap && !o
                        ? e === u.NEAREST
                          ? u.NEAREST_MIPMAP_NEAREST
                          : u.LINEAR_MIPMAP_LINEAR
                        : e,
                    ),
                    (this.minFilter = e)),
                  i !== this.wrapS &&
                    (u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, i),
                    u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, i),
                    (this.wrapS = i)));
              }
              bindExtraParam(e, i, o, a, u) {
                const { context: d } = this,
                  { gl: _ } = d;
                (_.bindTexture(_.TEXTURE_2D, this.texture),
                  i !== this.magFilter &&
                    (_.texParameteri(_.TEXTURE_2D, _.TEXTURE_MAG_FILTER, i),
                    (this.magFilter = i)),
                  e !== this.minFilter &&
                    (_.texParameteri(
                      _.TEXTURE_2D,
                      _.TEXTURE_MIN_FILTER,
                      this.useMipmap
                        ? e === _.NEAREST
                          ? _.NEAREST_MIPMAP_NEAREST
                          : _.LINEAR_MIPMAP_LINEAR
                        : e,
                    ),
                    (this.minFilter = e)),
                  o !== this.wrapS &&
                    (_.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_S, o),
                    (this.wrapS = o)),
                  a !== this.wrapT &&
                    (_.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_T, a),
                    (this.wrapT = a)),
                  u !== this.compareMode &&
                    (u
                      ? (_.texParameteri(
                          _.TEXTURE_2D,
                          _.TEXTURE_COMPARE_MODE,
                          _.COMPARE_REF_TO_TEXTURE,
                        ),
                        _.texParameteri(
                          _.TEXTURE_2D,
                          _.TEXTURE_COMPARE_FUNC,
                          u,
                        ))
                      : _.texParameteri(
                          _.TEXTURE_2D,
                          _.TEXTURE_COMPARE_MODE,
                          _.NONE,
                        ),
                    (this.compareMode = u)));
              }
              destroy() {
                const { gl: e } = this.context;
                (e.deleteTexture(this.texture), (this.texture = null));
              }
            }
            class rg {
              constructor(e, i) {
                ((this.context = e), (this.texture = i));
              }
              bind(e, i) {
                const { context: o } = this,
                  { gl: a } = o;
                (a.bindTexture(a.TEXTURE_2D, this.texture),
                  e !== this.minFilter &&
                    (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, e),
                    a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, e),
                    (this.minFilter = e)),
                  i !== this.wrapS &&
                    (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, i),
                    a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, i),
                    (this.wrapS = i)));
              }
            }
            function sg(n, e, i, o, a, u, d, _) {
              const v = [n, e, 1, i, o, 1, a, u, 1],
                b = [d, _, 1],
                E = fe([], v),
                [A, M, R] = Za(b, b, E);
              return de(v, v, [A, 0, 0, 0, M, 0, 0, 0, R]);
            }
            function Jb(n, e, i, o, a, u, d, _) {
              const v = (function (b, E, A, M, R, k, N, j) {
                const H = sg(0, 0, 1, 0, 1, 1, 0, 1),
                  J = sg(b, E, A, M, R, k, N, j);
                return de(J, J, fe([], H));
              })(n, e, i, o, a, u, d, _);
              return [v[2] / v[8] / mt, v[5] / v[8] / mt];
            }
            function og(n) {
              return [n[0], Math.min(Math.max(n[1], -85.051129), He)];
            }
            class Qb extends ya {
              constructor(e, i, o, a) {
                (super(),
                  (this.id = e),
                  (this.dispatcher = o),
                  (this.coordinates = i.coordinates),
                  (this.type = "image"),
                  (this.minzoom = 0),
                  (this.maxzoom = 22),
                  (this.tileSize = 512),
                  (this.tiles = {}),
                  (this._loaded = !1),
                  (this.onNorthPole = !1),
                  (this.onSouthPole = !1),
                  this.setEventedParent(a),
                  (this.options = i),
                  (this._dirty = !1));
              }
              load(e, i) {
                if (
                  ((this._loaded = i || !1),
                  this.fire(new _a("dataloading", { dataType: "source" })),
                  (this.url = this.options.url),
                  !this.url)
                )
                  return (
                    e && (this.coordinates = e),
                    (this._loaded = !0),
                    void this._finishLoading()
                  );
                this._imageRequest = sd(
                  this.map._requestManager.transformRequest(this.url, dc.Image),
                  (o, a) => {
                    ((this._imageRequest = null),
                      (this._loaded = !0),
                      o
                        ? this.fire(new Rh(o))
                        : a &&
                          ((this.image =
                            a instanceof HTMLImageElement
                              ? As.getImageData(a)
                              : a),
                          (this._dirty = !0),
                          (this.width = this.image.width),
                          (this.height = this.image.height),
                          e && (this.coordinates = e),
                          this._finishLoading()));
                  },
                );
              }
              loaded() {
                return this._loaded;
              }
              updateImage(e) {
                return e.url
                  ? (this._imageRequest &&
                      e.url !== this.options.url &&
                      (this._imageRequest.cancel(),
                      (this._imageRequest = null)),
                    (this.options.url = e.url),
                    this.load(e.coordinates, this._loaded),
                    this)
                  : this;
              }
              setTexture(e) {
                if (!(e.handle instanceof WebGLTexture))
                  throw new Error(
                    "The provided handle is not a WebGLTexture instance",
                  );
                return (
                  (this.texture = new rg(this.map.painter.context, e.handle)),
                  (this.width = e.dimensions[0]),
                  (this.height = e.dimensions[1]),
                  (this._dirty = !1),
                  (this._loaded = !0),
                  this._finishLoading(),
                  this
                );
              }
              _finishLoading() {
                this.map &&
                  (this.setCoordinates(this.coordinates),
                  this.fire(
                    new _a("data", {
                      dataType: "source",
                      sourceDataType: "metadata",
                    }),
                  ));
              }
              onAdd(e) {
                ((this.map = e), this.load());
              }
              onRemove(e) {
                (this._imageRequest &&
                  (this._imageRequest.cancel(), (this._imageRequest = null)),
                  !this.texture ||
                    this.texture instanceof rg ||
                    this.texture.destroy(),
                  this.boundsBuffer &&
                    (this.boundsBuffer.destroy(),
                    this.elevatedGlobeVertexBuffer &&
                      this.elevatedGlobeVertexBuffer.destroy(),
                    this.elevatedGlobeIndexBuffer &&
                      this.elevatedGlobeIndexBuffer.destroy()));
              }
              setCoordinates(e) {
                if (
                  ((this.coordinates = e),
                  (this._boundsArray = void 0),
                  (this._unsupportedCoords = !1),
                  !e.length)
                )
                  return this;
                ((this.onNorthPole = !1), (this.onSouthPole = !1));
                let i = e[0][1],
                  o = e[0][1];
                for (const u of e)
                  (u[1] > o && (o = u[1]), u[1] < i && (i = u[1]));
                const a = (o + i) / 2;
                if (
                  (a > He
                    ? (this.onNorthPole = !0)
                    : a < -85.051129 && (this.onSouthPole = !0),
                  !this.onNorthPole && !this.onSouthPole)
                ) {
                  const u = e.map(Te.fromLngLat);
                  ((this.tileID = (function (d) {
                    let _ = 1 / 0,
                      v = 1 / 0,
                      b = -1 / 0,
                      E = -1 / 0;
                    for (const N of d)
                      ((_ = Math.min(_, N.x)),
                        (v = Math.min(v, N.y)),
                        (b = Math.max(b, N.x)),
                        (E = Math.max(E, N.y)));
                    const A = Math.max(b - _, E - v),
                      M = Math.max(0, Math.floor(-Math.log(A) / Math.LN2)),
                      R = Math.pow(2, M);
                    let k = Math.floor(((_ + b) / 2) * R);
                    return (
                      k > 1 && (k -= 1),
                      new eh(M, k, Math.floor(((v + E) / 2) * R))
                    );
                  })(u)),
                    (this.minzoom = this.maxzoom = this.tileID.z));
                }
                return (
                  this.fire(
                    new _a("data", {
                      dataType: "source",
                      sourceDataType: "content",
                    }),
                  ),
                  this
                );
              }
              _clear() {
                ((this._boundsArray = void 0), (this._unsupportedCoords = !1));
              }
              _prepareData(e) {
                for (const H in this.tiles) {
                  const J = this.tiles[H];
                  J.state !== "loaded" &&
                    ((J.state = "loaded"), (J.texture = this.texture));
                }
                if (
                  this._boundsArray ||
                  this.onNorthPole ||
                  this.onSouthPole ||
                  this._unsupportedCoords
                )
                  return;
                const i = Pf(new eh(0, 0, 0), this.map.transform.projection),
                  o = [
                    i.projection.project(
                      this.coordinates[0][0],
                      this.coordinates[0][1],
                    ),
                    i.projection.project(
                      this.coordinates[1][0],
                      this.coordinates[1][1],
                    ),
                    i.projection.project(
                      this.coordinates[2][0],
                      this.coordinates[2][1],
                    ),
                    i.projection.project(
                      this.coordinates[3][0],
                      this.coordinates[3][1],
                    ),
                  ];
                if (
                  !(function (H) {
                    const J = H[1].x - H[0].x,
                      Q = H[1].y - H[0].y,
                      V = H[2].x - H[1].x,
                      X = H[2].y - H[1].y,
                      ee = H[3].x - H[2].x,
                      re = H[3].y - H[2].y,
                      ve = H[0].x - H[3].x,
                      ge = H[0].y - H[3].y,
                      be = J * X - V * Q,
                      Me = V * re - ee * X,
                      Ue = ee * ge - ve * re,
                      it = ve * Q - J * ge;
                    return (
                      (be > 0 && Me > 0 && Ue > 0 && it > 0) ||
                      (be < 0 && Me < 0 && Ue < 0 && it < 0)
                    );
                  })(o)
                )
                  return (
                    console.warn(
                      "Image source coordinates are defining non-convex area in the Mercator projection",
                    ),
                    void (this._unsupportedCoords = !0)
                  );
                const a = Pf(this.tileID, this.map.transform.projection),
                  [u, d, _, v] = this.coordinates.map((H) => {
                    const J = a.projection.project(H[0], H[1]);
                    return Nb(a, J)._round();
                  });
                this.perspectiveTransform = Jb(
                  u.x,
                  u.y,
                  d.x,
                  d.y,
                  _.x,
                  _.y,
                  v.x,
                  v.y,
                );
                const b = (this._boundsArray = new Il());
                (b.emplaceBack(u.x, u.y, 0, 0),
                  b.emplaceBack(d.x, d.y, mt, 0),
                  b.emplaceBack(v.x, v.y, 0, mt),
                  b.emplaceBack(_.x, _.y, mt, mt),
                  this.boundsBuffer &&
                    (this.boundsBuffer.destroy(),
                    this.elevatedGlobeVertexBuffer &&
                      this.elevatedGlobeVertexBuffer.destroy(),
                    this.elevatedGlobeIndexBuffer &&
                      this.elevatedGlobeIndexBuffer.destroy()),
                  (this.boundsBuffer = e.createVertexBuffer(b, By.members)),
                  (this.boundsSegments = Rn.simpleSegment(0, 0, 4, 2)));
                const E = [],
                  A = [
                    og((M = this.coordinates)[0]),
                    og(M[1]),
                    og(M[2]),
                    og(M[3]),
                  ];
                var M;
                const [R, k, N, j] = (function (H) {
                  let J = H[0][0],
                    Q = J,
                    V = H[0][1],
                    X = V;
                  for (let ee = 1; ee < H.length; ee++)
                    (H[ee][0] < J
                      ? (J = H[ee][0])
                      : H[ee][0] > Q && (Q = H[ee][0]),
                      H[ee][1] < V
                        ? (V = H[ee][1])
                        : H[ee][1] > X && (X = H[ee][1]));
                  return [J, V, Q - J, X - V];
                })(A);
                {
                  const H = new Il(),
                    [J, Q, V, X] = (function (Ge) {
                      let Je = Ge[0].x,
                        Ne = Je,
                        je = Ge[0].y,
                        at = je;
                      for (let ct = 1; ct < Ge.length; ct++)
                        (Ge[ct].x < Je
                          ? (Je = Ge[ct].x)
                          : Ge[ct].x > Ne && (Ne = Ge[ct].x),
                          Ge[ct].y < je
                            ? (je = Ge[ct].y)
                            : Ge[ct].y > at && (at = Ge[ct].y));
                      return [Je, je, Ne - Je, at - je];
                    })(o),
                    ee = (Ge) => [(Ge.x - J) / V, (Ge.y - Q) / X],
                    [re, ve, ge, be] = o.map(ee),
                    Me = (function (Ge, Je, Ne, je, at, ct, Nt, Ct) {
                      const yt = sg(0, 0, 1, 0, 1, 1, 0, 1);
                      return de(
                        yt,
                        yt,
                        fe([], sg(Ge, Je, Ne, je, at, ct, Nt, Ct)),
                      );
                    })(re[0], re[1], ve[0], ve[1], ge[0], ge[1], be[0], be[1]);
                  this.elevatedGlobePerspectiveTransform = Jb(
                    re[0],
                    re[1],
                    ve[0],
                    ve[1],
                    ge[0],
                    ge[1],
                    be[0],
                    be[1],
                  );
                  const Ue = (Ge, Je) => {
                      E.push(Ge.lng);
                      const Ne = Math.round(((Ge.lng - R) / N) * mt),
                        je = Math.round(((Ge.lat - k) / j) * mt),
                        at = ee(Je),
                        ct = Za([], [at[0], at[1], 1], Me),
                        Nt = Math.round((ct[0] / ct[2]) * mt),
                        Ct = Math.round((ct[1] / ct[2]) * mt);
                      H.emplaceBack(Ne, je, Nt, Ct);
                    },
                    it = o[3].x - o[0].x,
                    Xe = o[3].y - o[0].y,
                    tt = o[2].x - o[1].x,
                    nt = o[2].y - o[1].y;
                  for (let Ge = 0; Ge < 65; Ge++) {
                    const Je = Ge / 64,
                      Ne = [o[0].x + Je * it, o[0].y + Je * Xe],
                      je = [o[1].x + Je * tt, o[1].y + Je * nt],
                      at = je[0] - Ne[0],
                      ct = je[1] - Ne[1];
                    for (let Nt = 0; Nt < 65; Nt++) {
                      const Ct = Nt / 64,
                        yt = { x: Ne[0] + at * Ct, y: Ne[1] + ct * Ct };
                      Ue(i.projection.unproject(yt.x, yt.y), yt);
                    }
                  }
                  this.elevatedGlobeVertexBuffer = e.createVertexBuffer(
                    H,
                    By.members,
                  );
                }
                {
                  this.maxLongitudeTriangleSize = 0;
                  let H = [],
                    J = new dr();
                  const Q = (V, X, ee) => {
                    J.emplaceBack(V, X, ee);
                    const re = E[V],
                      ve = E[X],
                      ge = E[ee],
                      be = Math.min(Math.min(re, ve), ge),
                      Me = Math.max(Math.max(re, ve), ge) - be;
                    (Me > this.maxLongitudeTriangleSize &&
                      (this.maxLongitudeTriangleSize = Me),
                      H.push(be + Me / 2));
                  };
                  for (let V = 0; V < 64; V++)
                    for (let X = 0; X < 64; X++) {
                      const ee = 65 * V + X,
                        re = ee + 1,
                        ve = ee + 65,
                        ge = ve + 1;
                      (Q(ee, ve, re), Q(re, ve, ge));
                    }
                  (([H, J] = (function (V, X) {
                    const ee = Array.from({ length: V.length }, (ge, be) => be);
                    ee.sort((ge, be) => V[ge] - V[be]);
                    const re = [],
                      ve = new dr();
                    for (let ge = 0; ge < ee.length; ge++) {
                      const be = ee[ge];
                      re.push(V[be]);
                      const Me = 3 * be,
                        Ue = Me + 1;
                      ve.emplaceBack(
                        X.uint16[Me],
                        X.uint16[Ue],
                        X.uint16[Ue + 1],
                      );
                    }
                    return [re, ve];
                  })(H, J)),
                    (this.elevatedGlobeTrianglesCenterLongitudes = H),
                    (this.elevatedGlobeIndexBuffer = e.createIndexBuffer(J)));
                }
                ((this.elevatedGlobeSegments = Rn.simpleSegment(
                  0,
                  0,
                  4225,
                  8192,
                )),
                  (this.elevatedGlobeGridMatrix = new Float32Array([
                    0,
                    N / mt,
                    0,
                    j / mt,
                    0,
                    0,
                    k,
                    R,
                    0,
                  ])));
              }
              prepare() {
                const e = Object.keys(this.tiles).length !== 0;
                if (this.tileID && !e) return;
                const i = this.map.painter.context,
                  o = i.gl;
                (!this._dirty ||
                  this.texture instanceof rg ||
                  (this.texture
                    ? this.texture.update(this.image)
                    : ((this.texture = new Uy(i, this.image, o.RGBA8)),
                      this.texture.bind(o.LINEAR, o.CLAMP_TO_EDGE)),
                  (this._dirty = !1)),
                  e && this._prepareData(i));
              }
              loadTile(e, i) {
                this.tileID && this.tileID.equals(e.tileID.canonical)
                  ? ((this.tiles[String(e.tileID.wrap)] = e),
                    (e.buckets = {}),
                    i(null))
                  : ((e.state = "errored"), i(null));
              }
              serialize() {
                return {
                  type: "image",
                  url: this.options.url,
                  coordinates: this.coordinates,
                };
              }
              hasTransition() {
                return !1;
              }
              getSegmentsForLongitude(e) {
                const i = this.elevatedGlobeSegments;
                if (!this.elevatedGlobeTrianglesCenterLongitudes || !i)
                  return null;
                const o = this.elevatedGlobeTrianglesCenterLongitudes;
                let a = (u = e + 180) + 360 * Math.round((o[0] - u) / 360);
                var u;
                const d = new Rn(),
                  _ = (A, M) => {
                    d.segments.push({
                      vertexOffset: 0,
                      primitiveOffset: A,
                      vertexLength: i.segments[0].vertexLength,
                      primitiveLength: M,
                      sortKey: void 0,
                      vaos: {},
                    });
                  },
                  v = 0.51 * this.maxLongitudeTriangleSize;
                if (Math.abs(o[0] - a) <= v) {
                  const A = ar(o, 0, o.length, a + v);
                  return (
                    A === o.length ||
                      _(A, Tn(o, A + 1, o.length, a + 360 - v) - A),
                    d
                  );
                }
                a < o[0] && (a += 360);
                const b = Tn(o, 0, o.length, a - v);
                if (b === o.length) return (_(0, o.length), d);
                _(0, b - 0);
                const E = ar(o, b + 1, o.length, a + v);
                return (E !== o.length && _(E, o.length - E), d);
              }
            }
            const iI = (Math.pow(256, 2) - 1) / 16907520;
            class e1 extends Ir {
              constructor(e, i, o, a) {
                (super(
                  e,
                  {
                    layout:
                      Yb ||
                      (Yb = new Cn({
                        visibility: new st(Pe.layout_raster.visibility),
                      })),
                    paint:
                      Kb ||
                      (Kb = new Cn({
                        "raster-opacity": new st(
                          Pe.paint_raster["raster-opacity"],
                        ),
                        "raster-color": new Ra(Pe.paint_raster["raster-color"]),
                        "raster-color-mix": new st(
                          Pe.paint_raster["raster-color-mix"],
                        ),
                        "raster-color-range": new st(
                          Pe.paint_raster["raster-color-range"],
                        ),
                        "raster-hue-rotate": new st(
                          Pe.paint_raster["raster-hue-rotate"],
                        ),
                        "raster-brightness-min": new st(
                          Pe.paint_raster["raster-brightness-min"],
                        ),
                        "raster-brightness-max": new st(
                          Pe.paint_raster["raster-brightness-max"],
                        ),
                        "raster-saturation": new st(
                          Pe.paint_raster["raster-saturation"],
                        ),
                        "raster-contrast": new st(
                          Pe.paint_raster["raster-contrast"],
                        ),
                        "raster-resampling": new st(
                          Pe.paint_raster["raster-resampling"],
                        ),
                        "raster-fade-duration": new st(
                          Pe.paint_raster["raster-fade-duration"],
                        ),
                        "raster-emissive-strength": new st(
                          Pe.paint_raster["raster-emissive-strength"],
                        ),
                        "raster-array-band": new st(
                          Pe.paint_raster["raster-array-band"],
                        ),
                        "raster-elevation": new st(
                          Pe.paint_raster["raster-elevation"],
                        ),
                        "raster-color-use-theme": new vt({
                          type: "string",
                          default: "default",
                          "property-type": "data-driven",
                        }),
                      })),
                  },
                  i,
                  o,
                  a,
                ),
                  this.updateColorRamp(),
                  (this._curRampRange = [NaN, NaN]));
              }
              getProgramIds() {
                return ["raster"];
              }
              hasColorMap() {
                return !!this._transitionablePaint._values["raster-color"].value
                  .value;
              }
              tileCoverLift() {
                return this.paint.get("raster-elevation");
              }
              isDraped(e) {
                return (
                  !(
                    e &&
                    e._source instanceof Qb &&
                    (e._source.onNorthPole || e._source.onSouthPole)
                  ) && this.paint.get("raster-elevation") === 0
                );
              }
              _handleSpecialPaintPropertyUpdate(e) {
                (e !== "raster-color" && e !== "raster-color-range") ||
                  ((this._curRampRange = [NaN, NaN]), this.updateColorRamp());
              }
              updateColorRamp(e) {
                if (!this.hasColorMap() || !this._curRampRange) return;
                const i =
                    this._transitionablePaint._values["raster-color"].value
                      .expression,
                  [o, a] = e ||
                    this._transitionablePaint._values[
                      "raster-color-range"
                    ].value.expression.evaluate({ zoom: 0 }) || [NaN, NaN];
                (isNaN(o) && isNaN(a)) ||
                  (o === this._curRampRange[0] &&
                    a === this._curRampRange[1]) ||
                  ((this.colorRamp = hf({
                    expression: i,
                    evaluationKey: "rasterValue",
                    image: this.colorRamp,
                    clips: [{ start: o, end: a }],
                    resolution: 256,
                  })),
                  (this.colorRampTexture = null),
                  (this._curRampRange = [o, a]));
              }
            }
            let t1, i1, n1, r1, s1;
            class o1 extends Ir {
              constructor(e, i, o, a) {
                (super(
                  e,
                  {
                    layout:
                      t1 ||
                      (t1 = new Cn({
                        visibility: new st(
                          Pe["layout_raster-particle"].visibility,
                        ),
                      })),
                    paint:
                      i1 ||
                      (i1 = new Cn({
                        "raster-particle-array-band": new st(
                          Pe["paint_raster-particle"][
                            "raster-particle-array-band"
                          ],
                        ),
                        "raster-particle-count": new st(
                          Pe["paint_raster-particle"]["raster-particle-count"],
                        ),
                        "raster-particle-color": new Ra(
                          Pe["paint_raster-particle"]["raster-particle-color"],
                        ),
                        "raster-particle-max-speed": new st(
                          Pe["paint_raster-particle"][
                            "raster-particle-max-speed"
                          ],
                        ),
                        "raster-particle-speed-factor": new st(
                          Pe["paint_raster-particle"][
                            "raster-particle-speed-factor"
                          ],
                        ),
                        "raster-particle-fade-opacity-factor": new st(
                          Pe["paint_raster-particle"][
                            "raster-particle-fade-opacity-factor"
                          ],
                        ),
                        "raster-particle-reset-rate-factor": new st(
                          Pe["paint_raster-particle"][
                            "raster-particle-reset-rate-factor"
                          ],
                        ),
                        "raster-particle-elevation": new st(
                          Pe["paint_raster-particle"][
                            "raster-particle-elevation"
                          ],
                        ),
                        "raster-particle-color-use-theme": new vt({
                          type: "string",
                          default: "default",
                          "property-type": "data-driven",
                        }),
                      })),
                  },
                  i,
                  o,
                  a,
                ),
                  this._updateColorRamp(),
                  (this.lastInvalidatedAt = As.now()));
              }
              onRemove(e) {
                (this.colorRampTexture && this.colorRampTexture.destroy(),
                  this.tileFramebuffer && this.tileFramebuffer.destroy(),
                  this.particleFramebuffer &&
                    this.particleFramebuffer.destroy());
              }
              hasColorMap() {
                return !!this._transitionablePaint._values[
                  "raster-particle-color"
                ].value.value;
              }
              getProgramIds() {
                return ["rasterParticle"];
              }
              hasOffscreenPass() {
                return this.visibility !== "none";
              }
              isDraped(e) {
                return !1;
              }
              _handleSpecialPaintPropertyUpdate(e) {
                ((e !== "raster-particle-color" &&
                  e !== "raster-particle-max-speed") ||
                  (this._updateColorRamp(), this._invalidateAnimationState()),
                  e === "raster-particle-count" &&
                    this._invalidateAnimationState());
              }
              _updateColorRamp() {
                if (!this.hasColorMap()) return;
                const e =
                    this._transitionablePaint._values["raster-particle-color"]
                      .value.expression,
                  i = this._transitionablePaint._values[
                    "raster-particle-max-speed"
                  ].value.expression.evaluate({ zoom: 0 });
                ((this.colorRamp = hf({
                  expression: e,
                  evaluationKey: "rasterParticleSpeed",
                  image: this.colorRamp,
                  clips: [{ start: 0, end: i }],
                  resolution: 256,
                })),
                  (this.colorRampTexture = null));
              }
              _invalidateAnimationState() {
                this.lastInvalidatedAt = As.now();
              }
              tileCoverLift() {
                return this.paint.get("raster-particle-elevation");
              }
            }
            class nI extends Ir {
              constructor(e, i) {
                (super(e, {}, i, null),
                  (this.implementation = e),
                  e.slot && (this.slot = e.slot));
              }
              is3D(e) {
                return this.implementation.renderingMode === "3d";
              }
              hasOffscreenPass() {
                return this.implementation.prerender !== void 0;
              }
              isDraped(e) {
                return this.implementation.renderToTile !== void 0;
              }
              shouldRedrape() {
                return (
                  !!this.implementation.shouldRerenderTiles &&
                  this.implementation.shouldRerenderTiles()
                );
              }
              recalculate() {}
              updateTransitions() {}
              hasTransition() {
                return !1;
              }
              serialize() {}
              onAdd(e) {
                this.implementation.onAdd &&
                  this.implementation.onAdd(e, e.painter.context.gl);
              }
              onRemove(e) {
                this.implementation.onRemove &&
                  this.implementation.onRemove(e, e.painter.context.gl);
              }
            }
            function jy(n, e, i) {
              const o = [0, 0, 1],
                a = So([]);
              return (
                Io(a, a, i ? -Mi(n) + Math.PI : Mi(n)),
                Eo(a, a, -Mi(e)),
                Qs(o, o, a),
                tn(o, o)
              );
            }
            function a1(n, e) {
              const i = ag(n.projection, n.zoom, n.width, n.height),
                o = (function (u, d, _, v, b) {
                  const E = new Y(_.lng - 180 * jl, _.lat),
                    A = new Y(_.lng + 180 * jl, _.lat),
                    M = u.project(E.lng, E.lat),
                    R = u.project(A.lng, A.lat),
                    k = -Math.atan2(R.y - M.y, R.x - M.x),
                    N = Te.fromLngLat(_);
                  N.y = he(N.y, -1 + jl, 1 - jl);
                  const j = N.toLngLat(),
                    H = u.project(j.lng, j.lat),
                    J = Te.fromLngLat(j);
                  J.x += jl;
                  const Q = J.toLngLat(),
                    V = u.project(Q.lng, Q.lat),
                    X = c1(V.x - H.x, V.y - H.y, k),
                    ee = Te.fromLngLat(j);
                  ee.y += jl;
                  const re = ee.toLngLat(),
                    ve = u.project(re.lng, re.lat),
                    ge = c1(ve.x - H.x, ve.y - H.y, k),
                    be = Math.abs(X.x) / Math.abs(ge.y),
                    Me = xe([]);
                  pt(Me, Me, -k * (1 - (b ? 0 : v)));
                  const Ue = xe([]);
                  return (
                    gt(Ue, Ue, [1, 1 - (1 - be) * v, 1]),
                    (Ue[4] = (-ge.x / ge.y) * v),
                    pt(Ue, Ue, k),
                    Ae(Ue, Me, Ue),
                    Ue
                  );
                })(n.projection, 0, n.center, i, e),
                a = l1(n);
              return (gt(o, o, [a, a, 1]), o);
            }
            function l1(n) {
              const e = n.projection,
                i = ag(n.projection, n.zoom, n.width, n.height),
                o = Gy(e, n.center),
                a = Gy(e, Y.convert(e.center));
              return Math.pow(2, o * i + (1 - i) * a);
            }
            function ag(n, e, i, o, a = 1 / 0) {
              const u = n.range;
              if (!u) return 0;
              const d = Math.min(a, Math.max(i, o)),
                _ = Math.log(d / 1024) / Math.LN2;
              return Se(u[0] + _, u[1] + _, e);
            }
            const jl = 1 / 4e4;
            function Gy(n, e) {
              const i = he(e.lat, -85.051129, He),
                o = new Y(e.lng - 180 * jl, i),
                a = new Y(e.lng + 180 * jl, i),
                u = n.project(o.lng, i),
                d = n.project(a.lng, i),
                _ = Te.fromLngLat(o),
                v = Te.fromLngLat(a),
                b = d.x - u.x,
                E = d.y - u.y,
                A = v.x - _.x,
                M = v.y - _.y,
                R = Math.sqrt((A * A + M * M) / (b * b + E * E));
              return Math.log(R) / Math.LN2;
            }
            function c1(n, e, i) {
              const o = Math.cos(i),
                a = Math.sin(i);
              return { x: n * o - e * a, y: n * a + e * o };
            }
            function h1(n, e, i) {
              (xe(n),
                pt(n, n, Mi(e[2])),
                Rt(n, n, Mi(e[0])),
                Mt(n, n, Mi(e[1])),
                gt(n, n, i),
                Ae(n, n, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]));
            }
            function lg(n, e, i, o, a, u, d, _) {
              const v = [i[0] - e[0], i[1] - e[1], 0],
                b = [o[0] - e[0], o[1] - e[1], 0];
              if (Ri(v) < 1e-12 || Ri(b) < 1e-12) return So(n);
              const E = nr([], v, b);
              (tn(E, E),
                Ii(b, o, e),
                (v[2] = (u - a) * _),
                (b[2] = (d - a) * _));
              const A = v;
              return (nr(A, v, b), tn(A, A), Ja(n, E, A));
            }
            function $y(n, e, i = !1) {
              const o = Fl(e.zoom),
                a = (function (u, d, _) {
                  const v = d.worldSize,
                    b = [u[12], u[13], u[14]],
                    E = De(b[1] / v),
                    A = _e(b[0] / v),
                    M = xe([]),
                    R = me(1, E) * v,
                    k = me(1, 0) * v * et(E, d.zoom),
                    N = 1 / K_(v);
                  let j = k * N;
                  if (_) {
                    const V = ag(d.projection, d.zoom, d.width, d.height, 1024);
                    j =
                      N * d.projection.pixelSpaceConversion(d.center.lat, v, V);
                  }
                  const H = U(E, A);
                  ei(H, H, Vi([], tn([], H), R * j * b[2]));
                  const J = (function (V) {
                    const X = [V[0], V[1], V[2]];
                    let ee = [0, 1, 0];
                    const re = nr([], ee, X);
                    return (
                      nr(ee, X, re),
                      fs(ee) === 0 && ((ee = [0, 1, 0]), nr(re, X, ee)),
                      tn(re, re),
                      tn(ee, ee),
                      tn(X, X),
                      [
                        re[0],
                        re[1],
                        re[2],
                        0,
                        ee[0],
                        ee[1],
                        ee[2],
                        0,
                        X[0],
                        X[1],
                        X[2],
                        0,
                        V[0],
                        V[1],
                        V[2],
                        1,
                      ]
                    );
                  })(H);
                  (gt(M, M, [j, j, j * R]), Qe(M, M, [-b[0], -b[1], -b[2]]));
                  const Q = Ae([], d.globeMatrix, J);
                  return (Ae(Q, Q, M), Ae(Q, Q, u), Q);
                })(n, e, i);
              if (o > 0) {
                const u = (function (d, _) {
                  const v = _.worldSize,
                    b = (me(1, 0) * v * et(_.center.lat, _.zoom)) / K_(v),
                    E = me(1, _.center.lat) * v,
                    A = xe([]);
                  return (
                    Mt(A, A, Mi(_.center.lng)),
                    Rt(A, A, Mi(_.center.lat)),
                    Qe(A, A, [0, 0, x]),
                    gt(A, A, [b, b, b * E]),
                    Qe(A, A, [_.point.x - 0.5 * v, _.point.y - 0.5 * v, 0]),
                    Ae(A, A, d),
                    Ae(A, _.globeMatrix, A)
                  );
                })(n, e);
                return (function (d, _, v) {
                  const b = (k, N, j) => {
                      const H = Ri(k),
                        J = Ri(N),
                        Q = Oa(k, N, j);
                      return Vi(Q, Q, (1 / Ri(Q)) * Ht(H, J, j));
                    },
                    E = b([d[0], d[1], d[2]], [_[0], _[1], _[2]], v),
                    A = b([d[4], d[5], d[6]], [_[4], _[5], _[6]], v),
                    M = b([d[8], d[9], d[10]], [_[8], _[9], _[10]], v),
                    R = Oa([d[12], d[13], d[14]], [_[12], _[13], _[14]], v);
                  return [
                    E[0],
                    E[1],
                    E[2],
                    0,
                    A[0],
                    A[1],
                    A[2],
                    0,
                    M[0],
                    M[1],
                    M[2],
                    0,
                    R[0],
                    R[1],
                    R[2],
                    1,
                  ];
                })(a, u, o);
              }
              return a;
            }
            function u1(n, e, i, o) {
              const a = Ci.projectAabbCorners(o, i);
              let u = Number.MAX_VALUE,
                d = -1;
              for (let b = 0; b < a.length; ++b) {
                const E = a[b];
                ((E[0] = (0.5 * E[0] + 0.5) * e.width),
                  (E[1] = (0.5 - 0.5 * E[1]) * e.height),
                  E[2] < u && ((d = b), (u = E[2])));
              }
              const _ = (b) => new ft(a[b][0], a[b][1]);
              let v;
              switch (d) {
                case 0:
                case 6:
                  v = [_(1), _(5), _(4), _(7), _(3), _(2), _(1)];
                  break;
                case 1:
                case 7:
                  v = [_(0), _(4), _(5), _(6), _(2), _(3), _(0)];
                  break;
                case 3:
                case 5:
                  v = [_(1), _(0), _(4), _(7), _(6), _(2), _(1)];
                  break;
                default:
                  v = [_(1), _(5), _(6), _(7), _(3), _(0), _(1)];
              }
              if (Hr(n, v)) return u;
            }
            const rI = Ai([
                { name: "a_pos_3f", components: 3, type: "Float32" },
              ]),
              sI = Ai([{ name: "a_color_3f", components: 3, type: "Float32" }]),
              oI = Ai([{ name: "a_color_4f", components: 4, type: "Float32" }]),
              aI = Ai([{ name: "a_uv_2f", components: 2, type: "Float32" }]),
              lI = Ai([
                { name: "a_normal_3f", components: 3, type: "Float32" },
              ]),
              cI = Ai([
                { name: "a_normal_matrix0", components: 4, type: "Float32" },
                { name: "a_normal_matrix1", components: 4, type: "Float32" },
                { name: "a_normal_matrix2", components: 4, type: "Float32" },
                { name: "a_normal_matrix3", components: 4, type: "Float32" },
              ]),
              hI = Ai([
                { name: "a_pbr", components: 4, type: "Uint16" },
                {
                  name: "a_heightBasedEmissiveStrength",
                  components: 3,
                  type: "Float32",
                },
              ]),
              d1 = { None: 0, Model: 1, Symbol: 2, FillExtrusion: 4 };
            class cg {
              constructor(e, i, o, a) {
                ((this.message = (e ? `${e}: ` : "") + o),
                  a && (this.identifier = a),
                  i != null && i.__line__ && (this.line = i.__line__));
              }
            }
            function Hy(n, e) {
              const i = n.indexOf("://") === -1;
              try {
                return (new URL(n, i && e ? "http://example.com" : void 0), !0);
              } catch {
                return !1;
              }
            }
            class f1 {
              constructor(e, i) {
                ((this.feature = e),
                  (this.instancedDataOffset = i),
                  (this.instancedDataCount = 0),
                  (this.rotation = [0, 0, 0]),
                  (this.scale = [1, 1, 1]),
                  (this.translation = [0, 0, 0]));
              }
            }
            class p1 {
              constructor() {
                ((this.instancedDataArray = new Dl()),
                  (this.instancesEvaluatedElevation = []),
                  (this.features = []),
                  (this.idToFeaturesIndex = {}));
              }
            }
            class Wy {
              constructor(e) {
                ((this.zoom = e.zoom),
                  (this.canonical = e.canonical),
                  (this.layers = e.layers),
                  (this.layerIds = this.layers.map((i) => i.fqid)),
                  (this.projection = e.projection),
                  (this.index = e.index),
                  (this.worldview = e.worldview),
                  (this.hasZoomDependentProperties =
                    this.layers[0].isZoomDependent()),
                  (this.stateDependentLayerIds = this.layers
                    .filter((i) => i.isStateDependent())
                    .map((i) => i.id)),
                  (this.hasPattern = !1),
                  (this.instancesPerModel = {}),
                  (this.validForExaggeration = 0),
                  (this.maxVerticalOffset = 0),
                  (this.maxScale = 0),
                  (this.maxHeight = 0),
                  (this.lookupDim =
                    this.zoom > this.canonical.z
                      ? 256
                      : this.zoom > 15
                        ? 75
                        : 100),
                  (this.instanceCount = 0),
                  (this.terrainElevationMin = 0),
                  (this.terrainElevationMax = 0),
                  (this.validForDEMTile = { id: null, timestamp: 0 }),
                  (this.modelUris = []),
                  (this.modelsRequested = !1),
                  (this.activeReplacements = []),
                  (this.replacementUpdateTime = 0),
                  (this.styleDefinedModelURLs = e.styleDefinedModelURLs));
              }
              updateFootprints(e, i) {}
              populate(e, i, o, a) {
                this.tileToMeter = Ve(o);
                const u = this.layers[0]._featureFilter.needGeometry;
                this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
                for (const {
                  feature: d,
                  id: _,
                  index: v,
                  sourceLayerIndex: b,
                } of e) {
                  const E =
                      _ ??
                      (d.properties && d.properties.hasOwnProperty("id")
                        ? d.properties.id
                        : void 0),
                    A = bt(d, u);
                  if (
                    !this.layers[0]._featureFilter.filter(
                      new qi(this.zoom, { worldview: this.worldview }),
                      A,
                      o,
                    )
                  )
                    continue;
                  const M = {
                      id: E,
                      sourceLayerIndex: b,
                      index: v,
                      geometry: u ? A.geometry : Et(d, o, a),
                      properties: d.properties,
                      type: d.type,
                      patterns: {},
                    },
                    R = this.addFeature(M, M.geometry, A);
                  R &&
                    i.featureIndex.insert(
                      d,
                      M.geometry,
                      v,
                      b,
                      this.index,
                      this.instancesPerModel[R].instancedDataArray.length,
                      mt / 32,
                    );
                }
                this.lookup = null;
              }
              update(e, i, o, a) {
                for (const u in this.instancesPerModel) {
                  const d = this.instancesPerModel[u];
                  for (const _ in e)
                    d.idToFeaturesIndex.hasOwnProperty(_) &&
                      (this.evaluate(
                        d.features[d.idToFeaturesIndex[_]],
                        e[_],
                        d,
                        !0,
                      ),
                      (this.uploaded = !1));
                }
                this.maxHeight = 0;
              }
              updateZoomBasedPaintProperties() {
                if (!this.hasZoomDependentProperties) return !1;
                let e = !1;
                for (const i in this.instancesPerModel) {
                  const o = this.instancesPerModel[i];
                  for (const a of o.features) {
                    const u = this.layers[0],
                      d = a.feature,
                      _ = this.canonical,
                      v = u.paint.get("model-rotation").evaluate(d, {}, _),
                      b = u.paint.get("model-scale").evaluate(d, {}, _),
                      E = u.paint.get("model-translation").evaluate(d, {}, _);
                    (Is(a.rotation, v) &&
                      Is(a.scale, b) &&
                      Is(a.translation, E)) ||
                      (this.evaluate(a, a.featureStates, o, !0), (e = !0));
                  }
                }
                return e;
              }
              updateReplacement(e, i, o, a) {
                if (i.updateTime === this.replacementUpdateTime) return !1;
                this.replacementUpdateTime = i.updateTime;
                const u = i.getReplacementRegionsForTile(e.toUnwrapped(), !0);
                if (cy(this.activeReplacements, u)) return !1;
                this.activeReplacements = u;
                let d = !1;
                for (const _ in this.instancesPerModel) {
                  const v = this.instancesPerModel[_],
                    b = v.instancedDataArray;
                  for (const E of v.features) {
                    const A = E.instancedDataOffset,
                      M = E.instancedDataCount;
                    for (let R = 0; R < M; R++) {
                      const k = 16 * (R + A);
                      let N = b.float32[k + 0];
                      const j = N > mt;
                      N = j ? N - mt : N;
                      const H = Math.floor(N),
                        J = b.float32[k + 1];
                      let Q = !1;
                      for (const V of this.activeReplacements)
                        if (
                          !o0(V, o, d1.Model, a) &&
                          !(
                            V.min.x > H ||
                            H > V.max.x ||
                            V.min.y > J ||
                            J > V.max.y
                          ) &&
                          ((Q = d0(
                            u0(H, J, e.canonical, V.footprintTileId.canonical),
                            V.footprint,
                          )),
                          Q)
                        )
                          break;
                      ((b.float32[k] = Q ? N + mt : N), (d = d || Q !== j));
                    }
                  }
                }
                return d;
              }
              isEmpty() {
                for (const e in this.instancesPerModel)
                  if (this.instancesPerModel[e].instancedDataArray.length !== 0)
                    return !1;
                return !0;
              }
              uploadPending() {
                return !this.uploaded;
              }
              upload(e) {
                if (!this.uploaded)
                  for (const i in this.instancesPerModel) {
                    const o = this.instancesPerModel[i];
                    o.instancedDataArray.length < 0 ||
                      o.instancedDataArray.length === 0 ||
                      (o.instancedDataBuffer
                        ? o.instancedDataBuffer.updateData(o.instancedDataArray)
                        : (o.instancedDataBuffer = e.createVertexBuffer(
                            o.instancedDataArray,
                            cI.members,
                            !0,
                            void 0,
                            this.instanceCount,
                          )));
                  }
                this.uploaded = !0;
              }
              destroy() {
                for (const i in this.instancesPerModel) {
                  const o = this.instancesPerModel[i];
                  o.instancedDataArray.length !== 0 &&
                    o.instancedDataBuffer &&
                    o.instancedDataBuffer.destroy();
                }
                const e = this.layers[0].modelManager;
                if (e && this.modelUris && this.modelsRequested)
                  for (const i of this.modelUris) e.removeModel(i, "", !0);
              }
              addFeature(e, i, o) {
                const a = this.layers[0],
                  u = a.layout.get("model-id").evaluate(o, {}, this.canonical);
                if (!u)
                  return (
                    ri(
                      `modelId is not evaluated for layer ${a.id} and it is not going to get rendered.`,
                    ),
                    u
                  );
                ((Hy(u, !1) || this.styleDefinedModelURLs[u] !== void 0) &&
                  (this.modelUris.includes(u) || this.modelUris.push(u)),
                  this.instancesPerModel[u] ||
                    (this.instancesPerModel[u] = new p1()));
                const d = this.instancesPerModel[u],
                  _ = d.instancedDataArray,
                  v = new f1(o, _.length);
                for (const b of i)
                  for (const E of b) {
                    if (E.x < 0 || E.x >= mt || E.y < 0 || E.y >= mt) continue;
                    const A = (this.lookupDim - 1) / mt,
                      M = (this.lookupDim * ((E.y * A) | 0) + E.x * A) | 0;
                    if (this.lookup) {
                      if (this.lookup[M] !== 0) continue;
                      this.lookup[M] = 1;
                    }
                    this.instanceCount++;
                    const R = _.length;
                    (_.resize(R + 1),
                      d.instancesEvaluatedElevation.push(0),
                      (_.float32[16 * R] = E.x),
                      (_.float32[16 * R + 1] = E.y));
                  }
                return (
                  (v.instancedDataCount =
                    d.instancedDataArray.length - v.instancedDataOffset),
                  v.instancedDataCount > 0 &&
                    (e.id && (d.idToFeaturesIndex[e.id] = d.features.length),
                    d.features.push(v),
                    this.evaluate(v, {}, d, !1)),
                  u
                );
              }
              getModelUris() {
                return this.modelUris;
              }
              evaluate(e, i, o, a) {
                const u = this.layers[0],
                  d = e.feature,
                  _ = this.canonical,
                  v = (e.rotation = u.paint
                    .get("model-rotation")
                    .evaluate(d, i, _)),
                  b = (e.scale = u.paint.get("model-scale").evaluate(d, i, _)),
                  E = (e.translation = u.paint
                    .get("model-translation")
                    .evaluate(d, i, _)),
                  A = u.paint.get("model-color").evaluate(d, i, _);
                A.a = u.paint
                  .get("model-color-mix-intensity")
                  .evaluate(d, i, _);
                const M = [];
                (this.maxVerticalOffset < E[2] &&
                  (this.maxVerticalOffset = E[2]),
                  (this.maxScale = Math.max(
                    Math.max(this.maxScale, b[0]),
                    Math.max(b[1], b[2]),
                  )),
                  h1(M, v, b));
                const R = Math.round(100 * A.a) + A.b / 1.05;
                for (let k = 0; k < e.instancedDataCount; ++k) {
                  const N = e.instancedDataOffset + k,
                    j = 16 * N,
                    H = o.instancedDataArray.float32;
                  let J = 0;
                  a && (J = H[j + 6] - o.instancesEvaluatedElevation[N]);
                  const Q = 0 | H[j + 1];
                  ((H[j] = (0 | H[j]) + A.r / 1.05),
                    (H[j + 1] = Q + A.g / 1.05),
                    (H[j + 2] = R),
                    (H[j + 3] = 1 / (_.z > 10 ? this.tileToMeter : Ve(_, Q))),
                    (H[j + 4] = E[0]),
                    (H[j + 5] = E[1]),
                    (H[j + 6] = E[2] + J),
                    (H[j + 7] = M[0]),
                    (H[j + 8] = M[1]),
                    (H[j + 9] = M[2]),
                    (H[j + 10] = M[4]),
                    (H[j + 11] = M[5]),
                    (H[j + 12] = M[6]),
                    (H[j + 13] = M[8]),
                    (H[j + 14] = M[9]),
                    (H[j + 15] = M[10]),
                    (o.instancesEvaluatedElevation[N] = E[2]));
                }
              }
            }
            let m1, g1;
            (Tt(Wy, "ModelBucket", { omit: ["layers"] }),
              Tt(p1, "PerModelAttributes"),
              Tt(f1, "ModelFeature"));
            const ah = 64,
              Fu = {
                CoordinateSpaceTile: 1,
                HasMapboxMeshFeatures: 4,
                HasMeshoptCompression: 8,
              };
            function _1(n, e, i, o, a, u, d, _, v, b = !1) {
              const E = i.zoom,
                A = i.project(o),
                M = et(o.lat, E),
                R = 1 / M;
              (xe(n), Qe(n, n, [A.x + d[0] * R, A.y + d[1] * R, d[2]]));
              let k = 1,
                N = 1;
              const j = i.worldSize;
              if (b) {
                if (i.projection.name === "mercator") {
                  let V = 0;
                  i.elevation &&
                    (V = i.elevation.getAtPointOrZero(
                      new Te(A.x / j, A.y / j),
                      0,
                    ));
                  const X =
                    Cr([], [A.x, A.y, V, 1], i.projMatrix)[3] /
                    i.cameraToCenterDistance;
                  ((k = X), (N = X * et(i.center.lat, E)));
                } else if (i.projection.name === "globe") {
                  const V = $y(n, i),
                    X = [0, 0, 0, 1];
                  Cr(X, X, Ae([], i.projMatrix, V));
                  const ee = X[3] / i.cameraToCenterDistance,
                    re = Fl(E),
                    ve = i.projection.pixelsPerMeter(o.lat, j) * et(o.lat, E),
                    ge =
                      i.projection.pixelsPerMeter(i.center.lat, j) *
                      et(i.center.lat, E);
                  ((k = ee / Ht(ve, We(i.center.lat), re)),
                    (N = (ee * M) / ve),
                    (k *= ge),
                    (N *= ge));
                }
              } else k = R;
              gt(n, n, [k, k, N]);
              const H = [...n],
                J = e.orientation,
                Q = [];
              if (
                (h1(Q, [J[0] + a[0], J[1] + a[1], J[2] + a[2]], u),
                Ae(n, H, Q),
                _ && i.elevation)
              ) {
                let V = 0;
                const X = [];
                if (v && i.elevation) {
                  V = (function (re, ve, ge, be, Me) {
                    const Ue = ve.elevation;
                    if (!Ue) return 0;
                    const it = Ci.projectAabbCorners(ge, be),
                      Xe = me(1, Me.lat) * ve.worldSize,
                      tt = (function (ot, Jt) {
                        const At = [0, 0, 1],
                          Dt = [
                            { corners: [0, 1, 3, 2], dotProductWithUp: 0 },
                            { corners: [1, 5, 2, 6], dotProductWithUp: 0 },
                            { corners: [0, 4, 1, 5], dotProductWithUp: 0 },
                            { corners: [2, 6, 3, 7], dotProductWithUp: 0 },
                            { corners: [4, 7, 5, 6], dotProductWithUp: 0 },
                            { corners: [0, 3, 4, 7], dotProductWithUp: 0 },
                          ];
                        for (const Wt of Dt) {
                          const ni = ot[Wt.corners[0]],
                            ii = ot[Wt.corners[1]],
                            di = ot[Wt.corners[2]],
                            oi = [
                              ii[0] - ni[0],
                              ii[1] - ni[1],
                              Jt * (ii[2] - ni[2]),
                            ],
                            fi = nr(oi, oi, [
                              di[0] - ni[0],
                              di[1] - ni[1],
                              Jt * (di[2] - ni[2]),
                            ]);
                          (tn(fi, fi), (Wt.dotProductWithUp = wn(fi, At)));
                        }
                        return (
                          Dt.sort(
                            (Wt, ni) =>
                              Wt.dotProductWithUp - ni.dotProductWithUp,
                          ),
                          Dt[0].corners
                        );
                      })(it, Xe),
                      nt = it[tt[0]],
                      Ge = it[tt[1]],
                      Je = it[tt[2]],
                      Ne = it[tt[3]],
                      je = Ue.getAtPointOrZero(
                        new Te(nt[0] / ve.worldSize, nt[1] / ve.worldSize),
                        0,
                      ),
                      at = Ue.getAtPointOrZero(
                        new Te(Ge[0] / ve.worldSize, Ge[1] / ve.worldSize),
                        0,
                      ),
                      ct = Ue.getAtPointOrZero(
                        new Te(Je[0] / ve.worldSize, Je[1] / ve.worldSize),
                        0,
                      ),
                      Nt = Ue.getAtPointOrZero(
                        new Te(Ne[0] / ve.worldSize, Ne[1] / ve.worldSize),
                        0,
                      ),
                      Ct = (je + Nt) / 2,
                      yt = (at + ct) / 2;
                    return (
                      Ct > yt
                        ? at < ct
                          ? lg(re, Ge, Ne, nt, at, Nt, je, Xe)
                          : lg(re, Je, nt, Ne, ct, je, Nt, Xe)
                        : je < Nt
                          ? lg(re, nt, Ge, Je, je, at, ct, Xe)
                          : lg(re, Ne, Je, Ge, Nt, ct, at, Xe),
                      Math.max(Ct, yt)
                    );
                  })(X, i, e.aabb, n, o);
                  const ee = Ae([], Ot([], X), Q);
                  Ae(n, H, ee);
                } else
                  V = i.elevation.getAtPointOrZero(new Te(A.x / j, A.y / j), 0);
                V !== 0 && (n[14] += V);
              }
            }
            function Lf(n, e, i = !1) {
              n.uploaded ||
                ((n.gfxTexture = new Uy(e, n.image, i ? e.gl.R8 : e.gl.RGBA8, {
                  useMipmap: n.sampler.minFilter >= e.gl.NEAREST_MIPMAP_NEAREST,
                })),
                (n.uploaded = !0),
                (n.image = null));
            }
            function uI(n, e, i) {
              ((n.indexBuffer = e.createIndexBuffer(n.indexArray, !1, !0)),
                (n.vertexBuffer = e.createVertexBuffer(
                  n.vertexArray,
                  rI.members,
                  !1,
                  !0,
                )),
                n.normalArray &&
                  (n.normalBuffer = e.createVertexBuffer(
                    n.normalArray,
                    lI.members,
                    !1,
                    !0,
                  )),
                n.texcoordArray &&
                  (n.texcoordBuffer = e.createVertexBuffer(
                    n.texcoordArray,
                    aI.members,
                    !1,
                    !0,
                  )),
                n.colorArray &&
                  (n.colorBuffer = e.createVertexBuffer(
                    n.colorArray,
                    (n.colorArray.bytesPerElement === 12 ? sI : oI).members,
                    !1,
                    !0,
                  )),
                n.featureArray &&
                  (n.pbrBuffer = e.createVertexBuffer(
                    n.featureArray,
                    hI.members,
                    !0,
                  )),
                (n.segments = Rn.simpleSegment(
                  0,
                  0,
                  n.vertexArray.length,
                  n.indexArray.length,
                )));
              const o = n.material;
              (o.pbrMetallicRoughness.baseColorTexture &&
                Lf(o.pbrMetallicRoughness.baseColorTexture, e),
                o.pbrMetallicRoughness.metallicRoughnessTexture &&
                  Lf(o.pbrMetallicRoughness.metallicRoughnessTexture, e),
                o.normalTexture && Lf(o.normalTexture, e),
                o.occlusionTexture && Lf(o.occlusionTexture, e, i),
                o.emissionTexture && Lf(o.emissionTexture, e));
            }
            function qy(n, e, i) {
              if (n.meshes) for (const o of n.meshes) uI(o, e, i);
              if (n.children) for (const o of n.children) qy(o, e, i);
            }
            function hg(n) {
              if (n.meshes)
                for (const e of n.meshes)
                  (e.indexArray.destroy(),
                    e.vertexArray.destroy(),
                    e.colorArray && e.colorArray.destroy(),
                    e.normalArray && e.normalArray.destroy(),
                    e.texcoordArray && e.texcoordArray.destroy(),
                    e.featureArray && e.featureArray.destroy());
              if (n.children) for (const e of n.children) hg(e);
            }
            function Zy(n) {
              if (n.meshes)
                for (const i of n.meshes)
                  i.vertexBuffer &&
                    (i.vertexBuffer.destroy(),
                    i.indexBuffer.destroy(),
                    i.normalBuffer && i.normalBuffer.destroy(),
                    i.texcoordBuffer && i.texcoordBuffer.destroy(),
                    i.colorBuffer && i.colorBuffer.destroy(),
                    i.pbrBuffer && i.pbrBuffer.destroy(),
                    i.segments.destroy(),
                    i.material &&
                      ((e = i.material).pbrMetallicRoughness.baseColorTexture &&
                        e.pbrMetallicRoughness.baseColorTexture.gfxTexture &&
                        e.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(),
                      e.pbrMetallicRoughness.metallicRoughnessTexture &&
                        e.pbrMetallicRoughness.metallicRoughnessTexture
                          .gfxTexture &&
                        e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(),
                      e.normalTexture &&
                        e.normalTexture.gfxTexture &&
                        e.normalTexture.gfxTexture.destroy(),
                      e.emissionTexture &&
                        e.emissionTexture.gfxTexture &&
                        e.emissionTexture.gfxTexture.destroy(),
                      e.occlusionTexture &&
                        e.occlusionTexture.gfxTexture &&
                        e.occlusionTexture.gfxTexture.destroy()));
              var e;
              if (n.children) for (const i of n.children) Zy(i);
            }
            class Bu {
              constructor(e, i, o) {
                ((this._demTile = e),
                  (this._dem = this._demTile.dem),
                  (this._scale = i),
                  (this._offset = o));
              }
              static create(e, i, o) {
                const a = o || e.findDEMTileFor(i);
                if (!a || !a.dem) return;
                const u = a.dem,
                  d = a.tileID,
                  _ = 1 << (i.canonical.z - d.canonical.z);
                return new Bu(a, u.dim / mt / _, [
                  (i.canonical.x / _ - d.canonical.x) * u.dim,
                  (i.canonical.y / _ - d.canonical.y) * u.dim,
                ]);
              }
              tileCoordToPixel(e, i) {
                const o = i * this._scale + this._offset[1],
                  a = Math.floor(e * this._scale + this._offset[0]),
                  u = Math.floor(o);
                return new ft(a, u);
              }
              getElevationAt(e, i, o, a) {
                const u = e * this._scale + this._offset[0],
                  d = i * this._scale + this._offset[1],
                  _ = Math.floor(u),
                  v = Math.floor(d),
                  b = this._dem;
                return (
                  (a = !!a),
                  o
                    ? Ht(
                        Ht(b.get(_, v, a), b.get(_, v + 1, a), d - v),
                        Ht(b.get(_ + 1, v, a), b.get(_ + 1, v + 1, a), d - v),
                        u - _,
                      )
                    : b.get(_, v, a)
                );
              }
              getElevationAtPixel(e, i, o) {
                return this._dem.get(e, i, !!o);
              }
              getMeterToDEM(e) {
                return (
                  (1 << this._demTile.tileID.canonical.z) *
                  me(1, e) *
                  this._dem.stride
                );
              }
            }
            const Xy = new Float32Array(262144),
              lh = new Uint8Array(262144);
            function y1(n) {
              let e = 0;
              if (n.meshes)
                for (const i of n.meshes) e = Math.max(e, i.aabb.max[2]);
              if (n.children)
                for (const i of n.children) e = Math.max(e, y1(i));
              return e;
            }
            function x1(n, e, i) {
              if (n.meshes)
                for (const o of n.meshes) {
                  if (o.aabb.min[0] === 1 / 0) continue;
                  const a = Ci.applyTransform(o.aabb, n.matrix);
                  i.insert(e, a.min[0], a.min[1], a.max[0], a.max[1]);
                }
              if (n.children) for (const o of n.children) x1(o, e, i);
            }
            const v1 = ["", "wall", "door", "roof", "window", "lamp", "logo"];
            class b1 {
              constructor(e) {
                ((this.node = e),
                  (this.evaluatedRMEA = [
                    [1, 0, 0, 1],
                    [1, 0, 0, 1],
                    [1, 0, 0, 1],
                    [1, 0, 0, 1],
                    [0.4, 1, 0, 1],
                    [1, 0, 0, 1],
                    [1, 0, 0, 1],
                  ]),
                  (this.hiddenByReplacement = !1),
                  (this.evaluatedTranslation = [0, 0, 0]),
                  (this.evaluatedScale = [1, 1, 1]),
                  (this.evaluatedColor = []),
                  (this.emissionHeightBasedParams = []),
                  (this.cameraCollisionOpacity = 1),
                  (this.feature = {
                    type: "Point",
                    id: e.id,
                    geometry: [],
                    properties: { height: y1(e) },
                  }),
                  (this.aabb = this._getLocalBounds()),
                  (this.state = null));
              }
              _getLocalBounds() {
                if (!this.node.meshes)
                  return new Ci(
                    [1 / 0, 1 / 0, 1 / 0],
                    [-1 / 0, -1 / 0, -1 / 0],
                  );
                if (!this.aabb) {
                  let e = 0;
                  const i = new Ci(
                    [1 / 0, 1 / 0, 1 / 0],
                    [-1 / 0, -1 / 0, -1 / 0],
                  );
                  for (const o of this.node.meshes)
                    (this.node.lightMeshIndex !== e &&
                      ((o.transformedAabb = Ci.applyTransformFast(
                        o.aabb,
                        this.node.matrix,
                      )),
                      i.encapsulate(o.transformedAabb)),
                      e++);
                  this.aabb = i;
                }
                return this.aabb;
              }
            }
            class ug {
              constructor(e, i, o, a, u, d, _, v) {
                ((this.id = o),
                  (this.layers = e),
                  (this.layerIds = this.layers.map((b) => b.fqid)),
                  (this.stateDependentLayerIds = this.layers
                    .filter((b) => b.isStateDependent())
                    .map((b) => b.id)),
                  (this.modelTraits |= Fu.CoordinateSpaceTile),
                  (this.uploaded = !1),
                  (this.hasPattern = !1),
                  a && (this.modelTraits |= Fu.HasMapboxMeshFeatures),
                  u && (this.modelTraits |= Fu.HasMeshoptCompression),
                  (this.zoom = -1),
                  (this.terrainExaggeration = 1),
                  (this.projection = { name: "mercator" }),
                  (this.replacementUpdateTime = 0),
                  (this.elevationReadFromZ = 255),
                  (this.brightness = d),
                  (this.worldview = v),
                  (this.dirty = !0),
                  (this.needsUpload = !1),
                  (this.filter = null),
                  (this.nodesInfo = []));
                for (const b of i)
                  (this.nodesInfo.push(new b1(b)),
                    x1(b, _.featureIndexArray.length, _.grid),
                    _.featureIndexArray.emplaceBack(
                      this.nodesInfo.length - 1,
                      0,
                      _.bucketLayerIDs.length - 1,
                      0,
                    ));
                this.states = {};
              }
              updateFootprints(e, i) {
                for (const o of this.getNodesInfo()) {
                  const a = o.node;
                  a.footprint && i.push({ footprint: a.footprint, id: e });
                }
              }
              update(e) {
                const i = Object.keys(e).length !== 0;
                if (i && !this.stateDependentLayers.length) return;
                const o = i ? this.stateDependentLayers : this.layers;
                if (!to(e, this.states)) for (const a of o) this.evaluate(a, e);
                this.states = structuredClone(e);
              }
              populate() {
                console.log("populate 3D model bucket");
              }
              uploadPending() {
                return !this.uploaded || this.needsUpload;
              }
              upload(e) {
                if (!this.needsUpload) return;
                const i = this.getNodesInfo();
                for (const o of i) {
                  const a = o.node;
                  this.uploaded ? this.updatePbrBuffer(a) : qy(a, e, !0);
                }
                for (const o of i) hg(o.node);
                ((this.uploaded = !0), (this.needsUpload = !1));
              }
              updatePbrBuffer(e) {
                let i = !1;
                if (!e.meshes) return i;
                for (const o of e.meshes)
                  o.pbrBuffer &&
                    (o.pbrBuffer.updateData(o.featureArray), (i = !0));
                return i;
              }
              needsReEvaluation(e, i, o) {
                const a = e.transform.projectionOptions,
                  u = e.style.getBrightness(),
                  d = this.brightness !== u;
                if (
                  !this.uploaded ||
                  this.dirty ||
                  a.name !== this.projection.name ||
                  Of(o.paint.get("model-color").value, d) ||
                  Of(o.paint.get("model-color-mix-intensity").value, d) ||
                  Of(o.paint.get("model-roughness").value, d) ||
                  Of(o.paint.get("model-emissive-strength").value, d) ||
                  Of(
                    o.paint.get(
                      "model-height-based-emissive-strength-multiplier",
                    ).value,
                    d,
                  )
                ) {
                  ((this.projection = a), (this.brightness = u));
                  const _ = this.getNodesInfo();
                  for (const v of _) v.state = null;
                  return !0;
                }
                return !1;
              }
              evaluateTransform(e, i) {
                if (e.transform.zoom === this.zoom) return;
                this.zoom = e.transform.zoom;
                const o = this.getNodesInfo(),
                  a = this.id.canonical;
                for (const u of o) {
                  const d = u.feature;
                  ((u.evaluatedTranslation = i.paint
                    .get("model-translation")
                    .evaluate(d, {}, a)),
                    (u.evaluatedScale = i.paint
                      .get("model-scale")
                      .evaluate(d, {}, a)));
                }
              }
              evaluate(e, i) {
                const o = this.getNodesInfo();
                for (const a of o) {
                  if (!a.node.meshes) continue;
                  const u = a.feature,
                    d = i && i[u.id];
                  if (to(d, a.state)) continue;
                  a.state = structuredClone(d);
                  const _ = a.node.meshes && a.node.meshes[0].featureData,
                    v = a.evaluatedColor[2],
                    b = a.evaluatedRMEA[2],
                    E = this.id.canonical;
                  if (((a.hasTranslucentParts = !1), _)) {
                    for (let A = 0; A < v1.length; A++) {
                      const M = v1[A];
                      M.length && (u.properties.part = M);
                      const R = e.paint
                          .get("model-color")
                          .evaluate(u, d, E)
                          .toPremultipliedRenderColor(null),
                        k = e.paint
                          .get("model-color-mix-intensity")
                          .evaluate(u, d, E);
                      ((a.evaluatedColor[A] = [R.r, R.g, R.b, k]),
                        (a.evaluatedRMEA[A][0] = e.paint
                          .get("model-roughness")
                          .evaluate(u, d, E)),
                        (a.evaluatedRMEA[A][2] = e.paint
                          .get("model-emissive-strength")
                          .evaluate(u, d, E)),
                        (a.evaluatedRMEA[A][3] = R.a),
                        (a.emissionHeightBasedParams[A] = e.paint
                          .get(
                            "model-height-based-emissive-strength-multiplier",
                          )
                          .evaluate(u, d, E)),
                        !a.hasTranslucentParts &&
                          R.a < 1 &&
                          (a.hasTranslucentParts = !0));
                    }
                    (delete u.properties.part,
                      fI(
                        a,
                        v !== a.evaluatedColor[2] || b !== a.evaluatedRMEA[2],
                        this.modelTraits,
                      ));
                  } else
                    a.evaluatedRMEA[0][2] = e.paint
                      .get("model-emissive-strength")
                      .evaluate(u, d, E);
                  ((a.evaluatedTranslation = e.paint
                    .get("model-translation")
                    .evaluate(u, d, E)),
                    (a.evaluatedScale = e.paint
                      .get("model-scale")
                      .evaluate(u, d, E)),
                    this.updatePbrBuffer(a.node) || (this.needsUpload = !0));
                }
                this.dirty = !1;
              }
              elevationUpdate(e, i, o, a) {
                const u = e.findDEMTileFor(o);
                if (
                  u &&
                  (u.tileID.canonical !== this.terrainTile ||
                    i !== this.terrainExaggeration)
                ) {
                  if (
                    u.dem &&
                    u.tileID.overscaledZ !== this.elevationReadFromZ
                  ) {
                    this.elevationReadFromZ = u.tileID.overscaledZ;
                    const d = Bu.create(e, o, u);
                    if (!d) return;
                    this.modelTraits & Fu.HasMapboxMeshFeatures &&
                      this.updateDEM(e, d, o, a);
                    for (const _ of this.getNodesInfo()) {
                      const v = _.node;
                      if (
                        !v.footprint ||
                        !v.footprint.vertices ||
                        !v.footprint.vertices.length
                      )
                        continue;
                      const b = v.footprint.vertices;
                      let E = d.getElevationAt(b[0].x, b[0].y, !0, !0);
                      for (let A = 1; A < b.length; A++)
                        E = Math.min(
                          E,
                          d.getElevationAt(b[A].x, b[A].y, !0, !0),
                        );
                      v.elevation = E;
                    }
                  }
                  ((this.terrainTile = u.tileID.canonical),
                    (this.terrainExaggeration = i));
                }
              }
              updateDEM(e, i, o, a) {
                let u = i._dem._modifiedForSources[a];
                if (
                  (u === void 0 &&
                    ((i._dem._modifiedForSources[a] = []),
                    (u = i._dem._modifiedForSources[a])),
                  u.includes(o.canonical))
                )
                  return;
                const d = i._dem.dim;
                u.push(o.canonical);
                let _ = !1;
                for (const v of this.getNodesInfo()) {
                  const b = v.node;
                  if (!b.footprint || !b.footprint.grid) continue;
                  const E = b.footprint.grid,
                    A = i.tileCoordToPixel(E.min.x, E.min.y),
                    M = i.tileCoordToPixel(E.max.x, E.max.y),
                    R = Math.min(
                      Math.min(d - M.y, A.x),
                      Math.min(A.y, d - M.x),
                    );
                  if (R < 0) continue;
                  const k = he(R, 2, 5);
                  let N = Math.max(0, A.x - k),
                    j = Math.max(0, A.y - k),
                    H = Math.min(M.x + k, d - 1),
                    J = Math.min(M.y + k, d - 1);
                  for (let ee = j; ee <= J; ++ee)
                    for (let re = N; re <= H; ++re) lh[ee * d + re] = 255;
                  let Q = 0,
                    V = 0;
                  for (let ee = 0; ee < E.cellsY; ++ee)
                    for (let re = 0; re < E.cellsX; ++re) {
                      if (!E.cells[ee * E.cellsX + re]) continue;
                      const ve = i.tileCoordToPixel(
                          E.min.x + re / E.xScale,
                          E.min.y + ee / E.yScale,
                        ),
                        ge = i.tileCoordToPixel(
                          E.min.x + (re + 1) / E.xScale,
                          E.min.y + (ee + 1) / E.yScale,
                        );
                      for (let be = ve.y; be <= Math.min(ge.y + 1, d - 1); ++be)
                        for (
                          let Me = ve.x;
                          Me <= Math.min(ge.x + 1, d - 1);
                          ++Me
                        )
                          lh[be * d + Me] === 255 &&
                            ((lh[be * d + Me] = 0),
                            (Q += i.getElevationAtPixel(Me, be)),
                            V++);
                    }
                  const X = Q / V;
                  ((N = Math.max(1, A.x - k)),
                    (j = Math.max(1, A.y - k)),
                    (H = Math.min(M.x + k, d - 2)),
                    (J = Math.min(M.y + k, d - 2)),
                    (_ = !0));
                  for (let ee = j; ee <= J; ++ee)
                    for (let re = N; re <= H; ++re)
                      lh[ee * d + re] === 0 &&
                        (Xy[ee * d + re] = i._dem.set(re, ee, X));
                  for (let ee = 1; ee < k; ++ee) {
                    ((N = Math.max(1, A.x - ee)),
                      (j = Math.max(1, A.y - ee)),
                      (H = Math.min(M.x + ee, d - 2)),
                      (J = Math.min(M.y + ee, d - 2)));
                    for (let re = j; re <= J; ++re)
                      for (let ve = N; ve <= H; ++ve) {
                        const ge = re * d + ve;
                        if (lh[ge] === 255) {
                          let be = 0,
                            Me = 0,
                            Ue = -1,
                            it = -1;
                          for (let Xe = -1; Xe <= 1; ++Xe)
                            for (let tt = -1; tt <= 1; ++tt) {
                              const nt = (re + Xe) * d + ve + tt;
                              if (lh[nt] >= ee) continue;
                              const Ge = Xy[nt],
                                Je = Math.abs(Ge);
                              Je > Me &&
                                ((be = Ge), (Me = Je), (Ue = tt), (it = Xe));
                            }
                          if (Me > 0.1) {
                            const Xe = 1 - (ee + 0.5 * Math.abs(Ue * it)) / k;
                            let tt = i._dem.get(ve, re) + be * Xe;
                            const nt = i._dem.get(ve + Ue, re + it),
                              Ge = i._dem.get(ve - Ue, re - it, !0);
                            ((tt - nt) * (tt - Ge) > 0 && (tt = (nt + Ge) / 2),
                              (Xy[ge] = i._dem.set(ve, re, tt)),
                              (lh[ge] = ee));
                          }
                        }
                      }
                  }
                }
                _ &&
                  ((i._demTile.needsDEMTextureUpload = !0),
                  (i._dem._timestamp = As.now()));
              }
              setFilter(e) {
                this.filter = e ? Ud(e) : null;
              }
              getNodesInfo() {
                return this.filter
                  ? this.nodesInfo.filter((e) =>
                      this.filter.filter(
                        new qi(this.id.overscaledZ, {
                          worldview: this.worldview,
                        }),
                        e.feature,
                        this.id.canonical,
                      ),
                    )
                  : this.nodesInfo;
              }
              destroy() {
                const e = this.getNodesInfo();
                for (const i of e) (hg(i.node), Zy(i.node));
              }
              isEmpty() {
                return !this.nodesInfo.length;
              }
              updateReplacement(e, i) {
                if (i.updateTime === this.replacementUpdateTime) return;
                this.replacementUpdateTime = i.updateTime;
                const o = i.getReplacementRegionsForTile(e.toUnwrapped());
                for (const a of this.getNodesInfo()) {
                  const u = a.node.footprint;
                  a.hiddenByReplacement =
                    !!u && !o.find((d) => d.footprint === u);
                }
              }
              getHeightAtTileCoord(e, i) {
                const o = [],
                  a = [0, 0, 0],
                  u = xe([]);
                for (const d of this.getNodesInfo()) {
                  const _ = d.node.meshes[0],
                    v = _.transformedAabb;
                  if (
                    e < v.min[0] ||
                    i < v.min[1] ||
                    e > v.max[0] ||
                    i > v.max[1]
                  )
                    continue;
                  if (d.node.hidden === !0)
                    return {
                      height: 1 / 0,
                      maxHeight: d.feature.properties.height,
                      hidden: !1,
                      verticalScale: d.evaluatedScale[2],
                    };
                  (we(u, d.node.matrix), (a[0] = e), (a[1] = i), mn(a, a, u));
                  const b =
                      (((a[0] - _.aabb.min[0]) /
                        (_.aabb.max[0] - _.aabb.min[0])) *
                        ah) |
                      0,
                    E =
                      Math.min(
                        63,
                        (((a[1] - _.aabb.min[1]) /
                          (_.aabb.max[1] - _.aabb.min[1])) *
                          ah) |
                          0,
                      ) *
                        ah +
                      Math.min(63, b),
                    A = _.heightmap[E];
                  if (!(A < 0 && d.node.footprint))
                    return d.hiddenByReplacement
                      ? void 0
                      : {
                          height: A,
                          maxHeight: d.feature.properties.height,
                          hidden: !1,
                          verticalScale: d.evaluatedScale[2],
                        };
                  if (
                    (d.node.footprint.grid.query(new ft(e, i), new ft(e, i), o),
                    o.length > 0)
                  )
                    return {
                      height: void 0,
                      maxHeight: d.feature.properties.height,
                      hidden: d.hiddenByReplacement,
                      verticalScale: d.evaluatedScale[2],
                    };
                }
              }
            }
            function Of(n, e) {
              return n instanceof kc && !n.isLightConstant && e;
            }
            function dI(n, e, i, o, a, u, d, _) {
              let v = ((61440 & e) | ((61440 & e) >> 4)) >> 8,
                b = ((3840 & e) | ((3840 & e) >> 4)) >> 4,
                E = (240 & e) | ((240 & e) >> 4);
              i[3] > 0 &&
                ((v = Ht(v, 255 * i[0], i[3])),
                (b = Ht(b, 255 * i[1], i[3])),
                (E = Ht(E, 255 * i[2], i[3])));
              const A = (v << 8) | b,
                M = (E << 8) | Math.floor(255 * o[3]),
                R =
                  ((function (ee) {
                    const re = he(ee, 0, 2);
                    return Math.min(Math.round(0.5 * re * 255), 255);
                  })(o[2]) <<
                    8) |
                  ((15 * o[0]) << 4) |
                  (15 * o[1]),
                k = he(a[0], 0, 1),
                N = he(a[1], 0, 1),
                j = he(a[2], 0, 1),
                H = he(a[3], 0, 1);
              let J, Q, V, X;
              if (k !== N && d !== u && N !== k) {
                const ee = d - u;
                ((Q = 1 / (ee * (N - k))),
                  (V = -(u + ee * k) / (ee * (N - k))));
                const re = he(a[4], -1, 1);
                ((X = Math.pow(10, re)), (J = ((255 * j) << 8) | (255 * H)));
              } else ((J = 65535), (Q = 0), (V = 1), (X = 1));
              if ((n.emplaceBack(A, M, R, J, Q, V, X), _)) {
                const ee = _.length;
                _.clear();
                for (let re = 0; re < ee; re++)
                  _.emplaceBack(A, M, R, J, Q, V, X);
              }
            }
            function fI(n, e, i) {
              const o = n.node;
              let a = 0;
              const u = i & Fu.HasMeshoptCompression;
              for (const d of o.meshes) {
                if ((o.lights && o.lightMeshIndex === a) || !d.featureData)
                  continue;
                ((d.featureArray = new Wc()),
                  d.featureArray.reserve(d.featureData.length));
                let _ = e;
                for (const v of d.featureData) {
                  const b = u ? 65535 & v : (v >> 16) & 65535,
                    E = u ? (v >> 16) & 65535 : 65535 & v,
                    A = (15 & E) < 8 ? 15 & E : 0,
                    M = n.evaluatedRMEA[A],
                    R = n.evaluatedColor[A],
                    k = n.emissionHeightBasedParams[A];
                  let N;
                  if (
                    (_ &&
                      A === 2 &&
                      o.lights &&
                      ((N = new Wc()), N.resize(10 * o.lights.length)),
                    dI(
                      d.featureArray,
                      b,
                      R,
                      M,
                      k,
                      d.aabb.min[2],
                      d.aabb.max[2],
                      N,
                    ),
                    N && _)
                  ) {
                    _ = !1;
                    const j = o.meshes[o.lightMeshIndex];
                    ((j.featureArray = N), j.featureArray._trim());
                  }
                }
                (d.featureArray._trim(), a++);
              }
            }
            function w1(n, e, i, o) {
              const a = 1 << n.z;
              ((e.lat = De((o / mt + n.y) / a)),
                (e.lng = _e((i / mt + n.x) / a)));
            }
            function pI(n, e, i, o) {
              const a = n.getNodesInfo()[e];
              if (!a || a.hiddenByReplacement || !a.node.meshes) return;
              let u = Number.MAX_VALUE;
              const d = a.node,
                _ = i.tile,
                v = o.calculatePosMatrix(_.tileID.toUnwrapped(), o.worldSize),
                b = a.evaluatedScale;
              let E = 0;
              (o.elevation &&
                d.elevation &&
                (E = d.elevation * o.elevation.exaggeration()),
                Qe(v, v, [
                  (d.anchor ? d.anchor[0] : 0) * (b[0] - 1),
                  (d.anchor ? d.anchor[1] : 0) * (b[1] - 1),
                  E,
                ]),
                gt(v, v, b));
              const A = i.queryGeometry,
                M = A.isPointQuery() ? A.screenBounds : A.screenGeometry,
                R = function (N) {
                  const j = Ae([], v, N.matrix);
                  Ae(j, o.expandedFarZProjMatrix, j);
                  for (let H = 0; H < N.meshes.length; ++H) {
                    const J = N.meshes[H];
                    if (H === N.lightMeshIndex) continue;
                    const Q = u1(M, o, j, J.aabb);
                    Q != null && (u = Math.min(Q, u));
                  }
                  if (N.children) for (const H of N.children) R(H);
                };
              if ((R(d), u === Number.MAX_VALUE)) return;
              const k = new Y(0, 0);
              return (
                w1(_.tileID.canonical, k, a.node.anchor[0], a.node.anchor[1]),
                { intersectionZ: u, position: k, feature: a.feature }
              );
            }
            (Tt(ug, "Tiled3dModelBucket", { omit: ["layers"] }),
              Tt(b1, "Tiled3dModelFeature"));
            const mI = {
                circle: class extends Ir {
                  constructor(n, e, i, o) {
                    super(
                      n,
                      {
                        layout:
                          vv ||
                          (vv = new Cn({
                            "circle-sort-key": new vt(
                              Pe.layout_circle["circle-sort-key"],
                            ),
                            "circle-elevation-reference": new st(
                              Pe.layout_circle["circle-elevation-reference"],
                            ),
                            visibility: new st(Pe.layout_circle.visibility),
                          })),
                        paint:
                          bv ||
                          (bv = new Cn({
                            "circle-radius": new vt(
                              Pe.paint_circle["circle-radius"],
                            ),
                            "circle-color": new vt(
                              Pe.paint_circle["circle-color"],
                            ),
                            "circle-blur": new vt(
                              Pe.paint_circle["circle-blur"],
                            ),
                            "circle-opacity": new vt(
                              Pe.paint_circle["circle-opacity"],
                            ),
                            "circle-translate": new st(
                              Pe.paint_circle["circle-translate"],
                            ),
                            "circle-translate-anchor": new st(
                              Pe.paint_circle["circle-translate-anchor"],
                            ),
                            "circle-pitch-scale": new st(
                              Pe.paint_circle["circle-pitch-scale"],
                            ),
                            "circle-pitch-alignment": new st(
                              Pe.paint_circle["circle-pitch-alignment"],
                            ),
                            "circle-stroke-width": new vt(
                              Pe.paint_circle["circle-stroke-width"],
                            ),
                            "circle-stroke-color": new vt(
                              Pe.paint_circle["circle-stroke-color"],
                            ),
                            "circle-stroke-opacity": new vt(
                              Pe.paint_circle["circle-stroke-opacity"],
                            ),
                            "circle-emissive-strength": new st(
                              Pe.paint_circle["circle-emissive-strength"],
                            ),
                            "circle-color-use-theme": new vt({
                              type: "string",
                              default: "default",
                              "property-type": "data-driven",
                            }),
                            "circle-stroke-color-use-theme": new vt({
                              type: "string",
                              default: "default",
                              "property-type": "data-driven",
                            }),
                          })),
                      },
                      e,
                      i,
                      o,
                    );
                  }
                  createBucket(n) {
                    return new ws(n);
                  }
                  queryRadius(n) {
                    const e = n;
                    return (
                      Iu("circle-radius", this, e) +
                      Iu("circle-stroke-width", this, e) +
                      Tm(this.paint.get("circle-translate"))
                    );
                  }
                  queryIntersectsFeature(n, e, i, o, a, u, d, _) {
                    const v = xv(
                        this.paint.get("circle-translate"),
                        this.paint.get("circle-translate-anchor"),
                        u.angle,
                        n.pixelToTileUnitsFactor,
                      ),
                      b =
                        this.paint.get("circle-radius").evaluate(e, i) +
                        this.paint.get("circle-stroke-width").evaluate(e, i);
                    return kv(
                      n,
                      o,
                      u,
                      d,
                      _,
                      this.paint.get("circle-pitch-alignment") === "map",
                      this.paint.get("circle-pitch-scale") === "map",
                      v,
                      b,
                    );
                  }
                  getProgramIds() {
                    return ["circle"];
                  }
                  getDefaultProgramParams(n, e, i) {
                    const o = zv(this);
                    return {
                      config: new kl(this, { zoom: e, lut: i }),
                      defines: o,
                      overrideFog: !1,
                    };
                  }
                  is3D(n) {
                    return (
                      !n &&
                      !!this.layout &&
                      this.layout.get("circle-elevation-reference") !== "none"
                    );
                  }
                  hasElevation() {
                    return (
                      this.layout &&
                      this.layout.get("circle-elevation-reference") !== "none"
                    );
                  }
                },
                heatmap: class extends Ir {
                  createBucket(n) {
                    return new Ov(n);
                  }
                  constructor(n, e, i, o) {
                    (super(
                      n,
                      {
                        layout:
                          Fv ||
                          (Fv = new Cn({
                            visibility: new st(Pe.layout_heatmap.visibility),
                          })),
                        paint:
                          Bv ||
                          (Bv = new Cn({
                            "heatmap-radius": new vt(
                              Pe.paint_heatmap["heatmap-radius"],
                            ),
                            "heatmap-weight": new vt(
                              Pe.paint_heatmap["heatmap-weight"],
                            ),
                            "heatmap-intensity": new st(
                              Pe.paint_heatmap["heatmap-intensity"],
                            ),
                            "heatmap-color": new Ra(
                              Pe.paint_heatmap["heatmap-color"],
                            ),
                            "heatmap-opacity": new st(
                              Pe.paint_heatmap["heatmap-opacity"],
                            ),
                            "heatmap-color-use-theme": new vt({
                              type: "string",
                              default: "default",
                              "property-type": "data-driven",
                            }),
                          })),
                      },
                      e,
                      i,
                      o,
                    ),
                      this._updateColorRamp());
                  }
                  _handleSpecialPaintPropertyUpdate(n) {
                    n === "heatmap-color" && this._updateColorRamp();
                  }
                  _updateColorRamp() {
                    ((this.colorRamp = hf({
                      expression:
                        this._transitionablePaint._values["heatmap-color"].value
                          .expression,
                      evaluationKey: "heatmapDensity",
                      image: this.colorRamp,
                    })),
                      (this.colorRampTexture = null));
                  }
                  resize() {
                    this.heatmapFbo &&
                      (this.heatmapFbo.destroy(), (this.heatmapFbo = null));
                  }
                  queryRadius(n) {
                    return Iu("heatmap-radius", this, n);
                  }
                  queryIntersectsFeature(n, e, i, o, a, u, d, _) {
                    const v = this.paint.get("heatmap-radius").evaluate(e, i);
                    return kv(n, o, u, d, _, !0, !0, new ft(0, 0), v);
                  }
                  hasOffscreenPass() {
                    return (
                      this.paint.get("heatmap-opacity") !== 0 &&
                      this.visibility !== "none"
                    );
                  }
                  getProgramIds() {
                    return ["heatmap", "heatmapTexture"];
                  }
                  getDefaultProgramParams(n, e, i) {
                    return n === "heatmap"
                      ? {
                          config: new kl(this, { zoom: e, lut: i }),
                          overrideFog: !1,
                        }
                      : {};
                  }
                },
                hillshade: class extends Ir {
                  constructor(n, e, i, o) {
                    super(
                      n,
                      {
                        layout:
                          Nv ||
                          (Nv = new Cn({
                            visibility: new st(Pe.layout_hillshade.visibility),
                          })),
                        paint:
                          Vv ||
                          (Vv = new Cn({
                            "hillshade-illumination-direction": new st(
                              Pe.paint_hillshade[
                                "hillshade-illumination-direction"
                              ],
                            ),
                            "hillshade-illumination-anchor": new st(
                              Pe.paint_hillshade[
                                "hillshade-illumination-anchor"
                              ],
                            ),
                            "hillshade-exaggeration": new st(
                              Pe.paint_hillshade["hillshade-exaggeration"],
                            ),
                            "hillshade-shadow-color": new st(
                              Pe.paint_hillshade["hillshade-shadow-color"],
                            ),
                            "hillshade-highlight-color": new st(
                              Pe.paint_hillshade["hillshade-highlight-color"],
                            ),
                            "hillshade-accent-color": new st(
                              Pe.paint_hillshade["hillshade-accent-color"],
                            ),
                            "hillshade-emissive-strength": new st(
                              Pe.paint_hillshade["hillshade-emissive-strength"],
                            ),
                            "hillshade-shadow-color-use-theme": new vt({
                              type: "string",
                              default: "default",
                              "property-type": "data-driven",
                            }),
                            "hillshade-highlight-color-use-theme": new vt({
                              type: "string",
                              default: "default",
                              "property-type": "data-driven",
                            }),
                            "hillshade-accent-color-use-theme": new vt({
                              type: "string",
                              default: "default",
                              "property-type": "data-driven",
                            }),
                          })),
                      },
                      e,
                      i,
                      o,
                    );
                  }
                  shouldRedrape() {
                    return (
                      this.hasOffscreenPass() &&
                      this.paint.get("hillshade-illumination-anchor") ===
                        "viewport"
                    );
                  }
                  hasOffscreenPass() {
                    return (
                      this.paint.get("hillshade-exaggeration") !== 0 &&
                      this.visibility !== "none"
                    );
                  }
                  getProgramIds() {
                    return ["hillshade", "hillshadePrepare"];
                  }
                  getDefaultProgramParams(n, e, i) {
                    return { overrideFog: !1 };
                  }
                },
                fill: class extends Ir {
                  constructor(n, e, i, o) {
                    super(
                      n,
                      {
                        layout:
                          t0 ||
                          (t0 = new Cn({
                            "fill-sort-key": new vt(
                              Pe.layout_fill["fill-sort-key"],
                            ),
                            visibility: new st(Pe.layout_fill.visibility),
                            "fill-elevation-reference": new st(
                              Pe.layout_fill["fill-elevation-reference"],
                            ),
                            "fill-construct-bridge-guard-rail": new vt(
                              Pe.layout_fill[
                                "fill-construct-bridge-guard-rail"
                              ],
                            ),
                          })),
                        paint:
                          i0 ||
                          (i0 = new Cn({
                            "fill-antialias": new st(
                              Pe.paint_fill["fill-antialias"],
                            ),
                            "fill-opacity": new vt(
                              Pe.paint_fill["fill-opacity"],
                            ),
                            "fill-color": new vt(Pe.paint_fill["fill-color"]),
                            "fill-outline-color": new vt(
                              Pe.paint_fill["fill-outline-color"],
                            ),
                            "fill-translate": new st(
                              Pe.paint_fill["fill-translate"],
                            ),
                            "fill-translate-anchor": new st(
                              Pe.paint_fill["fill-translate-anchor"],
                            ),
                            "fill-pattern": new vt(
                              Pe.paint_fill["fill-pattern"],
                            ),
                            "fill-pattern-cross-fade": new st(
                              Pe.paint_fill["fill-pattern-cross-fade"],
                            ),
                            "fill-emissive-strength": new st(
                              Pe.paint_fill["fill-emissive-strength"],
                            ),
                            "fill-z-offset": new vt(
                              Pe.paint_fill["fill-z-offset"],
                            ),
                            "fill-bridge-guard-rail-color": new vt(
                              Pe.paint_fill["fill-bridge-guard-rail-color"],
                            ),
                            "fill-tunnel-structure-color": new vt(
                              Pe.paint_fill["fill-tunnel-structure-color"],
                            ),
                            "fill-color-use-theme": new vt({
                              type: "string",
                              default: "default",
                              "property-type": "data-driven",
                            }),
                            "fill-outline-color-use-theme": new vt({
                              type: "string",
                              default: "default",
                              "property-type": "data-driven",
                            }),
                            "fill-bridge-guard-rail-color-use-theme": new vt({
                              type: "string",
                              default: "default",
                              "property-type": "data-driven",
                            }),
                            "fill-tunnel-structure-color-use-theme": new vt({
                              type: "string",
                              default: "default",
                              "property-type": "data-driven",
                            }),
                          })),
                      },
                      e,
                      i,
                      o,
                    );
                  }
                  getProgramIds() {
                    const n = this.paint.get("fill-pattern"),
                      e = n && n.constantOr(1),
                      i = [e ? "fillPattern" : "fill"];
                    return (
                      this.paint.get("fill-antialias") &&
                        i.push(
                          e && !this.getPaintProperty("fill-outline-color")
                            ? "fillOutlinePattern"
                            : "fillOutline",
                        ),
                      i
                    );
                  }
                  getDefaultProgramParams(n, e, i) {
                    return {
                      config: new kl(this, { zoom: e, lut: i }),
                      overrideFog: !1,
                    };
                  }
                  recalculate(n, e) {
                    super.recalculate(n, e);
                    const i = this.paint._values["fill-outline-color"];
                    i.value.kind === "constant" &&
                      i.value.value === void 0 &&
                      (this.paint._values["fill-outline-color"] =
                        this.paint._values["fill-color"]);
                  }
                  createBucket(n) {
                    return new oy(n);
                  }
                  queryRadius() {
                    return Tm(this.paint.get("fill-translate"));
                  }
                  queryIntersectsFeature(n, e, i, o, a, u) {
                    return (
                      !n.queryGeometry.isAboveHorizon &&
                      ks(
                        yv(
                          n.tilespaceGeometry,
                          this.paint.get("fill-translate"),
                          this.paint.get("fill-translate-anchor"),
                          u.angle,
                          n.pixelToTileUnitsFactor,
                        ),
                        o,
                      )
                    );
                  }
                  isTileClipped() {
                    return this.paint.get("fill-z-offset").constantOr(1) === 0;
                  }
                  is3D(n) {
                    if (this.paint.get("fill-z-offset").constantOr(1) !== 0)
                      return !0;
                    const e =
                      this.layout &&
                      this.layout.get("fill-elevation-reference") !== "none";
                    return n != null ? e && !n : e;
                  }
                  hasElevation() {
                    return (
                      this.layout &&
                      this.layout.get("fill-elevation-reference") !== "none"
                    );
                  }
                  hasShadowPass() {
                    return (
                      this.layout &&
                      this.layout.get("fill-elevation-reference") !== "none"
                    );
                  }
                },
                "fill-extrusion": class extends Ir {
                  constructor(n, e, i, o) {
                    (super(
                      n,
                      {
                        layout:
                          A0 ||
                          (A0 = new Cn({
                            visibility: new st(
                              Pe["layout_fill-extrusion"].visibility,
                            ),
                            "fill-extrusion-edge-radius": new st(
                              Pe["layout_fill-extrusion"][
                                "fill-extrusion-edge-radius"
                              ],
                            ),
                          })),
                        paint:
                          M0 ||
                          (M0 = new Cn({
                            "fill-extrusion-opacity": new st(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-opacity"
                              ],
                            ),
                            "fill-extrusion-color": new vt(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-color"
                              ],
                            ),
                            "fill-extrusion-translate": new st(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-translate"
                              ],
                            ),
                            "fill-extrusion-translate-anchor": new st(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-translate-anchor"
                              ],
                            ),
                            "fill-extrusion-pattern": new vt(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-pattern"
                              ],
                            ),
                            "fill-extrusion-pattern-cross-fade": new st(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-pattern-cross-fade"
                              ],
                            ),
                            "fill-extrusion-height": new vt(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-height"
                              ],
                            ),
                            "fill-extrusion-base": new vt(
                              Pe["paint_fill-extrusion"]["fill-extrusion-base"],
                            ),
                            "fill-extrusion-height-alignment": new st(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-height-alignment"
                              ],
                            ),
                            "fill-extrusion-base-alignment": new st(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-base-alignment"
                              ],
                            ),
                            "fill-extrusion-vertical-gradient": new st(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-vertical-gradient"
                              ],
                            ),
                            "fill-extrusion-ambient-occlusion-intensity":
                              new st(
                                Pe["paint_fill-extrusion"][
                                  "fill-extrusion-ambient-occlusion-intensity"
                                ],
                              ),
                            "fill-extrusion-ambient-occlusion-radius": new st(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-ambient-occlusion-radius"
                              ],
                            ),
                            "fill-extrusion-ambient-occlusion-wall-radius":
                              new st(
                                Pe["paint_fill-extrusion"][
                                  "fill-extrusion-ambient-occlusion-wall-radius"
                                ],
                              ),
                            "fill-extrusion-ambient-occlusion-ground-radius":
                              new st(
                                Pe["paint_fill-extrusion"][
                                  "fill-extrusion-ambient-occlusion-ground-radius"
                                ],
                              ),
                            "fill-extrusion-ambient-occlusion-ground-attenuation":
                              new st(
                                Pe["paint_fill-extrusion"][
                                  "fill-extrusion-ambient-occlusion-ground-attenuation"
                                ],
                              ),
                            "fill-extrusion-flood-light-color": new st(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-flood-light-color"
                              ],
                            ),
                            "fill-extrusion-flood-light-intensity": new st(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-flood-light-intensity"
                              ],
                            ),
                            "fill-extrusion-flood-light-wall-radius": new vt(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-flood-light-wall-radius"
                              ],
                            ),
                            "fill-extrusion-flood-light-ground-radius": new vt(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-flood-light-ground-radius"
                              ],
                            ),
                            "fill-extrusion-flood-light-ground-attenuation":
                              new st(
                                Pe["paint_fill-extrusion"][
                                  "fill-extrusion-flood-light-ground-attenuation"
                                ],
                              ),
                            "fill-extrusion-vertical-scale": new st(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-vertical-scale"
                              ],
                            ),
                            "fill-extrusion-rounded-roof": new st(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-rounded-roof"
                              ],
                            ),
                            "fill-extrusion-cutoff-fade-range": new st(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-cutoff-fade-range"
                              ],
                            ),
                            "fill-extrusion-emissive-strength": new vt(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-emissive-strength"
                              ],
                            ),
                            "fill-extrusion-line-width": new vt(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-line-width"
                              ],
                            ),
                            "fill-extrusion-cast-shadows": new st(
                              Pe["paint_fill-extrusion"][
                                "fill-extrusion-cast-shadows"
                              ],
                            ),
                            "fill-extrusion-color-use-theme": new vt({
                              type: "string",
                              default: "default",
                              "property-type": "data-driven",
                            }),
                            "fill-extrusion-flood-light-color-use-theme":
                              new vt({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven",
                              }),
                          })),
                      },
                      e,
                      i,
                      o,
                    ),
                      (this._stats = {
                        numRenderedVerticesInShadowPass: 0,
                        numRenderedVerticesInTransparentPass: 0,
                      }));
                  }
                  createBucket(n) {
                    return new Om(n);
                  }
                  queryRadius() {
                    return Tm(this.paint.get("fill-extrusion-translate"));
                  }
                  is3D(n) {
                    return !0;
                  }
                  hasShadowPass() {
                    return this.paint.get("fill-extrusion-cast-shadows");
                  }
                  cutoffRange() {
                    return this.paint.get("fill-extrusion-cutoff-fade-range");
                  }
                  canCastShadows() {
                    return !0;
                  }
                  getProgramIds() {
                    return [
                      this.paint.get("fill-extrusion-pattern").constantOr(1)
                        ? "fillExtrusionPattern"
                        : "fillExtrusion",
                    ];
                  }
                  queryIntersectsFeature(n, e, i, o, a, u, d, _, v) {
                    const b = xv(
                        this.paint.get("fill-extrusion-translate"),
                        this.paint.get("fill-extrusion-translate-anchor"),
                        u.angle,
                        n.pixelToTileUnitsFactor,
                      ),
                      E = this.paint
                        .get("fill-extrusion-height")
                        .evaluate(e, i),
                      A = this.paint.get("fill-extrusion-base").evaluate(e, i),
                      M = [0, 0],
                      R = _ && u.elevation,
                      k = u.elevation ? u.elevation.exaggeration() : 1,
                      N = n.tile.getBucket(this);
                    if (R && N instanceof Om) {
                      const V = N.centroidVertexArray,
                        X = v + 1;
                      X < V.length &&
                        ((M[0] = V.geta_centroid_pos0(X)),
                        (M[1] = V.geta_centroid_pos1(X)));
                    }
                    if (M[0] === 0 && M[1] === 1) return !1;
                    u.projection.name === "globe" &&
                      (o = I0(
                        [o],
                        [new ft(0, 0), new ft(mt, mt)],
                        n.tileID.canonical,
                      )
                        .map((V) => V.polygon)
                        .flat());
                    const j = R ? _ : null,
                      [H, J] = (function (
                        V,
                        X,
                        ee,
                        re,
                        ve,
                        ge,
                        be,
                        Me,
                        Ue,
                        it,
                        Xe,
                      ) {
                        return V.projection.name === "globe"
                          ? (function (
                              tt,
                              nt,
                              Ge,
                              Je,
                              Ne,
                              je,
                              at,
                              ct,
                              Nt,
                              Ct,
                              yt,
                            ) {
                              const ot = [],
                                Jt = [],
                                At = tt.projection.upVectorScale(
                                  yt,
                                  tt.center.lat,
                                  tt.worldSize,
                                ).metersToTile,
                                Dt = [0, 0, 0, 1],
                                Wt = [0, 0, 0, 1],
                                ni = (di, oi, fi, Bi) => {
                                  ((di[0] = oi),
                                    (di[1] = fi),
                                    (di[2] = Bi),
                                    (di[3] = 1));
                                },
                                ii = E0();
                              (Ge > 0 && (Ge += ii), (Je += ii));
                              for (const di of nt) {
                                const oi = [],
                                  fi = [];
                                for (const Bi of di) {
                                  const sn = Bi.x + Ne.x,
                                    te = Bi.y + Ne.y,
                                    se = tt.projection.projectTilePoint(
                                      sn,
                                      te,
                                      yt,
                                    ),
                                    $e = tt.projection.upVector(yt, Bi.x, Bi.y);
                                  let ut = Ge,
                                    xt = Je;
                                  if (at) {
                                    const _t = k0(
                                      sn,
                                      te,
                                      Ge,
                                      Je,
                                      at,
                                      ct,
                                      Nt,
                                      Ct,
                                    );
                                    ((ut += _t.base), (xt += _t.top));
                                  }
                                  (Ge !== 0
                                    ? ni(
                                        Dt,
                                        se.x + $e[0] * At * ut,
                                        se.y + $e[1] * At * ut,
                                        se.z + $e[2] * At * ut,
                                      )
                                    : ni(Dt, se.x, se.y, se.z),
                                    ni(
                                      Wt,
                                      se.x + $e[0] * At * xt,
                                      se.y + $e[1] * At * xt,
                                      se.z + $e[2] * At * xt,
                                    ),
                                    mn(Dt, Dt, je),
                                    mn(Wt, Wt, je),
                                    oi.push(new nh(Dt[0], Dt[1], Dt[2])),
                                    fi.push(new nh(Wt[0], Wt[1], Wt[2])));
                                }
                                (ot.push(oi), Jt.push(fi));
                              }
                              return [ot, Jt];
                            })(V, X, ee, re, ve, ge, be, Me, Ue, it, Xe)
                          : be
                            ? (function (tt, nt, Ge, Je, Ne, je, at, ct, Nt) {
                                const Ct = [],
                                  yt = [],
                                  ot = [0, 0, 0, 1];
                                for (const Jt of tt) {
                                  const At = [],
                                    Dt = [];
                                  for (const Wt of Jt) {
                                    const ni = Wt.x + Je.x,
                                      ii = Wt.y + Je.y,
                                      di = k0(ni, ii, nt, Ge, je, at, ct, Nt);
                                    ((ot[0] = ni),
                                      (ot[1] = ii),
                                      (ot[2] = di.base),
                                      (ot[3] = 1),
                                      Cr(ot, ot, Ne),
                                      (ot[3] = Math.max(ot[3], 1e-5)));
                                    const oi = new nh(
                                      ot[0] / ot[3],
                                      ot[1] / ot[3],
                                      ot[2] / ot[3],
                                    );
                                    ((ot[0] = ni),
                                      (ot[1] = ii),
                                      (ot[2] = di.top),
                                      (ot[3] = 1),
                                      Cr(ot, ot, Ne),
                                      (ot[3] = Math.max(ot[3], 1e-5)));
                                    const fi = new nh(
                                      ot[0] / ot[3],
                                      ot[1] / ot[3],
                                      ot[2] / ot[3],
                                    );
                                    (At.push(oi), Dt.push(fi));
                                  }
                                  (Ct.push(At), yt.push(Dt));
                                }
                                return [Ct, yt];
                              })(X, ee, re, ve, ge, be, Me, Ue, it)
                            : (function (tt, nt, Ge, Je, Ne) {
                                const je = [],
                                  at = [],
                                  ct = Ne[8] * nt,
                                  Nt = Ne[9] * nt,
                                  Ct = Ne[10] * nt,
                                  yt = Ne[11] * nt,
                                  ot = Ne[8] * Ge,
                                  Jt = Ne[9] * Ge,
                                  At = Ne[10] * Ge,
                                  Dt = Ne[11] * Ge;
                                for (const Wt of tt) {
                                  const ni = [],
                                    ii = [];
                                  for (const di of Wt) {
                                    const oi = di.x + Je.x,
                                      fi = di.y + Je.y,
                                      Bi = Ne[0] * oi + Ne[4] * fi + Ne[12],
                                      sn = Ne[1] * oi + Ne[5] * fi + Ne[13],
                                      te = Ne[2] * oi + Ne[6] * fi + Ne[14],
                                      se = Ne[3] * oi + Ne[7] * fi + Ne[15],
                                      $e = Bi + ct,
                                      ut = sn + Nt,
                                      xt = te + Ct,
                                      _t = Math.max(se + yt, 1e-5),
                                      It = Bi + ot,
                                      $t = sn + Jt,
                                      yi = te + At,
                                      xi = Math.max(se + Dt, 1e-5);
                                    (ni.push(new nh($e / _t, ut / _t, xt / _t)),
                                      ii.push(
                                        new nh(It / xi, $t / xi, yi / xi),
                                      ));
                                  }
                                  (je.push(ni), at.push(ii));
                                }
                                return [je, at];
                              })(X, ee, re, ve, ge);
                      })(
                        u,
                        o,
                        A,
                        E,
                        b,
                        d,
                        j,
                        M,
                        k,
                        u.center.lat,
                        n.tileID.canonical,
                      ),
                      Q = n.queryGeometry;
                    return (function (V, X, ee) {
                      let re = 1 / 0;
                      ks(ee, X) && (re = z0(ee, X[0]));
                      for (let ve = 0; ve < X.length; ve++) {
                        const ge = X[ve],
                          be = V[ve];
                        for (let Me = 0; Me < ge.length - 1; Me++) {
                          const Ue = ge[Me],
                            it = [Ue, ge[Me + 1], be[Me + 1], be[Me], Ue];
                          Hr(ee, it) && (re = Math.min(re, z0(ee, it)));
                        }
                      }
                      return re !== 1 / 0 && re;
                    })(
                      H,
                      J,
                      Q.isPointQuery() ? Q.screenBounds : Q.screenGeometry,
                    );
                  }
                },
                building: class extends Ir {
                  constructor(n, e, i, o) {
                    (super(
                      n,
                      {
                        layout:
                          W0 ||
                          (W0 = new Cn({
                            visibility: new st(Pe.layout_building.visibility),
                            "building-roof-shape": new vt(
                              Pe.layout_building["building-roof-shape"],
                            ),
                            "building-height": new vt(
                              Pe.layout_building["building-height"],
                            ),
                            "building-base": new vt(
                              Pe.layout_building["building-base"],
                            ),
                          })),
                        paint:
                          q0 ||
                          (q0 = new Cn({
                            "building-opacity": new st(
                              Pe.paint_building["building-opacity"],
                            ),
                            "building-ambient-occlusion-wall-intensity": new st(
                              Pe.paint_building[
                                "building-ambient-occlusion-wall-intensity"
                              ],
                            ),
                            "building-ambient-occlusion-ground-intensity":
                              new st(
                                Pe.paint_building[
                                  "building-ambient-occlusion-ground-intensity"
                                ],
                              ),
                            "building-ambient-occlusion-ground-radius": new st(
                              Pe.paint_building[
                                "building-ambient-occlusion-ground-radius"
                              ],
                            ),
                            "building-ambient-occlusion-ground-attenuation":
                              new st(
                                Pe.paint_building[
                                  "building-ambient-occlusion-ground-attenuation"
                                ],
                              ),
                            "building-vertical-scale": new st(
                              Pe.paint_building["building-vertical-scale"],
                            ),
                            "building-cast-shadows": new st(
                              Pe.paint_building["building-cast-shadows"],
                            ),
                            "building-color": new vt(
                              Pe.paint_building["building-color"],
                            ),
                            "building-emissive-strength": new vt(
                              Pe.paint_building["building-emissive-strength"],
                            ),
                            "building-color-use-theme": new vt({
                              type: "string",
                              default: "default",
                              "property-type": "data-driven",
                            }),
                          })),
                      },
                      e,
                      i,
                      o,
                    ),
                      (this._stats = {
                        numRenderedVerticesInShadowPass: 0,
                        numRenderedVerticesInTransparentPass: 0,
                      }));
                  }
                  createBucket(n) {
                    return new H0(n);
                  }
                },
                line: class extends Ir {
                  constructor(n, e, i, o) {
                    const a = nb();
                    (super(n, a, e, i, o),
                      a.layout && (this.layout = new Da(a.layout)),
                      (this.gradientVersion = 0),
                      (this.hasElevatedBuckets = !1),
                      (this.hasNonElevatedBuckets = !1));
                  }
                  _handleSpecialPaintPropertyUpdate(n) {
                    if (n === "line-gradient") {
                      const e =
                        this._transitionablePaint._values["line-gradient"].value
                          .expression;
                      ((this.stepInterpolant =
                        e._styleExpression &&
                        e._styleExpression.expression instanceof Ac),
                        (this.gradientVersion =
                          (this.gradientVersion + 1) %
                          Number.MAX_SAFE_INTEGER));
                    }
                  }
                  gradientExpression() {
                    return this._transitionablePaint._values["line-gradient"]
                      .value.expression;
                  }
                  widthExpression() {
                    return this._transitionablePaint._values["line-width"].value
                      .expression;
                  }
                  recalculate(n, e) {
                    (super.recalculate(n, e),
                      (this.paint._values["line-floorwidth"] = (() => {
                        if (Sf) return Sf;
                        const i = nb();
                        return (
                          (Sf = new dE(
                            i.paint.properties["line-width"].specification,
                          )),
                          (Sf.useIntegerZoom = !0),
                          Sf
                        );
                      })().possiblyEvaluate(
                        this._transitioningPaint._values["line-width"].value,
                        n,
                      )));
                  }
                  createBucket(n) {
                    return new xy(n);
                  }
                  getProgramIds() {
                    return [
                      this.paint.get("line-pattern").constantOr(1)
                        ? "linePattern"
                        : "line",
                    ];
                  }
                  getDefaultProgramParams(n, e, i) {
                    const o = tb(this);
                    return {
                      config: new kl(this, { zoom: e, lut: i }),
                      defines: o,
                      overrideFog: !1,
                    };
                  }
                  queryRadius(n) {
                    const e = n,
                      i = rb(
                        Iu("line-width", this, e),
                        Iu("line-gap-width", this, e),
                      ),
                      o = Iu("line-offset", this, e);
                    return (
                      i / 2 + Math.abs(o) + Tm(this.paint.get("line-translate"))
                    );
                  }
                  queryIntersectsFeature(n, e, i, o, a, u) {
                    if (n.queryGeometry.isAboveHorizon) return !1;
                    const d = yv(
                        n.tilespaceGeometry,
                        this.paint.get("line-translate"),
                        this.paint.get("line-translate-anchor"),
                        u.angle,
                        n.pixelToTileUnitsFactor,
                      ),
                      _ =
                        (n.pixelToTileUnitsFactor / 2) *
                        rb(
                          this.paint.get("line-width").evaluate(e, i),
                          this.paint.get("line-gap-width").evaluate(e, i),
                        ),
                      v = this.paint.get("line-offset").evaluate(e, i);
                    return (
                      v &&
                        (o = (function (b, E) {
                          const A = [],
                            M = new ft(0, 0);
                          for (let R = 0; R < b.length; R++) {
                            const k = b[R],
                              N = [];
                            for (let j = 0; j < k.length; j++) {
                              const H = k[j],
                                J = k[j + 1],
                                Q =
                                  j === 0
                                    ? M
                                    : H.sub(k[j - 1])
                                        ._unit()
                                        ._perp(),
                                V =
                                  j === k.length - 1
                                    ? M
                                    : J.sub(H)._unit()._perp(),
                                X = Q._add(V)._unit();
                              (X._mult(1 / (X.x * V.x + X.y * V.y)),
                                N.push(X._mult(E)._add(H)));
                            }
                            A.push(N);
                          }
                          return A;
                        })(o, v * n.pixelToTileUnitsFactor)),
                      (function (b, E, A) {
                        for (let M = 0; M < E.length; M++) {
                          const R = E[M];
                          if (b.length >= 3) {
                            for (let k = 0; k < R.length; k++)
                              if (Gs(b, R[k])) return !0;
                          }
                          if (Zo(b, R, A)) return !0;
                        }
                        return !1;
                      })(d, o, _)
                    );
                  }
                  isTileClipped() {
                    return this.hasNonElevatedBuckets;
                  }
                  isDraped(n) {
                    return !this.hasElevatedBuckets;
                  }
                  hasElevation() {
                    return (
                      this.layout &&
                      this.layout.get("line-elevation-reference") !== "none"
                    );
                  }
                },
                symbol: ng,
                background: class extends Ir {
                  constructor(n, e, i, o) {
                    super(
                      n,
                      {
                        layout:
                          Zb ||
                          (Zb = new Cn({
                            visibility: new st(Pe.layout_background.visibility),
                          })),
                        paint:
                          Xb ||
                          (Xb = new Cn({
                            "background-pitch-alignment": new st(
                              Pe.paint_background["background-pitch-alignment"],
                            ),
                            "background-color": new st(
                              Pe.paint_background["background-color"],
                            ),
                            "background-pattern": new st(
                              Pe.paint_background["background-pattern"],
                            ),
                            "background-opacity": new st(
                              Pe.paint_background["background-opacity"],
                            ),
                            "background-emissive-strength": new st(
                              Pe.paint_background[
                                "background-emissive-strength"
                              ],
                            ),
                            "background-color-use-theme": new vt({
                              type: "string",
                              default: "default",
                              "property-type": "data-driven",
                            }),
                          })),
                      },
                      e,
                      i,
                      o,
                    );
                  }
                  getProgramIds() {
                    return [
                      this.paint.get("background-pattern")
                        ? "backgroundPattern"
                        : "background",
                    ];
                  }
                  getDefaultProgramParams(n, e, i) {
                    return { overrideFog: !1 };
                  }
                  is3D(n) {
                    return (
                      this.paint.get("background-pitch-alignment") ===
                      "viewport"
                    );
                  }
                },
                raster: e1,
                "raster-particle": o1,
                sky: class extends Ir {
                  constructor(n, e, i, o) {
                    (super(
                      n,
                      {
                        layout:
                          n1 ||
                          (n1 = new Cn({
                            visibility: new st(Pe.layout_sky.visibility),
                          })),
                        paint:
                          r1 ||
                          (r1 = new Cn({
                            "sky-type": new st(Pe.paint_sky["sky-type"]),
                            "sky-atmosphere-sun": new st(
                              Pe.paint_sky["sky-atmosphere-sun"],
                            ),
                            "sky-atmosphere-sun-intensity": new st(
                              Pe.paint_sky["sky-atmosphere-sun-intensity"],
                            ),
                            "sky-gradient-center": new st(
                              Pe.paint_sky["sky-gradient-center"],
                            ),
                            "sky-gradient-radius": new st(
                              Pe.paint_sky["sky-gradient-radius"],
                            ),
                            "sky-gradient": new Ra(
                              Pe.paint_sky["sky-gradient"],
                            ),
                            "sky-atmosphere-halo-color": new st(
                              Pe.paint_sky["sky-atmosphere-halo-color"],
                            ),
                            "sky-atmosphere-color": new st(
                              Pe.paint_sky["sky-atmosphere-color"],
                            ),
                            "sky-opacity": new st(Pe.paint_sky["sky-opacity"]),
                            "sky-gradient-use-theme": new vt({
                              type: "string",
                              default: "default",
                              "property-type": "data-driven",
                            }),
                            "sky-atmosphere-halo-color-use-theme": new vt({
                              type: "string",
                              default: "default",
                              "property-type": "data-driven",
                            }),
                            "sky-atmosphere-color-use-theme": new vt({
                              type: "string",
                              default: "default",
                              "property-type": "data-driven",
                            }),
                          })),
                      },
                      e,
                      i,
                      o,
                    ),
                      this._updateColorRamp());
                  }
                  _handleSpecialPaintPropertyUpdate(n) {
                    n === "sky-gradient"
                      ? this._updateColorRamp()
                      : (n !== "sky-atmosphere-sun" &&
                          n !== "sky-atmosphere-halo-color" &&
                          n !== "sky-atmosphere-color" &&
                          n !== "sky-atmosphere-sun-intensity") ||
                        (this._skyboxInvalidated = !0);
                  }
                  _updateColorRamp() {
                    ((this.colorRamp = hf({
                      expression:
                        this._transitionablePaint._values["sky-gradient"].value
                          .expression,
                      evaluationKey: "skyRadialProgress",
                    })),
                      this.colorRampTexture &&
                        (this.colorRampTexture.destroy(),
                        (this.colorRampTexture = null)));
                  }
                  needsSkyboxCapture(n) {
                    if (
                      this._skyboxInvalidated ||
                      !this.skyboxTexture ||
                      !this.skyboxGeometry
                    )
                      return !0;
                    if (!this.paint.get("sky-atmosphere-sun")) {
                      const e = n.style.light.properties.get("position");
                      return (
                        this._lightPosition.azimuthal !== e.azimuthal ||
                        this._lightPosition.polar !== e.polar
                      );
                    }
                    return !1;
                  }
                  getCenter(n, e) {
                    if (this.paint.get("sky-type") === "atmosphere") {
                      const o = this.paint.get("sky-atmosphere-sun"),
                        a = !o,
                        u = n.style.light,
                        d = u.properties.get("position");
                      return (
                        a &&
                          u.properties.get("anchor") === "viewport" &&
                          ri(
                            "The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly.",
                          ),
                        a
                          ? jy(d.azimuthal, 90 - d.polar, e)
                          : jy(o[0], 90 - o[1], e)
                      );
                    }
                    const i = this.paint.get("sky-gradient-center");
                    return jy(i[0], 90 - i[1], e);
                  }
                  isSky() {
                    return !0;
                  }
                  markSkyboxValid(n) {
                    ((this._skyboxInvalidated = !1),
                      (this._lightPosition =
                        n.style.light.properties.get("position")));
                  }
                  hasOffscreenPass() {
                    return !0;
                  }
                  getProgramIds() {
                    const n = this.paint.get("sky-type");
                    return n === "atmosphere"
                      ? ["skyboxCapture", "skybox"]
                      : n === "gradient"
                        ? ["skyboxGradient"]
                        : null;
                  }
                },
                slot: class extends Ir {
                  constructor(n, e, i, o) {
                    super(n, { paint: s1 || (s1 = new Cn({})) }, e, null);
                  }
                },
                model: class extends Ir {
                  constructor(n, e, i, o) {
                    (super(
                      n,
                      {
                        layout:
                          m1 ||
                          (m1 = new Cn({
                            visibility: new st(Pe.layout_model.visibility),
                            "model-id": new vt(Pe.layout_model["model-id"]),
                          })),
                        paint:
                          g1 ||
                          (g1 = new Cn({
                            "model-opacity": new vt(
                              Pe.paint_model["model-opacity"],
                            ),
                            "model-rotation": new vt(
                              Pe.paint_model["model-rotation"],
                            ),
                            "model-scale": new vt(
                              Pe.paint_model["model-scale"],
                            ),
                            "model-translation": new vt(
                              Pe.paint_model["model-translation"],
                            ),
                            "model-color": new vt(
                              Pe.paint_model["model-color"],
                            ),
                            "model-color-mix-intensity": new vt(
                              Pe.paint_model["model-color-mix-intensity"],
                            ),
                            "model-type": new st(Pe.paint_model["model-type"]),
                            "model-cast-shadows": new st(
                              Pe.paint_model["model-cast-shadows"],
                            ),
                            "model-receive-shadows": new st(
                              Pe.paint_model["model-receive-shadows"],
                            ),
                            "model-ambient-occlusion-intensity": new st(
                              Pe.paint_model[
                                "model-ambient-occlusion-intensity"
                              ],
                            ),
                            "model-emissive-strength": new vt(
                              Pe.paint_model["model-emissive-strength"],
                            ),
                            "model-roughness": new vt(
                              Pe.paint_model["model-roughness"],
                            ),
                            "model-height-based-emissive-strength-multiplier":
                              new vt(
                                Pe.paint_model[
                                  "model-height-based-emissive-strength-multiplier"
                                ],
                              ),
                            "model-cutoff-fade-range": new st(
                              Pe.paint_model["model-cutoff-fade-range"],
                            ),
                            "model-front-cutoff": new st(
                              Pe.paint_model["model-front-cutoff"],
                            ),
                            "model-color-use-theme": new vt({
                              type: "string",
                              default: "default",
                              "property-type": "data-driven",
                            }),
                          })),
                      },
                      e,
                      i,
                      o,
                    ),
                      (this._stats = {
                        numRenderedVerticesInShadowPass: 0,
                        numRenderedVerticesInTransparentPass: 0,
                      }));
                  }
                  createBucket(n) {
                    return new Wy(n);
                  }
                  getProgramIds() {
                    return ["model"];
                  }
                  is3D(n) {
                    return !0;
                  }
                  hasShadowPass() {
                    return !0;
                  }
                  canCastShadows() {
                    return !0;
                  }
                  hasLightBeamPass() {
                    return !0;
                  }
                  cutoffRange() {
                    return this.paint.get("model-cutoff-fade-range");
                  }
                  queryRadius(n) {
                    return n instanceof ug ? mt - 1 : 0;
                  }
                  queryIntersectsFeature(n, e, i, o, a, u) {
                    if (!this.modelManager) return !1;
                    const d = this.modelManager,
                      _ = n.tile.getBucket(this);
                    if (!(_ && _ instanceof Wy)) return !1;
                    for (const v in _.instancesPerModel) {
                      const b = _.instancesPerModel[v],
                        E =
                          e.id !== void 0
                            ? e.id
                            : e.properties && e.properties.hasOwnProperty("id")
                              ? e.properties.id
                              : void 0;
                      if (b.idToFeaturesIndex.hasOwnProperty(E)) {
                        const A = b.features[b.idToFeaturesIndex[E]],
                          M = d.getModel(v, this.scope);
                        if (!M) return !1;
                        let R = Ie();
                        const k = new Y(0, 0),
                          N = _.canonical;
                        let j = Number.MAX_VALUE;
                        for (let H = 0; H < A.instancedDataCount; ++H) {
                          const J = 16 * (A.instancedDataOffset + H),
                            Q = b.instancedDataArray.float32,
                            V = [Q[J + 4], Q[J + 5], Q[J + 6]];
                          (w1(N, k, Q[J], 0 | Q[J + 1]),
                            _1(R, M, u, k, A.rotation, A.scale, V, !1, !1, !1),
                            u.projection.name === "globe" && (R = $y(R, u)));
                          const X = Ae([], u.projMatrix, R),
                            ee = n.queryGeometry,
                            re = u1(
                              ee.isPointQuery()
                                ? ee.screenBounds
                                : ee.screenGeometry,
                              u,
                              X,
                              M.aabb,
                            );
                          re != null && (j = Math.min(re, j));
                        }
                        return j !== Number.MAX_VALUE && j;
                      }
                    }
                    return !1;
                  }
                  _handleOverridablePaintPropertyUpdate(n, e, i) {
                    return !(
                      !this.layout ||
                      e.isDataDriven() ||
                      i.isDataDriven() ||
                      (n !== "model-color" &&
                        n !== "model-color-mix-intensity" &&
                        n !== "model-rotation" &&
                        n !== "model-scale" &&
                        n !== "model-translation" &&
                        n !== "model-emissive-strength")
                    );
                  }
                  _isPropertyZoomDependent(n) {
                    const e = this._transitionablePaint._values[n];
                    return (
                      e != null &&
                      e.value != null &&
                      e.value.expression != null &&
                      e.value.expression instanceof Lc
                    );
                  }
                  isZoomDependent() {
                    return (
                      this._isPropertyZoomDependent("model-scale") ||
                      this._isPropertyZoomDependent("model-rotation") ||
                      this._isPropertyZoomDependent("model-translation")
                    );
                  }
                },
                clip: class extends Ir {
                  constructor(n, e, i, o) {
                    super(
                      n,
                      {
                        layout:
                          n0 ||
                          (n0 = new Cn({
                            "clip-layer-types": new st(
                              Pe.layout_clip["clip-layer-types"],
                            ),
                            "clip-layer-scope": new st(
                              Pe.layout_clip["clip-layer-scope"],
                            ),
                          })),
                        paint: r0 || (r0 = new Cn({})),
                      },
                      e,
                      i,
                      o,
                    );
                  }
                  recalculate(n, e) {
                    super.recalculate(n, e);
                  }
                  createBucket(n) {
                    return new s0(n);
                  }
                  is3D(n) {
                    return !0;
                  }
                },
              },
              Yy = new Li(0, 0, 0),
              Ky = { PATH_RULE_NON_ZERO: 1, PATH_RULE_EVEN_ODD: 2 },
              Jy = { LINE_CAP_BUTT: 1, LINE_CAP_ROUND: 2, LINE_CAP_SQUARE: 3 },
              dg = {
                LINE_JOIN_MITER: 1,
                LINE_JOIN_MITER_CLIP: 2,
                LINE_JOIN_ROUND: 3,
                LINE_JOIN_BEVEL: 4,
              },
              gI = { PAINT_ORDER_FILL_AND_STROKE: 1 },
              Ff = {
                PATH_COMMAND_MOVE: 1,
                PATH_COMMAND_LINE: 2,
                PATH_COMMAND_QUAD: 3,
                PATH_COMMAND_CUBIC: 4,
                PATH_COMMAND_CLOSE: 5,
              },
              T1 = { MASK_TYPE_LUMINANCE: 1 };
            function _I(n, e, i) {
              n === 1 &&
                e.icons.push(
                  (function (o, a) {
                    return (function (u) {
                      if (
                        (u.usvg_tree.height ||
                          (u.usvg_tree.height = u.usvg_tree.width),
                        !u.metadata)
                      )
                        return u;
                      const { metadata: d } = u;
                      if (d.content_area) {
                        const { content_area: _ } = d;
                        (_.top == null && (_.top = _.left),
                          _.width == null && (_.width = u.usvg_tree.width),
                          _.height == null && (_.height = _.width));
                      }
                      return (
                        d.stretch_x && d.stretch_x.length && S1(d, "x"),
                        d.stretch_y && d.stretch_y.length && S1(d, "y"),
                        u
                      );
                    })(o.readFields(yI, { name: void 0 }, a));
                  })(i, i.readVarint() + i.pos),
                );
            }
            function S1(n, e) {
              const i = [],
                o = n[`stretch_${e}`];
              let a = null;
              for (let u = 0; u < o.length; u++)
                a === null
                  ? (a = i.length === 0 ? o[0] : i[i.length - 1][1] + o[u])
                  : (i.push([a, a + o[u]]), (a = null));
              n[`stretch_${e}_areas`] = i;
            }
            function yI(n, e, i) {
              n === 1
                ? (e.name = i.readString())
                : n === 2
                  ? (e.metadata = (function (o, a) {
                      return o.readFields(
                        xI,
                        {
                          stretch_x: null,
                          stretch_y: null,
                          stretch_x_areas: null,
                          stretch_y_areas: null,
                          variables: [],
                        },
                        a,
                      );
                    })(i, i.readVarint() + i.pos))
                  : n === 3 &&
                    ((e.usvg_tree = (function (o, a) {
                      return o.readFields(
                        wI,
                        {
                          width: 20,
                          children: [],
                          linear_gradients: [],
                          radial_gradients: [],
                          clip_paths: [],
                          masks: [],
                        },
                        a,
                      );
                    })(i, i.readVarint() + i.pos)),
                    (e.data = "usvg_tree"));
            }
            function xI(n, e, i) {
              n === 1
                ? (e.stretch_x = i.readPackedVarint())
                : n === 2
                  ? (e.stretch_y = i.readPackedVarint())
                  : n === 3
                    ? (e.content_area = (function (o, a) {
                        return o.readFields(vI, { left: 0 }, a);
                      })(i, i.readVarint() + i.pos))
                    : n === 4 &&
                      e.variables.push(
                        (function (o, a) {
                          return o.readFields(bI, { name: void 0 }, a);
                        })(i, i.readVarint() + i.pos),
                      );
            }
            function vI(n, e, i) {
              n === 1
                ? (e.left = i.readVarint())
                : n === 2
                  ? (e.width = i.readVarint())
                  : n === 3
                    ? (e.top = i.readVarint())
                    : n === 4 && (e.height = i.readVarint());
            }
            function bI(n, e, i) {
              n === 1
                ? (e.name = i.readString())
                : n === 2 &&
                  ((e.rgb_color = mg(i.readVarint())), (e.value = "rgb_color"));
            }
            function wI(n, e, i) {
              n === 1
                ? (e.width = e.height = i.readVarint())
                : n === 2
                  ? (e.height = i.readVarint())
                  : n === 3
                    ? e.children.push(fg(i, i.readVarint() + i.pos))
                    : n === 4
                      ? e.linear_gradients.push(
                          (function (o, a) {
                            return o.readFields(
                              CI,
                              {
                                spread_method: 1,
                                stops: [],
                                x1: 0,
                                y1: 0,
                                x2: 1,
                                y2: 0,
                              },
                              a,
                            );
                          })(i, i.readVarint() + i.pos),
                        )
                      : n === 5
                        ? e.radial_gradients.push(
                            (function (o, a) {
                              return o.readFields(
                                DI,
                                {
                                  spread_method: 1,
                                  stops: [],
                                  cx: 0.5,
                                  cy: 0.5,
                                  r: 0.5,
                                  fx: 0.5,
                                  fy: 0.5,
                                  fr: 0,
                                },
                                a,
                              );
                            })(i, i.readVarint() + i.pos),
                          )
                        : n === 7
                          ? e.clip_paths.push(
                              (function (o, a) {
                                return o.readFields(RI, { children: [] }, a);
                              })(i, i.readVarint() + i.pos),
                            )
                          : n === 8 &&
                            e.masks.push(
                              (function (o, a) {
                                const u = o.readFields(
                                  zI,
                                  {
                                    left: 0,
                                    width: 20,
                                    mask_type: T1.MASK_TYPE_LUMINANCE,
                                    children: [],
                                  },
                                  a,
                                );
                                return (
                                  u.height == null && (u.height = u.width),
                                  u.top == null && (u.top = u.left),
                                  u
                                );
                              })(i, i.readVarint() + i.pos),
                            );
            }
            function fg(n, e) {
              return n.readFields(TI, {}, e);
            }
            function TI(n, e, i) {
              n === 1
                ? ((e.group = (function (o, a) {
                    return o.readFields(SI, { opacity: 255, children: [] }, a);
                  })(i, i.readVarint() + i.pos)),
                  (e.node = "group"))
                : n === 2 &&
                  ((e.path = (function (o, a) {
                    return o.readFields(
                      II,
                      {
                        paint_order: 1,
                        commands: [],
                        step: 1,
                        diffs: [],
                        rule: Ky.PATH_RULE_NON_ZERO,
                      },
                      a,
                    );
                  })(i, i.readVarint() + i.pos)),
                  (e.node = "path"));
            }
            function SI(n, e, i) {
              n === 1
                ? (e.transform = pg(i, i.readVarint() + i.pos))
                : n === 2
                  ? (e.opacity = i.readVarint())
                  : n === 5
                    ? (e.clip_path_idx = i.readVarint())
                    : n === 6
                      ? (e.mask_idx = i.readVarint())
                      : n === 7 &&
                        e.children.push(fg(i, i.readVarint() + i.pos));
            }
            function pg(n, e) {
              return n.readFields(
                EI,
                { sx: 1, ky: 0, kx: 0, sy: 1, tx: 0, ty: 0 },
                e,
              );
            }
            function EI(n, e, i) {
              n === 1
                ? (e.sx = i.readFloat())
                : n === 2
                  ? (e.ky = i.readFloat())
                  : n === 3
                    ? (e.kx = i.readFloat())
                    : n === 4
                      ? (e.sy = i.readFloat())
                      : n === 5
                        ? (e.tx = i.readFloat())
                        : n === 6 && (e.ty = i.readFloat());
            }
            function II(n, e, i) {
              n === 1
                ? (e.fill = (function (o, a) {
                    return o.readFields(
                      AI,
                      { rgb_color: Yy, paint: "rgb_color", opacity: 255 },
                      a,
                    );
                  })(i, i.readVarint() + i.pos))
                : n === 2
                  ? (e.stroke = (function (o, a) {
                      return o.readFields(
                        MI,
                        {
                          rgb_color: Yy,
                          paint: "rgb_color",
                          dasharray: [],
                          dashoffset: 0,
                          miterlimit: 4,
                          opacity: 255,
                          width: 1,
                          linecap: 1,
                          linejoin: 1,
                        },
                        a,
                      );
                    })(i, i.readVarint() + i.pos))
                  : n === 3
                    ? (e.paint_order = i.readVarint())
                    : n === 5
                      ? i.readPackedVarint(e.commands)
                      : n === 6
                        ? (e.step = i.readFloat())
                        : n === 7
                          ? i.readPackedSVarint(e.diffs)
                          : n === 8 && (e.rule = i.readVarint());
            }
            function AI(n, e, i) {
              n === 1
                ? ((e.rgb_color = mg(i.readVarint())), (e.paint = "rgb_color"))
                : n === 2
                  ? ((e.linear_gradient_idx = i.readVarint()),
                    (e.paint = "linear_gradient_idx"))
                  : n === 3
                    ? ((e.radial_gradient_idx = i.readVarint()),
                      (e.paint = "radial_gradient_idx"))
                    : n === 5 && (e.opacity = i.readVarint());
            }
            function mg(n) {
              return new Li(
                ((n >> 16) & 255) / 255,
                ((n >> 8) & 255) / 255,
                (255 & n) / 255,
                1,
              );
            }
            function MI(n, e, i) {
              n === 1
                ? ((e.rgb_color = mg(i.readVarint())), (e.paint = "rgb_color"))
                : n === 2
                  ? ((e.linear_gradient_idx = i.readVarint()),
                    (e.paint = "linear_gradient_idx"))
                  : n === 3
                    ? ((e.radial_gradient_idx = i.readVarint()),
                      (e.paint = "radial_gradient_idx"))
                    : n === 5
                      ? i.readPackedFloat(e.dasharray)
                      : n === 6
                        ? (e.dashoffset = i.readFloat())
                        : n === 7
                          ? (e.miterlimit = i.readFloat())
                          : n === 8
                            ? (e.opacity = i.readVarint())
                            : n === 9
                              ? (e.width = i.readFloat())
                              : n === 10
                                ? (e.linecap = i.readVarint())
                                : n === 11 && (e.linejoin = i.readVarint());
            }
            function CI(n, e, i) {
              n === 1
                ? (e.transform = pg(i, i.readVarint() + i.pos))
                : n === 2
                  ? (e.spread_method = i.readVarint())
                  : n === 3
                    ? e.stops.push(E1(i, i.readVarint() + i.pos))
                    : n === 4
                      ? (e.x1 = i.readFloat())
                      : n === 5
                        ? (e.y1 = i.readFloat())
                        : n === 6
                          ? (e.x2 = i.readFloat())
                          : n === 7 && (e.y2 = i.readFloat());
            }
            function E1(n, e) {
              return n.readFields(
                PI,
                { offset: 0, opacity: 255, rgb_color: Yy },
                e,
              );
            }
            function PI(n, e, i) {
              n === 1
                ? (e.offset = i.readFloat())
                : n === 2
                  ? (e.opacity = i.readVarint())
                  : n === 3 && (e.rgb_color = mg(i.readVarint()));
            }
            function DI(n, e, i) {
              n === 1
                ? (e.transform = pg(i, i.readVarint() + i.pos))
                : n === 2
                  ? (e.spread_method = i.readVarint())
                  : n === 3
                    ? e.stops.push(E1(i, i.readVarint() + i.pos))
                    : n === 4
                      ? (e.cx = i.readFloat())
                      : n === 5
                        ? (e.cy = i.readFloat())
                        : n === 6
                          ? (e.r = i.readFloat())
                          : n === 7
                            ? (e.fx = i.readFloat())
                            : n === 8
                              ? (e.fy = i.readFloat())
                              : n === 9 && (e.fr = i.readFloat());
            }
            function RI(n, e, i) {
              n === 1
                ? (e.transform = pg(i, i.readVarint() + i.pos))
                : n === 2
                  ? (e.clip_path_idx = i.readVarint())
                  : n === 3 && e.children.push(fg(i, i.readVarint() + i.pos));
            }
            function zI(n, e, i) {
              n === 1
                ? (e.left = e.top = i.readFloat())
                : n === 2
                  ? (e.width = e.height = i.readFloat())
                  : n === 3
                    ? (e.top = i.readFloat())
                    : n === 4
                      ? (e.height = i.readFloat())
                      : n === 5
                        ? (e.mask_type = i.readVarint())
                        : n === 6
                          ? (e.mask_idx = i.readVarint())
                          : n === 7 &&
                            e.children.push(fg(i, i.readVarint() + i.pos));
            }
            class kI {
              static calculate(e = {}, i = []) {
                const o = new Map(),
                  a = new Map();
                if (Object.keys(e).length === 0) return o;
                i.forEach((u) => {
                  a.set(u.name, u.rgb_color || new Li(0, 0, 0));
                });
                for (const [u, d] of Object.entries(e))
                  a.has(u)
                    ? o.set(a.get(u).toString(), d)
                    : console.warn(`Ignoring unknown image variable "${u}"`);
                return o;
              }
            }
            function Nu(n, e = 255, i) {
              const o = e / 255,
                a = n.toString(),
                u = i.has(a) ? i.get(a).clone() : n.clone();
              return ((u.a *= o), u.toString());
            }
            function Bf(n, e) {
              if (!Mh()) {
                const i = document.createElement("canvas");
                return ((i.width = n), (i.height = e), i);
              }
              return new OffscreenCanvas(n, e);
            }
            function LI(n, e) {
              const i = kI.calculate(
                  e.params,
                  n.metadata ? n.metadata.variables : [],
                ),
                o = n.usvg_tree,
                a = o.width,
                u = o.height,
                d = e.transform ? e.transform : new DOMMatrix(),
                _ = Math.max(1, Math.round(a * d.a)),
                v = Math.max(1, Math.round(u * d.d)),
                b = new DOMMatrix([_ / a, 0, 0, v / u, 0, 0]),
                E = Bf(_, v).getContext("2d");
              return (Qy(E, b, o, o, i), E.getImageData(0, 0, _, v));
            }
            function Qy(n, e, i, o, a) {
              for (const u of o.children) I1(n, e, i, u, a);
            }
            function I1(n, e, i, o, a) {
              o.group
                ? (n.save(),
                  (function (u, d, _, v, b) {
                    const E = v.mask_idx != null ? _.masks[v.mask_idx] : null,
                      A =
                        v.clip_path_idx != null
                          ? _.clip_paths[v.clip_path_idx]
                          : null;
                    if (
                      (v.transform && (d = Vu(v.transform).preMultiplySelf(d)),
                      !(function (k, N, j) {
                        return k.opacity !== 255 || N || j;
                      })(v, A != null, E != null))
                    )
                      return void Qy(u, d, _, v, b);
                    const M = Bf(u.canvas.width, u.canvas.height),
                      R = M.getContext("2d");
                    (Qy(R, d, _, v, b),
                      A && z1(R, d, _, A),
                      E && k1(R, d, _, E, b),
                      (u.globalAlpha = v.opacity / 255),
                      u.drawImage(M, 0, 0));
                  })(n, e, i, o.group, a),
                  n.restore())
                : o.path &&
                  (n.save(),
                  (function (u, d, _, v, b) {
                    (u.setTransform(d),
                      v.paint_order === gI.PAINT_ORDER_FILL_AND_STROKE
                        ? (A1(u, _, v, b), C1(u, _, v, b))
                        : (C1(u, _, v, b), A1(u, _, v, b)));
                  })(n, e, i, o.path, a),
                  n.restore());
            }
            function A1(n, e, i, o) {
              const a = i.fill;
              if (!a) return;
              const u = a.opacity / 255;
              switch ((n.save(), n.beginPath(), L1(i, n), a.paint)) {
                case "rgb_color":
                  n.fillStyle = Nu(a.rgb_color, a.opacity, o);
                  break;
                case "linear_gradient_idx": {
                  const d = e.linear_gradients[a.linear_gradient_idx];
                  (d.transform &&
                    n.setTransform(
                      Vu(d.transform).preMultiplySelf(n.getTransform()),
                    ),
                    (n.fillStyle = P1(n, d, u, o)));
                  break;
                }
                case "radial_gradient_idx": {
                  const d = e.radial_gradients[a.radial_gradient_idx];
                  (d.transform &&
                    n.setTransform(
                      Vu(d.transform).preMultiplySelf(n.getTransform()),
                    ),
                    (n.fillStyle = D1(n, d, u, o)));
                }
              }
              (n.fill(M1(i)), n.restore());
            }
            function M1(n) {
              return n.rule === Ky.PATH_RULE_NON_ZERO
                ? "nonzero"
                : n.rule === Ky.PATH_RULE_EVEN_ODD
                  ? "evenodd"
                  : void 0;
            }
            function C1(n, e, i, o) {
              const a = i.stroke;
              if (!a) return;
              const u = O1(i);
              ((n.lineWidth = a.width),
                (n.miterLimit = a.miterlimit),
                n.setLineDash(a.dasharray),
                (n.lineDashOffset = a.dashoffset));
              const d = a.opacity / 255;
              switch (a.paint) {
                case "rgb_color":
                  n.strokeStyle = Nu(a.rgb_color, a.opacity, o);
                  break;
                case "linear_gradient_idx":
                  n.strokeStyle = P1(
                    n,
                    e.linear_gradients[a.linear_gradient_idx],
                    d,
                    o,
                    !0,
                  );
                  break;
                case "radial_gradient_idx":
                  n.strokeStyle = D1(
                    n,
                    e.radial_gradients[a.radial_gradient_idx],
                    d,
                    o,
                    !0,
                  );
              }
              switch (a.linejoin) {
                case dg.LINE_JOIN_MITER_CLIP:
                case dg.LINE_JOIN_MITER:
                  n.lineJoin = "miter";
                  break;
                case dg.LINE_JOIN_ROUND:
                  n.lineJoin = "round";
                  break;
                case dg.LINE_JOIN_BEVEL:
                  n.lineJoin = "bevel";
              }
              switch (a.linecap) {
                case Jy.LINE_CAP_BUTT:
                  n.lineCap = "butt";
                  break;
                case Jy.LINE_CAP_ROUND:
                  n.lineCap = "round";
                  break;
                case Jy.LINE_CAP_SQUARE:
                  n.lineCap = "square";
              }
              n.stroke(u);
            }
            function P1(n, e, i, o, a = !1) {
              if (e.stops.length === 1) {
                const M = e.stops[0];
                return Nu(M.rgb_color, M.opacity * i, o);
              }
              const { x1: u, y1: d, x2: _, y2: v } = e;
              let b = new DOMPoint(u, d),
                E = new DOMPoint(_, v);
              if (a) {
                const M = Vu(e.transform);
                ((b = M.transformPoint(b)), (E = M.transformPoint(E)));
              }
              const A = n.createLinearGradient(b.x, b.y, E.x, E.y);
              for (const M of e.stops)
                A.addColorStop(M.offset, Nu(M.rgb_color, M.opacity * i, o));
              return A;
            }
            function D1(n, e, i, o, a = !1) {
              if (e.stops.length === 1) {
                const H = e.stops[0];
                return Nu(H.rgb_color, H.opacity * i, o);
              }
              const u = Vu(e.transform),
                { fx: d, fy: _, fr: v, cx: b, cy: E, r: A } = e;
              let M = new DOMPoint(d, _),
                R = new DOMPoint(b, E),
                k = v,
                N = A;
              if (a) {
                ((M = u.transformPoint(M)), (R = u.transformPoint(R)));
                const H = (u.a + u.d) / 2;
                ((k = v * H), (N = e.r * H));
              }
              const j = n.createRadialGradient(M.x, M.y, k, R.x, R.y, N);
              for (const H of e.stops)
                j.addColorStop(H.offset, Nu(H.rgb_color, H.opacity * i, o));
              return j;
            }
            function R1(n, e, i, o) {
              const a = o.transform ? Vu(o.transform).preMultiplySelf(e) : e,
                u = Bf(n.canvas.width, n.canvas.height),
                d = u.getContext("2d");
              for (const v of o.children)
                if (v.group) R1(d, a, i, v.group);
                else if (v.path) {
                  const b = v.path,
                    E = new Path2D();
                  (E.addPath(O1(b), a), d.fill(E, M1(b)));
                }
              const _ =
                o.clip_path_idx != null ? i.clip_paths[o.clip_path_idx] : null;
              (_ && z1(d, a, i, _),
                (n.globalCompositeOperation = "source-over"),
                n.drawImage(u, 0, 0));
            }
            function z1(n, e, i, o) {
              const a = Bf(n.canvas.width, n.canvas.height);
              (R1(a.getContext("2d"), e, i, o),
                (n.globalCompositeOperation = "destination-in"),
                n.drawImage(a, 0, 0));
            }
            function k1(n, e, i, o, a) {
              if (o.children.length === 0) return;
              const u = o.mask_idx != null ? i.masks[o.mask_idx] : null;
              u && k1(n, e, i, u, a);
              const d = n.canvas.width,
                _ = n.canvas.height,
                v = Bf(d, _),
                b = v.getContext("2d"),
                E = o.width,
                A = o.height,
                M = o.left,
                R = o.top,
                k = new Path2D(),
                N = new Path2D();
              (N.rect(M, R, E, A), k.addPath(N, e), b.clip(k));
              for (const J of o.children) I1(b, e, i, J, a);
              const j = b.getImageData(0, 0, d, _),
                H = j.data;
              if (o.mask_type === T1.MASK_TYPE_LUMINANCE)
                for (let J = 0; J < H.length; J += 4)
                  H[J + 3] =
                    (H[J + 3] / 255) *
                    (0.2126 * H[J] + 0.7152 * H[J + 1] + 0.0722 * H[J + 2]);
              (b.putImageData(j, 0, 0),
                (n.globalCompositeOperation = "destination-in"),
                n.drawImage(v, 0, 0));
            }
            function Vu(n) {
              return n
                ? new DOMMatrix([n.sx, n.ky, n.kx, n.sy, n.tx, n.ty])
                : new DOMMatrix();
            }
            function L1(n, e) {
              const i = n.step;
              let o = n.diffs[0] * i,
                a = n.diffs[1] * i;
              e.moveTo(o, a);
              for (let u = 0, d = 2; u < n.commands.length; u++)
                switch (n.commands[u]) {
                  case Ff.PATH_COMMAND_MOVE:
                    ((o += n.diffs[d++] * i),
                      (a += n.diffs[d++] * i),
                      e.moveTo(o, a));
                    break;
                  case Ff.PATH_COMMAND_LINE:
                    ((o += n.diffs[d++] * i),
                      (a += n.diffs[d++] * i),
                      e.lineTo(o, a));
                    break;
                  case Ff.PATH_COMMAND_QUAD: {
                    const _ = o + n.diffs[d++] * i,
                      v = a + n.diffs[d++] * i;
                    ((o = _ + n.diffs[d++] * i),
                      (a = v + n.diffs[d++] * i),
                      e.quadraticCurveTo(_, v, o, a));
                    break;
                  }
                  case Ff.PATH_COMMAND_CUBIC: {
                    const _ = o + n.diffs[d++] * i,
                      v = a + n.diffs[d++] * i,
                      b = _ + n.diffs[d++] * i,
                      E = v + n.diffs[d++] * i;
                    ((o = b + n.diffs[d++] * i),
                      (a = E + n.diffs[d++] * i),
                      e.bezierCurveTo(_, v, b, E, o, a));
                    break;
                  }
                  case Ff.PATH_COMMAND_CLOSE:
                    e.closePath();
                }
              return e;
            }
            function O1(n) {
              return L1(n, new Path2D());
            }
            class gg {
              constructor(e) {
                ((this.capacity = e), (this.cache = new Map()));
              }
              get(e) {
                if (!this.cache.has(e)) return;
                const i = this.cache.get(e);
                return (this.cache.delete(e), this.cache.set(e, i), i);
              }
              put(e, i) {
                (this.cache.has(e)
                  ? this.cache.delete(e)
                  : this.cache.size === this.capacity &&
                    this.cache.delete(this.cache.keys().next().value),
                  this.cache.set(e, i));
              }
              delete(e) {
                this.cache.delete(e);
              }
            }
            Tt(gg, "LRUCache");
            class ex {
              constructor() {
                ((this.cacheMap = new Map()),
                  (this.cacheDependenciesMap = new Map()));
              }
              static _getImage(e) {
                return new xr(e, e.data);
              }
              getFromCache(e, i, o) {
                return (
                  this.cacheMap.has(o) || this.cacheMap.set(o, new gg(150)),
                  this.cacheMap.get(o).get(za(e.toString(), i))
                );
              }
              setInCache(e, i, o, a) {
                (this.cacheDependenciesMap.has(a) ||
                  this.cacheDependenciesMap.set(a, new Map()),
                  this.cacheMap.has(a) || this.cacheMap.set(a, new gg(150)));
                const u = this.cacheDependenciesMap.get(a),
                  d = za(e.id.toString(), o);
                u.get(d) || u.set(d, new Set());
                const _ = this.cacheMap.get(a),
                  v = e.toString();
                (u.get(d).add(v), _.put(za(e.toString(), o), i));
              }
              removeImagesFromCacheByIds(e, i, o = 0) {
                if (!this.cacheMap.has(o) || !this.cacheDependenciesMap.has(o))
                  return;
                const a = this.cacheMap.get(o),
                  u = this.cacheDependenciesMap.get(o);
                for (const d of e) {
                  const _ = za(d.toString(), i);
                  if (u.has(_)) {
                    for (const v of u.get(_)) a.delete(v);
                    u.delete(_);
                  }
                }
              }
              rasterize(e, i, o, a, u = LI) {
                const d = this.getFromCache(e, o, a);
                if (d) return d.clone();
                const _ = u(i.icon, e.options),
                  v = ex._getImage(_);
                return (this.setInCache(e, v, o, a), v.clone());
              }
            }
            class F1 {
              constructor(e) {
                ((this.size = e),
                  (this.minimums = []),
                  (this.maximums = []),
                  (this.leaves = []));
              }
              getElevation(e, i) {
                const o = this.toIdx(e, i);
                return { min: this.minimums[o], max: this.maximums[o] };
              }
              isLeaf(e, i) {
                return this.leaves[this.toIdx(e, i)];
              }
              toIdx(e, i) {
                return i * this.size + e;
              }
            }
            function B1(n, e, i, o) {
              let a = 0,
                u = Number.MAX_VALUE;
              for (let d = 0; d < 3; d++)
                if (Math.abs(o[d]) < 1e-15) {
                  if (i[d] < n[d] || i[d] > e[d]) return null;
                } else {
                  const _ = 1 / o[d];
                  let v = (n[d] - i[d]) * _,
                    b = (e[d] - i[d]) * _;
                  if (v > b) {
                    const E = v;
                    ((v = b), (b = E));
                  }
                  if ((v > a && (a = v), b < u && (u = b), a > u)) return null;
                }
              return a;
            }
            function N1(n, e, i, o, a, u, d, _, v, b, E) {
              const A = o - n,
                M = a - e,
                R = u - i,
                k = d - n,
                N = _ - e,
                j = v - i,
                H = E[1] * j - E[2] * N,
                J = E[2] * k - E[0] * j,
                Q = E[0] * N - E[1] * k,
                V = A * H + M * J + R * Q;
              if (Math.abs(V) < 1e-15) return null;
              const X = 1 / V,
                ee = b[0] - n,
                re = b[1] - e,
                ve = b[2] - i,
                ge = (ee * H + re * J + ve * Q) * X;
              if (ge < 0 || ge > 1) return null;
              const be = re * R - ve * M,
                Me = ve * A - ee * R,
                Ue = ee * M - re * A,
                it = (E[0] * be + E[1] * Me + E[2] * Ue) * X;
              return it < 0 || ge + it > 1
                ? null
                : (k * be + N * Me + j * Ue) * X;
            }
            function V1(n, e, i) {
              return (n - e) / (i - e);
            }
            function U1(n, e, i, o, a, u, d, _, v) {
              const b = 1 << i,
                E = u - o,
                A = d - a,
                M = ((n + 1) / b) * E + o,
                R = ((e + 0) / b) * A + a,
                k = ((e + 1) / b) * A + a;
              ((_[0] = ((n + 0) / b) * E + o),
                (_[1] = R),
                (v[0] = M),
                (v[1] = k));
            }
            class j1 {
              constructor(e) {
                if (
                  ((this.maximums = []),
                  (this.minimums = []),
                  (this.leaves = []),
                  (this.childOffsets = []),
                  (this.nodeCount = 0),
                  (this.dem = e),
                  (this._siblingOffset = [
                    [0, 0],
                    [1, 0],
                    [0, 1],
                    [1, 1],
                  ]),
                  !this.dem)
                )
                  return;
                const i = (function (u) {
                    const d = Math.ceil(Math.log2(u.dim / 8)),
                      _ = [];
                    let v = Math.ceil(Math.pow(2, d));
                    const b = 1 / v,
                      E = (R, k, N, j, H) => {
                        const J = j ? 1 : 0,
                          Q = (R + 1) * N - J,
                          V = k * N,
                          X = (k + 1) * N - J;
                        ((H[0] = R * N), (H[1] = V), (H[2] = Q), (H[3] = X));
                      };
                    let A = new F1(v);
                    const M = [];
                    for (let R = 0; R < v * v; R++) {
                      E(R % v, Math.floor(R / v), b, !1, M);
                      const k = Gl(M[0], M[1], u),
                        N = Gl(M[2], M[1], u),
                        j = Gl(M[2], M[3], u),
                        H = Gl(M[0], M[3], u);
                      (A.minimums.push(Math.min(k, N, j, H)),
                        A.maximums.push(Math.max(k, N, j, H)),
                        A.leaves.push(1));
                    }
                    for (_.push(A), v /= 2; v >= 1; v /= 2) {
                      const R = _[_.length - 1];
                      A = new F1(v);
                      for (let k = 0; k < v * v; k++) {
                        E(k % v, Math.floor(k / v), 2, !0, M);
                        const N = R.getElevation(M[0], M[1]),
                          j = R.getElevation(M[2], M[1]),
                          H = R.getElevation(M[2], M[3]),
                          J = R.getElevation(M[0], M[3]),
                          Q = R.isLeaf(M[0], M[1]),
                          V = R.isLeaf(M[2], M[1]),
                          X = R.isLeaf(M[2], M[3]),
                          ee = R.isLeaf(M[0], M[3]),
                          re = Math.min(N.min, j.min, H.min, J.min),
                          ve = Math.max(N.max, j.max, H.max, J.max),
                          ge = Q && V && X && ee;
                        (A.maximums.push(ve),
                          A.minimums.push(re),
                          A.leaves.push(ve - re <= 5 && ge ? 1 : 0));
                      }
                      _.push(A);
                    }
                    return _;
                  })(this.dem),
                  o = i.length - 1,
                  a = i[o];
                (this._addNode(a.minimums[0], a.maximums[0], a.leaves[0]),
                  this._construct(i, 0, 0, o, 0));
              }
              raycastRoot(e, i, o, a, u, d, _ = 1) {
                return B1([e, i, -100], [o, a, this.maximums[0] * _], u, d);
              }
              raycast(e, i, o, a, u, d, _ = 1) {
                if (!this.nodeCount) return null;
                const v = this.raycastRoot(e, i, o, a, u, d, _);
                if (v == null) return null;
                const b = [],
                  E = [],
                  A = [],
                  M = [],
                  R = [{ idx: 0, t: v, nodex: 0, nodey: 0, depth: 0 }];
                for (; R.length > 0; ) {
                  const {
                    idx: k,
                    t: N,
                    nodex: j,
                    nodey: H,
                    depth: J,
                  } = R.pop();
                  if (this.leaves[k]) {
                    U1(j, H, J, e, i, o, a, A, M);
                    const V = 1 << J,
                      X = (j + 0) / V,
                      ee = (j + 1) / V,
                      re = (H + 0) / V,
                      ve = (H + 1) / V,
                      ge = Gl(X, re, this.dem) * _,
                      be = Gl(ee, re, this.dem) * _,
                      Me = Gl(ee, ve, this.dem) * _,
                      Ue = Gl(X, ve, this.dem) * _,
                      it = N1(
                        A[0],
                        A[1],
                        ge,
                        M[0],
                        A[1],
                        be,
                        M[0],
                        M[1],
                        Me,
                        u,
                        d,
                      ),
                      Xe = N1(
                        M[0],
                        M[1],
                        Me,
                        A[0],
                        M[1],
                        Ue,
                        A[0],
                        A[1],
                        ge,
                        u,
                        d,
                      ),
                      tt = Math.min(
                        it !== null ? it : Number.MAX_VALUE,
                        Xe !== null ? Xe : Number.MAX_VALUE,
                      );
                    if (tt !== Number.MAX_VALUE) return tt;
                    {
                      const nt = _r([], u, d, N);
                      if (
                        G1(
                          ge,
                          be,
                          Ue,
                          Me,
                          V1(nt[0], A[0], M[0]),
                          V1(nt[1], A[1], M[1]),
                        ) >= nt[2]
                      )
                        return N;
                    }
                    continue;
                  }
                  let Q = 0;
                  for (let V = 0; V < this._siblingOffset.length; V++) {
                    (U1(
                      (j << 1) + this._siblingOffset[V][0],
                      (H << 1) + this._siblingOffset[V][1],
                      J + 1,
                      e,
                      i,
                      o,
                      a,
                      A,
                      M,
                    ),
                      (A[2] = -100),
                      (M[2] = this.maximums[this.childOffsets[k] + V] * _));
                    const X = B1(A, M, u, d);
                    if (X != null) {
                      const ee = X;
                      b[V] = ee;
                      let re = !1;
                      for (let ve = 0; ve < Q && !re; ve++)
                        ee >= b[E[ve]] && (E.splice(ve, 0, V), (re = !0));
                      (re || (E[Q] = V), Q++);
                    }
                  }
                  for (let V = 0; V < Q; V++) {
                    const X = E[V];
                    R.push({
                      idx: this.childOffsets[k] + X,
                      t: b[X],
                      nodex: (j << 1) + this._siblingOffset[X][0],
                      nodey: (H << 1) + this._siblingOffset[X][1],
                      depth: J + 1,
                    });
                  }
                }
                return null;
              }
              _addNode(e, i, o) {
                return (
                  this.minimums.push(e),
                  this.maximums.push(i),
                  this.leaves.push(o),
                  this.childOffsets.push(0),
                  this.nodeCount++
                );
              }
              _construct(e, i, o, a, u) {
                if (e[a].isLeaf(i, o) === 1) return;
                this.childOffsets[u] || (this.childOffsets[u] = this.nodeCount);
                const d = a - 1,
                  _ = e[d];
                let v = 0,
                  b = 0;
                for (let E = 0; E < this._siblingOffset.length; E++) {
                  const A = 2 * i + this._siblingOffset[E][0],
                    M = 2 * o + this._siblingOffset[E][1],
                    R = _.getElevation(A, M),
                    k = _.isLeaf(A, M),
                    N = this._addNode(R.min, R.max, k);
                  (k && (v |= 1 << E), b || (b = N));
                }
                for (let E = 0; E < this._siblingOffset.length; E++)
                  v & (1 << E) ||
                    this._construct(
                      e,
                      2 * i + this._siblingOffset[E][0],
                      2 * o + this._siblingOffset[E][1],
                      d,
                      b + E,
                    );
              }
            }
            function G1(n, e, i, o, a, u) {
              return Ht(Ht(n, i, u), Ht(e, o, u), a);
            }
            function Gl(n, e, i) {
              const o = i.dim,
                a = he(n * o - 0.5, 0, o - 1),
                u = he(e * o - 0.5, 0, o - 1),
                d = Math.floor(a),
                _ = Math.floor(u),
                v = Math.min(d + 1, o - 1),
                b = Math.min(_ + 1, o - 1);
              return G1(
                i.get(d, _),
                i.get(v, _),
                i.get(d, b),
                i.get(v, b),
                a - d,
                u - _,
              );
            }
            const OI = {
              mapbox: [6553.6, 25.6, 0.1, 1e4],
              terrarium: [256, 1, 1 / 256, 32768],
            };
            function FI(n, e, i) {
              return (256 * n * 256 + 256 * e + i) / 10 - 1e4;
            }
            function BI(n, e, i) {
              return 256 * n + e + i / 256 - 32768;
            }
            class _g {
              get tree() {
                return (this._tree || this._buildQuadTree(), this._tree);
              }
              constructor(e, i, o, a = !1) {
                if (((this.uid = e), i.height !== i.width))
                  throw new RangeError("DEM tiles must be square");
                if (o && o !== "mapbox" && o !== "terrarium")
                  return void ri(
                    `"${o}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`,
                  );
                this.stride = i.height;
                const u = (this.dim = i.height - 2),
                  d = new Uint32Array(i.data.buffer);
                if (
                  ((this.pixels = new Uint8Array(i.data.buffer)),
                  (this.floatView = new Float32Array(i.data.buffer)),
                  (this.borderReady = a),
                  (this._modifiedForSources = {}),
                  !a)
                ) {
                  for (let v = 0; v < u; v++)
                    ((d[this._idx(-1, v)] = d[this._idx(0, v)]),
                      (d[this._idx(u, v)] = d[this._idx(u - 1, v)]),
                      (d[this._idx(v, -1)] = d[this._idx(v, 0)]),
                      (d[this._idx(v, u)] = d[this._idx(v, u - 1)]));
                  ((d[this._idx(-1, -1)] = d[this._idx(0, 0)]),
                    (d[this._idx(u, -1)] = d[this._idx(u - 1, 0)]),
                    (d[this._idx(-1, u)] = d[this._idx(0, u - 1)]),
                    (d[this._idx(u, u)] = d[this._idx(u - 1, u - 1)]));
                }
                const _ = o === "terrarium" ? BI : FI;
                for (let v = 0; v < d.length; ++v) {
                  const b = 4 * v;
                  this.floatView[v] = _(
                    this.pixels[b],
                    this.pixels[b + 1],
                    this.pixels[b + 2],
                  );
                }
                this._timestamp = As.now();
              }
              _buildQuadTree() {
                this._tree = new j1(this);
              }
              get(e, i, o = !1) {
                o && ((e = he(e, -1, this.dim)), (i = he(i, -1, this.dim)));
                const a = this._idx(e, i);
                return this.floatView[a];
              }
              set(e, i, o) {
                const a = this._idx(e, i),
                  u = this.floatView[a];
                return ((this.floatView[a] = o), o - u);
              }
              static getUnpackVector(e) {
                return OI[e];
              }
              _idx(e, i) {
                if (e < -1 || e >= this.dim + 1 || i < -1 || i >= this.dim + 1)
                  throw new RangeError(
                    "out of range source coordinates for DEM data",
                  );
                return (i + 1) * this.stride + (e + 1);
              }
              static pack(e, i) {
                const o = [0, 0, 0, 0],
                  a = _g.getUnpackVector(i);
                let u = Math.floor((e + a[3]) / a[2]);
                return (
                  (o[2] = u % 256),
                  (u = Math.floor(u / 256)),
                  (o[1] = u % 256),
                  (u = Math.floor(u / 256)),
                  (o[0] = u),
                  o
                );
              }
              getPixels() {
                return new Gv(
                  { width: this.stride, height: this.stride },
                  this.pixels,
                );
              }
              backfillBorder(e, i, o) {
                if (this.dim !== e.dim)
                  throw new Error("dem dimension mismatch");
                let a = i * this.dim,
                  u = i * this.dim + this.dim,
                  d = o * this.dim,
                  _ = o * this.dim + this.dim;
                switch (i) {
                  case -1:
                    a = u - 1;
                    break;
                  case 1:
                    u = a + 1;
                }
                switch (o) {
                  case -1:
                    d = _ - 1;
                    break;
                  case 1:
                    _ = d + 1;
                }
                const v = -i * this.dim,
                  b = -o * this.dim;
                for (let E = d; E < _; E++)
                  for (let A = a; A < u; A++) {
                    const M = 4 * this._idx(A, E),
                      R = 4 * this._idx(A + v, E + b);
                    ((this.pixels[M + 0] = e.pixels[R + 0]),
                      (this.pixels[M + 1] = e.pixels[R + 1]),
                      (this.pixels[M + 2] = e.pixels[R + 2]),
                      (this.pixels[M + 3] = e.pixels[R + 3]));
                  }
              }
              onDeserialize() {
                this._tree && (this._tree.dem = this);
              }
            }
            function NI(n, e, i) {
              n === 1
                ? (e.headerLength = i.readFixed32())
                : n === 2
                  ? (e.x = i.readVarint())
                  : n === 3
                    ? (e.y = i.readVarint())
                    : n === 4
                      ? (e.z = i.readVarint())
                      : n === 5 &&
                        e.layers.push(
                          (function (o, a) {
                            return o.readFields(
                              $I,
                              {
                                version: 0,
                                name: "",
                                units: "",
                                tileSize: 0,
                                buffer: 0,
                                pixelFormat: 0,
                                dataIndex: [],
                              },
                              a,
                            );
                          })(i, i.readVarint() + i.pos),
                        );
            }
            function VI(n, e, i) {
              n === 1
                ? ((e.delta_filter = (function (o, a) {
                    return o.readFields(UI, { blockSize: 0 }, a);
                  })(i, i.readVarint() + i.pos)),
                  (e.filter = "delta_filter"))
                : n === 2
                  ? (i.readVarint(), (e.filter = "zigzag_filter"))
                  : n === 3
                    ? (i.readVarint(), (e.filter = "bitshuffle_filter"))
                    : n === 4 &&
                      (i.readVarint(), (e.filter = "byteshuffle_filter"));
            }
            function UI(n, e, i) {
              n === 1 && (e.blockSize = i.readVarint());
            }
            function jI(n, e, i) {
              n === 1
                ? (i.readVarint(), (e.codec = "gzip_data"))
                : n === 2
                  ? (i.readVarint(), (e.codec = "jpeg_image"))
                  : n === 3
                    ? (i.readVarint(), (e.codec = "webp_image"))
                    : n === 4 && (i.readVarint(), (e.codec = "png_image"));
            }
            function GI(n, e, i) {
              let o = 0,
                a = 0;
              (n === 1
                ? (e.firstByte = i.readFixed64())
                : n === 2
                  ? (e.lastByte = i.readFixed64())
                  : n === 3
                    ? e.filters.push(
                        (function (u, d) {
                          return u.readFields(VI, {}, d);
                        })(i, i.readVarint() + i.pos),
                      )
                    : n === 4
                      ? (e.codec = (function (u, d) {
                          return u.readFields(jI, {}, d);
                        })(i, i.readVarint() + i.pos))
                      : n === 5
                        ? (a = i.readFloat())
                        : n === 6
                          ? (o = i.readFloat())
                          : n === 7
                            ? e.bands.push(i.readString())
                            : n === 8
                              ? (e.offset = i.readDouble())
                              : n === 9 && (e.scale = i.readDouble()),
                e.offset === 0 && (e.offset = a),
                e.scale === 0 && (e.scale = o));
            }
            function $I(n, e, i) {
              n === 1
                ? (e.version = i.readVarint())
                : n === 2
                  ? (e.name = i.readString())
                  : n === 3
                    ? (e.units = i.readString())
                    : n === 4
                      ? (e.tileSize = i.readVarint())
                      : n === 5
                        ? (e.buffer = i.readVarint())
                        : n === 6
                          ? (e.pixelFormat = i.readVarint())
                          : n === 7 &&
                            e.dataIndex.push(
                              (function (o, a) {
                                return o.readFields(
                                  GI,
                                  {
                                    firstByte: 0,
                                    lastByte: 0,
                                    filters: [],
                                    codec: null,
                                    offset: 0,
                                    scale: 0,
                                    bands: [],
                                  },
                                  a,
                                );
                              })(i, i.readVarint() + i.pos),
                            );
            }
            function HI(n, e, i) {
              if (n === 2)
                (function (o, a, u) {
                  o.readFields(WI, u, a);
                })(i, i.readVarint() + i.pos, e);
              else if (n === 3) throw new Error("Not implemented");
            }
            function WI(n, e, i) {
              if (n === 1) {
                let o = 0;
                const a = i.readVarint() + i.pos;
                for (; i.pos < a; ) e[o++] = i.readVarint();
              }
            }
            function qI(n, e) {
              if (e.length !== 4)
                throw new Error(
                  `Expected data of dimension 4 but got ${e.length}.`,
                );
              let i = e[3];
              for (let o = 2; o >= 1; o--) {
                const a = o === 1 ? 1 : 0,
                  u = o === 2 ? 1 : 0;
                for (let d = 0; d < e[0]; d++) {
                  const _ = e[1] * d;
                  for (let v = a; v < e[1]; v++) {
                    const b = e[2] * (v + _);
                    for (let E = u; E < e[2]; E++) {
                      const A = e[3] * (E + b);
                      for (let M = 0; M < e[3]; M++) {
                        const R = A + M;
                        n[R] += n[R - i];
                      }
                    }
                  }
                }
                i *= e[o];
              }
              return n;
            }
            function ZI(n) {
              for (let e = 0, i = n.length; e < i; e++)
                n[e] = (n[e] >>> 1) ^ -(1 & n[e]);
              return n;
            }
            function XI(n, e) {
              switch (e) {
                case "uint32":
                  return n;
                case "uint16":
                  for (let i = 0; i < n.length; i += 2) {
                    const o = n[i],
                      a = n[i + 1];
                    ((n[i] =
                      ((240 & o) >> 4) |
                      ((61440 & o) >> 8) |
                      ((240 & a) << 4) |
                      (61440 & a)),
                      (n[i + 1] =
                        (15 & o) |
                        ((3840 & o) >> 4) |
                        ((15 & a) << 8) |
                        ((3840 & a) << 4)));
                  }
                  return n;
                case "uint8":
                  for (let i = 0; i < n.length; i += 4) {
                    const o = n[i],
                      a = n[i + 1],
                      u = n[i + 2],
                      d = n[i + 3];
                    ((n[i + 0] =
                      ((192 & o) >> 6) |
                      ((192 & a) >> 4) |
                      ((192 & u) >> 2) |
                      (192 & d)),
                      (n[i + 1] =
                        ((48 & o) >> 4) |
                        ((48 & a) >> 2) |
                        (48 & u) |
                        ((48 & d) << 2)),
                      (n[i + 2] =
                        ((12 & o) >> 2) |
                        (12 & a) |
                        ((12 & u) << 2) |
                        ((12 & d) << 4)),
                      (n[i + 3] =
                        (3 & o) |
                        ((3 & a) << 2) |
                        ((3 & u) << 4) |
                        ((3 & d) << 6)));
                  }
                  return n;
                default:
                  throw new Error(`Invalid pixel format, "${e}"`);
              }
            }
            (Tt(_g, "DEMData"), Tt(j1, "DemMinMaxQuadTree", { omit: ["dem"] }));
            var Ls = Uint8Array,
              Nf = Uint16Array,
              YI = Int32Array,
              $1 = new Ls([
                0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4,
                4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0,
              ]),
              H1 = new Ls([
                0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9,
                9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0,
              ]),
              KI = new Ls([
                16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1,
                15,
              ]),
              W1 = function (n, e) {
                for (var i = new Nf(31), o = 0; o < 31; ++o)
                  i[o] = e += 1 << n[o - 1];
                var a = new YI(i[30]);
                for (o = 1; o < 30; ++o)
                  for (var u = i[o]; u < i[o + 1]; ++u)
                    a[u] = ((u - i[o]) << 5) | o;
                return { b: i, r: a };
              },
              q1 = W1($1, 2),
              Z1 = q1.b,
              JI = q1.r;
            ((Z1[28] = 258), (JI[258] = 28));
            for (
              var QI = W1(H1, 0).b, X1 = new Nf(32768), Qn = 0;
              Qn < 32768;
              ++Qn
            ) {
              var Uu = ((43690 & Qn) >> 1) | ((21845 & Qn) << 1);
              X1[Qn] =
                (((65280 &
                  (Uu =
                    ((61680 &
                      (Uu = ((52428 & Uu) >> 2) | ((13107 & Uu) << 2))) >>
                      4) |
                    ((3855 & Uu) << 4))) >>
                  8) |
                  ((255 & Uu) << 8)) >>
                1;
            }
            var Vf = function (n, e, i) {
                for (var o = n.length, a = 0, u = new Nf(e); a < o; ++a)
                  n[a] && ++u[n[a] - 1];
                var d,
                  _ = new Nf(e);
                for (a = 1; a < e; ++a) _[a] = (_[a - 1] + u[a - 1]) << 1;
                d = new Nf(1 << e);
                var v = 15 - e;
                for (a = 0; a < o; ++a)
                  if (n[a])
                    for (
                      var b = (a << 4) | n[a],
                        E = e - n[a],
                        A = _[n[a] - 1]++ << E,
                        M = A | ((1 << E) - 1);
                      A <= M;
                      ++A
                    )
                      d[X1[A] >> v] = b;
                return d;
              },
              Uf = new Ls(288);
            for (Qn = 0; Qn < 144; ++Qn) Uf[Qn] = 8;
            for (Qn = 144; Qn < 256; ++Qn) Uf[Qn] = 9;
            for (Qn = 256; Qn < 280; ++Qn) Uf[Qn] = 7;
            for (Qn = 280; Qn < 288; ++Qn) Uf[Qn] = 8;
            var Y1 = new Ls(32);
            for (Qn = 0; Qn < 32; ++Qn) Y1[Qn] = 5;
            var eA = Vf(Uf, 9),
              tA = Vf(Y1, 5),
              tx = function (n) {
                for (var e = n[0], i = 1; i < n.length; ++i)
                  n[i] > e && (e = n[i]);
                return e;
              },
              xo = function (n, e, i) {
                var o = (e / 8) | 0;
                return ((n[o] | (n[o + 1] << 8)) >> (7 & e)) & i;
              },
              ix = function (n, e) {
                var i = (e / 8) | 0;
                return (n[i] | (n[i + 1] << 8) | (n[i + 2] << 16)) >> (7 & e);
              },
              iA = [
                "unexpected EOF",
                "invalid block type",
                "invalid length/literal",
                "invalid distance",
                "stream finished",
                "no stream handler",
                ,
                "no callback",
                "invalid UTF-8 data",
                "extra field too long",
                "date not in range 1980-2099",
                "filename too long",
                "stream finishing",
                "invalid zip data",
              ],
              vo = function (n, e, i) {
                var o = new Error(e || iA[n]);
                if (
                  ((o.code = n),
                  Error.captureStackTrace && Error.captureStackTrace(o, vo),
                  !i)
                )
                  throw o;
                return o;
              },
              nA = new Ls(0),
              rA = typeof TextDecoder < "u" && new TextDecoder();
            try {
              rA.decode(nA, { stream: !0 });
            } catch {}
            const sA = { gzip_data: "gzip" };
            class $s extends Error {
              constructor(e) {
                (super(e), (this.name = "MRTError"));
              }
            }
            const oA = { 0: "uint32", 1: "uint32", 2: "uint16", 3: "uint8" },
              K1 = { uint32: 1, uint16: 2, uint8: 4 },
              aA = {
                uint32: Uint32Array,
                uint16: Uint16Array,
                uint8: Uint8Array,
              };
            let nx;
            class yg {
              constructor(e = 5) {
                ((this.x = NaN),
                  (this.y = NaN),
                  (this.z = NaN),
                  (this.layers = {}),
                  (this._cacheSize = e));
              }
              getLayer(e) {
                const i = this.layers[e];
                if (!i) throw new $s(`Layer '${e}' not found`);
                return i;
              }
              getHeaderLength(e) {
                const i = new Uint8Array(e),
                  o = new DataView(e);
                if (i[0] !== 13) throw new $s("File is not a valid MRT.");
                return o.getUint32(1, !0);
              }
              parseHeader(e) {
                const i = new Uint8Array(e),
                  o = this.getHeaderLength(e);
                if (i.length < o)
                  throw new $s(
                    `Expected header with length >= ${o} but got buffer of length ${i.length}`,
                  );
                const a = (function (u, d) {
                  return u.readFields(
                    NI,
                    { headerLength: 0, x: 0, y: 0, z: 0, layers: [] },
                    void 0,
                  );
                })(new nx(i.subarray(0, o)));
                if (
                  !isNaN(this.x) &&
                  (this.x !== a.x || this.y !== a.y || this.z !== a.z)
                )
                  throw new $s(
                    `Invalid attempt to parse header ${a.z}/${a.x}/${a.y} for tile ${this.z}/${this.x}/${this.y}`,
                  );
                ((this.x = a.x), (this.y = a.y), (this.z = a.z));
                for (const u of a.layers)
                  this.layers[u.name] = new J1(u, {
                    cacheSize: this._cacheSize,
                  });
                return this;
              }
              createDecodingTask(e) {
                const i = [],
                  o = this.getLayer(e.layerName);
                for (let a of e.blockIndices) {
                  const u = o.dataIndex[a],
                    d = u.firstByte - e.firstByte,
                    _ = u.lastByte - e.firstByte;
                  if (o._blocksInProgress.has(a)) continue;
                  const v = {
                    layerName: o.name,
                    firstByte: d,
                    lastByte: _,
                    pixelFormat: o.pixelFormat,
                    blockIndex: a,
                    blockShape: [u.bands.length].concat(o.bandShape),
                    buffer: o.buffer,
                    codec: u.codec.codec,
                    filters: u.filters.map((b) => b.filter),
                  };
                  (o._blocksInProgress.add(a), i.push(v));
                }
                return new Q1(
                  i,
                  () => {
                    i.forEach((a) => o._blocksInProgress.delete(a.blockIndex));
                  },
                  (a, u) => {
                    if (
                      (i.forEach((d) =>
                        o._blocksInProgress.delete(d.blockIndex),
                      ),
                      a)
                    )
                      throw a;
                    u.forEach((d) => {
                      this.getLayer(d.layerName).processDecodedData(d);
                    });
                  },
                );
              }
            }
            class J1 {
              constructor(
                {
                  version: e,
                  name: i,
                  units: o,
                  tileSize: a,
                  pixelFormat: u,
                  buffer: d,
                  dataIndex: _,
                },
                v,
              ) {
                if (((this.version = e), this.version !== 1))
                  throw new $s(
                    `Cannot parse raster layer encoded with MRT version ${e}`,
                  );
                ((this.name = i),
                  (this.units = o),
                  (this.tileSize = a),
                  (this.buffer = d),
                  (this.pixelFormat = oA[u]),
                  (this.dataIndex = _),
                  (this.bandShape = [
                    a + 2 * d,
                    a + 2 * d,
                    K1[this.pixelFormat],
                  ]),
                  (this._decodedBlocks = new gg(v ? v.cacheSize : 5)),
                  (this._blocksInProgress = new Set()));
              }
              get dimension() {
                return K1[this.pixelFormat];
              }
              get cacheSize() {
                return this._decodedBlocks.capacity;
              }
              getBandList() {
                return this.dataIndex.map(({ bands: e }) => e).flat();
              }
              processDecodedData(e) {
                const i = e.blockIndex.toString();
                this._decodedBlocks.get(i) ||
                  this._decodedBlocks.put(i, e.data);
              }
              getBlockForBand(e) {
                let i = 0;
                switch (typeof e) {
                  case "string":
                    for (const [o, a] of this.dataIndex.entries()) {
                      for (const [u, d] of a.bands.entries())
                        if (d === e)
                          return {
                            bandIndex: i + u,
                            blockIndex: o,
                            blockBandIndex: u,
                          };
                      i += a.bands.length;
                    }
                    break;
                  case "number":
                    for (const [o, a] of this.dataIndex.entries()) {
                      if (e >= i && e < i + a.bands.length)
                        return {
                          bandIndex: e,
                          blockIndex: o,
                          blockBandIndex: e - i,
                        };
                      i += a.bands.length;
                    }
                    break;
                  default:
                    throw new $s(
                      `Invalid band \`${JSON.stringify(e)}\`. Expected string or integer.`,
                    );
                }
                return { blockIndex: -1, blockBandIndex: -1 };
              }
              getDataRange(e) {
                let i = 1 / 0,
                  o = -1 / 0;
                const a = [],
                  u = new Set();
                for (const d of e) {
                  const { blockIndex: _ } = this.getBlockForBand(d);
                  if (_ < 0) throw new $s(`Invalid band: ${JSON.stringify(d)}`);
                  const v = this.dataIndex[_];
                  (a.includes(_) || a.push(_),
                    u.add(_),
                    (i = Math.min(i, v.firstByte)),
                    (o = Math.max(o, v.lastByte)));
                }
                if (u.size > this.cacheSize)
                  throw new $s(
                    `Number of blocks to decode (${u.size}) exceeds cache size (${this.cacheSize}).`,
                  );
                return {
                  layerName: this.name,
                  firstByte: i,
                  lastByte: o,
                  blockIndices: a,
                };
              }
              hasBand(e) {
                const { blockIndex: i } = this.getBlockForBand(e);
                return i >= 0;
              }
              hasDataForBand(e) {
                const { blockIndex: i } = this.getBlockForBand(e);
                return i >= 0 && !!this._decodedBlocks.get(i.toString());
              }
              getBandView(e) {
                const { blockIndex: i, blockBandIndex: o } =
                  this.getBlockForBand(e);
                if (i < 0) throw new $s(`Band not found: ${JSON.stringify(e)}`);
                const a = this._decodedBlocks.get(i.toString());
                if (!a)
                  throw new $s(
                    `Data for band ${JSON.stringify(e)} of layer "${this.name}" not decoded.`,
                  );
                const u = this.dataIndex[i],
                  d = this.bandShape.reduce((b, E) => b * E, 1),
                  _ = o * d,
                  v = a.subarray(_, _ + d);
                return {
                  data: v,
                  bytes: new Uint8Array(v.buffer).subarray(
                    v.byteOffset,
                    v.byteOffset + v.byteLength,
                  ),
                  tileSize: this.tileSize,
                  buffer: this.buffer,
                  pixelFormat: this.pixelFormat,
                  dimension: this.dimension,
                  offset: u.offset,
                  scale: u.scale,
                };
              }
            }
            yg.setPbf = function (n) {
              nx = n;
            };
            class Q1 {
              constructor(e, i, o) {
                ((this.tasks = e),
                  (this._onCancel = i),
                  (this._onComplete = o),
                  (this._finalized = !1));
              }
              cancel() {
                this._finalized || (this._onCancel(), (this._finalized = !0));
              }
              complete(e, i) {
                this._finalized ||
                  (this._onComplete(e, i), (this._finalized = !0));
              }
            }
            function ch(n, e) {
              const i = n.json.bufferViews[e.bufferView],
                o = Nm[e.componentType];
              return new o(
                n.buffers[i.buffer],
                (e.byteOffset || 0) + (i.byteOffset || 0),
                e.count *
                  (i.byteStride &&
                  i.byteStride !== Tf[e.type] * o.BYTES_PER_ELEMENT
                    ? i.byteStride / o.BYTES_PER_ELEMENT
                    : Tf[e.type]),
              );
            }
            function rx(n, e, i, o) {
              const a = Nm[e.componentType],
                u = (function (E) {
                  switch (E) {
                    case Int8Array:
                      return 1 / 127;
                    case Uint8Array:
                      return 1 / 255;
                    case Int16Array:
                      return 1 / 32767;
                    case Uint16Array:
                      return 1 / 65535;
                    default:
                      return 1;
                  }
                })(a),
                d = n.json.bufferViews[e.bufferView],
                _ = d.byteStride
                  ? d.byteStride / a.BYTES_PER_ELEMENT
                  : Tf[e.type],
                v = i.float32,
                b = v.length / i.capacity;
              for (let E = 0, A = 0; E < e.count * _; E += _, A += b)
                for (let M = 0; M < b; M++) v[A + M] = o[E + M] * u;
              i._trim();
            }
            function lA(n, e, i) {
              const o = n.indices,
                a = n.attributes,
                u = {};
              u.indexArray = new dr();
              const d = e.json.accessors[o],
                _ = d.count / 3;
              u.indexArray.reserve(_);
              const v = ch(e, d);
              for (let M = 0; M < _; M++)
                u.indexArray.emplaceBack(v[3 * M], v[3 * M + 1], v[3 * M + 2]);
              (u.indexArray._trim(), (u.vertexArray = new Vs()));
              const b = e.json.accessors[a.POSITION];
              u.vertexArray.reserve(b.count);
              const E = ch(e, b);
              for (let M = 0; M < b.count; M++)
                u.vertexArray.emplaceBack(E[3 * M], E[3 * M + 1], E[3 * M + 2]);
              if (
                (u.vertexArray._trim(),
                (u.aabb = new Ci(b.min, b.max)),
                (u.centroid = (function (M, R) {
                  const k = [0, 0, 0],
                    N = M.length;
                  if (N > 0) {
                    for (let j = 0; j < N; j++) {
                      const H = 3 * M[j];
                      ((k[0] += R[H]), (k[1] += R[H + 1]), (k[2] += R[H + 2]));
                    }
                    ((k[0] /= N), (k[1] /= N), (k[2] /= N));
                  }
                  return k;
                })(v, E)),
                a.COLOR_0 !== void 0)
              ) {
                const M = e.json.accessors[a.COLOR_0],
                  R = Tf[M.type],
                  k = ch(e, M);
                ((u.colorArray = R === 3 ? new Vs() : new ur()),
                  u.colorArray.resize(M.count),
                  rx(e, M, u.colorArray, k));
              }
              if (a.NORMAL !== void 0) {
                u.normalArray = new Vs();
                const M = e.json.accessors[a.NORMAL];
                u.normalArray.resize(M.count);
                const R = ch(e, M);
                rx(e, M, u.normalArray, R);
              }
              if (a.TEXCOORD_0 !== void 0 && i.length > 0) {
                u.texcoordArray = new ka();
                const M = e.json.accessors[a.TEXCOORD_0];
                u.texcoordArray.resize(M.count);
                const R = ch(e, M);
                rx(e, M, u.texcoordArray, R);
              }
              if (a._FEATURE_ID_RGBA4444 !== void 0) {
                const M = e.json.accessors[a._FEATURE_ID_RGBA4444];
                e.json.extensionsUsed &&
                  e.json.extensionsUsed.includes("EXT_meshopt_compression") &&
                  (u.featureData = ch(e, M));
              }
              a._FEATURE_RGBA4444 !== void 0 &&
                (u.featureData = new Uint32Array(
                  ch(e, e.json.accessors[a._FEATURE_RGBA4444]).buffer,
                ));
              const A = n.material;
              return (
                (u.material = (function (M, R) {
                  const {
                      emissiveFactor: k = [0, 0, 0],
                      alphaMode: N = "OPAQUE",
                      alphaCutoff: j = 0.5,
                      normalTexture: H,
                      occlusionTexture: J,
                      emissiveTexture: Q,
                      doubleSided: V,
                    } = M,
                    {
                      baseColorFactor: X = [1, 1, 1, 1],
                      metallicFactor: ee = 1,
                      roughnessFactor: re = 1,
                      baseColorTexture: ve,
                      metallicRoughnessTexture: ge,
                    } = M.pbrMetallicRoughness || {},
                    be = J ? R[J.index] : void 0;
                  if (
                    J &&
                    J.extensions &&
                    J.extensions.KHR_texture_transform &&
                    be
                  ) {
                    const Me = J.extensions.KHR_texture_transform;
                    be.offsetScale = [
                      Me.offset[0],
                      Me.offset[1],
                      Me.scale[0],
                      Me.scale[1],
                    ];
                  }
                  return {
                    pbrMetallicRoughness: {
                      baseColorFactor: new Li(...X),
                      metallicFactor: ee,
                      roughnessFactor: re,
                      baseColorTexture: ve ? R[ve.index] : void 0,
                      metallicRoughnessTexture: ge ? R[ge.index] : void 0,
                    },
                    doubleSided: V,
                    emissiveFactor: new Li(...k),
                    alphaMode: N,
                    alphaCutoff: j,
                    normalTexture: H ? R[H.index] : void 0,
                    occlusionTexture: be,
                    emissionTexture: Q ? R[Q.index] : void 0,
                    defined: M.defined === void 0,
                  };
                })(A !== void 0 ? e.json.materials[A] : { defined: !1 }, i)),
                u
              );
            }
            function ew(n, e, i) {
              const {
                  matrix: o,
                  rotation: a,
                  translation: u,
                  scale: d,
                  mesh: _,
                  extras: v,
                  children: b,
                } = n,
                E = {};
              if (
                ((E.matrix =
                  o ||
                  (function (A, M, R, k) {
                    var N = M[0],
                      j = M[1],
                      H = M[2],
                      J = M[3],
                      Q = N + N,
                      V = j + j,
                      X = H + H,
                      ee = N * Q,
                      re = N * V,
                      ve = N * X,
                      ge = j * V,
                      be = j * X,
                      Me = H * X,
                      Ue = J * Q,
                      it = J * V,
                      Xe = J * X,
                      tt = k[0],
                      nt = k[1],
                      Ge = k[2];
                    return (
                      (A[0] = (1 - (ge + Me)) * tt),
                      (A[1] = (re + Xe) * tt),
                      (A[2] = (ve - it) * tt),
                      (A[3] = 0),
                      (A[4] = (re - Xe) * nt),
                      (A[5] = (1 - (ee + Me)) * nt),
                      (A[6] = (be + Ue) * nt),
                      (A[7] = 0),
                      (A[8] = (ve + it) * Ge),
                      (A[9] = (be - Ue) * Ge),
                      (A[10] = (1 - (ee + ge)) * Ge),
                      (A[11] = 0),
                      (A[12] = R[0]),
                      (A[13] = R[1]),
                      (A[14] = R[2]),
                      (A[15] = 1),
                      A
                    );
                  })([], a || [0, 0, 0, 1], u || [0, 0, 0], d || [1, 1, 1])),
                _ !== void 0)
              ) {
                E.meshes = i[_];
                const A = (E.anchor = [0, 0]);
                for (const M of E.meshes) {
                  const { min: R, max: k } = M.aabb;
                  ((A[0] += R[0] + k[0]), (A[1] += R[1] + k[1]));
                }
                ((A[0] = Math.floor(A[0] / E.meshes.length / 2)),
                  (A[1] = Math.floor(A[1] / E.meshes.length / 2)));
              }
              if (
                (v &&
                  (v.id && (E.id = v.id),
                  v.lights &&
                    (E.lights = (function (A) {
                      if (!A.length) return [];
                      const M = (function (H) {
                          const J = atob(H),
                            Q = new Uint8Array(J.length);
                          for (let V = 0; V < J.length; V++)
                            Q[V] = J.codePointAt(V);
                          return Q;
                        })(A),
                        R = [],
                        k = M.length / 24,
                        N = new Uint16Array(M.buffer),
                        j = new Float32Array(M.buffer);
                      for (let H = 0; H < k; H++) {
                        const J = N[2 * H * 6] / 30,
                          Q = N[2 * H * 6 + 1] / 30,
                          V = N[2 * H * 6 + 10] / 100,
                          X = j[6 * H + 1],
                          ee = j[6 * H + 2],
                          re = j[6 * H + 3],
                          ve = j[6 * H + 4],
                          ge = re - X,
                          be = ve - ee,
                          Me = Math.hypot(ge, be);
                        R.push({
                          pos: [X + 0.5 * ge, ee + 0.5 * be, Q],
                          normal: [be / Me, -ge / Me, 0],
                          width: Me,
                          height: J,
                          depth: V,
                          points: [X, ee, re, ve],
                        });
                      }
                      return R;
                    })(v.lights))),
                b)
              ) {
                const A = [];
                for (const M of b) A.push(ew(e.json.nodes[M], e, i));
                E.children = A;
              }
              return E;
            }
            function cA(n) {
              if (n.vertices.length === 0 || n.indices.length === 0)
                return null;
              const e = new ay(n.vertices, n.indices, 8, 256),
                [i, o] = [e.min.clone(), e.max.clone()];
              return {
                vertices: n.vertices,
                indices: n.indices,
                grid: e,
                min: i,
                max: o,
              };
            }
            function hA(n) {
              if (!n.extras || !n.extras.ground) return null;
              const e = n.extras.ground;
              if (!e || !Array.isArray(e) || e.length === 0) return null;
              const i = e[0];
              if (!i || !Array.isArray(i) || i.length === 0) return null;
              const o = [];
              for (const d of i) {
                if (!Array.isArray(d) || d.length !== 2) continue;
                const _ = d[0],
                  v = d[1];
                typeof _ == "number" &&
                  typeof v == "number" &&
                  o.push(new ft(_, v));
              }
              if (o.length < 3) return null;
              o.length > 1 && o[o.length - 1].equals(o[0]) && o.pop();
              let a = 0;
              for (let d = 0; d < o.length; d++) {
                const _ = o[d],
                  v = o[(d + 1) % o.length],
                  b = o[(d + 2) % o.length];
                a += (_.x - v.x) * (b.y - v.y) - (b.x - v.x) * (_.y - v.y);
              }
              a > 0 && o.reverse();
              const u = uf(
                o.flatMap((d) => [d.x, d.y]),
                [],
              );
              return u.length === 0 ? null : { vertices: o, indices: u };
            }
            function uA(n, e) {
              const i = [],
                o = [];
              let a = 0;
              const u = [];
              for (const d of n) {
                a = i.length;
                const _ = d.vertexArray.float32,
                  v = d.indexArray.uint16;
                for (let b = 0; b < d.vertexArray.length; b++)
                  ((u[0] = _[3 * b + 0]),
                    (u[1] = _[3 * b + 1]),
                    (u[2] = _[3 * b + 2]),
                    mn(u, u, e),
                    i.push(new ft(u[0], u[1])));
                for (let b = 0; b < 3 * d.indexArray.length; b++)
                  o.push(v[b] + a);
              }
              if (o.length % 3 != 0) return null;
              for (let d = 0; d < o.length; d += 3) {
                const _ = i[o[d + 0]],
                  v = i[o[d + 1]],
                  b = i[o[d + 2]];
                (_.x - v.x) * (b.y - v.y) - (b.x - v.x) * (_.y - v.y) > 0 &&
                  ([o[d + 1], o[d + 2]] = [o[d + 2], o[d + 1]]);
              }
              return { vertices: i, indices: o };
            }
            function tw(n) {
              const e = (function (v, b) {
                  const E = [],
                    A = WebGL2RenderingContext;
                  if (v.json.textures)
                    for (const M of v.json.textures) {
                      const R = {
                        magFilter: A.LINEAR,
                        minFilter: A.NEAREST,
                        wrapS: A.REPEAT,
                        wrapT: A.REPEAT,
                      };
                      (M.sampler !== void 0 &&
                        Object.assign(R, v.json.samplers[M.sampler]),
                        E.push({
                          image: b[M.source],
                          sampler: R,
                          uploaded: !1,
                        }));
                    }
                  return E;
                })(n, n.images),
                i = (function (v, b) {
                  const E = [];
                  for (const A of v.json.meshes) {
                    const M = [];
                    for (const R of A.primitives) M.push(lA(R, v, b));
                    E.push(M);
                  }
                  return E;
                })(n, e),
                { scenes: o, scene: a, nodes: u } = n.json,
                d = o ? o[a || 0].nodes : u,
                _ = [];
              for (const v of d) _.push(ew(u[v], n, i));
              return (
                (function (v, b, E) {
                  const A = {},
                    M = new Set();
                  for (let R = 0; R < v.length; R++) {
                    const k = E[b[R]];
                    if (!k.extras) continue;
                    const N = k.extras["mapbox:footprint:version"],
                      j = k.extras["mapbox:footprint:id"];
                    ((N || j) && M.add(R), N === "1.0.0" && j && (A[j] = R));
                  }
                  for (let R = 0; R < v.length; R++) {
                    if (M.has(R)) continue;
                    const k = v[R],
                      N = E[b[R]];
                    if (!N.extras) continue;
                    let j = null;
                    (k.id in A && (j = uA(v[A[k.id]].meshes, k.matrix)),
                      j || (j = hA(N)),
                      j && (k.footprint = cA(j)));
                  }
                  if (M.size > 0) {
                    const R = Array.from(M.values()).sort((k, N) => k - N);
                    for (let k = R.length - 1; k >= 0; k--) v.splice(R[k], 1);
                  }
                })(_, d, n.json.nodes),
                _
              );
            }
            function dA(n) {
              ((n.heightmap = new Float32Array(4096)), n.heightmap.fill(-1));
              const e = n.vertexArray.float32,
                i = n.aabb.min[0] - 1,
                o = n.aabb.min[1] - 1,
                a = ah / (n.aabb.max[0] - i + 2),
                u = ah / (n.aabb.max[1] - o + 2);
              for (let d = 0; d < e.length; d += 3) {
                const _ = e[d + 2],
                  v = ((e[d + 0] - i) * a) | 0,
                  b = ((e[d + 1] - o) * u) | 0;
                _ > n.heightmap[b * ah + v] && (n.heightmap[b * ah + v] = _);
              }
            }
            function fA(n, e) {
              const i = {};
              ((i.indexArray = new dr()),
                i.indexArray.reserve(4 * n.length),
                (i.vertexArray = new Vs()),
                i.vertexArray.reserve(10 * n.length),
                (i.colorArray = new ur()),
                i.vertexArray.reserve(10 * n.length));
              let o = 0;
              for (const d of n) {
                const _ = Math.min(10, Math.max(4, 1.3 * d.height)) * e,
                  v = [-d.normal[1], d.normal[0], 0],
                  b = Math.min(0.29, (0.1 * d.width) / d.depth),
                  E = d.width - 2 * d.depth * e * (b + 0.01),
                  A = _r([], d.pos, v, E / 2),
                  M = _r([], d.pos, v, -E / 2),
                  R = [A[0], A[1], A[2] + d.height],
                  k = [M[0], M[1], M[2] + d.height],
                  N = _r([], d.normal, v, b);
                Vi(N, N, _);
                const j = _r([], d.normal, v, -b);
                (Vi(j, j, _),
                  ei(N, A, N),
                  ei(j, M, j),
                  (A[2] += 0.1),
                  (M[2] += 0.1),
                  i.vertexArray.emplaceBack(N[0], N[1], N[2]),
                  i.vertexArray.emplaceBack(j[0], j[1], j[2]),
                  i.vertexArray.emplaceBack(A[0], A[1], A[2]),
                  i.vertexArray.emplaceBack(M[0], M[1], M[2]),
                  i.vertexArray.emplaceBack(R[0], R[1], R[2]),
                  i.vertexArray.emplaceBack(k[0], k[1], k[2]),
                  i.vertexArray.emplaceBack(A[0], A[1], A[2]),
                  i.vertexArray.emplaceBack(M[0], M[1], M[2]),
                  i.vertexArray.emplaceBack(N[0], N[1], N[2]),
                  i.vertexArray.emplaceBack(j[0], j[1], j[2]));
                const H = E / _ / 2;
                (i.colorArray.emplaceBack(-H - b, -1, H, 0.8),
                  i.colorArray.emplaceBack(H + b, -1, H, 0.8),
                  i.colorArray.emplaceBack(-H, 0, H, 1.3),
                  i.colorArray.emplaceBack(H, 0, H, 1.3),
                  i.colorArray.emplaceBack(H + b, -0.8, H, 0.7),
                  i.colorArray.emplaceBack(H + b, -0.8, H, 0.7),
                  i.colorArray.emplaceBack(0, 0, H, 1.3),
                  i.colorArray.emplaceBack(0, 0, H, 1.3),
                  i.colorArray.emplaceBack(H + b, -1.2, H, 0.8),
                  i.colorArray.emplaceBack(H + b, -1.2, H, 0.8),
                  i.indexArray.emplaceBack(6 + o, 4 + o, 8 + o),
                  i.indexArray.emplaceBack(7 + o, 9 + o, 5 + o),
                  i.indexArray.emplaceBack(0 + o, 1 + o, 2 + o),
                  i.indexArray.emplaceBack(1 + o, 3 + o, 2 + o),
                  (o += 10));
              }
              const a = { defined: !0 };
              a.emissiveFactor = Li.black;
              const u = {};
              return (
                (u.baseColorFactor = Li.white),
                (a.pbrMetallicRoughness = u),
                (i.material = a),
                (i.aabb = new Ci(
                  [1 / 0, 1 / 0, 1 / 0],
                  [-1 / 0, -1 / 0, -1 / 0],
                )),
                i
              );
            }
            ((yg.performDecoding = function (n, e) {
              const i = new Uint8Array(n);
              return Promise.all(
                e.tasks.map((o) => {
                  const {
                      layerName: a,
                      firstByte: u,
                      lastByte: d,
                      pixelFormat: _,
                      blockShape: v,
                      blockIndex: b,
                      filters: E,
                      codec: A,
                    } = o,
                    M = i.subarray(u, d + 1),
                    R = new Uint32Array(v[0] * v[1] * v[2]);
                  let k;
                  if (A !== "gzip_data") throw new $s(`Unhandled codec: ${A}`);
                  return (
                    (k = (function (N, j) {
                      if (!globalThis.DecompressionStream && j === "gzip_data")
                        return Promise.resolve(
                          ((V = (function (re) {
                            (re[0] == 31 && re[1] == 139 && re[2] == 8) ||
                              vo(6, "invalid gzip data");
                            var ve = re[3],
                              ge = 10;
                            4 & ve && (ge += 2 + (re[10] | (re[11] << 8)));
                            for (
                              var be = ((ve >> 3) & 1) + ((ve >> 4) & 1);
                              be > 0;
                              be -= !re[ge++]
                            );
                            return ge + (2 & ve);
                          })((Q = N))) +
                            8 >
                            Q.length && vo(6, "invalid gzip data"),
                          (function (re, ve, ge, be) {
                            var Me = re.length;
                            if (!Me || (ve.f && !ve.l)) return ge || new Ls(0);
                            var Ue = !ge,
                              it = Ue || ve.i != 2,
                              Xe = ve.i;
                            Ue && (ge = new Ls(3 * Me));
                            var tt,
                              nt,
                              Ge = function (Bn) {
                                var dn = ge.length;
                                if (Bn > dn) {
                                  var en = new Ls(Math.max(2 * dn, Bn));
                                  (en.set(ge), (ge = en));
                                }
                              },
                              Je = ve.f || 0,
                              Ne = ve.p || 0,
                              je = ve.b || 0,
                              at = ve.l,
                              ct = ve.d,
                              Nt = ve.m,
                              Ct = ve.n,
                              yt = 8 * Me;
                            do {
                              if (!at) {
                                Je = xo(re, Ne, 1);
                                var ot = xo(re, Ne + 1, 3);
                                if (((Ne += 3), !ot)) {
                                  var Jt =
                                      re[(te = 4 + (((Ne + 7) / 8) | 0)) - 4] |
                                      (re[te - 3] << 8),
                                    At = te + Jt;
                                  if (At > Me) {
                                    Xe && vo(0);
                                    break;
                                  }
                                  (it && Ge(je + Jt),
                                    ge.set(re.subarray(te, At), je),
                                    (ve.b = je += Jt),
                                    (ve.p = Ne = 8 * At),
                                    (ve.f = Je));
                                  continue;
                                }
                                if (ot == 1)
                                  ((at = eA), (ct = tA), (Nt = 9), (Ct = 5));
                                else if (ot == 2) {
                                  var Dt = xo(re, Ne, 31) + 257,
                                    Wt = xo(re, Ne + 10, 15) + 4,
                                    ni = Dt + xo(re, Ne + 5, 31) + 1;
                                  Ne += 14;
                                  for (
                                    var ii = new Ls(ni),
                                      di = new Ls(19),
                                      oi = 0;
                                    oi < Wt;
                                    ++oi
                                  )
                                    di[KI[oi]] = xo(re, Ne + 3 * oi, 7);
                                  Ne += 3 * Wt;
                                  var fi = tx(di),
                                    Bi = (1 << fi) - 1,
                                    sn = Vf(di, fi);
                                  for (oi = 0; oi < ni; ) {
                                    var te,
                                      se = sn[xo(re, Ne, Bi)];
                                    if (((Ne += 15 & se), (te = se >> 4) < 16))
                                      ii[oi++] = te;
                                    else {
                                      var $e = 0,
                                        ut = 0;
                                      for (
                                        te == 16
                                          ? ((ut = 3 + xo(re, Ne, 3)),
                                            (Ne += 2),
                                            ($e = ii[oi - 1]))
                                          : te == 17
                                            ? ((ut = 3 + xo(re, Ne, 7)),
                                              (Ne += 3))
                                            : te == 18 &&
                                              ((ut = 11 + xo(re, Ne, 127)),
                                              (Ne += 7));
                                        ut--;

                                      )
                                        ii[oi++] = $e;
                                    }
                                  }
                                  var xt = ii.subarray(0, Dt),
                                    _t = ii.subarray(Dt);
                                  ((Nt = tx(xt)),
                                    (Ct = tx(_t)),
                                    (at = Vf(xt, Nt)),
                                    (ct = Vf(_t, Ct)));
                                } else vo(1);
                                if (Ne > yt) {
                                  Xe && vo(0);
                                  break;
                                }
                              }
                              it && Ge(je + 131072);
                              for (
                                var It = (1 << Nt) - 1,
                                  $t = (1 << Ct) - 1,
                                  yi = Ne;
                                ;
                                yi = Ne
                              ) {
                                var xi = ($e = at[ix(re, Ne) & It]) >> 4;
                                if ((Ne += 15 & $e) > yt) {
                                  Xe && vo(0);
                                  break;
                                }
                                if (($e || vo(2), xi < 256)) ge[je++] = xi;
                                else {
                                  if (xi == 256) {
                                    ((yi = Ne), (at = null));
                                    break;
                                  }
                                  var ai = xi - 254;
                                  xi > 264 &&
                                    ((ai =
                                      xo(
                                        re,
                                        Ne,
                                        (1 << (vi = $1[(oi = xi - 257)])) - 1,
                                      ) + Z1[oi]),
                                    (Ne += vi));
                                  var Gi = ct[ix(re, Ne) & $t],
                                    Qi = Gi >> 4;
                                  if (
                                    (Gi || vo(3),
                                    (Ne += 15 & Gi),
                                    (_t = QI[Qi]),
                                    Qi > 3)
                                  ) {
                                    var vi = H1[Qi];
                                    ((_t += ix(re, Ne) & ((1 << vi) - 1)),
                                      (Ne += vi));
                                  }
                                  if (Ne > yt) {
                                    Xe && vo(0);
                                    break;
                                  }
                                  it && Ge(je + 131072);
                                  var En = je + ai;
                                  if (je < _t) {
                                    var on = 0 - _t,
                                      Ni = Math.min(_t, En);
                                    for (on + je < 0 && vo(3); je < Ni; ++je)
                                      ge[je] = (void 0)[on + je];
                                  }
                                  for (; je < En; ++je) ge[je] = ge[je - _t];
                                }
                              }
                              ((ve.l = at),
                                (ve.p = yi),
                                (ve.b = je),
                                (ve.f = Je),
                                at &&
                                  ((Je = 1),
                                  (ve.m = Nt),
                                  (ve.d = ct),
                                  (ve.n = Ct)));
                            } while (!Je);
                            return je != ge.length && Ue
                              ? ((tt = ge),
                                ((nt = je) == null || nt > tt.length) &&
                                  (nt = tt.length),
                                new Ls(tt.subarray(0, nt)))
                              : ge.subarray(0, je);
                          })(
                            Q.subarray(V, -8),
                            { i: 2 },
                            new Ls(
                              ((H = Q)[(J = H.length) - 4] |
                                (H[J - 3] << 8) |
                                (H[J - 2] << 16) |
                                (H[J - 1] << 24)) >>>
                                0,
                            ),
                          )),
                        );
                      var H, J, Q, V;
                      const X = sA[j];
                      if (!X) throw new Error(`Unhandled codec: ${j}`);
                      const ee = new globalThis.DecompressionStream(X);
                      return new Response(
                        new Blob([N]).stream().pipeThrough(ee),
                      )
                        .arrayBuffer()
                        .then((re) => new Uint8Array(re));
                    })(M, A).then(
                      (N) => (
                        (function (j, H) {
                          j.readFields(HI, H);
                        })(new nx(N), R),
                        new aA[_](R.buffer)
                      ),
                    )),
                    k
                      .then((N) => {
                        for (let j = E.length - 1; j >= 0; j--)
                          switch (E[j]) {
                            case "delta_filter":
                              qI(N, v);
                              break;
                            case "zigzag_filter":
                              ZI(N);
                              break;
                            case "bitshuffle_filter":
                              XI(N, _);
                              break;
                            default:
                              throw new $s(`Unhandled filter "${E[j]}"`);
                          }
                        return { layerName: a, blockIndex: b, data: N };
                      })
                      .catch((N) => {
                        throw N;
                      })
                  );
                }),
              );
            }),
              Tt(Q1, "MRTDecodingBatch", {
                omit: ["_onCancel", "_onComplete"],
              }),
              Tt(yg, "MapboxRasterTile"),
              Tt(J1, "MapboxRasterLayer", { omit: ["_blocksInProgress"] }));
            class iw {
              constructor(e) {
                ((this._stringToNumber = {}), (this._numberToString = []));
                for (let i = 0; i < e.length; i++) {
                  const o = e[i];
                  ((this._stringToNumber[o] = i),
                    (this._numberToString[i] = o));
                }
              }
              encode(e) {
                return this._stringToNumber[e];
              }
              decode(e) {
                return this._numberToString[e];
              }
            }
            const pA = [
              "id",
              "tile",
              "layer",
              "source",
              "sourceLayer",
              "state",
            ];
            class ju {
              constructor(e, i, o, a, u) {
                ((this.type = "Feature"),
                  (this._vectorTileFeature = e),
                  (this._z = i),
                  (this._x = o),
                  (this._y = a),
                  (this.properties = e.properties),
                  (this.id = u));
              }
              clone() {
                const e = new ju(
                  this._vectorTileFeature,
                  this._z,
                  this._x,
                  this._y,
                  this.id,
                );
                return (
                  this.state && (e.state = Object.assign({}, this.state)),
                  this.layer && (e.layer = Object.assign({}, this.layer)),
                  this.source && (e.source = this.source),
                  this.sourceLayer && (e.sourceLayer = this.sourceLayer),
                  e
                );
              }
              get geometry() {
                return (
                  this._geometry === void 0 &&
                    (this._geometry = this._vectorTileFeature.toGeoJSON(
                      this._x,
                      this._y,
                      this._z,
                    ).geometry),
                  this._geometry
                );
              }
              set geometry(e) {
                this._geometry = e;
              }
              toJSON() {
                const e = {
                  type: "Feature",
                  state: void 0,
                  geometry: this.geometry,
                  properties: this.properties,
                };
                for (const i of pA) this[i] !== void 0 && (e[i] = this[i]);
                return e;
              }
            }
            class nw {
              constructor(e, i) {
                ((this.tileID = e),
                  (this.x = e.canonical.x),
                  (this.y = e.canonical.y),
                  (this.z = e.canonical.z),
                  (this.grid = new co(mt, 16, 0)),
                  (this.featureIndexArray = new gm()),
                  (this.promoteId = i),
                  (this.is3DTile = !1),
                  (this.serializedLayersCache = new Map()));
              }
              insert(e, i, o, a, u, d = 0, _ = 0) {
                const v = this.featureIndexArray.length;
                this.featureIndexArray.emplaceBack(o, a, u, d);
                const b = this.grid;
                for (let E = 0; E < i.length; E++) {
                  const A = i[E],
                    M = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                  for (let R = 0; R < A.length; R++) {
                    const k = A[R];
                    ((M[0] = Math.min(M[0], k.x)),
                      (M[1] = Math.min(M[1], k.y)),
                      (M[2] = Math.max(M[2], k.x)),
                      (M[3] = Math.max(M[3], k.y)));
                  }
                  (_ !== 0 &&
                    ((M[0] -= _), (M[1] -= _), (M[2] += _), (M[3] += _)),
                    M[0] < mt &&
                      M[1] < mt &&
                      M[2] >= 0 &&
                      M[3] >= 0 &&
                      b.insert(v, M[0], M[1], M[2], M[3]));
                }
              }
              loadVTLayers() {
                if (!this.vtLayers) {
                  ((this.vtLayers = new li.VectorTile(
                    new Um(this.rawTileData),
                  ).layers),
                    (this.sourceLayerCoder = new iw(
                      this.vtLayers
                        ? Object.keys(this.vtLayers).sort()
                        : ["_geojsonTileLayer"],
                    )),
                    (this.vtFeatures = {}));
                  for (const e in this.vtLayers) this.vtFeatures[e] = [];
                }
                return this.vtLayers;
              }
              query(e, i) {
                const {
                  tilespaceGeometry: o,
                  transform: a,
                  tileTransform: u,
                  pixelPosMatrix: d,
                  availableImages: _,
                  worldview: v,
                } = i;
                (this.loadVTLayers(), this.serializedLayersCache.clear());
                const b = o.bufferedTilespaceBounds,
                  E = this.grid.query(
                    b.min.x,
                    b.min.y,
                    b.max.x,
                    b.max.y,
                    (k, N, j, H) => Ol(o.bufferedTilespaceGeometry, k, N, j, H),
                  );
                E.sort(mA);
                let A = null;
                a.elevation &&
                  E.length > 0 &&
                  (A = Bu.create(a.elevation, this.tileID));
                const M = {};
                let R;
                for (let k = 0; k < E.length; k++) {
                  const N = E[k];
                  if (N === R) continue;
                  R = N;
                  const j = this.featureIndexArray.get(N);
                  let H = null;
                  this.is3DTile
                    ? this.loadMatchingModelFeature(M, j, e, o, a, v)
                    : this.loadMatchingFeature(
                        M,
                        j,
                        e,
                        _,
                        v,
                        (J, Q, V, X = 0) => (
                          H || (H = Et(J, this.tileID.canonical, u)),
                          Q.queryIntersectsFeature(
                            o,
                            J,
                            V,
                            H,
                            this.z,
                            a,
                            d,
                            A,
                            X,
                          )
                        ),
                      );
                }
                return M;
              }
              loadMatchingFeature(e, i, o, a, u, d) {
                const {
                    featureIndex: _,
                    bucketIndex: v,
                    sourceLayerIndex: b,
                    layoutVertexArrayOffset: E,
                  } = i,
                  A = this.bucketLayerIDs[v],
                  M = o.layers,
                  R = Object.keys(M);
                if (R.length && !Qt(R, A)) return;
                const k = o.sourceCache,
                  N = this.sourceLayerCoder.decode(b),
                  j = this.vtLayers[N].feature(_),
                  H = this.getId(j, N);
                for (let J = 0; J < A.length; J++) {
                  const Q = A[J];
                  if (!M[Q]) continue;
                  const { styleLayer: V, targets: X } = M[Q];
                  let ee = {};
                  H !== void 0 && (ee = k.getFeatureState(V.sourceLayer, H));
                  const re = !d || d(j, V, ee, E);
                  if (!re) continue;
                  const ve = new ju(j, this.z, this.x, this.y, H);
                  ((ve.tile = this.tileID.canonical), (ve.state = ee));
                  let ge = this.serializedLayersCache.get(Q);
                  (ge ||
                    ((ge = V.serialize()),
                    (ge.id = Q),
                    this.serializedLayersCache.set(Q, ge)),
                    (ve.source = ge.source),
                    (ve.sourceLayer = ge["source-layer"]),
                    (ve.layer = Le({}, ge)),
                    (ve.layer.paint = rw(ge.paint, V.paint, j, ee, a)),
                    (ve.layer.layout = rw(ge.layout, V.layout, j, ee, a)));
                  let be = !1;
                  for (const Me of X) {
                    this.updateFeatureProperties(ve, Me);
                    const { filter: Ue } = Me;
                    if (Ue) {
                      if (((j.properties = ve.properties), Ue.needGeometry)) {
                        const it = bt(j, !0);
                        if (
                          !Ue.filter(
                            new qi(this.tileID.overscaledZ, { worldview: u }),
                            it,
                            this.tileID.canonical,
                          )
                        )
                          continue;
                      } else if (
                        !Ue.filter(
                          new qi(this.tileID.overscaledZ, { worldview: u }),
                          j,
                        )
                      )
                        continue;
                    }
                    ((be = !0), Me.targetId && this.addFeatureVariant(ve, Me));
                  }
                  be && this.appendToResult(e, Q, _, ve, re);
                }
              }
              loadMatchingModelFeature(e, i, o, a, u, d) {
                const { featureIndex: _, bucketIndex: v } = i,
                  b = this.bucketLayerIDs[v],
                  E = o.layers,
                  A = Object.keys(E);
                if (!A.length || Qt(A, b))
                  for (let M = 0; M < b.length; M++) {
                    const R = b[M],
                      { styleLayer: k, targets: N } = E[R];
                    if (k.type !== "model") continue;
                    const j = a.tile,
                      H = j.getBucket(k);
                    if (!(H && H instanceof ug)) continue;
                    const J = pI(H, _, a, u);
                    if (!J) continue;
                    const { z: Q, x: V, y: X } = j.tileID.canonical,
                      { feature: ee, intersectionZ: re, position: ve } = J;
                    let ge = {};
                    ee.id !== void 0 &&
                      (ge = o.sourceCache.getFeatureState(
                        k.sourceLayer,
                        ee.id,
                      ));
                    const be = new ju({}, Q, V, X, ee.id);
                    ((be.tile = this.tileID.canonical),
                      (be.state = ge),
                      (be.properties = ee.properties),
                      (be.geometry = {
                        type: "Point",
                        coordinates: [ve.lng, ve.lat],
                      }));
                    let Me = this.serializedLayersCache.get(R);
                    (Me ||
                      ((Me = k.serialize()),
                      (Me.id = R),
                      this.serializedLayersCache.set(R, Me)),
                      (be.source = Me.source),
                      (be.sourceLayer = Me["source-layer"]),
                      (be.layer = Le({}, Me)));
                    let Ue = !1;
                    for (const it of N) {
                      this.updateFeatureProperties(be, it);
                      const { filter: Xe } = it;
                      if (Xe) {
                        if (
                          ((ee.properties = be.properties), Xe.needGeometry)
                        ) {
                          if (
                            !Xe.filter(
                              new qi(this.tileID.overscaledZ, { worldview: d }),
                              ee,
                              this.tileID.canonical,
                            )
                          )
                            continue;
                        } else if (
                          !Xe.filter(
                            new qi(this.tileID.overscaledZ, { worldview: d }),
                            ee,
                          )
                        )
                          continue;
                      }
                      ((Ue = !0),
                        it.targetId && this.addFeatureVariant(be, it));
                    }
                    Ue && this.appendToResult(e, R, _, be, re);
                  }
              }
              updateFeatureProperties(e, i, o) {
                if (i.properties) {
                  const a = {};
                  for (const u in i.properties) {
                    const d = i.properties[u].evaluate(
                      { zoom: this.z },
                      e._vectorTileFeature,
                      e.state,
                      e.tile,
                      o,
                    );
                    d != null && (a[u] = d);
                  }
                  e.properties = a;
                }
              }
              addFeatureVariant(e, i, o) {
                const a = {
                  target: i.target,
                  namespace: i.namespace,
                  uniqueFeatureID: i.uniqueFeatureID,
                };
                (i.properties && (a.properties = e.properties),
                  (e.variants = e.variants || {}),
                  (e.variants[i.targetId] = e.variants[i.targetId] || []),
                  e.variants[i.targetId].push(a));
              }
              appendToResult(e, i, o, a, u) {
                let d = e[i];
                (d === void 0 && (d = e[i] = []),
                  d.push({ featureIndex: o, feature: a, intersectionZ: u }));
              }
              lookupSymbolFeatures(e, i, o, a, u, d) {
                const _ = {};
                this.loadVTLayers();
                for (const v of e)
                  this.loadMatchingFeature(
                    _,
                    {
                      bucketIndex: i,
                      sourceLayerIndex: o,
                      featureIndex: v,
                      layoutVertexArrayOffset: 0,
                    },
                    a,
                    u,
                    d,
                  );
                return _;
              }
              loadFeature(e) {
                const { featureIndex: i, sourceLayerIndex: o } = e;
                this.loadVTLayers();
                const a = this.sourceLayerCoder.decode(o),
                  u = this.vtFeatures[a];
                if (u[i]) return u[i];
                const d = this.vtLayers[a].feature(i);
                return ((u[i] = d), d);
              }
              hasLayer(e) {
                for (const i of this.bucketLayerIDs)
                  for (const o of i) if (e === o) return !0;
                return !1;
              }
              getId(e, i) {
                let o = e.id;
                if (this.promoteId) {
                  const a =
                    Array.isArray(this.promoteId) ||
                    typeof this.promoteId != "object"
                      ? this.promoteId
                      : this.promoteId[i];
                  if (a != null)
                    if (Array.isArray(a)) {
                      if (!this.promoteIdExpression) {
                        const u = lo(a);
                        if (u.result !== "success") {
                          const d = u.value
                            .map((_) => `${_.key}: ${_.message}`)
                            .join(", ");
                          return void ri(
                            `Failed to create expression for promoteId: ${d}`,
                          );
                        }
                        this.promoteIdExpression = u.value;
                      }
                      (this.promoteIdExpression._evaluator ||
                        (this.promoteIdExpression._evaluator = new wc()),
                        (o = this.promoteIdExpression.evaluate(
                          { zoom: 0 },
                          e,
                        )));
                    } else o = e.properties[a];
                  typeof o == "boolean" && (o = Number(o));
                }
                return o;
              }
            }
            function rw(n, e, i, o, a) {
              return zt(n, (u, d) => {
                const _ = e instanceof Da ? e.get(d) : null;
                return _ && _.evaluate ? _.evaluate(i, o, void 0, a) : _;
              });
            }
            function mA(n, e) {
              return e - n;
            }
            Tt(nw, "FeatureIndex", {
              omit: ["rawTileData", "sourceLayerCoder"],
            });
            const sw = [
              Int8Array,
              Uint8Array,
              Uint8ClampedArray,
              Int16Array,
              Uint16Array,
              Int32Array,
              Uint32Array,
              Float32Array,
              Float64Array,
            ];
            class sx {
              static from(e) {
                if (!(e instanceof ArrayBuffer))
                  throw new Error("Data must be an instance of ArrayBuffer.");
                const [i, o] = new Uint8Array(e, 0, 2);
                if (i !== 219)
                  throw new Error(
                    "Data does not appear to be in a KDBush format.",
                  );
                const a = o >> 4;
                if (a !== 1)
                  throw new Error(`Got v${a} data when expected v1.`);
                const u = sw[15 & o];
                if (!u) throw new Error("Unrecognized array type.");
                const [d] = new Uint16Array(e, 2, 1),
                  [_] = new Uint32Array(e, 4, 1);
                return new sx(_, d, u, e);
              }
              constructor(e, i = 64, o = Float64Array, a) {
                if (isNaN(e) || e < 0)
                  throw new Error(`Unpexpected numItems value: ${e}.`);
                ((this.numItems = +e),
                  (this.nodeSize = Math.min(Math.max(+i, 2), 65535)),
                  (this.ArrayType = o),
                  (this.IndexArrayType =
                    e < 65536 ? Uint16Array : Uint32Array));
                const u = sw.indexOf(this.ArrayType),
                  d = 2 * e * this.ArrayType.BYTES_PER_ELEMENT,
                  _ = e * this.IndexArrayType.BYTES_PER_ELEMENT,
                  v = (8 - (_ % 8)) % 8;
                if (u < 0)
                  throw new Error(`Unexpected typed array class: ${o}.`);
                a && a instanceof ArrayBuffer
                  ? ((this.data = a),
                    (this.ids = new this.IndexArrayType(this.data, 8, e)),
                    (this.coords = new this.ArrayType(
                      this.data,
                      8 + _ + v,
                      2 * e,
                    )),
                    (this._pos = 2 * e),
                    (this._finished = !0))
                  : ((this.data = new ArrayBuffer(8 + d + _ + v)),
                    (this.ids = new this.IndexArrayType(this.data, 8, e)),
                    (this.coords = new this.ArrayType(
                      this.data,
                      8 + _ + v,
                      2 * e,
                    )),
                    (this._pos = 0),
                    (this._finished = !1),
                    new Uint8Array(this.data, 0, 2).set([219, 16 + u]),
                    (new Uint16Array(this.data, 2, 1)[0] = i),
                    (new Uint32Array(this.data, 4, 1)[0] = e));
              }
              add(e, i) {
                const o = this._pos >> 1;
                return (
                  (this.ids[o] = o),
                  (this.coords[this._pos++] = e),
                  (this.coords[this._pos++] = i),
                  o
                );
              }
              finish() {
                const e = this._pos >> 1;
                if (e !== this.numItems)
                  throw new Error(
                    `Added ${e} items when expected ${this.numItems}.`,
                  );
                return (
                  ox(
                    this.ids,
                    this.coords,
                    this.nodeSize,
                    0,
                    this.numItems - 1,
                    0,
                  ),
                  (this._finished = !0),
                  this
                );
              }
              range(e, i, o, a) {
                if (!this._finished)
                  throw new Error(
                    "Data not yet indexed - call index.finish().",
                  );
                const { ids: u, coords: d, nodeSize: _ } = this,
                  v = [0, u.length - 1, 0],
                  b = [];
                for (; v.length; ) {
                  const E = v.pop() || 0,
                    A = v.pop() || 0,
                    M = v.pop() || 0;
                  if (A - M <= _) {
                    for (let j = M; j <= A; j++) {
                      const H = d[2 * j],
                        J = d[2 * j + 1];
                      H >= e && H <= o && J >= i && J <= a && b.push(u[j]);
                    }
                    continue;
                  }
                  const R = (M + A) >> 1,
                    k = d[2 * R],
                    N = d[2 * R + 1];
                  (k >= e && k <= o && N >= i && N <= a && b.push(u[R]),
                    (E === 0 ? e <= k : i <= N) &&
                      (v.push(M), v.push(R - 1), v.push(1 - E)),
                    (E === 0 ? o >= k : a >= N) &&
                      (v.push(R + 1), v.push(A), v.push(1 - E)));
                }
                return b;
              }
              within(e, i, o) {
                if (!this._finished)
                  throw new Error(
                    "Data not yet indexed - call index.finish().",
                  );
                const { ids: a, coords: u, nodeSize: d } = this,
                  _ = [0, a.length - 1, 0],
                  v = [],
                  b = o * o;
                for (; _.length; ) {
                  const E = _.pop() || 0,
                    A = _.pop() || 0,
                    M = _.pop() || 0;
                  if (A - M <= d) {
                    for (let j = M; j <= A; j++)
                      aw(u[2 * j], u[2 * j + 1], e, i) <= b && v.push(a[j]);
                    continue;
                  }
                  const R = (M + A) >> 1,
                    k = u[2 * R],
                    N = u[2 * R + 1];
                  (aw(k, N, e, i) <= b && v.push(a[R]),
                    (E === 0 ? e - o <= k : i - o <= N) &&
                      (_.push(M), _.push(R - 1), _.push(1 - E)),
                    (E === 0 ? e + o >= k : i + o >= N) &&
                      (_.push(R + 1), _.push(A), _.push(1 - E)));
                }
                return v;
              }
            }
            function ox(n, e, i, o, a, u) {
              if (a - o <= i) return;
              const d = (o + a) >> 1;
              (ow(n, e, d, o, a, u),
                ox(n, e, i, o, d - 1, 1 - u),
                ox(n, e, i, d + 1, a, 1 - u));
            }
            function ow(n, e, i, o, a, u) {
              for (; a > o; ) {
                if (a - o > 600) {
                  const b = a - o + 1,
                    E = i - o + 1,
                    A = Math.log(b),
                    M = 0.5 * Math.exp((2 * A) / 3),
                    R =
                      0.5 *
                      Math.sqrt((A * M * (b - M)) / b) *
                      (E - b / 2 < 0 ? -1 : 1);
                  ow(
                    n,
                    e,
                    i,
                    Math.max(o, Math.floor(i - (E * M) / b + R)),
                    Math.min(a, Math.floor(i + ((b - E) * M) / b + R)),
                    u,
                  );
                }
                const d = e[2 * i + u];
                let _ = o,
                  v = a;
                for (
                  jf(n, e, o, i), e[2 * a + u] > d && jf(n, e, o, a);
                  _ < v;

                ) {
                  for (jf(n, e, _, v), _++, v--; e[2 * _ + u] < d; ) _++;
                  for (; e[2 * v + u] > d; ) v--;
                }
                (e[2 * o + u] === d ? jf(n, e, o, v) : (v++, jf(n, e, v, a)),
                  v <= i && (o = v + 1),
                  i <= v && (a = v - 1));
              }
            }
            function jf(n, e, i, o) {
              (ax(n, i, o), ax(e, 2 * i, 2 * o), ax(e, 2 * i + 1, 2 * o + 1));
            }
            function ax(n, e, i) {
              const o = n[e];
              ((n[e] = n[i]), (n[i] = o));
            }
            function aw(n, e, i, o) {
              const a = n - i,
                u = e - o;
              return a * a + u * u;
            }
            ((r.$ = lr),
              (r.A = _a),
              (r.B = oo),
              (r.C = za),
              (r.D = Cu),
              (r.E = ya),
              (r.F = 2),
              (r.G = Mf),
              (r.H = Eb),
              (r.I = Kr),
              (r.J = zo),
              (r.K = class extends cg {}),
              (r.L = va),
              (r.M = Ds),
              (r.N = Rc),
              (r.O = Dc),
              (r.P = ft),
              (r.Q = Ld),
              (r.R = dc),
              (r.S = su),
              (r.T = Uy),
              (r.U = cu),
              (r.V = cg),
              (r.W = Yp),
              (r.X = lo),
              (r.Y = Wh),
              (r.Z = _l),
              (r._ = gl),
              (r.a = function (n) {
                return hr.API_CDN_URL_REGEX.test(n);
              }),
              (r.a$ = Be),
              (r.a0 = xa),
              (r.a1 = hu),
              (r.a2 = zc),
              (r.a3 = kd),
              (r.a4 = function (n) {
                const e = n.value;
                let i = [];
                if (!e) return i;
                const o = zo(e);
                return o !== "string"
                  ? ((i = i.concat([
                      new cg(n.key, e, `string expected, "${o}" found`),
                    ])),
                    i)
                  : (Hy(e, !0) ||
                      (i = i.concat([new cg(n.key, e, `invalid url "${e}"`)])),
                    i);
              }),
              (r.a5 = Pe),
              (r.a6 = im),
              (r.a7 = Cn),
              (r.a8 = st),
              (r.a9 = class {
                constructor(n) {
                  this.specification = n;
                }
                possiblyEvaluate(n, e) {
                  return _n(n.expression.evaluate(e));
                }
                interpolate(n, e, i) {
                  return {
                    x: Ht(n.x, e.x, i),
                    y: Ht(n.y, e.y, i),
                    z: Ht(n.z, e.z, i),
                    azimuthal: Ht(n.azimuthal, e.azimuthal, i),
                    polar: Ht(n.polar, e.polar, i),
                  };
                }
              }),
              (r.aA = Cr),
              (r.aB = x),
              (r.aC = Gs),
              (r.aD = ce),
              (r.aE = Oe),
              (r.aF = function (n, e) {
                const i = {};
                for (let o = 0; o < e.length; o++) {
                  const a = e[o];
                  a in n && (i[a] = n[a]);
                }
                return i;
              }),
              (r.aG = ie),
              (r.aH = le),
              (r.aI = class {
                constructor(n) {
                  ((this.entries = {}), (this.scheduler = n));
                }
                request(n, e, i, o) {
                  const a = (this.entries[n] = this.entries[n] || {
                    callbacks: [],
                  });
                  if (a.result) {
                    const [u, d] = a.result;
                    return (
                      this.scheduler
                        ? this.scheduler.add(() => {
                            o(u, d);
                          }, e)
                        : o(u, d),
                      () => {}
                    );
                  }
                  return (
                    a.callbacks.push(o),
                    a.cancel ||
                      (a.cancel = i((u, d) => {
                        a.result = [u, d];
                        for (const _ of a.callbacks)
                          this.scheduler
                            ? this.scheduler.add(() => {
                                _(u, d);
                              }, e)
                            : _(u, d);
                        setTimeout(() => delete this.entries[n], 3e3);
                      })),
                    () => {
                      a.result ||
                        ((a.callbacks = a.callbacks.filter((u) => u !== o)),
                        a.callbacks.length ||
                          (a.cancel(), delete this.entries[n]));
                    }
                  );
                }
              }),
              (r.aJ = function (n, e, i) {
                const o = JSON.stringify(n.request);
                return (
                  n.data &&
                    (this.deduped.entries[o] = { result: [null, n.data] }),
                  this.deduped.request(
                    o,
                    {
                      type: "parseTile",
                      isSymbolTile: n.isSymbolTile,
                      zoom: n.tileZoom,
                    },
                    (a) => {
                      const u = fc(n.request, (d, _, v, b) => {
                        d
                          ? a(d)
                          : _ &&
                            a(null, {
                              vectorTile: i
                                ? void 0
                                : new li.VectorTile(new Um(_)),
                              rawData: _,
                              cacheControl: v,
                              expires: b,
                            });
                      });
                      return () => {
                        (u.cancel(), a());
                      };
                    },
                    e,
                  )
                );
              }),
              (r.aK = function (n) {
                (nd++,
                  nd > no &&
                    (n.getActor().send("enforceCacheSizeLimit", Ms), (nd = 0)));
              }),
              (r.aL = function (n) {
                return n <= 1
                  ? 1
                  : Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
              }),
              (r.aM = Lr),
              (r.aN = e1),
              (r.aO = o1),
              (r.aP = Qb),
              (r.aQ = function (n, e) {
                const i = document.createElement("video");
                ((i.muted = !0),
                  (i.onloadstart = function () {
                    e(null, i);
                  }));
                for (let o = 0; o < n.length; o++) {
                  const a = document.createElement("source");
                  (c_(n[o]) || (i.crossOrigin = "Anonymous"),
                    (a.src = n[o]),
                    i.appendChild(a));
                }
                return { cancel: () => {} };
              }),
              (r.aR = rg),
              (r.aS = function (n) {
                return fetch(n)
                  .then((e) => e.arrayBuffer())
                  .then((e) => $0(e, 0, n));
              }),
              (r.aT = tw),
              (r.aU = class {
                constructor(n, e, i, o) {
                  ((this.id = n),
                    (this.position =
                      e != null ? new Y(e[0], e[1]) : new Y(0, 0)),
                    (this.orientation = i ?? [0, 0, 0]),
                    (this.nodes = o),
                    (this.uploaded = !1),
                    (this.aabb = new Ci(
                      [1 / 0, 1 / 0, 1 / 0],
                      [-1 / 0, -1 / 0, -1 / 0],
                    )),
                    (this.matrix = []));
                }
                _applyTransformations(n, e) {
                  if ((Ae(n.matrix, e, n.matrix), n.meshes))
                    for (const i of n.meshes) {
                      const o = Ci.applyTransformFast(i.aabb, n.matrix);
                      this.aabb.encapsulate(o);
                    }
                  if (n.children)
                    for (const i of n.children)
                      this._applyTransformations(i, n.matrix);
                }
                computeBoundsAndApplyParent() {
                  const n = xe([]);
                  for (const e of this.nodes) this._applyTransformations(e, n);
                }
                computeModelMatrix(n, e, i, o, a, u, d = !1) {
                  _1(
                    this.matrix,
                    this,
                    n.transform,
                    this.position,
                    e,
                    i,
                    o,
                    a,
                    u,
                    d,
                  );
                }
                upload(n) {
                  if (!this.uploaded) {
                    for (const e of this.nodes) qy(e, n);
                    for (const e of this.nodes) hg(e);
                    this.uploaded = !0;
                  }
                }
                destroy() {
                  for (const n of this.nodes) Zy(n);
                }
              }),
              (r.aV = Pt),
              (r.aW = Pf),
              (r.aX = _e),
              (r.aY = De),
              (r.aZ = Il),
              (r.a_ = dr),
              (r.aa = qi),
              (r.ab = Lc),
              (r.ac = Te),
              (r.ad = mn),
              (r.ae = Ri),
              (r.af = Se),
              (r.ag = Da),
              (r.ah = Fl),
              (r.ai = Ht),
              (r.aj = mt),
              (r.ak = kh),
              (r.al = Mi),
              (r.am = Li),
              (r.an = class {
                constructor(n) {
                  this.specification = n;
                }
                possiblyEvaluate(n, e) {
                  return (function ([i, o]) {
                    const a = _n([1, i, o]);
                    return { x: a.x, y: a.y, z: a.z };
                  })(n.expression.evaluate(e));
                }
                interpolate(n, e, i) {
                  return {
                    x: Ht(n.x, e.x, i),
                    y: Ht(n.y, e.y, i),
                    z: Ht(n.z, e.z, i),
                  };
                }
              }),
              (r.ao = function (n, e, i = 0, o = !0) {
                const a = new ft(i, i),
                  u = n.sub(a),
                  d = e.add(a),
                  _ = [u, new ft(d.x, u.y), d, new ft(u.x, d.y)];
                return (o && _.push(u.clone()), _);
              }),
              (r.ap = function (n, e) {
                const i = [];
                for (let o = 0; o < n.length; o++) {
                  const a = ke(o - 1, -1, n.length - 1),
                    u = ke(o + 1, -1, n.length - 1),
                    d = n[o],
                    _ = n[u],
                    v = n[a].sub(d).unit(),
                    b = _.sub(d).unit(),
                    E = b.angleWithSep(v.x, v.y),
                    A = v
                      .add(b)
                      .unit()
                      .mult((-1 * e) / Math.sin(E / 2));
                  i.push(d.add(A));
                }
                return i;
              }),
              (r.aq = Nb),
              (r.ar = Ol),
              (r.as = function (n, e, i = 0) {
                return wi(
                  ((e.x - i) * n.scale - n.x) * mt,
                  (e.y * n.scale - n.y) * mt,
                  ze(e.z, e.y),
                );
              }),
              (r.at = Gn),
              (r.au = tn),
              (r.av = hn),
              (r.aw = K0),
              (r.ax = function (n) {
                let e = 1 / 0,
                  i = 1 / 0,
                  o = -1 / 0,
                  a = -1 / 0;
                for (const u of n)
                  ((e = Math.min(e, u.x)),
                    (i = Math.min(i, u.y)),
                    (o = Math.max(o, u.x)),
                    (a = Math.max(a, u.y)));
                return { min: new ft(e, i), max: new ft(o, a) };
              }),
              (r.ay = he),
              (r.az = Ae),
              (r.b = function (n) {
                return hr.API_FONTS_REGEX.test(n);
              }),
              (r.b$ = function (n, e, i) {
                i *= 0.5;
                var o = e[0],
                  a = e[1],
                  u = e[2],
                  d = e[3],
                  _ = Math.sin(i),
                  v = Math.cos(i);
                return (
                  (n[0] = o * v + a * _),
                  (n[1] = a * v - o * _),
                  (n[2] = u * v + d * _),
                  (n[3] = d * v - u * _),
                  n
                );
              }),
              (r.b0 = yu),
              (r.b1 = ig),
              (r.b2 = function () {
                fo.isLoading() || fo.isLoaded() || Tl() !== "deferred" || tm();
              }),
              (r.b3 = Ud),
              (r.b4 = bt),
              (r.b5 = ju),
              (r.b6 = Pi),
              (r.b7 = xy),
              (r.b8 = oy),
              (r.b9 = Et),
              (r.bA = function (n, e) {
                const { x: i, y: o } = n.point,
                  a = Pv(i, o, n.worldSize / n._pixelsPerMercatorPixel, 0, 0);
                return Ae(a, a, Y_(Yo(e)));
              }),
              (r.bB = q),
              (r.bC = function (n) {
                return ((n[0] = 0), (n[1] = 0), (n[2] = 0), n);
              }),
              (r.bD = function (n, e) {
                return Math.hypot(e[0] - n[0], e[1] - n[1], e[2] - n[2]);
              }),
              (r.bE = _r),
              (r.bF = nr),
              (r.bG = wn),
              (r.bH = Af),
              (r.bI = hs),
              (r.bJ = Ay),
              (r.bK = function (n, e, i, o, a) {
                const u = 5 * e + 2;
                ((n.float32[u + 0] = i),
                  (n.float32[u + 1] = o),
                  (n.float32[u + 2] = a));
              }),
              (r.bL = tg),
              (r.bM = Fm),
              (r.bN = Hr),
              (r.bO = cr),
              (r.bP = o0),
              (r.bQ = d1),
              (r.bR = u0),
              (r.bS = d0),
              (r.bT = Iy),
              (r.bU = Rb),
              (r.bV = Dy),
              (r.bW = sx),
              (r.bX = ke),
              (r.bY = Vi),
              (r.bZ = To),
              (r.b_ = So),
              (r.ba = po),
              (r.bb = Hc),
              (r.bc = Sv),
              (r.bd = Rn),
              (r.be = uf),
              (r.bf = By),
              (r.bg = function (n, e) {
                const i = Fl(e.zoom);
                if (i === 0) return Yo(n);
                const o = Im(n),
                  a = X_(o),
                  u = ce(o.getWest()) * e.worldSize,
                  d = ce(o.getEast()) * e.worldSize,
                  _ = le(o.getNorth()) * e.worldSize,
                  v = le(o.getSouth()) * e.worldSize,
                  b = [u, _, 0],
                  E = [d, _, 0],
                  A = [u, v, 0],
                  M = [d, v, 0],
                  R = we([], e.globeMatrix);
                return (
                  mn(b, b, R),
                  mn(E, E, R),
                  mn(A, A, R),
                  mn(M, M, R),
                  (a[0] = Oa(a[0], A, i)),
                  (a[1] = Oa(a[1], M, i)),
                  (a[2] = Oa(a[2], E, i)),
                  (a[3] = Oa(a[3], b, i)),
                  Ci.fromPoints(a)
                );
              }),
              (r.bh = Mm),
              (r.bi = we),
              (r.bj = cf),
              (r.bk = Oa),
              (r.bl = Vc),
              (r.bm = sS),
              (r.bn = Re),
              (r.bo = Qe),
              (r.bp = yg),
              (r.bq = Um),
              (r.br = fc),
              (r.bs = function (n, e) {
                const i = [];
                for (const o in n) o in e || i.push(o);
                return i;
              }),
              (r.bt = Ee),
              (r.bu = [
                "type",
                "source",
                "source-layer",
                "minzoom",
                "maxzoom",
                "filter",
                "layout",
              ]),
              (r.bv = to),
              (r.bw = function (n) {
                var e = new B(16);
                return (
                  (e[0] = n[0]),
                  (e[1] = n[1]),
                  (e[2] = n[2]),
                  (e[3] = n[3]),
                  (e[4] = n[4]),
                  (e[5] = n[5]),
                  (e[6] = n[6]),
                  (e[7] = n[7]),
                  (e[8] = n[8]),
                  (e[9] = n[9]),
                  (e[10] = n[10]),
                  (e[11] = n[11]),
                  (e[12] = n[12]),
                  (e[13] = n[13]),
                  (e[14] = n[14]),
                  (e[15] = n[15]),
                  e
                );
              }),
              (r.bx = xe),
              (r.by = pt),
              (r.bz = Ie),
              (r.c = Eh),
              (r.c$ = Bm),
              (r.c0 = Eo),
              (r.c1 = Mn),
              (r.c2 = function (n, e) {
                return (
                  (n[0] = -e[0]),
                  (n[1] = -e[1]),
                  (n[2] = -e[2]),
                  (n[3] = e[3]),
                  n
                );
              }),
              (r.c3 = Ot),
              (r.c4 = function (n, e, i, o, a) {
                var u,
                  d = 1 / Math.tan(e / 2);
                return (
                  (n[0] = d / i),
                  (n[1] = 0),
                  (n[2] = 0),
                  (n[3] = 0),
                  (n[4] = 0),
                  (n[5] = d),
                  (n[6] = 0),
                  (n[7] = 0),
                  (n[8] = 0),
                  (n[9] = 0),
                  (n[11] = -1),
                  (n[12] = 0),
                  (n[13] = 0),
                  (n[15] = 0),
                  a != null && a !== 1 / 0
                    ? ((n[10] = (a + o) * (u = 1 / (o - a))),
                      (n[14] = 2 * a * o * u))
                    : ((n[10] = -1), (n[14] = -2 * o)),
                  n
                );
              }),
              (r.c5 = function (n, e, i, o, a, u, d) {
                var _ = 1 / (e - i),
                  v = 1 / (o - a),
                  b = 1 / (u - d);
                return (
                  (n[0] = -2 * _),
                  (n[1] = 0),
                  (n[2] = 0),
                  (n[3] = 0),
                  (n[4] = 0),
                  (n[5] = -2 * v),
                  (n[6] = 0),
                  (n[7] = 0),
                  (n[8] = 0),
                  (n[9] = 0),
                  (n[10] = 2 * b),
                  (n[11] = 0),
                  (n[12] = (e + i) * _),
                  (n[13] = (a + o) * v),
                  (n[14] = (d + u) * b),
                  (n[15] = 1),
                  n
                );
              }),
              (r.c6 = me),
              (r.c7 = function (n, e, i) {
                ((n[4 * e + 0] = i[0]),
                  (n[4 * e + 1] = i[1]),
                  (n[4 * e + 2] = i[2]),
                  (n[4 * e + 3] = i[3]));
              }),
              (r.c8 = wu),
              (r.c9 = Xc),
              (r.cA = ag),
              (r.cB = _i),
              (r.cC = a1),
              (r.cD = function (n) {
                const e = a1(n, !0);
                return q([], [e[0], e[1], e[4], e[5]]);
              }),
              (r.cE = gt),
              (r.cF = Ji),
              (r.cG = Rt),
              (r.cH = function (n) {
                const { x: e, y: i } = n.point,
                  { lng: o, lat: a } = n._center;
                return Pv(e, i, n.worldSize, o, a);
              }),
              (r.cI = Ln),
              (r.cJ = Fe),
              (r.cK = Au),
              (r.cL = w),
              (r.cM = function (n, e, i) {
                let o = 0;
                for (let a = 0; a < 2; ++a)
                  (n[a] > 0 && (o += (n[a] - 0) * (n[a] - 0)),
                    e[a] < 0 && (o += (0 - e[a]) * (0 - e[a])));
                return o;
              }),
              (r.cN = function (n) {
                return n * n * n * n * n;
              }),
              (r.cO = ue),
              (r.cP = 45),
              (r.cQ = Tu),
              (r.cR = function (n, e, i) {
                const o = Math.sqrt(n * n + e * e + i * i),
                  a = o > 0 ? Math.acos(i / o) * rc : 0;
                let u = n !== 0 || e !== 0 ? Math.atan2(-e, -n) * rc + 90 : 0;
                return (u < 0 && (u += 360), [o, u, a]);
              }),
              (r.cS = wi),
              (r.cT = _n),
              (r.cU = Ve),
              (r.cV = ei),
              (r.cW = Ci),
              (r.cX = Ii),
              (r.cY = function (n) {
                return [
                  Math.pow(n[0], 1 / 2.2),
                  Math.pow(n[1], 1 / 2.2),
                  Math.pow(n[2], 1 / 2.2),
                ];
              }),
              (r.cZ = Hy),
              (r.c_ = function (n, e) {
                return n.readFields(_I, { icons: [] }, e);
              }),
              (r.ca = Vn),
              (r.cb = Us),
              (r.cc = Rl),
              (r.cd = Y),
              (r.ce = $b),
              (r.cf = function () {
                var n = new B(4);
                return (
                  B != Float32Array && ((n[1] = 0), (n[2] = 0)),
                  (n[0] = 1),
                  (n[3] = 1),
                  n
                );
              }),
              (r.cg = function (n, e, i) {
                var o = e[0],
                  a = e[1],
                  u = e[2],
                  d = e[3],
                  _ = Math.sin(i),
                  v = Math.cos(i);
                return (
                  (n[0] = o * v + u * _),
                  (n[1] = a * v + d * _),
                  (n[2] = o * -_ + u * v),
                  (n[3] = a * -_ + d * v),
                  n
                );
              }),
              (r.ch = function (n, e) {
                return (
                  n[0] === e[0] &&
                  n[1] === e[1] &&
                  n[2] === e[2] &&
                  n[3] === e[3]
                );
              }),
              (r.ci = Is),
              (r.cj = function (n) {
                return Math.hypot(n[0], n[1], n[2], n[3]);
              }),
              (r.ck = eo),
              (r.cl = Qs),
              (r.cm = Tv),
              (r.cn = xn),
              (r.co = l1),
              (r.cp = eh),
              (r.cq = Av),
              (r.cr = function (n, e, i, o, a, u, d, _, v) {
                if (v.name === "globe") return Av(n, e, new eh(i, o, a), !1);
                const b = Pf({ z: i, x: o, y: a }, v);
                return new Ci(
                  [(u + b.x / b.scale) * e, e * (b.y / b.scale), d],
                  [(u + b.x2 / b.scale) * e, e * (b.y2 / b.scale), _],
                );
              }),
              (r.cs = function (n, e, i) {
                return (
                  (n[0] = Math.min(e[0], i[0])),
                  (n[1] = Math.min(e[1], i[1])),
                  (n[2] = Math.min(e[2], i[2])),
                  (n[3] = Math.min(e[3], i[3])),
                  n
                );
              }),
              (r.ct = function (n, e, i) {
                return (
                  (n[0] = Math.max(e[0], i[0])),
                  (n[1] = Math.max(e[1], i[1])),
                  (n[2] = Math.max(e[2], i[2])),
                  (n[3] = Math.max(e[3], i[3])),
                  n
                );
              }),
              (r.cu = function (n) {
                const e = Math.round(((n + 45 + 360) % 360) / 90) % 4;
                return W[e];
              }),
              (r.cv = He),
              (r.cw = la),
              (r.cx = S),
              (r.cy = function (n) {
                const e = xe(new Float64Array(16));
                Ae(e, n.pixelMatrix, n.globeMatrix);
                const i = [0, z, 0],
                  o = [0, O, 0];
                return (
                  mn(i, i, e),
                  mn(o, o, e),
                  [
                    i[0] > 0 &&
                      i[0] <= n.width &&
                      i[1] > 0 &&
                      i[1] <= n.height &&
                      !J_(n, new Y(n.center.lat, 90)),
                    o[0] > 0 &&
                      o[0] <= n.width &&
                      o[1] > 0 &&
                      o[1] <= n.height &&
                      !J_(n, new Y(n.center.lat, -90)),
                  ]
                );
              }),
              (r.cz = function (n, e) {
                const { scale: i } = n.tileTransform,
                  o =
                    (i * mt) /
                    (n.tileSize *
                      Math.pow(
                        2,
                        e.zoom - n.tileID.overscaledZ + n.tileID.canonical.z,
                      ));
                return (function (a, u, d) {
                  var _ = u[1],
                    v = u[2],
                    b = u[3],
                    E = d[0],
                    A = d[1];
                  return (
                    (a[0] = u[0] * E),
                    (a[1] = _ * E),
                    (a[2] = v * A),
                    (a[3] = b * A),
                    a
                  );
                })(new Float32Array(4), e.inverseAdjustmentMatrix, [o, o]);
              }),
              (r.d = function (n) {
                return hr.API_TILEJSON_REGEX.test(n);
              }),
              (r.d$ = ef),
              (r.d0 = ku),
              (r.d1 = Cy),
              (r.d2 = Ch),
              (r.d3 = Pa),
              (r.d4 = gs),
              (r.d5 = mc),
              (r.d6 = Kt),
              (r.d7 = function (n) {
                const e = n.indexOf(Bc);
                return e >= 0 ? n.slice(0, e) : n;
              }),
              (r.d8 = function (n) {
                return n.indexOf(Bc) >= 0;
              }),
              (r.d9 = function (n) {
                const e = n.lastIndexOf(Bc);
                return e >= 0 ? n.slice(e + 1) : "";
              }),
              (r.dA = Cv),
              (r.dB = Ur),
              (r.dC = Tr),
              (r.dD = 256),
              (r.dE = function (n, e) {
                const i = [0, 0, 0];
                return (mn(i, i, Mm(Yo(e.canonical))), mn(i, i, n), i);
              }),
              (r.dF = (n) => ({
                u_matrix: new Rl(n),
                u_texsize: new Us(n),
                u_pixels_to_tile_units: new Yc(n),
                u_device_pixel_ratio: new Vn(n),
                u_width_scale: new Vn(n),
                u_floor_width_scale: new Vn(n),
                u_image: new wu(n),
                u_units_to_pixels: new Us(n),
                u_tile_units_to_pixels: new Vn(n),
                u_alpha_discard_threshold: new Vn(n),
                u_trim_offset: new Us(n),
                u_trim_fade_range: new Us(n),
                u_trim_color: new Tu(n),
                u_emissive_strength: new Vn(n),
                u_zbias_factor: new Vn(n),
                u_tile_to_meter: new Vn(n),
                u_ground_shadow_factor: new Xc(n),
                u_pattern_transition: new Vn(n),
              })),
              (r.dG = (n) => ({
                u_matrix: new Rl(n),
                u_pixels_to_tile_units: new Yc(n),
                u_device_pixel_ratio: new Vn(n),
                u_width_scale: new Vn(n),
                u_floor_width_scale: new Vn(n),
                u_units_to_pixels: new Us(n),
                u_dash_image: new wu(n),
                u_gradient_image: new wu(n),
                u_image_height: new Vn(n),
                u_texsize: new Us(n),
                u_tile_units_to_pixels: new Vn(n),
                u_alpha_discard_threshold: new Vn(n),
                u_trim_offset: new Us(n),
                u_trim_fade_range: new Us(n),
                u_trim_color: new Tu(n),
                u_emissive_strength: new Vn(n),
                u_zbias_factor: new Vn(n),
                u_tile_to_meter: new Vn(n),
                u_ground_shadow_factor: new Xc(n),
              })),
              (r.dH = (n) => ({
                u_camera_to_center_distance: new Vn(n),
                u_extrude_scale: new Yc(n),
                u_device_pixel_ratio: new Vn(n),
                u_matrix: new Rl(n),
                u_inv_rot_matrix: new Rl(n),
                u_merc_center: new Us(n),
                u_tile_id: new Xc(n),
                u_zoom_transition: new Vn(n),
                u_up_dir: new Xc(n),
                u_emissive_strength: new Vn(n),
              })),
              (r.dI = Xd),
              (r.dJ = bE),
              (r.dK = zv),
              (r.dL = (n, e, i, o, a, u) => {
                const d = n.transform,
                  _ = d.projection.name === "globe";
                let v;
                if (u.paint.get("circle-pitch-alignment") === "map")
                  if (_) {
                    const E =
                      Cv(d.zoom, e.canonical) * d._pixelsPerMercatorPixel;
                    v = Float32Array.from([E, 0, 0, E]);
                  } else v = d.calculatePixelsToTileUnitsMatrix(i);
                else
                  v = new Float32Array([
                    d.pixelsToGLUnits[0],
                    0,
                    0,
                    d.pixelsToGLUnits[1],
                  ]);
                const b = {
                  u_camera_to_center_distance:
                    n.transform.getCameraToCenterDistance(d.projection),
                  u_matrix: n.translatePosMatrix(
                    e.projMatrix,
                    i,
                    u.paint.get("circle-translate"),
                    u.paint.get("circle-translate-anchor"),
                  ),
                  u_device_pixel_ratio: As.devicePixelRatio,
                  u_extrude_scale: v,
                  u_inv_rot_matrix: hS,
                  u_merc_center: [0, 0],
                  u_tile_id: [0, 0, 0],
                  u_zoom_transition: 0,
                  u_up_dir: [0, 0, 0],
                  u_emissive_strength: u.paint.get("circle-emissive-strength"),
                };
                if (_) {
                  ((b.u_inv_rot_matrix = o),
                    (b.u_merc_center = a),
                    (b.u_tile_id = [
                      e.canonical.x,
                      e.canonical.y,
                      1 << e.canonical.z,
                    ]),
                    (b.u_zoom_transition = Fl(d.zoom)));
                  const E = a[0] * mt,
                    A = a[1] * mt;
                  b.u_up_dir = d.projection.upVector(new eh(0, 0, 0), E, A);
                }
                return b;
              }),
              (r.dM = tb),
              (r.dN = Gr),
              (r.dO = (n, e, i, o, a, u, d, _, v, b) => {
                const E = n.transform,
                  A =
                    E.pitch < 15
                      ? J0(0.07, 0.7, he((14 - E.zoom) / 5, 0, 1))
                      : 0.07,
                  M =
                    i.paint
                      .get("line-trim-color-use-theme")
                      .constantOr("default") === "none";
                return {
                  u_matrix: eb(n, e, i, o),
                  u_texsize: e.imageAtlasTexture
                    ? e.imageAtlasTexture.size
                    : [0, 0],
                  u_pixels_to_tile_units: E.calculatePixelsToTileUnitsMatrix(e),
                  u_device_pixel_ratio: a,
                  u_width_scale: u,
                  u_floor_width_scale: d,
                  u_image: 0,
                  u_tile_units_to_pixels: Q0(e, E),
                  u_units_to_pixels: [
                    1 / E.pixelsToGLUnits[0],
                    1 / E.pixelsToGLUnits[1],
                  ],
                  u_alpha_discard_threshold: 0,
                  u_trim_offset: _,
                  u_trim_fade_range: i.paint.get("line-trim-fade-range"),
                  u_trim_color: i.paint
                    .get("line-trim-color")
                    .toPremultipliedRenderColor(M ? null : i.lut)
                    .toArray01(),
                  u_emissive_strength: i.paint.get("line-emissive-strength"),
                  u_zbias_factor: A,
                  u_tile_to_meter: Ve(e.tileID.canonical, 0),
                  u_ground_shadow_factor: v,
                  u_pattern_transition: b,
                };
              }),
              (r.dP = (n, e, i, o, a, u, d, _, v, b) => {
                const E = n.transform,
                  A = E.calculatePixelsToTileUnitsMatrix(e),
                  M =
                    i.paint
                      .get("line-trim-color-use-theme")
                      .constantOr("default") === "none",
                  R =
                    E.pitch < 15
                      ? J0(0.07, 0.7, he((14 - E.zoom) / 5, 0, 1))
                      : 0.07;
                return {
                  u_matrix: eb(n, e, i, o),
                  u_pixels_to_tile_units: A,
                  u_device_pixel_ratio: u,
                  u_width_scale: d,
                  u_floor_width_scale: _,
                  u_units_to_pixels: [
                    1 / E.pixelsToGLUnits[0],
                    1 / E.pixelsToGLUnits[1],
                  ],
                  u_dash_image: 0,
                  u_gradient_image: 1,
                  u_image_height: a,
                  u_texsize:
                    ib(i) && e.lineAtlasTexture
                      ? e.lineAtlasTexture.size
                      : [0, 0],
                  u_tile_units_to_pixels: Q0(e, n.transform),
                  u_alpha_discard_threshold: 0,
                  u_trim_offset: v,
                  u_trim_fade_range: i.paint.get("line-trim-fade-range"),
                  u_trim_color: i.paint
                    .get("line-trim-color")
                    .toPremultipliedRenderColor(M ? null : i.lut)
                    .toArray01(),
                  u_emissive_strength: i.paint.get("line-emissive-strength"),
                  u_zbias_factor: R,
                  u_tile_to_meter: Ve(e.tileID.canonical, 0),
                  u_ground_shadow_factor: b,
                };
              }),
              (r.dQ = dt),
              (r.dR = hf),
              (r.dS = ze),
              (r.dT = nS),
              (r.dU = Om),
              (r.dV = E0),
              (r.dW = Nl),
              (r.dX = 450),
              (r.dY = 7),
              (r.dZ = iI),
              (r.d_ = Ai),
              (r.da = function (n) {
                const e = [],
                  i = n.id;
                return (
                  i === void 0 &&
                    e.push({
                      message: `layers.${i}: missing required property "id"`,
                    }),
                  n.render === void 0 &&
                    e.push({
                      message: `layers.${i}: missing required method "render"`,
                    }),
                  n.renderingMode &&
                    n.renderingMode !== "2d" &&
                    n.renderingMode !== "3d" &&
                    e.push({
                      message: `layers.${i}: property "renderingMode" must be either "2d" or "3d"`,
                    }),
                  e
                );
              }),
              (r.db = function (n, e, i, o) {
                return n.type === "custom"
                  ? new nI(n, e)
                  : new mI[n.type](n, e, i, o);
              }),
              (r.dc = Xt),
              (r.dd = function (n) {
                const e = n.indexOf(Bc);
                return e >= 0 ? n.slice(e + 1) : "";
              }),
              (r.de = class extends ju {
                constructor(n, e) {
                  (super(n._vectorTileFeature, n._z, n._x, n._y, n.id),
                    n.state && (this.state = Object.assign({}, n.state)),
                    (this.target = e.target),
                    (this.namespace = e.namespace),
                    e.properties && (this.properties = e.properties),
                    this.target &&
                      (("featuresetId" in this.target &&
                        !this.target.importId) ||
                        "layerId" in this.target) &&
                      ((this.source = n.source),
                      (this.sourceLayer = n.sourceLayer),
                      (this.layer = n.layer)));
                }
                toJSON() {
                  const n = super.toJSON();
                  return (
                    (n.target = this.target),
                    (n.namespace = this.namespace),
                    n
                  );
                }
              }),
              (r.df = lu),
              (r.dg = nl),
              (r.dh = function (n) {
                return (
                  n({ pluginStatus: kr, pluginURL: uo }),
                  lu.on("pluginStateChange", n),
                  n
                );
              }),
              (r.di = wm),
              (r.dj = class extends mo {
                constructor(n) {
                  (super(n), (this.current = sf));
                }
                set(n, e, i) {
                  if (this.fetchUniformLocation(n, e)) {
                    for (let o = 0; o < 9; o++)
                      if (i[o] !== this.current[o]) {
                        ((this.current = i),
                          this.gl.uniformMatrix3fv(this.location, !1, i));
                        break;
                      }
                  }
                }
              }),
              (r.dk = K),
              (r.dl = function (n, e, i) {
                const o = Fl(i.zoom),
                  a = n.style.map._antialias,
                  u = n.terrain && n.terrain.exaggeration() > 0;
                return o === 0 && !a && !u;
              }),
              (r.dm = function (n) {
                const e = n.pixelsPerMeter,
                  i = e / me(1, n.center.lat),
                  o = xe(new Float64Array(16));
                return (
                  Qe(o, o, [n.point.x, n.point.y, 0]),
                  gt(o, o, [i, i, e]),
                  Float32Array.from(o)
                );
              }),
              (r.dn = Im),
              (r.dp = function (n) {
                const e = He - 5;
                n = (he(n, -80.051129, e) / e) * 90;
                const i = Math.pow(Math.abs(Math.sin(Mi(n))), 3);
                return Math.round(i * (L.length - 1));
              }),
              (r.dq = function (n, e, i, o) {
                const a = e.getNorth(),
                  u = e.getSouth(),
                  d = e.getWest(),
                  _ = e.getEast(),
                  v = 1 << n.z,
                  b = _ - d,
                  E = a - u,
                  A = b / D,
                  M = -E / L[i],
                  R = [0, A, 0, M, 0, 0, a, d, 0];
                if (n.z > 0) {
                  const k = 180 / o;
                  de(R, R, [
                    k / b + 1,
                    0,
                    0,
                    0,
                    k / E + 1,
                    0,
                    (-0.5 * k) / A,
                    (0.5 * k) / M,
                    1,
                  ]);
                }
                return ((R[2] = v), (R[5] = n.x), (R[8] = n.y), R);
              }),
              (r.dr = Yo),
              (r.ds = function (n, e, i) {
                const o = xe(new Float64Array(16)),
                  a = (e / (1 << n) - 0.5) * Math.PI * 2;
                return (Mt(o, i.globeMatrix, a), Float32Array.from(o));
              }),
              (r.dt = class {
                isDataAvailableAtPoint(n) {
                  const e = this._source();
                  if (this.isUsingMockSource() || !e || n.y < 0 || n.y > 1)
                    return !1;
                  const i = e.getSource().maxzoom,
                    o = 1 << i,
                    a = Math.floor(n.x),
                    u = Math.floor((n.x - a) * o),
                    d = Math.floor(n.y * o),
                    _ = this.findDEMTileFor(new Lr(i, a, i, u, d));
                  return !(!_ || !_.dem);
                }
                getAtPointOrZero(n, e = 0) {
                  return this.getAtPoint(n, e) || 0;
                }
                getAtPoint(n, e, i = !0) {
                  if (this.isUsingMockSource()) return null;
                  e == null && (e = null);
                  const o = this._source();
                  if (!o || n.y < 0 || n.y > 1) return e;
                  const a = o.getSource().maxzoom,
                    u = 1 << a,
                    d = Math.floor(n.x),
                    _ = n.x - d,
                    v = new Lr(a, d, a, Math.floor(_ * u), Math.floor(n.y * u)),
                    b = this.findDEMTileFor(v);
                  if (!b || !b.dem) return e;
                  const E = b.dem,
                    A = 1 << b.tileID.canonical.z,
                    M = (_ * A - b.tileID.canonical.x) * E.dim,
                    R = (n.y * A - b.tileID.canonical.y) * E.dim,
                    k = Math.floor(M),
                    N = Math.floor(R);
                  return (
                    (i ? this.exaggeration() : 1) *
                    Ht(
                      Ht(E.get(k, N), E.get(k, N + 1), R - N),
                      Ht(E.get(k + 1, N), E.get(k + 1, N + 1), R - N),
                      M - k,
                    )
                  );
                }
                getAtTileOffset(n, e, i) {
                  const o = 1 << n.canonical.z;
                  return this.getAtPointOrZero(
                    new Te(
                      n.wrap + (n.canonical.x + e / mt) / o,
                      (n.canonical.y + i / mt) / o,
                    ),
                  );
                }
                getAtTileOffsetFunc(n, e, i, o) {
                  return (a) => {
                    const u = this.getAtTileOffset(n, a.x, a.y),
                      d = o.upVector(n.canonical, a.x, a.y);
                    return (
                      Vi(
                        d,
                        d,
                        u * o.upVectorScale(n.canonical, e, i).metersToTile,
                      ),
                      d
                    );
                  };
                }
                getForTilePoints(n, e, i, o) {
                  if (this.isUsingMockSource()) return !1;
                  const a = Bu.create(this, n, o);
                  return (
                    !!a &&
                    (e.forEach((u) => {
                      u[2] =
                        this.exaggeration() * a.getElevationAt(u[0], u[1], i);
                    }),
                    !0)
                  );
                }
                getMinMaxForTile(n) {
                  if (this.isUsingMockSource()) return null;
                  const e = this.findDEMTileFor(n);
                  if (!e || !e.dem) return null;
                  const i = e.dem.tree,
                    o = e.tileID,
                    a = 1 << (n.canonical.z - o.canonical.z);
                  let u = n.canonical.x / a - o.canonical.x,
                    d = n.canonical.y / a - o.canonical.y,
                    _ = 0;
                  for (
                    let v = 0;
                    v < n.canonical.z - o.canonical.z && !i.leaves[_];
                    v++
                  ) {
                    ((u *= 2), (d *= 2));
                    const b = 2 * Math.floor(d) + Math.floor(u);
                    ((_ = i.childOffsets[_] + b), (u %= 1), (d %= 1));
                  }
                  return {
                    min: this.exaggeration() * i.minimums[_],
                    max: this.exaggeration() * i.maximums[_],
                  };
                }
                getMinElevationBelowMSL() {
                  throw new Error("Pure virtual method called.");
                }
                raycast(n, e, i) {
                  throw new Error("Pure virtual method called.");
                }
                pointCoordinate(n) {
                  throw new Error("Pure virtual method called.");
                }
                _source() {
                  throw new Error("Pure virtual method called.");
                }
                isUsingMockSource() {
                  throw new Error("Pure virtual method called.");
                }
                exaggeration() {
                  throw new Error("Pure virtual method called.");
                }
                findDEMTileFor(n) {
                  throw new Error("Pure virtual method called.");
                }
                get visibleDemTiles() {
                  throw new Error("Getter must be implemented in subclass.");
                }
                getMinMaxForVisibleTiles() {
                  const n = this.visibleDemTiles;
                  if (n.length === 0) return null;
                  let e = !1,
                    i = Number.MAX_VALUE,
                    o = Number.MIN_VALUE;
                  for (const a of n) {
                    const u = this.getMinMaxForTile(a.tileID);
                    u &&
                      ((i = Math.min(i, u.min)),
                      (o = Math.max(o, u.max)),
                      (e = !0));
                  }
                  return e ? { min: i, max: o } : null;
                }
              }),
              (r.du = Gv),
              (r.dv = Em),
              (r.dw = function (n, e) {
                return [
                  Math.pow(n[0], 2.2) * e,
                  Math.pow(n[1], 2.2) * e,
                  Math.pow(n[2], 2.2) * e,
                ];
              }),
              (r.dx = ne),
              (r.dy = function (n, e) {
                var i = Math.sin(e),
                  o = Math.cos(e);
                return (
                  (n[0] = o),
                  (n[1] = i),
                  (n[2] = 0),
                  (n[3] = -i),
                  (n[4] = o),
                  (n[5] = 0),
                  (n[6] = 0),
                  (n[7] = 0),
                  (n[8] = 1),
                  n
                );
              }),
              (r.dz = Za),
              (r.e = hr),
              (r.e$ = iw),
              (r.e0 = 256),
              (r.e1 = Y_),
              (r.e2 = Vs),
              (r.e3 = Mt),
              (r.e4 = function (n, e) {
                return (
                  (n[0] = e[0]),
                  (n[1] = e[1]),
                  (n[2] = e[2]),
                  (n[3] = e[4]),
                  (n[4] = e[5]),
                  (n[5] = e[6]),
                  (n[6] = e[8]),
                  (n[7] = e[9]),
                  (n[8] = e[10]),
                  n
                );
              }),
              (r.e5 = Wo),
              (r.e6 = $c),
              (r.e7 = Hp),
              (r.e8 = function (n, e, i, o, a) {
                return he(((n - e) / (i - e)) * (a - o) + o, o, a);
              }),
              (r.e9 = Io),
              (r.eA = function (n, e, i) {
                return (
                  (n[0] = e[0] / i[0]),
                  (n[1] = e[1] / i[1]),
                  (n[2] = e[2] / i[2]),
                  n
                );
              }),
              (r.eB = Xa),
              (r.eC = U),
              (r.eD = fs),
              (r.eE = function (n, e, i, o) {
                return ((n[0] = e), (n[1] = i), (n[2] = o), n);
              }),
              (r.eF = function ([n, e, i]) {
                const o = Math.hypot(n, e, i),
                  a = Math.atan2(n, i),
                  u = 0.5 * Math.PI - Math.acos(-e / o);
                return new Y(Fe(a), Fe(u));
              }),
              (r.eG = ic),
              (r.eH = Gy),
              (r.eI = function (n) {
                const e = n.navigator ? n.navigator.userAgent : null;
                return (
                  !!(function (i) {
                    if (On == null) {
                      const o = i.navigator ? i.navigator.userAgent : null;
                      On =
                        !!i.safari ||
                        !(
                          !o ||
                          !(
                            /\b(iPad|iPhone|iPod)\b/.test(o) ||
                            (o.match("Safari") && !o.match("Chrome"))
                          )
                        );
                    }
                    return On;
                  })(n) &&
                  !(
                    !e ||
                    !(
                      e.match("Version/15.4") ||
                      e.match("Version/15.5") ||
                      e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/)
                    )
                  )
                );
              }),
              (r.eJ = function (n, e) {
                ((Ms = n), (no = e));
              }),
              (r.eK = J_),
              (r.eL = Dv),
              (r.eM = function (n) {
                const e = [0, 0, 0],
                  i = xe(new Float64Array(16));
                return (
                  Ae(i, n.pixelMatrix, n.globeMatrix),
                  mn(e, e, i),
                  new ft(e[0], e[1])
                );
              }),
              (r.eN = function () {
                const n = bf;
                n &&
                  (n.isPreloaded() && n.numActive() === 1
                    ? (n.release(fy), (bf = null))
                    : console.warn(
                        "Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()",
                      ));
              }),
              (r.eO = function () {
                Bm().acquire(fy);
              }),
              (r.eP = Tl),
              (r.eQ = function (n, e, i = !1) {
                if (kr === Qr.deferred || kr === Qr.loading || kr === Qr.loaded)
                  throw new Error(
                    "setRTLTextPlugin cannot be called multiple times.",
                  );
                ((uo = As.resolveURL(n)),
                  (kr = Qr.deferred),
                  (Vd = e),
                  au(),
                  i || tm());
              }),
              (r.eR = function (n) {
                ((Pu = As.resolveURL(n)),
                  Du || (Du = new Cu(Bm(), new ya())),
                  Du.broadcast("setMeshoptUrl", Pu));
              }),
              (r.eS = B0),
              (r.eT = function (n) {
                ((my = As.resolveURL(n)),
                  Du || (Du = new Cu(Bm(), new ya())),
                  Du.broadcast("setDracoUrl", my));
              }),
              (r.eU = F0),
              (r.eV = vf),
              (r.eW = function (n) {
                const e = fa();
                if (!e) return;
                const i = e.delete(io);
                n && i.then(() => n()).catch(n);
              }),
              (r.eX = rh),
              (r.eY = Tt),
              (r.eZ = Bl),
              (r.e_ = yo),
              (r.ea = function (n, e) {
                var i = e[0],
                  o = e[1],
                  a = e[2],
                  u = e[3],
                  d = e[4],
                  _ = e[5],
                  v = e[6],
                  b = e[7],
                  E = e[8],
                  A = E * d - _ * b,
                  M = -E * u + _ * v,
                  R = b * u - d * v,
                  k = i * A + o * M + a * R;
                return k
                  ? ((n[0] = A * (k = 1 / k)),
                    (n[1] = (-E * o + a * b) * k),
                    (n[2] = (_ * o - a * d) * k),
                    (n[3] = M * k),
                    (n[4] = (E * i - a * v) * k),
                    (n[5] = (-_ * i + a * u) * k),
                    (n[6] = R * k),
                    (n[7] = (-b * i + o * v) * k),
                    (n[8] = (d * i - o * u) * k),
                    n)
                  : null;
              }),
              (r.eb = qr),
              (r.ec = et),
              (r.ed = $y),
              (r.ee = function (n, e) {
                if (n === e) {
                  var i = e[1],
                    o = e[2],
                    a = e[3],
                    u = e[6],
                    d = e[7],
                    _ = e[11];
                  ((n[1] = e[4]),
                    (n[2] = e[8]),
                    (n[3] = e[12]),
                    (n[4] = i),
                    (n[6] = e[9]),
                    (n[7] = e[13]),
                    (n[8] = o),
                    (n[9] = u),
                    (n[11] = e[14]),
                    (n[12] = a),
                    (n[13] = d),
                    (n[14] = _));
                } else
                  ((n[0] = e[0]),
                    (n[1] = e[4]),
                    (n[2] = e[8]),
                    (n[3] = e[12]),
                    (n[4] = e[1]),
                    (n[5] = e[5]),
                    (n[6] = e[9]),
                    (n[7] = e[13]),
                    (n[8] = e[2]),
                    (n[9] = e[6]),
                    (n[10] = e[10]),
                    (n[11] = e[14]),
                    (n[12] = e[3]),
                    (n[13] = e[7]),
                    (n[14] = e[11]),
                    (n[15] = e[15]));
                return n;
              }),
              (r.ef = qt),
              (r.eg = [1, 1, 1]),
              (r.eh = class {
                constructor(n, e, i, o) {
                  ((this.context = n),
                    (this.format = o),
                    (this.size = i),
                    (this.texture = n.gl.createTexture()));
                  const [a, u, d] = this.size,
                    { gl: _ } = n;
                  (_.bindTexture(_.TEXTURE_3D, this.texture),
                    n.pixelStoreUnpackFlipY.set(!1),
                    n.pixelStoreUnpack.set(1),
                    n.pixelStoreUnpackPremultiplyAlpha.set(!1),
                    _.texImage3D(
                      _.TEXTURE_3D,
                      0,
                      this.format,
                      a,
                      u,
                      d,
                      0,
                      Ny(this.format),
                      Vy(this.format),
                      e.data,
                    ));
                }
                bind(n, e) {
                  const { context: i } = this,
                    { gl: o } = i;
                  (o.bindTexture(o.TEXTURE_3D, this.texture),
                    n !== this.minFilter &&
                      (o.texParameteri(o.TEXTURE_3D, o.TEXTURE_MAG_FILTER, n),
                      o.texParameteri(o.TEXTURE_3D, o.TEXTURE_MIN_FILTER, n),
                      (this.minFilter = n)),
                    e !== this.wrapS &&
                      (o.texParameteri(o.TEXTURE_3D, o.TEXTURE_WRAP_S, e),
                      o.texParameteri(o.TEXTURE_3D, o.TEXTURE_WRAP_T, e),
                      (this.wrapS = e)));
                }
                destroy() {
                  const { gl: n } = this.context;
                  (n.deleteTexture(this.texture), (this.texture = null));
                }
              }),
              (r.ei = Bu),
              (r.ej = function (n, e, i, o) {
                var a = new B(4);
                return ((a[0] = n), (a[1] = e), (a[2] = i), (a[3] = o), a);
              }),
              (r.ek = Mr),
              (r.el = function (n, e, i, o) {
                var a = e[0],
                  u = e[1],
                  d = e[2],
                  _ = e[3];
                return (
                  (n[0] = a + o * (i[0] - a)),
                  (n[1] = u + o * (i[1] - u)),
                  (n[2] = d + o * (i[2] - d)),
                  (n[3] = _ + o * (i[3] - _)),
                  n
                );
              }),
              (r.em = Fu),
              (r.en = Ho),
              (r.eo = ka),
              (r.ep = function (
                n,
                e,
                i,
                o,
                a,
                u,
                d,
                _,
                v,
                b,
                E,
                A,
                M,
                R,
                k,
                N,
              ) {
                var j = new B(16);
                return (
                  (j[0] = n),
                  (j[1] = e),
                  (j[2] = i),
                  (j[3] = o),
                  (j[4] = a),
                  (j[5] = u),
                  (j[6] = d),
                  (j[7] = _),
                  (j[8] = v),
                  (j[9] = b),
                  (j[10] = E),
                  (j[11] = A),
                  (j[12] = M),
                  (j[13] = R),
                  (j[14] = k),
                  (j[15] = N),
                  j
                );
              }),
              (r.eq = $),
              (r.er = gu),
              (r.es = Jd),
              (r.et = class {
                constructor() {
                  ((this._updateTime = 0),
                    (this._sourceIds = []),
                    (this._activeRegions = []),
                    (this._prevRegions = []),
                    (this._globalClipBounds = {
                      min: new ft(1 / 0, 1 / 0),
                      max: new ft(-1 / 0, -1 / 0),
                    }));
                }
                clear() {
                  (this._activeRegions.length > 0 && ++this._updateTime,
                    (this._activeRegions = []),
                    (this._prevRegions = []));
                }
                get updateTime() {
                  return this._updateTime;
                }
                getReplacementRegionsForTile(n, e = !1) {
                  const i = l0(new ft(0, 0), new ft(mt, mt), n),
                    o = [];
                  if (e && !ly(i, this._globalClipBounds)) return o;
                  for (const a of this._activeRegions) {
                    if (a.hiddenByOverlap || !ly(i, a)) continue;
                    const u = BS(a.min, a.max, n);
                    o.push({
                      min: u.min,
                      max: u.max,
                      sourceId: this._sourceIds[a.priority],
                      footprint: a.footprint,
                      footprintTileId: a.tileId,
                      order: a.order,
                      clipMask: a.clipMask,
                      clipScope: a.clipScope,
                    });
                  }
                  return o;
                }
                setSources(n) {
                  this._setSources(
                    n.map((e) => ({
                      getSourceId: () => e.cache.id,
                      getFootprints: () => {
                        const i = [];
                        for (const o of e.cache.getVisibleCoordinates()) {
                          const a = e.cache.getTile(o).buckets[e.layer];
                          a && a.updateFootprints(o.toUnwrapped(), i);
                        }
                        return i;
                      },
                      getOrder: () => e.order,
                      getClipMask: () => e.clipMask,
                      getClipScope: () => e.clipScope,
                    })),
                  );
                }
                _addSource(n) {
                  const e = n.getFootprints();
                  if (e.length === 0) return;
                  const i = n.getOrder(),
                    o = n.getClipMask(),
                    a = n.getClipScope();
                  for (const u of e) {
                    if (!u.footprint) continue;
                    const d = l0(u.footprint.min, u.footprint.max, u.id);
                    this._activeRegions.push({
                      min: d.min,
                      max: d.max,
                      hiddenByOverlap: !1,
                      priority: this._sourceIds.length,
                      tileId: u.id,
                      footprint: u.footprint,
                      order: i,
                      clipMask: o,
                      clipScope: a,
                    });
                  }
                  this._sourceIds.push(n.getSourceId());
                }
                _computeReplacement() {
                  this._activeRegions.sort(
                    (e, i) =>
                      e.priority - i.priority ||
                      km(e.min, i.min) ||
                      km(e.max, i.max) ||
                      e.order - i.order ||
                      e.clipMask - i.clipMask ||
                      (function (o, a) {
                        const u = (d, _) => d + _;
                        return (
                          o.length - a.length ||
                          o.reduce(u, "").localeCompare(a.reduce(u, ""))
                        );
                      })(e.clipScope, i.clipScope),
                  );
                  let n =
                    this._activeRegions.length !== this._prevRegions.length;
                  if (!n) {
                    let e = 0;
                    for (; !n && e !== this._activeRegions.length; ) {
                      const i = this._activeRegions[e],
                        o = this._prevRegions[e];
                      ((n =
                        i.priority !== o.priority ||
                        !a0(i, o) ||
                        i.order !== o.order ||
                        i.clipMask !== o.clipMask ||
                        !to(i.clipScope, o.clipScope)),
                        ++e);
                    }
                  }
                  if (n) {
                    ++this._updateTime;
                    for (const i of this._activeRegions)
                      i.order !== zm &&
                        ((this._globalClipBounds.min.x = Math.min(
                          this._globalClipBounds.min.x,
                          i.min.x,
                        )),
                        (this._globalClipBounds.min.y = Math.min(
                          this._globalClipBounds.min.y,
                          i.min.y,
                        )),
                        (this._globalClipBounds.max.x = Math.max(
                          this._globalClipBounds.max.x,
                          i.max.x,
                        )),
                        (this._globalClipBounds.max.y = Math.max(
                          this._globalClipBounds.max.y,
                          i.max.y,
                        )));
                    const e = (i) => {
                      const o = this._activeRegions;
                      if (i >= o.length) return i;
                      const a = o[i].priority;
                      for (; i < o.length && o[i].priority === a; ) ++i;
                      return i;
                    };
                    if (this._sourceIds.length > 1) {
                      let i = 0,
                        o = e(i);
                      for (; i !== o; ) {
                        let a = i;
                        const u = i;
                        for (; a !== o; ) {
                          const d = this._activeRegions[a];
                          d.hiddenByOverlap = !1;
                          for (let _ = 0; _ < u; _++) {
                            const v = this._activeRegions[_];
                            if (
                              !v.hiddenByOverlap &&
                              d.order === zm &&
                              ly(d, v) &&
                              ((d.hiddenByOverlap = h0(
                                d.footprint,
                                d.tileId,
                                v.footprint,
                                v.tileId,
                              )),
                              d.hiddenByOverlap)
                            )
                              break;
                          }
                          ++a;
                        }
                        ((i = o), (o = e(i)));
                      }
                    }
                  }
                }
                _setSources(n) {
                  (([this._prevRegions, this._activeRegions] = [
                    this._activeRegions,
                    [],
                  ]),
                    (this._sourceIds = []));
                  for (let e = n.length - 1; e >= 0; e--) this._addSource(n[e]);
                  this._computeReplacement();
                }
              }),
              (r.eu = zm),
              (r.ev = class {
                constructor(n) {
                  (this._createGrid(n), this._createPoles(n));
                }
                destroy() {
                  (this._poleIndexBuffer.destroy(),
                    this._gridBuffer.destroy(),
                    this._gridIndexBuffer.destroy(),
                    this._poleNorthVertexBuffer.destroy(),
                    this._poleSouthVertexBuffer.destroy());
                  for (const n of this._poleSegments) n.destroy();
                  for (const n of this._gridSegments)
                    (n.withSkirts.destroy(), n.withoutSkirts.destroy());
                }
                _fillGridMeshWithLods(n, e) {
                  const i = new po(),
                    o = new dr(),
                    a = [],
                    u = n + 1 + 2,
                    d = e[0] + 1,
                    _ = e[0] + 1 + (1 + e.length),
                    v = (b, E, A) => {
                      let M = b === u - 1 ? b - 2 : b === 0 ? b : b - 1;
                      return ((M += A ? 24575 : 0), [M, E]);
                    };
                  for (let b = 0; b < u; ++b) i.emplaceBack(...v(b, 0, !0));
                  for (let b = 0; b < d; ++b)
                    for (let E = 0; E < u; ++E)
                      i.emplaceBack(...v(E, b, (E === 0 || E === u - 1) && !0));
                  for (let b = 0; b < e.length; ++b) {
                    const E = e[b];
                    for (let A = 0; A < u; ++A) i.emplaceBack(...v(A, E, !0));
                  }
                  for (let b = 0; b < e.length; ++b) {
                    const E = o.length,
                      A = e[b] + 1 + 2,
                      M = new dr();
                    for (let N = 0; N < A - 1; N++) {
                      const j = N === A - 2,
                        H = j ? u * (_ - e.length + b - N) : u;
                      for (let J = 0; J < u - 1; J++) {
                        const Q = N * u + J;
                        N === 0 || j || J === 0 || J === u - 2
                          ? (M.emplaceBack(Q + 1, Q, Q + H),
                            M.emplaceBack(Q + H, Q + H + 1, Q + 1))
                          : (o.emplaceBack(Q + 1, Q, Q + H),
                            o.emplaceBack(Q + H, Q + H + 1, Q + 1));
                      }
                    }
                    const R = Rn.simpleSegment(0, E, i.length, o.length - E);
                    for (let N = 0; N < M.uint16.length; N += 3)
                      o.emplaceBack(
                        M.uint16[N],
                        M.uint16[N + 1],
                        M.uint16[N + 2],
                      );
                    const k = Rn.simpleSegment(0, E, i.length, o.length - E);
                    a.push({ withoutSkirts: R, withSkirts: k });
                  }
                  return { vertices: i, indices: o, segments: a };
                }
                _createGrid(n) {
                  const e = this._fillGridMeshWithLods(D, L);
                  ((this._gridSegments = e.segments),
                    (this._gridBuffer = n.createVertexBuffer(
                      e.vertices,
                      Sv.members,
                    )),
                    (this._gridIndexBuffer = n.createIndexBuffer(
                      e.indices,
                      !0,
                    )));
                }
                _createPoles(n) {
                  const e = new dr();
                  for (let d = 0; d <= D; d++) e.emplaceBack(0, d + 1, d + 2);
                  this._poleIndexBuffer = n.createIndexBuffer(e, !0);
                  const i = new Wo(),
                    o = new Wo(),
                    a = new Wo(),
                    u = new Wo();
                  this._poleSegments = [];
                  for (let d = 0, _ = 0; d < w; d++) {
                    const v = 360 / (1 << d);
                    (i.emplaceBack(0, -x, 0, 0.5, 0),
                      o.emplaceBack(0, -x, 0, 0.5, 1),
                      a.emplaceBack(0, -x, 0, 0.5, 0.5),
                      u.emplaceBack(0, -x, 0, 0.5, 0.5));
                    for (let b = 0; b <= D; b++) {
                      let E = b / D,
                        A = 0;
                      const M = Ht(0, v, E),
                        [R, k, N] = G(lS, cS, M, x);
                      (i.emplaceBack(R, k, N, E, A),
                        o.emplaceBack(R, k, N, E, 1 - A));
                      const j = Mi(M);
                      ((E = 0.5 + 0.5 * Math.sin(j)),
                        (A = 0.5 + 0.5 * Math.cos(j)),
                        a.emplaceBack(R, k, N, E, A),
                        u.emplaceBack(R, k, N, E, 1 - A));
                    }
                    (this._poleSegments.push(Rn.simpleSegment(_, 0, 66, 64)),
                      (_ += 66));
                  }
                  ((this._poleNorthVertexBuffer = n.createVertexBuffer(
                    i,
                    Sm,
                    !1,
                  )),
                    (this._poleSouthVertexBuffer = n.createVertexBuffer(
                      o,
                      Sm,
                      !1,
                    )),
                    (this._texturedPoleNorthVertexBuffer = n.createVertexBuffer(
                      a,
                      Sm,
                      !1,
                    )),
                    (this._texturedPoleSouthVertexBuffer = n.createVertexBuffer(
                      u,
                      Sm,
                      !1,
                    )));
                }
                getGridBuffers(n, e) {
                  return [
                    this._gridBuffer,
                    this._gridIndexBuffer,
                    e
                      ? this._gridSegments[n].withSkirts
                      : this._gridSegments[n].withoutSkirts,
                  ];
                }
                getPoleBuffers(n, e) {
                  return [
                    e
                      ? this._texturedPoleNorthVertexBuffer
                      : this._poleNorthVertexBuffer,
                    e
                      ? this._texturedPoleSouthVertexBuffer
                      : this._poleSouthVertexBuffer,
                    this._poleIndexBuffer,
                    this._poleSegments[n],
                  ];
                }
              }),
              (r.ew = oe),
              (r.ex = function () {
                return (
                  !!document.fullscreenElement ||
                  !!document.webkitFullscreenElement
                );
              }),
              (r.ey = ye),
              (r.ez = Ce),
              (r.f = function (n) {
                return btoa(
                  encodeURIComponent(n).replace(/%([0-9A-F]{2})/g, (e, i) =>
                    String.fromCharCode(+("0x" + i)),
                  ),
                );
              }),
              (r.f0 = nw),
              (r.f1 = Z0),
              (r.f2 = gi),
              (r.f3 = "hd_road_elevation"),
              (r.f4 = cs),
              (r.f5 = zt),
              (r.f6 = ih),
              (r.f7 = My),
              (r.f8 = sh),
              (r.f9 = function (n, e, i, o, a, u, d, _ = 1, v, b, E) {
                (n.createArrays(),
                  (n.tilePixelRatio = mt / (512 * n.overscaling)),
                  (n.compareText = {}),
                  (n.iconsNeedLinear = !1));
                const A = n.layers[0].layout,
                  M = n.layers[0]._unevaluatedLayout._values,
                  R = {};
                ((R.scaleFactor = _),
                  (R.textSizeScaleRange = A.get("text-size-scale-range")),
                  (R.iconSizeScaleRange = A.get("icon-size-scale-range")));
                const [k, N] = R.textSizeScaleRange,
                  [j, H] = R.iconSizeScaleRange;
                ((R.textScaleFactor = he(R.scaleFactor, k, N)),
                  (R.iconScaleFactor = he(R.scaleFactor, j, H)));
                const J = M["text-size"],
                  Q = M["icon-size"];
                if (n.textSizeData.kind === "composite") {
                  const { minZoom: ge, maxZoom: be } = n.textSizeData;
                  R.compositeTextSizes = [
                    J.possiblyEvaluate(new qi(ge, { worldview: E }), u),
                    J.possiblyEvaluate(new qi(be, { worldview: E }), u),
                  ];
                }
                if (n.iconSizeData.kind === "composite") {
                  const { minZoom: ge, maxZoom: be } = n.iconSizeData;
                  R.compositeIconSizes = [
                    Q.possiblyEvaluate(new qi(ge, { worldview: E }), u),
                    Q.possiblyEvaluate(new qi(be, { worldview: E }), u),
                  ];
                }
                ((R.layoutTextSize = J.possiblyEvaluate(
                  new qi(d + 1, { worldview: E }),
                  u,
                )),
                  (R.layoutIconSize = Q.possiblyEvaluate(
                    new qi(d + 1, { worldview: E }),
                    u,
                  )),
                  (R.textMaxSize = J.possiblyEvaluate(
                    new qi(18, { worldview: E }),
                    u,
                  )));
                const V = A.get("symbol-placement"),
                  X =
                    A.get("text-rotation-alignment") === "map" && V !== "point",
                  ee = A.get("text-size");
                let re = !1;
                const ve = [];
                for (const ge of n.features) {
                  const be = A.get("text-font").evaluate(ge, {}, u).join(","),
                    Me = ee.evaluate(ge, {}, u) * R.textScaleFactor,
                    Ue =
                      R.layoutTextSize.evaluate(ge, {}, u) * R.textScaleFactor,
                    it =
                      R.layoutIconSize.evaluate(ge, {}, u) * R.iconScaleFactor,
                    Xe = { horizontal: {}, vertical: void 0 },
                    tt = ge.text;
                  let nt,
                    Ge = [0, 0];
                  if (tt) {
                    const Wt = tt.toString(),
                      ni =
                        A.get("text-letter-spacing").evaluate(ge, {}, u) * cr,
                      ii = A.get("text-line-height").evaluate(ge, {}, u) * cr,
                      di = L_(Wt) ? ni : 0,
                      oi = A.get("text-anchor").evaluate(ge, {}, u),
                      fi = A.get("text-variable-anchor");
                    if (!fi) {
                      const $e = A.get("text-radial-offset").evaluate(
                        ge,
                        {},
                        u,
                      );
                      if ($e) Ge = Rb(oi, [$e * cr, Py]);
                      else {
                        const ut = A.get("text-offset").evaluate(ge, {}, u);
                        Ge = [ut[0] * cr, ut[1] * cr];
                      }
                    }
                    let Bi = X
                      ? "center"
                      : A.get("text-justify").evaluate(ge, {}, u);
                    const sn = V === "point",
                      te = sn
                        ? A.get("text-max-width").evaluate(ge, {}, u) * cr
                        : 1 / 0,
                      se = ($e) => {
                        n.allowVerticalPlacement &&
                          Oc(Wt) &&
                          (Xe.vertical = Ey(
                            tt,
                            e,
                            i,
                            a,
                            be,
                            te,
                            ii,
                            oi,
                            $e,
                            di,
                            Ge,
                            hs.vertical,
                            !0,
                            Ue,
                            Me,
                            v,
                          ));
                      };
                    if (!X && fi) {
                      const $e = Bi === "auto" ? fi.map((xt) => Dy(xt)) : [Bi];
                      let ut = !1;
                      for (let xt = 0; xt < $e.length; xt++) {
                        const _t = $e[xt];
                        if (!Xe.horizontal[_t])
                          if (ut) Xe.horizontal[_t] = Xe.horizontal[0];
                          else {
                            const It = Ey(
                              tt,
                              e,
                              i,
                              a,
                              be,
                              te,
                              ii,
                              "center",
                              _t,
                              di,
                              Ge,
                              hs.horizontal,
                              !1,
                              Ue,
                              Me,
                              v,
                            );
                            It &&
                              ((Xe.horizontal[_t] = It),
                              (ut = It.positionedLines.length === 1));
                          }
                      }
                      se("left");
                    } else {
                      if (
                        (Bi === "auto" && (Bi = Dy(oi)),
                        sn ||
                          A.get("text-writing-mode").indexOf("horizontal") >=
                            0 ||
                          !Oc(Wt))
                      ) {
                        const $e = Ey(
                          tt,
                          e,
                          i,
                          a,
                          be,
                          te,
                          ii,
                          oi,
                          Bi,
                          di,
                          Ge,
                          hs.horizontal,
                          !1,
                          Ue,
                          Me,
                          v,
                        );
                        $e && (Xe.horizontal[Bi] = $e);
                      }
                      se(sn ? "left" : Bi);
                    }
                  }
                  let Je,
                    Ne,
                    je,
                    at,
                    ct,
                    Nt,
                    Ct = !1;
                  const yt = A.get("icon-text-fit").evaluate(ge, {}, u);
                  if (ge.icon && ge.icon.hasPrimary()) {
                    const Wt = kb(
                      ge.icon,
                      n.iconSizeData,
                      M["icon-size"],
                      u,
                      n.zoom,
                      ge,
                      v,
                      R.iconScaleFactor,
                      E,
                    );
                    ((Je = Wt.iconPrimary), (je = Wt.iconSecondary));
                    const ni = Je.toString();
                    if (
                      ((Ne = o.get(ni)),
                      Ne &&
                        ((ct = A.get("icon-offset").evaluate(ge, {}, u)),
                        (Nt = A.get("icon-anchor").evaluate(ge, {}, u)),
                        (nt = RE(
                          a.get(ni),
                          je ? a.get(je.toString()) : void 0,
                          ct,
                          Nt,
                        )),
                        (Ct = Ne.sdf),
                        n.sdfIcons === void 0
                          ? (n.sdfIcons = Ne.sdf)
                          : n.sdfIcons !== Ne.sdf &&
                            ri(
                              "Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer",
                            ),
                        (Ne.pixelRatio !== n.pixelRatio ||
                          A.get("icon-rotate").constantOr(1) !== 0) &&
                          (n.iconsNeedLinear = !0)),
                      je)
                    ) {
                      const ii = je.toString();
                      at = o.get(ii);
                    }
                  }
                  re = re || !(!ge.icon || !ge.icon.hasSecondary());
                  const ot = Ry(Xe.horizontal) || Xe.vertical;
                  n.iconsInText || (n.iconsInText = !!ot && ot.iconsInText);
                  const Jt = (Ue * R.textScaleFactor) / cr,
                    { defaultShapedIcon: At, verticallyShapedIcon: Dt } = jE(
                      n,
                      nt,
                      A,
                      ge,
                      u,
                      Xe,
                      Jt,
                      ct,
                      yt,
                    );
                  (yt !== "none" &&
                    nt &&
                    (gb(nt) || _b(nt)) &&
                    (qm(0, Ne, Je, nt, At, yt, b, o, a),
                    qm(0, at, je, nt, At, yt, b, o, a),
                    Dt &&
                      (qm(0, Ne, Je, nt, Dt, yt, b, o, a),
                      qm(0, at, je, nt, Dt, yt, b, o, a))),
                    (nt = At),
                    ve.push({
                      feature: ge,
                      shapedTextOrientations: Xe,
                      shapedText: ot,
                      shapedIcon: nt,
                      iconPrimary: Je,
                      iconSecondary: je,
                      iconOffset: ct,
                      iconAnchor: Nt,
                      verticallyShapedIcon: Dt,
                      layoutTextSize: Ue,
                      layoutIconSize: it,
                      textOffset: Ge,
                      isSDFIcon: Ct,
                      iconTextFit: yt,
                    }));
                }
                return {
                  featureData: ve,
                  sizes: R,
                  hasAnySecondaryIcon: re,
                  textAlongLine: X,
                  symbolPlacement: V,
                };
              }),
              (r.fa = Ib),
              (r.fb = function (n, e, i, o, a, u, d, _, v, b) {
                const {
                  featureData: E,
                  hasAnySecondaryIcon: A,
                  sizes: M,
                  textAlongLine: R,
                  symbolPlacement: k,
                } = e;
                for (const N of E) {
                  const {
                    shapedIcon: j,
                    verticallyShapedIcon: H,
                    feature: J,
                    shapedTextOrientations: Q,
                    shapedText: V,
                    layoutTextSize: X,
                    textOffset: ee,
                    isSDFIcon: re,
                    iconPrimary: ve,
                    iconSecondary: ge,
                    iconTextFit: be,
                    iconOffset: Me,
                  } = N;
                  (Lb(j, b.iconPositions, ve, ge),
                    Lb(H, b.iconPositions, ve, ge),
                    UE(Q, b.iconPositions),
                    VE(ve, ge, b.iconPositions),
                    (V || j) &&
                      GE(
                        n,
                        J,
                        Q,
                        j,
                        H,
                        v,
                        M,
                        X,
                        0,
                        ee,
                        re,
                        o,
                        a,
                        d,
                        _,
                        A,
                        be,
                        Me,
                        R,
                        k,
                      ));
                }
                i &&
                  n.generateCollisionDebugBuffers(
                    u,
                    n.collisionBoxArray,
                    M.textScaleFactor,
                  );
              }),
              (r.fc = li),
              (r.fd = _g),
              (r.fe = ua),
              (r.ff = ti),
              (r.fg = lb),
              (r.fh = Co),
              (r.fi = function (n) {
                let e = 0;
                if (new Uint32Array(n, 0, 1)[0] !== V0) {
                  const i = new Uint32Array(n, 0, 7),
                    [, , o, a, u, d] = i;
                  ((e = i.byteLength + a + u + d + u),
                    (o !== n.byteLength || e >= n.byteLength) &&
                      ri("Invalid b3dm header information."));
                }
                return $0(n, e);
              }),
              (r.fj = function (n, e) {
                const i = tw(n);
                for (const o of i) {
                  for (const a of o.meshes) dA(a);
                  o.lights &&
                    ((o.lightMeshIndex = o.meshes.length),
                    o.meshes.push(fA(o.lights, e)));
                }
                return i;
              }),
              (r.fk = ug),
              (r.fl = Ui),
              (r.fm = L0),
              (r.fn = fo),
              (r.fo = Qr),
              (r.fp = function (n) {
                (tl(),
                  Fs != null &&
                    Fs.then((e) => {
                      e.keys()
                        .then((i) => {
                          for (let o = 0; o < i.length - n; o++)
                            e.delete(i[o]).catch((a) => ri(a.message));
                        })
                        .catch((i) => ri(i.message));
                    }).catch((e) => ri(e.message)));
              }),
              (r.g = function (n, e) {
                return nl(Le(n, { method: "GET" }), e);
              }),
              (r.h = Le),
              (r.i = function (n) {
                return hr.API_STYLE_REGEX.test(n) && !Eh(n);
              }),
              (r.j = function (n) {
                return n.indexOf("mapbox:") === 0;
              }),
              (r.k = Po),
              (r.l = rd),
              (r.m = function (n) {
                return decodeURIComponent(
                  atob(n)
                    .split("")
                    .map(
                      (e) =>
                        "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2),
                    )
                    .join(""),
                );
              }),
              (r.n = function (n, e) {
                return nl(Le(n, { type: "json" }), e);
              }),
              (r.o = sd),
              (r.p = function (n, e) {
                return nl(Le(n, { method: "POST" }), e);
              }),
              (r.q = As),
              (r.r = xr),
              (r.s = function (n) {
                try {
                  const e = self[n];
                  return (
                    e.setItem("_mapbox_test_", 1),
                    e.removeItem("_mapbox_test_"),
                    !0
                  );
                } catch {
                  return !1;
                }
              }),
              (r.t = Mh),
              (r.u = function () {
                return (function n(e) {
                  return e
                    ? (e ^ (Math.random() * (16 >> (e / 4)))).toString(16)
                    : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(
                        /[018]/g,
                        n,
                      );
                })();
              }),
              (r.v = function (n) {
                return (
                  !!n &&
                  /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(
                    n,
                  )
                );
              }),
              (r.w = ri),
              (r.x = function () {
                return (py || (py = new rh()), py);
              }),
              (r.y = ex),
              (r.z = Rh));
          }),
            I(["./shared"], function (r) {
              function F(Fe) {
                const W = Fe ? Fe.url.toString() : void 0;
                return W ? performance.getEntriesByName(W) : [];
              }
              function B(Fe) {
                if (
                  typeof Fe == "number" ||
                  typeof Fe == "boolean" ||
                  typeof Fe == "string" ||
                  Fe == null
                )
                  return JSON.stringify(Fe);
                if (Array.isArray(Fe)) {
                  let K = "[";
                  for (const oe of Fe) K += `${B(oe)},`;
                  return `${K}]`;
                }
                let W = "{";
                for (const K of Object.keys(Fe).sort())
                  W += `${K}:${B(Fe[K])},`;
                return `${W}}`;
              }
              function q(Fe) {
                let W = "";
                for (const K of r.bu) W += `/${B(Fe[K])}`;
                return W;
              }
              class ne {
                constructor(W) {
                  ((this.keyCache = {}),
                    (this._layers = {}),
                    (this._layerConfigs = {}),
                    W && this.replace(W));
                }
                replace(W, K) {
                  ((this._layerConfigs = {}),
                    (this._layers = {}),
                    this.update(W, [], K));
                }
                update(W, K, oe) {
                  this._options = oe;
                  for (const he of W)
                    ((this._layerConfigs[he.id] = he),
                      (this._layers[he.id] = r.db(
                        he,
                        this.scope,
                        null,
                        this._options,
                      )).compileFilter(oe),
                      this.keyCache[he.id] && delete this.keyCache[he.id]);
                  for (const he of K)
                    (delete this.keyCache[he],
                      delete this._layerConfigs[he],
                      delete this._layers[he]);
                  this.familiesBySource = {};
                  const ye = (function (he, Se) {
                    const ke = {};
                    for (let Le = 0; Le < he.length; Le++) {
                      const Ye = he[Le];
                      let Be = Se && Se[Ye.id];
                      (Be ||
                        (Ye.type === "symbol"
                          ? (Be = Ye.id)
                          : ((Be = q(Ye)),
                            Ye.type === "line" &&
                              Ye.paint &&
                              (function Pt(zt) {
                                return (
                                  (typeof zt == "string" &&
                                    zt === "line-progress") ||
                                  (Array.isArray(zt)
                                    ? zt.some(Pt)
                                    : !(!zt || typeof zt != "object") &&
                                      Object.values(zt).some(Pt))
                                );
                              })(Ye.paint["line-width"]) &&
                              (Be += `/${B(Ye.paint["line-width"])}`))),
                        Se && (Se[Ye.id] = Be));
                      let dt = ke[Be];
                      (dt || (dt = ke[Be] = []), dt.push(Ye));
                    }
                    const Ee = [];
                    for (const Le in ke) Ee.push(ke[Le]);
                    return Ee;
                  })(Object.values(this._layerConfigs), this.keyCache);
                  for (const he of ye) {
                    const Se = he.map((dt) => this._layers[dt.id]),
                      ke = Se[0];
                    if (ke.visibility === "none") continue;
                    const Ee = ke.source || "";
                    let Le = this.familiesBySource[Ee];
                    Le || (Le = this.familiesBySource[Ee] = {});
                    const Ye = ke.sourceLayer || "_geojsonTileLayer";
                    let Be = Le[Ye];
                    (Be || (Be = Le[Ye] = []), Be.push(Se));
                  }
                }
              }
              const fe = 1 * r.e_;
              class de {
                constructor(W) {
                  const K = {},
                    oe = [];
                  for (const ke in W) {
                    const Ee = W[ke],
                      Le = (K[ke] = {});
                    for (const Ye in Ee.glyphs) {
                      const Be = Ee.glyphs[+Ye];
                      if (
                        !Be ||
                        Be.bitmap.width === 0 ||
                        Be.bitmap.height === 0
                      )
                        continue;
                      const dt = Be.metrics.localGlyph ? fe : 1,
                        Pt = {
                          x: 0,
                          y: 0,
                          w: Be.bitmap.width + 2 * dt,
                          h: Be.bitmap.height + 2 * dt,
                        };
                      (oe.push(Pt), (Le[Ye] = Pt));
                    }
                  }
                  const { w: ye, h: he } = r.H(oe),
                    Se = new r.eZ({ width: ye || 1, height: he || 1 });
                  for (const ke in W) {
                    const Ee = W[ke];
                    for (const Le in Ee.glyphs) {
                      const Ye = Ee.glyphs[+Le];
                      if (
                        !Ye ||
                        Ye.bitmap.width === 0 ||
                        Ye.bitmap.height === 0
                      )
                        continue;
                      const Be = K[ke][Le],
                        dt = Ye.metrics.localGlyph ? fe : 1;
                      r.eZ.copy(
                        Ye.bitmap,
                        Se,
                        { x: 0, y: 0 },
                        { x: Be.x + dt, y: Be.y + dt },
                        Ye.bitmap,
                      );
                    }
                  }
                  ((this.image = Se), (this.positions = K));
                }
              }
              r.eY(de, "GlyphAtlas");
              class Ie {
                constructor(W) {
                  ((this.tileID = new r.aM(
                    W.tileID.overscaledZ,
                    W.tileID.wrap,
                    W.tileID.canonical.z,
                    W.tileID.canonical.x,
                    W.tileID.canonical.y,
                  )),
                    (this.tileZoom = W.tileZoom),
                    (this.uid = W.uid),
                    (this.zoom = W.zoom),
                    (this.lut = W.lut),
                    (this.canonical = W.tileID.canonical),
                    (this.pixelRatio = W.pixelRatio),
                    (this.tileSize = W.tileSize),
                    (this.source = W.source),
                    (this.scope = W.scope),
                    (this.overscaling = this.tileID.overscaleFactor()),
                    (this.showCollisionBoxes = W.showCollisionBoxes),
                    (this.collectResourceTiming =
                      !!W.request && W.request.collectResourceTiming),
                    (this.promoteId = W.promoteId),
                    (this.isSymbolTile = W.isSymbolTile),
                    (this.tileTransform = r.aW(
                      W.tileID.canonical,
                      W.projection,
                    )),
                    (this.projection = W.projection),
                    (this.worldview = W.worldview),
                    (this.localizableLayerIds = W.localizableLayerIds),
                    (this.brightness = W.brightness),
                    (this.extraShadowCaster = !!W.extraShadowCaster),
                    (this.tessellationStep = W.tessellationStep),
                    (this.scaleFactor = W.scaleFactor),
                    (this.worldview = W.worldview));
                }
                parse(W, K, oe, ye, he, Se) {
                  ((this.status = "parsing"),
                    (this.data = W),
                    (this.collisionBoxArray = new r.b0()));
                  const ke = new r.e$(Object.keys(W.layers).sort()),
                    Ee = new r.f0(this.tileID, this.promoteId);
                  Ee.bucketLayerIDs = [];
                  const Le = {},
                    Ye = new r.f1(256, 256),
                    Be = {
                      featureIndex: Ee,
                      iconDependencies: new Map(),
                      patternDependencies: new Map(),
                      glyphDependencies: {},
                      lineAtlas: Ye,
                      availableImages: oe,
                      brightness: this.brightness,
                      scaleFactor: this.scaleFactor,
                      elevationFeatures: void 0,
                    },
                    dt = [],
                    Pt = K.familiesBySource[this.source];
                  for (const Xt in Pt) {
                    const Kt = W.layers[Xt];
                    if (!Kt) continue;
                    let Qt = !1,
                      mi = !1,
                      ri = !1;
                    for (const Ui of Pt[Xt])
                      (Ui[0].type === "symbol" ? (Qt = !0) : (mi = !0),
                        Ui[0].is3D() && Ui[0].type !== "model" && (ri = !0));
                    if (
                      (this.extraShadowCaster && !ri) ||
                      (this.isSymbolTile === !0 && !Qt) ||
                      (this.isSymbolTile === !1 && !mi)
                    )
                      continue;
                    Kt.version === 1 &&
                      r.w(
                        `Vector tile source "${this.source}" layer "${Xt}" does not use vector tile spec v2 and therefore may have some rendering errors.`,
                      );
                    const Ki = ke.encode(Xt),
                      gn = [];
                    let _n = !1;
                    for (let Ui = 0, Pi = 0; Ui < Kt.length; Ui++) {
                      const On = Kt.feature(Ui),
                        Mn = Ee.getId(On, Xt);
                      if (
                        this.localizableLayerIds &&
                        this.localizableLayerIds.has(Xt)
                      ) {
                        const Tn = On.properties
                          ? On.properties.worldview
                          : null;
                        if (this.worldview && typeof Tn == "string")
                          if (Tn === "all") On.properties.$localized = !0;
                          else {
                            if (!Tn.split(",").includes(this.worldview))
                              continue;
                            ((On.properties.$localized = !0),
                              (On.properties.worldview = this.worldview));
                          }
                      }
                      (!_n &&
                        On.properties &&
                        On.properties.hasOwnProperty(r.f2) &&
                        (_n = !0),
                        gn.push({
                          feature: On,
                          id: Mn,
                          index: Pi,
                          sourceLayerIndex: Ki,
                        }),
                        Pi++);
                    }
                    _n &&
                      !Be.elevationFeatures &&
                      W.layers.hasOwnProperty(r.f3) &&
                      (Be.elevationFeatures = r.f4.parseFrom(
                        W.layers[r.f3],
                        this.canonical,
                      ));
                    for (const Ui of Pt[Xt]) {
                      const Pi = Ui[0];
                      if (
                        (this.extraShadowCaster &&
                          (!Pi.is3D() || Pi.type === "model")) ||
                        (this.isSymbolTile !== void 0 &&
                          (Pi.type === "symbol") !== this.isSymbolTile) ||
                        (Pi.minzoom && this.zoom < Math.floor(Pi.minzoom)) ||
                        (Pi.maxzoom && this.zoom >= Pi.maxzoom) ||
                        Pi.visibility === "none"
                      )
                        continue;
                      xe(Ui, this.zoom, Be.brightness, oe, this.worldview);
                      const On = (Le[Pi.id] = Pi.createBucket({
                        index: Ee.bucketLayerIDs.length,
                        layers: Ui,
                        zoom: this.zoom,
                        lut: this.lut,
                        canonical: this.canonical,
                        pixelRatio: this.pixelRatio,
                        overscaling: this.overscaling,
                        collisionBoxArray: this.collisionBoxArray,
                        sourceLayerIndex: Ki,
                        sourceID: this.source,
                        projection: this.projection.spec,
                        tessellationStep: this.tessellationStep,
                        styleDefinedModelURLs: ye,
                        worldview: this.worldview,
                      }));
                      Ee.bucketLayerIDs.push(
                        Ui.map((Tn) => r.C(Tn.id, Tn.scope)),
                      );
                      let Mn = On.prepare ? On.prepare() : null;
                      Mn != null
                        ? ((Mn = Mn.then(() =>
                            On.populate(
                              gn,
                              Be,
                              this.tileID.canonical,
                              this.tileTransform,
                            ),
                          )),
                          dt.push(Mn))
                        : On.populate(
                            gn,
                            Be,
                            this.tileID.canonical,
                            this.tileTransform,
                          );
                    }
                  }
                  const zt = () => {
                    let Xt, Kt, Qt, mi, ri, Ki;
                    Ye.trim();
                    const gn = {
                        type: "maybePrepare",
                        isSymbolTile: this.isSymbolTile,
                        zoom: this.zoom,
                      },
                      _n = () => {
                        if (Xt) return ((this.status = "done"), Se(Xt));
                        if (this.extraShadowCaster)
                          ((this.status = "done"),
                            Se(null, {
                              buckets: Object.values(Le).filter(
                                (Pi) => !Pi.isEmpty(),
                              ),
                              featureIndex: Ee,
                              collisionBoxArray: null,
                              glyphAtlasImage: null,
                              lineAtlas: null,
                              imageAtlas: null,
                              brightness: Be.brightness,
                              glyphMap: null,
                              iconMap: null,
                              glyphPositions: null,
                            }));
                        else if (Kt && Qt && mi) {
                          const Pi = new de(Kt),
                            On = new Map();
                          for (const [ar, Ur] of Qt.entries()) {
                            const { imagePosition: Tr } = r.f7(ar, Ur, r.f8);
                            On.set(ar, Tr);
                          }
                          const Mn = {};
                          for (const ar in Le) {
                            const Ur = Le[ar];
                            Ur instanceof r.b1 &&
                              (xe(
                                Ur.layers,
                                this.zoom,
                                Be.brightness,
                                oe,
                                this.worldview,
                              ),
                              (Mn[ar] = r.f9(
                                Ur,
                                Kt,
                                Pi.positions,
                                Qt,
                                On,
                                this.tileID.canonical,
                                this.tileZoom,
                                this.scaleFactor,
                                this.pixelRatio,
                                ri,
                                this.worldview,
                              )));
                          }
                          const Tn = { iconsPending: !0, patternsPending: !0 };
                          (this.rasterizeIfNeeded(he, Qt, ri, () => {
                            ((Tn.iconsPending = !1), Ui(Mn, Pi, Tn));
                          }),
                            this.rasterizeIfNeeded(he, mi, Ki, () => {
                              ((Tn.patternsPending = !1), Ui(Mn, Pi, Tn));
                            }));
                        }
                      },
                      Ui = (Pi, On, Mn, Tn) => {
                        if (Mn.iconsPending || Mn.patternsPending) return;
                        const ar = new r.fa(Qt, mi, this.lut);
                        for (const Ur in Le) {
                          const Tr = Le[Ur];
                          if (Ur in Pi)
                            r.fb(
                              Tr,
                              Pi[Ur],
                              this.showCollisionBoxes,
                              oe,
                              this.tileID.canonical,
                              this.tileZoom,
                              this.projection,
                              this.brightness,
                              Qt,
                              ar,
                            );
                          else if (
                            Tr.hasPattern &&
                            (Tr instanceof r.b7 ||
                              Tr instanceof r.b8 ||
                              Tr instanceof r.dU)
                          ) {
                            xe(
                              Tr.layers,
                              this.zoom,
                              Be.brightness,
                              oe,
                              this.worldview,
                            );
                            const sc = Object.fromEntries(ar.patternPositions);
                            Tr.addFeatures(
                              Be,
                              this.tileID.canonical,
                              sc,
                              oe,
                              this.tileTransform,
                              this.brightness,
                            );
                          }
                        }
                        ((this.status = "done"),
                          Se(null, {
                            buckets: Object.values(Le).filter(
                              (Ur) => !Ur.isEmpty(),
                            ),
                            featureIndex: Ee,
                            collisionBoxArray: this.collisionBoxArray,
                            glyphAtlasImage: On.image,
                            lineAtlas: Ye,
                            imageAtlas: ar,
                            brightness: Be.brightness,
                          }));
                      };
                    if (!this.extraShadowCaster) {
                      const Pi = r.f5(Be.glyphDependencies, (Tn) =>
                        Object.keys(Tn).map(Number),
                      );
                      Object.keys(Pi).length
                        ? he.send(
                            "getGlyphs",
                            { uid: this.uid, stacks: Pi, scope: this.scope },
                            (Tn, ar) => {
                              Xt || ((Xt = Tn), (Kt = ar), _n());
                            },
                            void 0,
                            !1,
                            gn,
                          )
                        : (Kt = {});
                      const On = Array.from(Be.iconDependencies.keys()).map(
                        (Tn) => r.I.parse(Tn),
                      );
                      On.length
                        ? he.send(
                            "getImages",
                            {
                              images: On,
                              source: this.source,
                              scope: this.scope,
                              tileID: this.tileID,
                              type: "icons",
                            },
                            (Tn, ar) => {
                              Xt ||
                                ((Xt = Tn),
                                (Qt = new Map()),
                                (ri = this.updateImageMapAndGetImageTaskQueue(
                                  Qt,
                                  ar,
                                  Be.iconDependencies,
                                )),
                                _n());
                            },
                            void 0,
                            !1,
                            gn,
                          )
                        : ((Qt = new Map()), (ri = new Map()));
                      const Mn = Array.from(Be.patternDependencies.keys()).map(
                        (Tn) => r.I.parse(Tn),
                      );
                      Mn.length
                        ? he.send(
                            "getImages",
                            {
                              images: Mn,
                              source: this.source,
                              scope: this.scope,
                              tileID: this.tileID,
                              type: "patterns",
                            },
                            (Tn, ar) => {
                              Xt ||
                                ((Xt = Tn),
                                (mi = new Map()),
                                (Ki = this.updateImageMapAndGetImageTaskQueue(
                                  mi,
                                  ar,
                                  Be.patternDependencies,
                                )),
                                _n());
                            },
                            void 0,
                            !1,
                            gn,
                          )
                        : ((mi = new Map()), (Ki = new Map()));
                    }
                    if (
                      Be.elevationFeatures &&
                      Be.elevationFeatures.length > 0
                    ) {
                      const Pi = [];
                      for (const Mn of Object.values(Le))
                        if (Mn instanceof r.b8) {
                          const Tn = Mn.getUnevaluatedPortalGraph();
                          Tn && Pi.push(Tn);
                        }
                      const On = r.f6.evaluate(Pi);
                      for (const Mn of Object.values(Le))
                        if (Mn instanceof r.b8) {
                          const Tn = W.layers[ke.decode(Mn.sourceLayerIndex)];
                          Mn.setEvaluatedPortalGraph(
                            On,
                            Tn,
                            this.tileID.canonical,
                            Be.availableImages,
                            Be.brightness,
                          );
                        }
                    }
                    _n();
                  };
                  dt.length > 0
                    ? Promise.allSettled(dt).then(zt).catch(Se)
                    : zt();
                }
                rasterizeIfNeeded(W, K, oe, ye) {
                  Array.from(K.values()).some((he) => he.usvg)
                    ? this.rasterize(W, K, oe, ye)
                    : ye();
                }
                updateImageMapAndGetImageTaskQueue(W, K, oe) {
                  const ye = new Map();
                  for (const he of K.keys()) {
                    const Se = oe.get(he) || [];
                    for (const ke of Se) {
                      const Ee = ke.toString(),
                        Le = K.get(ke.id.toString());
                      Le.usvg
                        ? ye.has(Ee) ||
                          (ye.set(Ee, ke), W.set(Ee, Object.assign({}, Le)))
                        : W.set(Ee, Le);
                    }
                  }
                  return ye;
                }
                rasterize(W, K, oe, ye) {
                  this.rasterizeTask = W.send(
                    "rasterizeImages",
                    { scope: this.scope, tasks: oe },
                    (he, Se) => {
                      if (!he)
                        for (const [ke, Ee] of Se.entries()) {
                          const Le = Object.assign(K.get(ke), { data: Ee });
                          K.set(ke, Le);
                        }
                      ye();
                    },
                  );
                }
                cancelRasterize() {
                  this.rasterizeTask && this.rasterizeTask.cancel();
                }
              }
              function xe(Fe, W, K, oe, ye) {
                const he = new r.aa(W, { brightness: K, worldview: ye });
                for (const Se of Fe) Se.recalculate(he, oe);
              }
              class we extends r.E {
                constructor(W, K, oe, ye, he, Se, ke) {
                  (super(),
                    (this.actor = W),
                    (this.layerIndex = K),
                    (this.availableImages = oe),
                    (this.availableModels = ye),
                    (this.loadVectorData = Se || r.aJ),
                    (this.loading = {}),
                    (this.loaded = {}),
                    (this.deduped = new r.aI(W.scheduler)),
                    (this.isSpriteLoaded = he),
                    (this.scheduler = W.scheduler),
                    (this.brightness = ke));
                }
                loadTile(W, K) {
                  const oe = W.uid,
                    ye = W && W.request,
                    he = ye && ye.collectResourceTiming,
                    Se = (this.loading[oe] = new Ie(W));
                  Se.abort = this.loadVectorData(W, (ke, Ee) => {
                    const Le = !this.loading[oe];
                    if (
                      (delete this.loading[oe],
                      Se.cancelRasterize(),
                      Le || ke || !Ee)
                    )
                      return (
                        (Se.status = "done"),
                        Le || (this.loaded[oe] = Se),
                        K(ke)
                      );
                    const Ye = Ee.rawData,
                      Be = {};
                    (Ee.expires && (Be.expires = Ee.expires),
                      Ee.cacheControl && (Be.cacheControl = Ee.cacheControl),
                      (Se.vectorTile =
                        Ee.vectorTile || new r.fc.VectorTile(new r.bq(Ye))));
                    const dt = () => {
                      Se.parse(
                        Se.vectorTile,
                        this.layerIndex,
                        this.availableImages,
                        this.availableModels,
                        this.actor,
                        (Pt, zt) => {
                          if (Pt || !zt) return K(Pt);
                          const Xt = {};
                          if (he) {
                            const Kt = F(ye);
                            Kt.length > 0 &&
                              (Xt.resourceTiming = JSON.parse(
                                JSON.stringify(Kt),
                              ));
                          }
                          K(
                            null,
                            r.h({ rawTileData: Ye.slice(0) }, zt, Be, Xt),
                          );
                        },
                      );
                    };
                    (this.isSpriteLoaded
                      ? dt()
                      : this.once("isSpriteLoaded", () => {
                          this.scheduler
                            ? this.scheduler.add(dt, {
                                type: "parseTile",
                                isSymbolTile: W.isSymbolTile,
                                zoom: W.tileZoom,
                              })
                            : dt();
                        }),
                      (this.loaded = this.loaded || {}),
                      (this.loaded[oe] = Se));
                  });
                }
                reloadTile(W, K) {
                  const oe = this.loaded,
                    ye = W.uid;
                  if (oe && oe[ye]) {
                    const he = oe[ye];
                    ((he.scaleFactor = W.scaleFactor),
                      (he.showCollisionBoxes = W.showCollisionBoxes),
                      (he.projection = W.projection),
                      (he.brightness = W.brightness),
                      (he.tileTransform = r.aW(
                        W.tileID.canonical,
                        W.projection,
                      )),
                      (he.extraShadowCaster = W.extraShadowCaster),
                      (he.lut = W.lut),
                      (he.worldview = W.worldview));
                    const Se = (ke, Ee) => {
                      const Le = he.reloadCallback;
                      (Le &&
                        (delete he.reloadCallback,
                        he.parse(
                          he.vectorTile,
                          this.layerIndex,
                          this.availableImages,
                          this.availableModels,
                          this.actor,
                          Le,
                        )),
                        K(ke, Ee));
                    };
                    he.status === "parsing"
                      ? (he.reloadCallback = Se)
                      : he.status === "done" &&
                        (he.vectorTile
                          ? he.parse(
                              he.vectorTile,
                              this.layerIndex,
                              this.availableImages,
                              this.availableModels,
                              this.actor,
                              Se,
                            )
                          : Se());
                  } else K(null, void 0);
                }
                abortTile(W, K) {
                  const oe = W.uid,
                    ye = this.loading[oe];
                  (ye && (ye.abort && ye.abort(), delete this.loading[oe]),
                    K());
                }
                removeTile(W, K) {
                  const oe = this.loaded,
                    ye = W.uid;
                  (oe && oe[ye] && delete oe[ye], K());
                }
              }
              class Ae {
                loadTile(W, K) {
                  const {
                      uid: oe,
                      encoding: ye,
                      rawImageData: he,
                      padding: Se,
                    } = W,
                    ke =
                      ImageBitmap && he instanceof ImageBitmap
                        ? this.getImageData(he, Se)
                        : he;
                  K(null, new r.fd(oe, ke, ye, Se < 1));
                }
                reloadTile(W, K) {
                  K(null, null);
                }
                abortTile(W, K) {
                  K();
                }
                removeTile(W, K) {
                  K();
                }
                getImageData(W, K) {
                  ((this.offscreenCanvas && this.offscreenCanvasContext) ||
                    ((this.offscreenCanvas = new OffscreenCanvas(
                      W.width,
                      W.height,
                    )),
                    (this.offscreenCanvasContext =
                      this.offscreenCanvas.getContext("2d", {
                        willReadFrequently: !0,
                      }))),
                    (this.offscreenCanvas.width = W.width),
                    (this.offscreenCanvas.height = W.height),
                    this.offscreenCanvasContext.drawImage(
                      W,
                      0,
                      0,
                      W.width,
                      W.height,
                    ));
                  const oe = this.offscreenCanvasContext.getImageData(
                    -K,
                    -K,
                    W.width + 2 * K,
                    W.height + 2 * K,
                  );
                  return (
                    this.offscreenCanvasContext.clearRect(
                      0,
                      0,
                      this.offscreenCanvas.width,
                      this.offscreenCanvas.height,
                    ),
                    oe
                  );
                }
              }
              r.bp.setPbf(r.bq);
              class Qe {
                constructor(W) {
                  ((this._mrt = new r.bp(W.partial ? 30 : 1 / 0)),
                    (this._isHeaderLoaded = !1),
                    (this.uid = W.uid),
                    (this.tileID = W.tileID),
                    (this.source = W.source));
                }
                parse(W, K) {
                  const oe = this._mrt;
                  ((this.status = "parsing"), (this._entireBuffer = W));
                  try {
                    (oe.parseHeader(W), (this._isHeaderLoaded = !0));
                    const ye = [];
                    for (const he in oe.layers) {
                      const Se = oe.getLayer(he),
                        ke = Se.getDataRange(Se.getBandList()),
                        Ee = oe.createDecodingTask(ke),
                        Le = W.slice(ke.firstByte, ke.lastByte + 1),
                        Ye = r.bp
                          .performDecoding(Le, Ee)
                          .then((Be) => Ee.complete(null, Be))
                          .catch((Be) => Ee.complete(Be, null));
                      ye.push(Ye);
                    }
                    Promise.allSettled(ye)
                      .then(() => K(null, oe))
                      .catch((he) => K(he));
                  } catch (ye) {
                    K(ye);
                  }
                }
              }
              class gt {
                constructor(W) {
                  ((this.actor = W), (this.loading = {}), (this.loaded = {}));
                }
                loadTile(W, K) {
                  const oe = W.uid,
                    ye = W.request,
                    he = (this.loading[oe] = new Qe(W)),
                    { cancel: Se } = r.br(ye, (ke, Ee, Le, Ye) => {
                      const Be = !this.loading[oe];
                      if ((delete this.loading[oe], Be || ke || !Ee))
                        return (
                          (he.status = "done"),
                          Be || (this.loaded[oe] = he),
                          K(ke)
                        );
                      (he.parse(Ee, (dt, Pt) => {
                        if (dt || !Pt) return K(dt);
                        K(null, Pt, Le, Ye);
                      }),
                        (this.loaded[oe] = he));
                    });
                  he.abort = Se;
                }
                reloadTile(W, K) {
                  K(null, void 0);
                }
                abortTile(W, K) {
                  const oe = W.uid,
                    ye = this.loading[oe];
                  (ye && (ye.abort && ye.abort(), delete this.loading[oe]),
                    K());
                }
                removeTile(W, K) {
                  const oe = W.uid;
                  (this.loaded[oe] && delete this.loaded[oe], K());
                }
                decodeRasterArray(W, K) {
                  r.bp
                    .performDecoding(W.buffer, W.task)
                    .then((oe) => K(null, oe))
                    .catch((oe) => K(oe));
                }
              }
              const Rt = r.fc.VectorTileFeature.prototype.toGeoJSON;
              class Mt {
                constructor(W) {
                  ((this._feature = W),
                    (this.extent = r.aj),
                    (this.type = W.type),
                    (this.properties = W.tags),
                    "id" in W &&
                      !isNaN(W.id) &&
                      (this.id = parseInt(W.id, 10)));
                }
                loadGeometry() {
                  if (this._feature.type === 1) {
                    const W = [];
                    for (const K of this._feature.geometry)
                      W.push([new r.P(K[0], K[1])]);
                    return W;
                  }
                  {
                    const W = [];
                    for (const K of this._feature.geometry) {
                      const oe = [];
                      for (const ye of K) oe.push(new r.P(ye[0], ye[1]));
                      W.push(oe);
                    }
                    return W;
                  }
                }
                toGeoJSON(W, K, oe) {
                  return Rt.call(this, W, K, oe);
                }
              }
              class pt {
                constructor(W) {
                  ((this.layers = { _geojsonTileLayer: this }),
                    (this.name = "_geojsonTileLayer"),
                    (this.extent = r.aj),
                    (this.length = W.length),
                    (this._features = W));
                }
                feature(W) {
                  return new Mt(this._features[W]);
                }
              }
              class Re {
                constructor(W, K) {
                  ((this.name = W),
                    (this.extent = r.aj),
                    (this.length = K.length),
                    (this._features = K));
                }
                feature(W) {
                  return new Mt(this._features[W]);
                }
              }
              class rt extends pt {
                constructor(W) {
                  (super([]), (this.layers = {}));
                  for (const K in W) this.layers[K] = new Re(K, W[K]);
                }
              }
              const Ot = 64 / 4096,
                _i = 128;
              class qt {
                constructor() {
                  this.features = new Map();
                }
                clear() {
                  this.features.clear();
                }
                load(W = [], K) {
                  for (const oe of W) {
                    const ye = oe.id;
                    if (ye == null) continue;
                    let he = this.features.get(ye);
                    (he && this.updateCache(he, K),
                      oe.geometry
                        ? ((he = Ri(oe)),
                          this.updateCache(he, K),
                          this.features.set(ye, he))
                        : this.features.delete(ye),
                      this.updateCache(he, K));
                  }
                }
                updateCache(W, K) {
                  for (const { canonical: oe, uid: ye } of Object.values(K)) {
                    const { z: he, x: Se, y: ke } = oe;
                    pi(W, Math.pow(2, he), Se, ke) && delete K[ye];
                  }
                }
                getTile(W, K, oe) {
                  const ye = Math.pow(2, W),
                    he = [];
                  for (const Se of this.features.values())
                    pi(Se, ye, K, oe) && he.push(Ln(Se, ye, K, oe));
                  return { features: he };
                }
                getFeatures() {
                  return [...this.features.values()];
                }
              }
              function pi(
                { minX: Fe, minY: W, maxX: K, maxY: oe },
                ye,
                he,
                Se,
              ) {
                return (
                  Fe < (he + 1 + Ot) / ye &&
                  W < (Se + 1 + Ot) / ye &&
                  K > (he - Ot) / ye &&
                  oe > (Se - Ot) / ye
                );
              }
              function Ri(Fe) {
                const { id: W, geometry: K, properties: oe } = Fe;
                if (!K) return;
                if (K.type === "GeometryCollection")
                  throw new Error(
                    "GeometryCollection not supported in dynamic mode.",
                  );
                const { type: ye, coordinates: he } = K,
                  Se = {
                    id: W,
                    type: 1,
                    geometry: [],
                    tags: oe,
                    minX: 1 / 0,
                    minY: 1 / 0,
                    maxX: -1 / 0,
                    maxY: -1 / 0,
                  },
                  ke = Se.geometry;
                if (ye === "Point") wi(he, ke, Se);
                else if (ye === "MultiPoint")
                  for (const Ee of he) wi(Ee, ke, Se);
                else if (ye === "LineString") ((Se.type = 2), ei(he, ke, Se));
                else if (ye === "MultiLineString")
                  ((Se.type = 2), Ii(he, ke, Se));
                else if (ye === "Polygon") ((Se.type = 3), Ii(he, ke, Se, !0));
                else {
                  if (ye !== "MultiPolygon")
                    throw new Error(
                      "Input data is not a valid GeoJSON object.",
                    );
                  Se.type = 3;
                  for (const Ee of he) Ii(Ee, ke, Se, !0);
                }
                return Se;
              }
              function wi([Fe, W], K, oe) {
                const ye = r.aD(Fe);
                let he = r.aH(W);
                ((he = he < 0 ? 0 : he > 1 ? 1 : he),
                  K.push(ye, he),
                  (oe.minX = Math.min(oe.minX, ye)),
                  (oe.minY = Math.min(oe.minY, he)),
                  (oe.maxX = Math.max(oe.maxX, ye)),
                  (oe.maxY = Math.max(oe.maxY, he)));
              }
              function ei(Fe, W, K, oe = !1, ye = !1) {
                const he = [];
                for (const Se of Fe) wi(Se, he, K);
                (W.push(he),
                  oe &&
                    (function (Se, ke) {
                      let Ee = 0;
                      for (
                        let Le = 0, Ye = Se.length, Be = Ye - 2;
                        Le < Ye;
                        Be = Le, Le += 2
                      )
                        Ee += (Se[Le] - Se[Be]) * (Se[Le + 1] + Se[Be + 1]);
                      if (Ee > 0 === ke)
                        for (let Le = 0, Ye = Se.length; Le < Ye / 2; Le += 2) {
                          const Be = Se[Le],
                            dt = Se[Le + 1];
                          ((Se[Le] = Se[Ye - 2 - Le]),
                            (Se[Le + 1] = Se[Ye - 1 - Le]),
                            (Se[Ye - 2 - Le] = Be),
                            (Se[Ye - 1 - Le] = dt));
                        }
                    })(he, ye));
              }
              function Ii(Fe, W, K, oe = !1) {
                for (let ye = 0; ye < Fe.length; ye++)
                  ei(Fe[ye], W, K, oe, ye === 0);
              }
              function Ln(Fe, W, K, oe) {
                const { id: ye, type: he, geometry: Se, tags: ke } = Fe,
                  Ee = [];
                if (he === 1)
                  (function (Le, Ye, Be, dt, Pt) {
                    for (let zt = 0; zt < Le.length; zt += 2) {
                      const Xt = Math.round(r.aj * (Le[zt + 0] * Ye - Be)),
                        Kt = Math.round(r.aj * (Le[zt + 1] * Ye - dt));
                      Pt.push([Xt, Kt]);
                    }
                  })(Se, W, K, oe, Ee);
                else for (const Le of Se) ir(Le, W, K, oe, Ee);
                return { id: ye, type: he, geometry: Ee, tags: ke };
              }
              function ir(Fe, W, K, oe, ye) {
                const Se = r.aj + _i;
                let ke;
                for (let Ee = 0; Ee < Fe.length - 2; Ee += 2) {
                  let Le = Math.round(r.aj * (Fe[Ee + 0] * W - K)),
                    Ye = Math.round(r.aj * (Fe[Ee + 1] * W - oe)),
                    Be = Math.round(r.aj * (Fe[Ee + 2] * W - K)),
                    dt = Math.round(r.aj * (Fe[Ee + 3] * W - oe));
                  const Pt = Be - Le,
                    zt = dt - Ye;
                  (Le < -128 && Be < -128) ||
                    (Le < -128
                      ? ((Ye += Math.round(zt * ((-128 - Le) / Pt))),
                        (Le = -128))
                      : Be < -128 &&
                        ((dt = Ye + Math.round(zt * ((-128 - Le) / Pt))),
                        (Be = -128)),
                    (Ye < -128 && dt < -128) ||
                      (Ye < -128
                        ? ((Le += Math.round(Pt * ((-128 - Ye) / zt))),
                          (Ye = -128))
                        : dt < -128 &&
                          ((Be = Le + Math.round(Pt * ((-128 - Ye) / zt))),
                          (dt = -128)),
                      (Le >= Se && Be >= Se) ||
                        (Le >= Se
                          ? ((Ye += Math.round(zt * ((Se - Le) / Pt))),
                            (Le = Se))
                          : Be >= Se &&
                            ((dt = Ye + Math.round(zt * ((Se - Le) / Pt))),
                            (Be = Se)),
                        (Ye >= Se && dt >= Se) ||
                          (Ye >= Se
                            ? ((Le += Math.round(Pt * ((Se - Ye) / zt))),
                              (Ye = Se))
                            : dt >= Se &&
                              ((Be = Le + Math.round(Pt * ((Se - Ye) / zt))),
                              (dt = Se)),
                          (ke &&
                            Le === ke[ke.length - 1][0] &&
                            Ye === ke[ke.length - 1][1]) ||
                            ((ke = [[Le, Ye]]), ye.push(ke)),
                          ke.push([Be, dt])))));
                }
              }
              var or,
                Vi,
                _r,
                yr = { exports: {} },
                fs = (function () {
                  if (_r) return yr.exports;
                  _r = 1;
                  var Fe = r.fg(),
                    W = (function () {
                      if (Vi) return or;
                      Vi = 1;
                      var Ye = r.fe(),
                        Be = r.ff().VectorTileFeature;
                      function dt(zt, Xt) {
                        ((this.options = Xt || {}),
                          (this.features = zt),
                          (this.length = zt.length));
                      }
                      function Pt(zt, Xt) {
                        ((this.id = typeof zt.id == "number" ? zt.id : void 0),
                          (this.type = zt.type),
                          (this.rawGeometry =
                            zt.type === 1 ? [zt.geometry] : zt.geometry),
                          (this.properties = zt.tags),
                          (this.extent = Xt || 4096));
                      }
                      return (
                        (or = dt),
                        (dt.prototype.feature = function (zt) {
                          return new Pt(this.features[zt], this.options.extent);
                        }),
                        (Pt.prototype.loadGeometry = function () {
                          var zt = this.rawGeometry;
                          this.geometry = [];
                          for (var Xt = 0; Xt < zt.length; Xt++) {
                            for (
                              var Kt = zt[Xt], Qt = [], mi = 0;
                              mi < Kt.length;
                              mi++
                            )
                              Qt.push(new Ye(Kt[mi][0], Kt[mi][1]));
                            this.geometry.push(Qt);
                          }
                          return this.geometry;
                        }),
                        (Pt.prototype.bbox = function () {
                          this.geometry || this.loadGeometry();
                          for (
                            var zt = this.geometry,
                              Xt = 1 / 0,
                              Kt = -1 / 0,
                              Qt = 1 / 0,
                              mi = -1 / 0,
                              ri = 0;
                            ri < zt.length;
                            ri++
                          )
                            for (
                              var Ki = zt[ri], gn = 0;
                              gn < Ki.length;
                              gn++
                            ) {
                              var _n = Ki[gn];
                              ((Xt = Math.min(Xt, _n.x)),
                                (Kt = Math.max(Kt, _n.x)),
                                (Qt = Math.min(Qt, _n.y)),
                                (mi = Math.max(mi, _n.y)));
                            }
                          return [Xt, Qt, Kt, mi];
                        }),
                        (Pt.prototype.toGeoJSON = Be.prototype.toGeoJSON),
                        or
                      );
                    })();
                  function K(Ye) {
                    var Be = new Fe();
                    return (
                      (function (dt, Pt) {
                        for (var zt in dt.layers)
                          Pt.writeMessage(3, oe, dt.layers[zt]);
                      })(Ye, Be),
                      Be.finish()
                    );
                  }
                  function oe(Ye, Be) {
                    var dt;
                    (Be.writeVarintField(15, Ye.version || 1),
                      Be.writeStringField(1, Ye.name || ""),
                      Be.writeVarintField(5, Ye.extent || 4096));
                    var Pt = {
                      keys: [],
                      values: [],
                      keycache: {},
                      valuecache: {},
                    };
                    for (dt = 0; dt < Ye.length; dt++)
                      ((Pt.feature = Ye.feature(dt)),
                        Be.writeMessage(2, ye, Pt));
                    var zt = Pt.keys;
                    for (dt = 0; dt < zt.length; dt++)
                      Be.writeStringField(3, zt[dt]);
                    var Xt = Pt.values;
                    for (dt = 0; dt < Xt.length; dt++)
                      Be.writeMessage(4, Le, Xt[dt]);
                  }
                  function ye(Ye, Be) {
                    var dt = Ye.feature;
                    (dt.id !== void 0 && Be.writeVarintField(1, dt.id),
                      Be.writeMessage(2, he, Ye),
                      Be.writeVarintField(3, dt.type),
                      Be.writeMessage(4, Ee, dt));
                  }
                  function he(Ye, Be) {
                    var dt = Ye.feature,
                      Pt = Ye.keys,
                      zt = Ye.values,
                      Xt = Ye.keycache,
                      Kt = Ye.valuecache;
                    for (var Qt in dt.properties) {
                      var mi = dt.properties[Qt],
                        ri = Xt[Qt];
                      if (mi !== null) {
                        (ri === void 0 &&
                          (Pt.push(Qt), (Xt[Qt] = ri = Pt.length - 1)),
                          Be.writeVarint(ri));
                        var Ki = typeof mi;
                        Ki !== "string" &&
                          Ki !== "boolean" &&
                          Ki !== "number" &&
                          (mi = JSON.stringify(mi));
                        var gn = Ki + ":" + mi,
                          _n = Kt[gn];
                        (_n === void 0 &&
                          (zt.push(mi), (Kt[gn] = _n = zt.length - 1)),
                          Be.writeVarint(_n));
                      }
                    }
                  }
                  function Se(Ye, Be) {
                    return (Be << 3) + (7 & Ye);
                  }
                  function ke(Ye) {
                    return (Ye << 1) ^ (Ye >> 31);
                  }
                  function Ee(Ye, Be) {
                    for (
                      var dt = Ye.loadGeometry(),
                        Pt = Ye.type,
                        zt = 0,
                        Xt = 0,
                        Kt = dt.length,
                        Qt = 0;
                      Qt < Kt;
                      Qt++
                    ) {
                      var mi = dt[Qt],
                        ri = 1;
                      (Pt === 1 && (ri = mi.length), Be.writeVarint(Se(1, ri)));
                      for (
                        var Ki = Pt === 3 ? mi.length - 1 : mi.length, gn = 0;
                        gn < Ki;
                        gn++
                      ) {
                        gn === 1 && Pt !== 1 && Be.writeVarint(Se(2, Ki - 1));
                        var _n = mi[gn].x - zt,
                          Ui = mi[gn].y - Xt;
                        (Be.writeVarint(ke(_n)),
                          Be.writeVarint(ke(Ui)),
                          (zt += _n),
                          (Xt += Ui));
                      }
                      Pt === 3 && Be.writeVarint(Se(7, 1));
                    }
                  }
                  function Le(Ye, Be) {
                    var dt = typeof Ye;
                    dt === "string"
                      ? Be.writeStringField(1, Ye)
                      : dt === "boolean"
                        ? Be.writeBooleanField(7, Ye)
                        : dt === "number" &&
                          (Ye % 1 != 0
                            ? Be.writeDoubleField(3, Ye)
                            : Ye < 0
                              ? Be.writeSVarintField(6, Ye)
                              : Be.writeVarintField(5, Ye));
                  }
                  return (
                    (yr.exports = K),
                    (yr.exports.fromVectorTileJs = K),
                    (yr.exports.fromGeojsonVt = function (Ye, Be) {
                      Be = Be || {};
                      var dt = {};
                      for (var Pt in Ye)
                        ((dt[Pt] = new W(Ye[Pt].features, Be)),
                          (dt[Pt].name = Pt),
                          (dt[Pt].version = Be.version),
                          (dt[Pt].extent = Be.extent));
                      return K({ layers: dt });
                    }),
                    (yr.exports.GeoJSONWrapper = W),
                    yr.exports
                  );
                })(),
                qr = r.fh(fs);
              const tn = {
                  minZoom: 0,
                  maxZoom: 16,
                  minPoints: 2,
                  radius: 40,
                  extent: 512,
                  nodeSize: 64,
                  log: !1,
                  generateId: !1,
                  reduce: null,
                  map: (Fe) => Fe,
                },
                wn =
                  Math.fround ||
                  ((nr = new Float32Array(1)), (Fe) => ((nr[0] = +Fe), nr[0]));
              var nr;
              const ps = 3,
                mn = 5,
                Za = 6;
              class Qs {
                constructor(W) {
                  ((this.options = Object.assign(Object.create(tn), W)),
                    (this.trees = new Array(this.options.maxZoom + 1)),
                    (this.stride = this.options.reduce ? 7 : 6),
                    (this.clusterProps = []));
                }
                load(W) {
                  const { log: K, minZoom: oe, maxZoom: ye } = this.options;
                  K && console.time("total time");
                  const he = `prepare ${W.length} points`;
                  (K && console.time(he), (this.points = W));
                  const Se = [];
                  for (let Ee = 0; Ee < W.length; Ee++) {
                    const Le = W[Ee];
                    if (!Le.geometry) continue;
                    const [Ye, Be] = Le.geometry.coordinates,
                      dt = wn(Xa(Ye)),
                      Pt = wn(To(Be));
                    (Se.push(dt, Pt, 1 / 0, Ee, -1, 1),
                      this.options.reduce && Se.push(0));
                  }
                  let ke = (this.trees[ye + 1] = this._createTree(Se));
                  K && console.timeEnd(he);
                  for (let Ee = ye; Ee >= oe; Ee--) {
                    const Le = +Date.now();
                    ((ke = this.trees[Ee] =
                      this._createTree(this._cluster(ke, Ee))),
                      K &&
                        console.log(
                          "z%d: %d clusters in %dms",
                          Ee,
                          ke.numItems,
                          +Date.now() - Le,
                        ));
                  }
                  return (K && console.timeEnd("total time"), this);
                }
                getClusters(W, K) {
                  let oe = ((((W[0] + 180) % 360) + 360) % 360) - 180;
                  const ye = Math.max(-90, Math.min(90, W[1]));
                  let he =
                    W[2] === 180
                      ? 180
                      : ((((W[2] + 180) % 360) + 360) % 360) - 180;
                  const Se = Math.max(-90, Math.min(90, W[3]));
                  if (W[2] - W[0] >= 360) ((oe = -180), (he = 180));
                  else if (oe > he) {
                    const Be = this.getClusters([oe, ye, 180, Se], K),
                      dt = this.getClusters([-180, ye, he, Se], K);
                    return Be.concat(dt);
                  }
                  const ke = this.trees[this._limitZoom(K)],
                    Ee = ke.range(Xa(oe), To(Se), Xa(he), To(ye)),
                    Le = ke.data,
                    Ye = [];
                  for (const Be of Ee) {
                    const dt = this.stride * Be;
                    Ye.push(
                      Le[dt + mn] > 1
                        ? Is(Le, dt, this.clusterProps)
                        : this.points[Le[dt + ps]],
                    );
                  }
                  return Ye;
                }
                getChildren(W) {
                  const K = this._getOriginId(W),
                    oe = this._getOriginZoom(W),
                    ye = "No cluster with the specified id.",
                    he = this.trees[oe];
                  if (!he) throw new Error(ye);
                  const Se = he.data;
                  if (K * this.stride >= Se.length) throw new Error(ye);
                  const ke =
                      this.options.radius /
                      (this.options.extent * Math.pow(2, oe - 1)),
                    Ee = he.within(
                      Se[K * this.stride],
                      Se[K * this.stride + 1],
                      ke,
                    ),
                    Le = [];
                  for (const Ye of Ee) {
                    const Be = Ye * this.stride;
                    Se[Be + 4] === W &&
                      Le.push(
                        Se[Be + mn] > 1
                          ? Is(Se, Be, this.clusterProps)
                          : this.points[Se[Be + ps]],
                      );
                  }
                  if (Le.length === 0) throw new Error(ye);
                  return Le;
                }
                getLeaves(W, K, oe) {
                  const ye = [];
                  return (
                    this._appendLeaves(ye, W, (K = K || 10), (oe = oe || 0), 0),
                    ye
                  );
                }
                getTile(W, K, oe) {
                  const ye = this.trees[this._limitZoom(W)],
                    he = Math.pow(2, W),
                    { extent: Se, radius: ke } = this.options,
                    Ee = ke / Se,
                    Le = (oe - Ee) / he,
                    Ye = (oe + 1 + Ee) / he,
                    Be = { features: [] };
                  return (
                    this._addTileFeatures(
                      ye.range((K - Ee) / he, Le, (K + 1 + Ee) / he, Ye),
                      ye.data,
                      K,
                      oe,
                      he,
                      Be,
                    ),
                    K === 0 &&
                      this._addTileFeatures(
                        ye.range(1 - Ee / he, Le, 1, Ye),
                        ye.data,
                        he,
                        oe,
                        he,
                        Be,
                      ),
                    K === he - 1 &&
                      this._addTileFeatures(
                        ye.range(0, Le, Ee / he, Ye),
                        ye.data,
                        -1,
                        oe,
                        he,
                        Be,
                      ),
                    Be.features.length ? Be : null
                  );
                }
                getClusterExpansionZoom(W) {
                  let K = this._getOriginZoom(W) - 1;
                  for (; K <= this.options.maxZoom; ) {
                    const oe = this.getChildren(W);
                    if ((K++, oe.length !== 1)) break;
                    W = oe[0].properties.cluster_id;
                  }
                  return K;
                }
                _appendLeaves(W, K, oe, ye, he) {
                  const Se = this.getChildren(K);
                  for (const ke of Se) {
                    const Ee = ke.properties;
                    if (
                      (Ee && Ee.cluster
                        ? he + Ee.point_count <= ye
                          ? (he += Ee.point_count)
                          : (he = this._appendLeaves(
                              W,
                              Ee.cluster_id,
                              oe,
                              ye,
                              he,
                            ))
                        : he < ye
                          ? he++
                          : W.push(ke),
                      W.length === oe)
                    )
                      break;
                  }
                  return he;
                }
                _createTree(W) {
                  const K = new r.bW(
                    (W.length / this.stride) | 0,
                    this.options.nodeSize,
                    Float32Array,
                  );
                  for (let oe = 0; oe < W.length; oe += this.stride)
                    K.add(W[oe], W[oe + 1]);
                  return (K.finish(), (K.data = W), K);
                }
                _addTileFeatures(W, K, oe, ye, he, Se) {
                  for (const ke of W) {
                    const Ee = ke * this.stride,
                      Le = K[Ee + mn] > 1;
                    let Ye, Be, dt;
                    if (Le)
                      ((Ye = Gn(K, Ee, this.clusterProps)),
                        (Be = K[Ee]),
                        (dt = K[Ee + 1]));
                    else {
                      const Xt = this.points[K[Ee + ps]];
                      Ye = Xt.properties;
                      const [Kt, Qt] = Xt.geometry.coordinates;
                      ((Be = Xa(Kt)), (dt = To(Qt)));
                    }
                    const Pt = {
                      type: 1,
                      geometry: [
                        [
                          Math.round(this.options.extent * (Be * he - oe)),
                          Math.round(this.options.extent * (dt * he - ye)),
                        ],
                      ],
                      tags: Ye,
                    };
                    let zt;
                    ((zt =
                      Le || this.options.generateId
                        ? K[Ee + ps]
                        : this.points[K[Ee + ps]].id),
                      zt !== void 0 && (Pt.id = zt),
                      Se.features.push(Pt));
                  }
                }
                _limitZoom(W) {
                  return Math.max(
                    this.options.minZoom,
                    Math.min(Math.floor(+W), this.options.maxZoom + 1),
                  );
                }
                _cluster(W, K) {
                  const {
                      radius: oe,
                      extent: ye,
                      reduce: he,
                      minPoints: Se,
                    } = this.options,
                    ke = oe / (ye * Math.pow(2, K)),
                    Ee = W.data,
                    Le = [],
                    Ye = this.stride;
                  for (let Be = 0; Be < Ee.length; Be += Ye) {
                    if (Ee[Be + 2] <= K) continue;
                    Ee[Be + 2] = K;
                    const dt = Ee[Be],
                      Pt = Ee[Be + 1],
                      zt = W.within(Ee[Be], Ee[Be + 1], ke),
                      Xt = Ee[Be + mn];
                    let Kt = Xt;
                    for (const Qt of zt) {
                      const mi = Qt * Ye;
                      Ee[mi + 2] > K && (Kt += Ee[mi + mn]);
                    }
                    if (Kt > Xt && Kt >= Se) {
                      let Qt,
                        mi = dt * Xt,
                        ri = Pt * Xt,
                        Ki = -1;
                      const gn =
                        ((Be / Ye) << 5) + (K + 1) + this.points.length;
                      for (const _n of zt) {
                        const Ui = _n * Ye;
                        if (Ee[Ui + 2] <= K) continue;
                        Ee[Ui + 2] = K;
                        const Pi = Ee[Ui + mn];
                        ((mi += Ee[Ui] * Pi),
                          (ri += Ee[Ui + 1] * Pi),
                          (Ee[Ui + 4] = gn),
                          he &&
                            (Qt ||
                              ((Qt = this._map(Ee, Be, !0)),
                              (Ki = this.clusterProps.length),
                              this.clusterProps.push(Qt)),
                            he(Qt, this._map(Ee, Ui))));
                      }
                      ((Ee[Be + 4] = gn),
                        Le.push(mi / Kt, ri / Kt, 1 / 0, gn, -1, Kt),
                        he && Le.push(Ki));
                    } else {
                      for (let Qt = 0; Qt < Ye; Qt++) Le.push(Ee[Be + Qt]);
                      if (Kt > 1)
                        for (const Qt of zt) {
                          const mi = Qt * Ye;
                          if (!(Ee[mi + 2] <= K)) {
                            Ee[mi + 2] = K;
                            for (let ri = 0; ri < Ye; ri++)
                              Le.push(Ee[mi + ri]);
                          }
                        }
                    }
                  }
                  return Le;
                }
                _getOriginId(W) {
                  return (W - this.points.length) >> 5;
                }
                _getOriginZoom(W) {
                  return (W - this.points.length) % 32;
                }
                _map(W, K, oe) {
                  if (W[K + mn] > 1) {
                    const Se = this.clusterProps[W[K + Za]];
                    return oe ? Object.assign({}, Se) : Se;
                  }
                  const ye = this.points[W[K + ps]].properties,
                    he = this.options.map(ye);
                  return oe && he === ye ? Object.assign({}, he) : he;
                }
              }
              function Is(Fe, W, K) {
                return {
                  type: "Feature",
                  id: Fe[W + ps],
                  properties: Gn(Fe, W, K),
                  geometry: {
                    type: "Point",
                    coordinates: [
                      ((oe = Fe[W]), 360 * (oe - 0.5)),
                      Mr(Fe[W + 1]),
                    ],
                  },
                };
                var oe;
              }
              function Gn(Fe, W, K) {
                const oe = Fe[W + mn],
                  ye =
                    oe >= 1e4
                      ? `${Math.round(oe / 1e3)}k`
                      : oe >= 1e3
                        ? Math.round(oe / 100) / 10 + "k"
                        : oe,
                  he = Fe[W + Za],
                  Se = he === -1 ? {} : Object.assign({}, K[he]);
                return Object.assign(Se, {
                  cluster: !0,
                  cluster_id: Fe[W + ps],
                  point_count: oe,
                  point_count_abbreviated: ye,
                });
              }
              function Xa(Fe) {
                return Fe / 360 + 0.5;
              }
              function To(Fe) {
                const W = Math.sin((Fe * Math.PI) / 180),
                  K = 0.5 - (0.25 * Math.log((1 + W) / (1 - W))) / Math.PI;
                return K < 0 ? 0 : K > 1 ? 1 : K;
              }
              function Mr(Fe) {
                const W = ((180 - 360 * Fe) * Math.PI) / 180;
                return (360 * Math.atan(Math.exp(W))) / Math.PI - 90;
              }
              function la(Fe, W, K, oe) {
                let ye = oe;
                const he = W + ((K - W) >> 1);
                let Se,
                  ke = K - W;
                const Ee = Fe[W],
                  Le = Fe[W + 1],
                  Ye = Fe[K],
                  Be = Fe[K + 1];
                for (let dt = W + 3; dt < K; dt += 3) {
                  const Pt = ic(Fe[dt], Fe[dt + 1], Ee, Le, Ye, Be);
                  if (Pt > ye) ((Se = dt), (ye = Pt));
                  else if (Pt === ye) {
                    const zt = Math.abs(dt - he);
                    zt < ke && ((Se = dt), (ke = zt));
                  }
                }
                ye > oe &&
                  (Se - W > 3 && la(Fe, W, Se, oe),
                  (Fe[Se + 2] = ye),
                  K - Se > 3 && la(Fe, Se, K, oe));
              }
              function ic(Fe, W, K, oe, ye, he) {
                let Se = ye - K,
                  ke = he - oe;
                if (Se !== 0 || ke !== 0) {
                  const Ee =
                    ((Fe - K) * Se + (W - oe) * ke) / (Se * Se + ke * ke);
                  Ee > 1
                    ? ((K = ye), (oe = he))
                    : Ee > 0 && ((K += Se * Ee), (oe += ke * Ee));
                }
                return ((Se = Fe - K), (ke = W - oe), Se * Se + ke * ke);
              }
              function Cr(Fe, W, K, oe) {
                const ye = {
                  id: Fe ?? null,
                  type: W,
                  geometry: K,
                  tags: oe,
                  minX: 1 / 0,
                  minY: 1 / 0,
                  maxX: -1 / 0,
                  maxY: -1 / 0,
                };
                if (W === "Point" || W === "MultiPoint" || W === "LineString")
                  Zr(ye, K);
                else if (W === "Polygon") Zr(ye, K[0]);
                else if (W === "MultiLineString")
                  for (const he of K) Zr(ye, he);
                else if (W === "MultiPolygon")
                  for (const he of K) Zr(ye, he[0]);
                return ye;
              }
              function Zr(Fe, W) {
                for (let K = 0; K < W.length; K += 3)
                  ((Fe.minX = Math.min(Fe.minX, W[K])),
                    (Fe.minY = Math.min(Fe.minY, W[K + 1])),
                    (Fe.maxX = Math.max(Fe.maxX, W[K])),
                    (Fe.maxY = Math.max(Fe.maxY, W[K + 1])));
              }
              function So(Fe, W, K, oe) {
                if (!W.geometry) return;
                const ye = W.geometry.coordinates;
                if (ye && ye.length === 0) return;
                const he = W.geometry.type,
                  Se = Math.pow(K.tolerance / ((1 << K.maxZoom) * K.extent), 2);
                let ke = [],
                  Ee = W.id;
                if (
                  (K.promoteId
                    ? (Ee = W.properties[K.promoteId])
                    : K.generateId && (Ee = oe || 0),
                  he === "Point")
                )
                  Eo(ye, ke);
                else if (he === "MultiPoint") for (const Le of ye) Eo(Le, ke);
                else if (he === "LineString") Io(ye, ke, Se, !1);
                else if (he === "MultiLineString") {
                  if (K.lineMetrics) {
                    for (const Le of ye)
                      ((ke = []),
                        Io(Le, ke, Se, !1),
                        Fe.push(Cr(Ee, "LineString", ke, W.properties)));
                    return;
                  }
                  Pr(ye, ke, Se, !1);
                } else if (he === "Polygon") Pr(ye, ke, Se, !0);
                else {
                  if (he !== "MultiPolygon") {
                    if (he === "GeometryCollection") {
                      for (const Le of W.geometry.geometries)
                        So(
                          Fe,
                          { id: Ee, geometry: Le, properties: W.properties },
                          K,
                          oe,
                        );
                      return;
                    }
                    throw new Error(
                      "Input data is not a valid GeoJSON object.",
                    );
                  }
                  for (const Le of ye) {
                    const Ye = [];
                    (Pr(Le, Ye, Se, !0), ke.push(Ye));
                  }
                }
                Fe.push(Cr(Ee, he, ke, W.properties));
              }
              function Eo(Fe, W) {
                W.push(Ya(Fe[0]), Ka(Fe[1]), 0);
              }
              function Io(Fe, W, K, oe) {
                let ye,
                  he,
                  Se = 0;
                for (let Ee = 0; Ee < Fe.length; Ee++) {
                  const Le = Ya(Fe[Ee][0]),
                    Ye = Ka(Fe[Ee][1]);
                  (W.push(Le, Ye, 0),
                    Ee > 0 &&
                      (Se += oe
                        ? (ye * Ye - Le * he) / 2
                        : Math.sqrt(
                            Math.pow(Le - ye, 2) + Math.pow(Ye - he, 2),
                          )),
                    (ye = Le),
                    (he = Ye));
                }
                const ke = W.length - 3;
                ((W[2] = 1),
                  la(W, 0, ke, K),
                  (W[ke + 2] = 1),
                  (W.size = Math.abs(Se)),
                  (W.start = 0),
                  (W.end = W.size));
              }
              function Pr(Fe, W, K, oe) {
                for (let ye = 0; ye < Fe.length; ye++) {
                  const he = [];
                  (Io(Fe[ye], he, K, oe), W.push(he));
                }
              }
              function Ya(Fe) {
                return Fe / 360 + 0.5;
              }
              function Ka(Fe) {
                const W = Math.sin((Fe * Math.PI) / 180),
                  K = 0.5 - (0.25 * Math.log((1 + W) / (1 - W))) / Math.PI;
                return K < 0 ? 0 : K > 1 ? 1 : K;
              }
              function Xr(Fe, W, K, oe, ye, he, Se, ke) {
                if (((oe /= W), he >= (K /= W) && Se < oe)) return Fe;
                if (Se < K || he >= oe) return null;
                const Ee = [];
                for (const Le of Fe) {
                  const Ye = Le.geometry;
                  let Be = Le.type;
                  const dt = ye === 0 ? Le.minX : Le.minY,
                    Pt = ye === 0 ? Le.maxX : Le.maxY;
                  if (dt >= K && Pt < oe) {
                    Ee.push(Le);
                    continue;
                  }
                  if (Pt < K || dt >= oe) continue;
                  let zt = [];
                  if (Be === "Point" || Be === "MultiPoint")
                    nc(Ye, zt, K, oe, ye);
                  else if (Be === "LineString")
                    eo(Ye, zt, K, oe, ye, !1, ke.lineMetrics);
                  else if (Be === "MultiLineString") wr(Ye, zt, K, oe, ye, !1);
                  else if (Be === "Polygon") wr(Ye, zt, K, oe, ye, !0);
                  else if (Be === "MultiPolygon")
                    for (const Xt of Ye) {
                      const Kt = [];
                      (wr(Xt, Kt, K, oe, ye, !0), Kt.length && zt.push(Kt));
                    }
                  if (zt.length) {
                    if (ke.lineMetrics && Be === "LineString") {
                      for (const Xt of zt) Ee.push(Cr(Le.id, Be, Xt, Le.tags));
                      continue;
                    }
                    ((Be !== "LineString" && Be !== "MultiLineString") ||
                      (zt.length === 1
                        ? ((Be = "LineString"), (zt = zt[0]))
                        : (Be = "MultiLineString")),
                      (Be !== "Point" && Be !== "MultiPoint") ||
                        (Be = zt.length === 3 ? "Point" : "MultiPoint"),
                      Ee.push(Cr(Le.id, Be, zt, Le.tags)));
                  }
                }
                return Ee.length ? Ee : null;
              }
              function nc(Fe, W, K, oe, ye) {
                for (let he = 0; he < Fe.length; he += 3) {
                  const Se = Fe[he + ye];
                  Se >= K && Se <= oe && ms(W, Fe[he], Fe[he + 1], Fe[he + 2]);
                }
              }
              function eo(Fe, W, K, oe, ye, he, Se) {
                let ke = Ja(Fe);
                const Ee = ye === 0 ? ca : Ao;
                let Le,
                  Ye,
                  Be = Fe.start;
                for (let Kt = 0; Kt < Fe.length - 3; Kt += 3) {
                  const Qt = Fe[Kt],
                    mi = Fe[Kt + 1],
                    ri = Fe[Kt + 2],
                    Ki = Fe[Kt + 3],
                    gn = Fe[Kt + 4],
                    _n = ye === 0 ? Qt : mi,
                    Ui = ye === 0 ? Ki : gn;
                  let Pi = !1;
                  (Se &&
                    (Le = Math.sqrt(
                      Math.pow(Qt - Ki, 2) + Math.pow(mi - gn, 2),
                    )),
                    _n < K
                      ? Ui > K &&
                        ((Ye = Ee(ke, Qt, mi, Ki, gn, K)),
                        Se && (ke.start = Be + Le * Ye))
                      : _n > oe
                        ? Ui < oe &&
                          ((Ye = Ee(ke, Qt, mi, Ki, gn, oe)),
                          Se && (ke.start = Be + Le * Ye))
                        : ms(ke, Qt, mi, ri),
                    Ui < K &&
                      _n >= K &&
                      ((Ye = Ee(ke, Qt, mi, Ki, gn, K)), (Pi = !0)),
                    Ui > oe &&
                      _n <= oe &&
                      ((Ye = Ee(ke, Qt, mi, Ki, gn, oe)), (Pi = !0)),
                    !he &&
                      Pi &&
                      (Se && (ke.end = Be + Le * Ye),
                      W.push(ke),
                      (ke = Ja(Fe))),
                    Se && (Be += Le));
                }
                let dt = Fe.length - 3;
                const Pt = Fe[dt],
                  zt = Fe[dt + 1],
                  Xt = ye === 0 ? Pt : zt;
                (Xt >= K && Xt <= oe && ms(ke, Pt, zt, Fe[dt + 2]),
                  (dt = ke.length - 3),
                  he &&
                    dt >= 3 &&
                    (ke[dt] !== ke[0] || ke[dt + 1] !== ke[1]) &&
                    ms(ke, ke[0], ke[1], ke[2]),
                  ke.length && W.push(ke));
              }
              function Ja(Fe) {
                const W = [];
                return (
                  (W.size = Fe.size),
                  (W.start = Fe.start),
                  (W.end = Fe.end),
                  W
                );
              }
              function wr(Fe, W, K, oe, ye, he) {
                for (const Se of Fe) eo(Se, W, K, oe, ye, he, !1);
              }
              function ms(Fe, W, K, oe) {
                Fe.push(W, K, oe);
              }
              function ca(Fe, W, K, oe, ye, he) {
                const Se = (he - W) / (oe - W);
                return (ms(Fe, he, K + (ye - K) * Se, 1), Se);
              }
              function Ao(Fe, W, K, oe, ye, he) {
                const Se = (he - K) / (ye - K);
                return (ms(Fe, W + (oe - W) * Se, he, 1), Se);
              }
              function ha(Fe, W) {
                const K = [];
                for (let oe = 0; oe < Fe.length; oe++) {
                  const ye = Fe[oe],
                    he = ye.type;
                  let Se;
                  if (
                    he === "Point" ||
                    he === "MultiPoint" ||
                    he === "LineString"
                  )
                    Se = Mo(ye.geometry, W);
                  else if (he === "MultiLineString" || he === "Polygon") {
                    Se = [];
                    for (const ke of ye.geometry) Se.push(Mo(ke, W));
                  } else if (he === "MultiPolygon") {
                    Se = [];
                    for (const ke of ye.geometry) {
                      const Ee = [];
                      for (const Le of ke) Ee.push(Mo(Le, W));
                      Se.push(Ee);
                    }
                  }
                  K.push(Cr(ye.id, he, Se, ye.tags));
                }
                return K;
              }
              function Mo(Fe, W) {
                const K = [];
                ((K.size = Fe.size),
                  Fe.start !== void 0 &&
                    ((K.start = Fe.start), (K.end = Fe.end)));
                for (let oe = 0; oe < Fe.length; oe += 3)
                  K.push(Fe[oe] + W, Fe[oe + 1], Fe[oe + 2]);
                return K;
              }
              function Qa(Fe, W) {
                if (Fe.transformed) return Fe;
                const K = 1 << Fe.z,
                  oe = Fe.x,
                  ye = Fe.y;
                for (const he of Fe.features) {
                  const Se = he.geometry,
                    ke = he.type;
                  if (((he.geometry = []), ke === 1))
                    for (let Ee = 0; Ee < Se.length; Ee += 2)
                      he.geometry.push(bn(Se[Ee], Se[Ee + 1], W, K, oe, ye));
                  else
                    for (let Ee = 0; Ee < Se.length; Ee++) {
                      const Le = [];
                      for (let Ye = 0; Ye < Se[Ee].length; Ye += 2)
                        Le.push(bn(Se[Ee][Ye], Se[Ee][Ye + 1], W, K, oe, ye));
                      he.geometry.push(Le);
                    }
                }
                return ((Fe.transformed = !0), Fe);
              }
              function bn(Fe, W, K, oe, ye, he) {
                return [
                  Math.round(K * (Fe * oe - ye)),
                  Math.round(K * (W * oe - he)),
                ];
              }
              function Co(Fe, W, K, oe, ye) {
                const he =
                    W === ye.maxZoom
                      ? 0
                      : ye.tolerance / ((1 << W) * ye.extent),
                  Se = {
                    features: [],
                    numPoints: 0,
                    numSimplified: 0,
                    numFeatures: Fe.length,
                    source: null,
                    x: K,
                    y: oe,
                    z: W,
                    transformed: !1,
                    minX: 2,
                    minY: 1,
                    maxX: -1,
                    maxY: 0,
                  };
                for (const ke of Fe) el(Se, ke, he, ye);
                return Se;
              }
              function el(Fe, W, K, oe) {
                const ye = W.geometry,
                  he = W.type,
                  Se = [];
                if (
                  ((Fe.minX = Math.min(Fe.minX, W.minX)),
                  (Fe.minY = Math.min(Fe.minY, W.minY)),
                  (Fe.maxX = Math.max(Fe.maxX, W.maxX)),
                  (Fe.maxY = Math.max(Fe.maxY, W.maxY)),
                  he === "Point" || he === "MultiPoint")
                )
                  for (let ke = 0; ke < ye.length; ke += 3)
                    (Se.push(ye[ke], ye[ke + 1]),
                      Fe.numPoints++,
                      Fe.numSimplified++);
                else if (he === "LineString") Yr(Se, ye, Fe, K, !1, !1);
                else if (he === "MultiLineString" || he === "Polygon")
                  for (let ke = 0; ke < ye.length; ke++)
                    Yr(Se, ye[ke], Fe, K, he === "Polygon", ke === 0);
                else if (he === "MultiPolygon")
                  for (let ke = 0; ke < ye.length; ke++) {
                    const Ee = ye[ke];
                    for (let Le = 0; Le < Ee.length; Le++)
                      Yr(Se, Ee[Le], Fe, K, !0, Le === 0);
                  }
                if (Se.length) {
                  let ke = W.tags || null;
                  if (he === "LineString" && oe.lineMetrics) {
                    ke = {};
                    for (const Le in W.tags) ke[Le] = W.tags[Le];
                    ((ke.mapbox_clip_start = ye.start / ye.size),
                      (ke.mapbox_clip_end = ye.end / ye.size));
                  }
                  const Ee = {
                    geometry: Se,
                    type:
                      he === "Polygon" || he === "MultiPolygon"
                        ? 3
                        : he === "LineString" || he === "MultiLineString"
                          ? 2
                          : 1,
                    tags: ke,
                  };
                  (W.id !== null && (Ee.id = W.id), Fe.features.push(Ee));
                }
              }
              function Yr(Fe, W, K, oe, ye, he) {
                const Se = oe * oe;
                if (oe > 0 && W.size < (ye ? Se : oe))
                  return void (K.numPoints += W.length / 3);
                const ke = [];
                for (let Ee = 0; Ee < W.length; Ee += 3)
                  ((oe === 0 || W[Ee + 2] > Se) &&
                    (K.numSimplified++, ke.push(W[Ee], W[Ee + 1])),
                    K.numPoints++);
                (ye &&
                  (function (Ee, Le) {
                    let Ye = 0;
                    for (
                      let Be = 0, dt = Ee.length, Pt = dt - 2;
                      Be < dt;
                      Pt = Be, Be += 2
                    )
                      Ye += (Ee[Be] - Ee[Pt]) * (Ee[Be + 1] + Ee[Pt + 1]);
                    if (Ye > 0 === Le)
                      for (let Be = 0, dt = Ee.length; Be < dt / 2; Be += 2) {
                        const Pt = Ee[Be],
                          zt = Ee[Be + 1];
                        ((Ee[Be] = Ee[dt - 2 - Be]),
                          (Ee[Be + 1] = Ee[dt - 1 - Be]),
                          (Ee[dt - 2 - Be] = Pt),
                          (Ee[dt - 1 - Be] = zt));
                      }
                  })(ke, he),
                  Fe.push(ke));
              }
              const td = {
                maxZoom: 14,
                indexMaxZoom: 5,
                indexMaxPoints: 1e5,
                tolerance: 3,
                extent: 4096,
                buffer: 64,
                lineMetrics: !1,
                promoteId: null,
                generateId: !1,
                debug: 0,
              };
              class Sh {
                constructor(W, K) {
                  const oe = (K = this.options =
                    (function (he, Se) {
                      for (const ke in Se) he[ke] = Se[ke];
                      return he;
                    })(Object.create(td), K)).debug;
                  if (
                    (oe && console.time("preprocess data"),
                    K.maxZoom < 0 || K.maxZoom > 24)
                  )
                    throw new Error("maxZoom should be in the 0-24 range");
                  if (K.promoteId && K.generateId)
                    throw new Error(
                      "promoteId and generateId cannot be used together.",
                    );
                  let ye = (function (he, Se) {
                    const ke = [];
                    if (he.type === "FeatureCollection")
                      for (let Ee = 0; Ee < he.features.length; Ee++)
                        So(ke, he.features[Ee], Se, Ee);
                    else
                      So(ke, he.type === "Feature" ? he : { geometry: he }, Se);
                    return ke;
                  })(W, K);
                  ((this.tiles = {}),
                    (this.tileCoords = []),
                    oe &&
                      (console.timeEnd("preprocess data"),
                      console.log(
                        "index: maxZoom: %d, maxPoints: %d",
                        K.indexMaxZoom,
                        K.indexMaxPoints,
                      ),
                      console.time("generate tiles"),
                      (this.stats = {}),
                      (this.total = 0)),
                    (ye = (function (he, Se) {
                      const ke = Se.buffer / Se.extent;
                      let Ee = he;
                      const Le = Xr(he, 1, -1 - ke, ke, 0, -1, 2, Se),
                        Ye = Xr(he, 1, 1 - ke, 2 + ke, 0, -1, 2, Se);
                      return (
                        (Le || Ye) &&
                          ((Ee = Xr(he, 1, -ke, 1 + ke, 0, -1, 2, Se) || []),
                          Le && (Ee = ha(Le, 1).concat(Ee)),
                          Ye && (Ee = Ee.concat(ha(Ye, -1)))),
                        Ee
                      );
                    })(ye, K)),
                    ye.length && this.splitTile(ye, 0, 0, 0),
                    oe &&
                      (ye.length &&
                        console.log(
                          "features: %d, points: %d",
                          this.tiles[0].numFeatures,
                          this.tiles[0].numPoints,
                        ),
                      console.timeEnd("generate tiles"),
                      console.log(
                        "tiles generated:",
                        this.total,
                        JSON.stringify(this.stats),
                      )));
                }
                splitTile(W, K, oe, ye, he, Se, ke) {
                  const Ee = [W, K, oe, ye],
                    Le = this.options,
                    Ye = Le.debug;
                  for (; Ee.length; ) {
                    ((ye = Ee.pop()),
                      (oe = Ee.pop()),
                      (K = Ee.pop()),
                      (W = Ee.pop()));
                    const Be = 1 << K,
                      dt = ua(K, oe, ye);
                    let Pt = this.tiles[dt];
                    if (
                      !Pt &&
                      (Ye > 1 && console.time("creation"),
                      (Pt = this.tiles[dt] = Co(W, K, oe, ye, Le)),
                      this.tileCoords.push({ z: K, x: oe, y: ye }),
                      Ye)
                    ) {
                      Ye > 1 &&
                        (console.log(
                          "tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",
                          K,
                          oe,
                          ye,
                          Pt.numFeatures,
                          Pt.numPoints,
                          Pt.numSimplified,
                        ),
                        console.timeEnd("creation"));
                      const Pi = `z${K}`;
                      ((this.stats[Pi] = (this.stats[Pi] || 0) + 1),
                        this.total++);
                    }
                    if (((Pt.source = W), he == null)) {
                      if (
                        K === Le.indexMaxZoom ||
                        Pt.numPoints <= Le.indexMaxPoints
                      )
                        continue;
                    } else {
                      if (K === Le.maxZoom || K === he) continue;
                      if (he != null) {
                        const Pi = he - K;
                        if (oe !== Se >> Pi || ye !== ke >> Pi) continue;
                      }
                    }
                    if (((Pt.source = null), W.length === 0)) continue;
                    Ye > 1 && console.time("clipping");
                    const zt = (0.5 * Le.buffer) / Le.extent,
                      Xt = 0.5 - zt,
                      Kt = 0.5 + zt,
                      Qt = 1 + zt;
                    let mi = null,
                      ri = null,
                      Ki = null,
                      gn = null,
                      _n = Xr(W, Be, oe - zt, oe + Kt, 0, Pt.minX, Pt.maxX, Le),
                      Ui = Xr(W, Be, oe + Xt, oe + Qt, 0, Pt.minX, Pt.maxX, Le);
                    ((W = null),
                      _n &&
                        ((mi = Xr(
                          _n,
                          Be,
                          ye - zt,
                          ye + Kt,
                          1,
                          Pt.minY,
                          Pt.maxY,
                          Le,
                        )),
                        (ri = Xr(
                          _n,
                          Be,
                          ye + Xt,
                          ye + Qt,
                          1,
                          Pt.minY,
                          Pt.maxY,
                          Le,
                        )),
                        (_n = null)),
                      Ui &&
                        ((Ki = Xr(
                          Ui,
                          Be,
                          ye - zt,
                          ye + Kt,
                          1,
                          Pt.minY,
                          Pt.maxY,
                          Le,
                        )),
                        (gn = Xr(
                          Ui,
                          Be,
                          ye + Xt,
                          ye + Qt,
                          1,
                          Pt.minY,
                          Pt.maxY,
                          Le,
                        )),
                        (Ui = null)),
                      Ye > 1 && console.timeEnd("clipping"),
                      Ee.push(mi || [], K + 1, 2 * oe, 2 * ye),
                      Ee.push(ri || [], K + 1, 2 * oe, 2 * ye + 1),
                      Ee.push(Ki || [], K + 1, 2 * oe + 1, 2 * ye),
                      Ee.push(gn || [], K + 1, 2 * oe + 1, 2 * ye + 1));
                  }
                }
                getTile(W, K, oe) {
                  ((W = +W), (K = +K), (oe = +oe));
                  const ye = this.options,
                    { extent: he, debug: Se } = ye;
                  if (W < 0 || W > 24) return null;
                  const ke = 1 << W,
                    Ee = ua(W, (K = (K + ke) & (ke - 1)), oe);
                  if (this.tiles[Ee]) return Qa(this.tiles[Ee], he);
                  Se > 1 && console.log("drilling down to z%d-%d-%d", W, K, oe);
                  let Le,
                    Ye = W,
                    Be = K,
                    dt = oe;
                  for (; !Le && Ye > 0; )
                    (Ye--,
                      (Be >>= 1),
                      (dt >>= 1),
                      (Le = this.tiles[ua(Ye, Be, dt)]));
                  return Le && Le.source
                    ? (Se > 1 &&
                        (console.log("found parent tile z%d-%d-%d", Ye, Be, dt),
                        console.time("drilling down")),
                      this.splitTile(Le.source, Ye, Be, dt, W, K, oe),
                      Se > 1 && console.timeEnd("drilling down"),
                      this.tiles[Ee] ? Qa(this.tiles[Ee], he) : null)
                    : null;
                }
              }
              function ua(Fe, W, K) {
                return 32 * ((1 << Fe) * K + W) + Fe;
              }
              function ft(Fe, W) {
                const K = Fe.tileID.canonical;
                if (!this._geoJSONIndex) return void W(null, null);
                const oe = this._geoJSONIndex.getTile(K.z, K.x, K.y);
                if (!oe) return void W(null, null);
                const ye = (Ee) =>
                    Ee.tags &&
                    "3d_elevation_id" in Ee.tags &&
                    "source" in Ee.tags &&
                    Ee.tags.source === "elevation",
                  he = oe.features.filter((Ee) => ye(Ee));
                let Se;
                if (he.length > 0) {
                  const Ee = oe.features.filter((Le) => !ye(Le));
                  Se = new rt({ _geojsonTileLayer: Ee, hd_road_elevation: he });
                } else Se = new pt(oe.features);
                let ke = qr(Se);
                ((ke.byteOffset === 0 &&
                  ke.byteLength === ke.buffer.byteLength) ||
                  (ke = new Uint8Array(ke)),
                  W(null, { vectorTile: Se, rawData: ke.buffer }));
              }
              class to extends we {
                constructor(W, K, oe, ye, he, Se, ke) {
                  (super(W, K, oe, ye, he, ft, ke),
                    Se && (this.loadGeoJSON = Se),
                    (this._dynamicIndex = new qt()));
                }
                loadData(W, K) {
                  const oe = W && W.request,
                    ye = oe && oe.collectResourceTiming;
                  this.loadGeoJSON(W, (he, Se) => {
                    if (he || !Se) return K(he);
                    if (typeof Se != "object")
                      return K(
                        new Error(
                          `Input data given to '${W.source}' is not a valid GeoJSON object.`,
                        ),
                      );
                    {
                      try {
                        if (W.filter) {
                          const Ee = r.X(W.filter, {
                            type: "boolean",
                            "property-type": "data-driven",
                            overridable: !1,
                            transition: !1,
                          });
                          if (Ee.result === "error")
                            throw new Error(
                              Ee.value
                                .map((Le) => `${Le.key}: ${Le.message}`)
                                .join(", "),
                            );
                          Se.features = Se.features.filter((Le) =>
                            Ee.value.evaluate({ zoom: 0 }, Le),
                          );
                        }
                        (W.dynamic
                          ? (Se.type === "Feature" &&
                              (Se = {
                                type: "FeatureCollection",
                                features: [Se],
                              }),
                            W.append ||
                              (this._dynamicIndex.clear(), (this.loaded = {})),
                            this._dynamicIndex.load(Se.features, this.loaded),
                            W.cluster &&
                              (Se.features = this._dynamicIndex.getFeatures()))
                          : (this.loaded = {}),
                          (this._geoJSONIndex = W.cluster
                            ? new Qs(
                                (function ({
                                  superclusterOptions: Ee,
                                  clusterProperties: Le,
                                }) {
                                  if (!Le || !Ee) return Ee;
                                  const Ye = {},
                                    Be = {},
                                    dt = { accumulated: null, zoom: 0 },
                                    Pt = { properties: null },
                                    zt = Object.keys(Le);
                                  for (const Xt of zt) {
                                    const [Kt, Qt] = Le[Xt],
                                      mi = r.X(Qt),
                                      ri = r.X(
                                        typeof Kt == "string"
                                          ? [Kt, ["accumulated"], ["get", Xt]]
                                          : Kt,
                                      );
                                    ((Ye[Xt] = mi.value), (Be[Xt] = ri.value));
                                  }
                                  return (
                                    (Ee.map = (Xt) => {
                                      Pt.properties = Xt;
                                      const Kt = {};
                                      for (const Qt of zt)
                                        Kt[Qt] = Ye[Qt].evaluate(dt, Pt);
                                      return Kt;
                                    }),
                                    (Ee.reduce = (Xt, Kt) => {
                                      Pt.properties = Kt;
                                      for (const Qt of zt)
                                        ((dt.accumulated = Xt[Qt]),
                                          (Xt[Qt] = Be[Qt].evaluate(dt, Pt)));
                                    }),
                                    Ee
                                  );
                                })(W),
                              ).load(Se.features)
                            : W.dynamic
                              ? this._dynamicIndex
                              : (function (Ee, Le) {
                                  return new Sh(Ee, Le);
                                })(Se, W.geojsonVtOptions)));
                      } catch (Ee) {
                        return K(Ee);
                      }
                      const ke = {};
                      if (ye) {
                        const Ee = F(oe);
                        Ee &&
                          ((ke.resourceTiming = {}),
                          (ke.resourceTiming[W.source] = JSON.parse(
                            JSON.stringify(Ee),
                          )));
                      }
                      K(null, ke);
                    }
                  });
                }
                reloadTile(W, K) {
                  const oe = this.loaded;
                  return oe && oe[W.uid]
                    ? W.partial
                      ? K(null, void 0)
                      : super.reloadTile(W, K)
                    : this.loadTile(W, K);
                }
                loadGeoJSON(W, K) {
                  if (W.request) r.n(W.request, K);
                  else {
                    if (typeof W.data != "string")
                      return K(
                        new Error(
                          `Input data given to '${W.source}' is not a valid GeoJSON object.`,
                        ),
                      );
                    try {
                      return K(null, JSON.parse(W.data));
                    } catch {
                      return K(
                        new Error(
                          `Input data given to '${W.source}' is not a valid GeoJSON object.`,
                        ),
                      );
                    }
                  }
                }
                getClusterExpansionZoom(W, K) {
                  try {
                    K(
                      null,
                      this._geoJSONIndex.getClusterExpansionZoom(W.clusterId),
                    );
                  } catch (oe) {
                    K(oe);
                  }
                }
                getClusterChildren(W, K) {
                  try {
                    K(null, this._geoJSONIndex.getChildren(W.clusterId));
                  } catch (oe) {
                    K(oe);
                  }
                }
                getClusterLeaves(W, K) {
                  try {
                    K(
                      null,
                      this._geoJSONIndex.getLeaves(
                        W.clusterId,
                        W.limit,
                        W.offset,
                      ),
                    );
                  } catch (oe) {
                    K(oe);
                  }
                }
              }
              class id {
                constructor(W, K, oe) {
                  ((this.tileID = new r.aM(
                    W.tileID.overscaledZ,
                    W.tileID.wrap,
                    W.tileID.canonical.z,
                    W.tileID.canonical.x,
                    W.tileID.canonical.y,
                  )),
                    (this.tileZoom = W.tileZoom),
                    (this.uid = W.uid),
                    (this.zoom = W.zoom),
                    (this.canonical = W.tileID.canonical),
                    (this.pixelRatio = W.pixelRatio),
                    (this.tileSize = W.tileSize),
                    (this.source = W.source),
                    (this.overscaling = this.tileID.overscaleFactor()),
                    (this.projection = W.projection),
                    (this.brightness = K),
                    (this.worldview = oe));
                }
                parse(W, K, oe, ye) {
                  this.status = "parsing";
                  const he = new r.aM(
                      oe.tileID.overscaledZ,
                      oe.tileID.wrap,
                      oe.tileID.canonical.z,
                      oe.tileID.canonical.x,
                      oe.tileID.canonical.y,
                    ),
                    Se = [],
                    ke = K.familiesBySource[oe.source],
                    Ee = new r.f0(he, oe.promoteId);
                  ((Ee.bucketLayerIDs = []),
                    (Ee.is3DTile = !0),
                    r
                      .fi(W)
                      .then((Le) => {
                        if (!Le) return ye(new Error("Could not parse tile"));
                        const Ye =
                            (Le.json.extensionsUsed &&
                              Le.json.extensionsUsed.includes(
                                "MAPBOX_mesh_features",
                              )) ||
                            (Le.json.asset.extras &&
                              Le.json.asset.extras.MAPBOX_mesh_features),
                          Be =
                            Le.json.extensionsUsed &&
                            Le.json.extensionsUsed.includes(
                              "EXT_meshopt_compression",
                            ),
                          dt = new r.aa(this.zoom, {
                            brightness: this.brightness,
                            worldview: this.worldview,
                          });
                        for (const Pt in ke)
                          for (const zt of ke[Pt]) {
                            const Xt = zt[0];
                            (Ee.bucketLayerIDs.push(
                              zt.map((mi) => r.C(mi.id, mi.scope)),
                            ),
                              Xt.recalculate(dt, []));
                            const Kt = r.fj(Le, 1 / r.cU(oe.tileID.canonical)),
                              Qt = new r.fk(
                                zt,
                                Kt,
                                he,
                                Ye,
                                Be,
                                this.brightness,
                                Ee,
                                this.worldview,
                              );
                            (Ye || (Qt.needsUpload = !0),
                              Se.push(Qt),
                              Qt.evaluate(Xt));
                          }
                        ((this.status = "done"),
                          ye(null, {
                            buckets: Se,
                            featureIndex: Ee,
                            collisionBoxArray: null,
                            glyphAtlasImage: null,
                            lineAtlas: null,
                            imageAtlas: null,
                            brightness: null,
                          }));
                      })
                      .catch((Le) => ye(new Error(Le.message))));
                }
              }
              class rc {
                constructor(W, K, oe, ye, he, Se, ke, Ee) {
                  ((this.actor = W),
                    (this.layerIndex = K),
                    (this.availableImages = oe),
                    (this.availableModels = ye),
                    (this.brightness = ke),
                    (this.loading = {}),
                    (this.loaded = {}),
                    (this.worldview = Ee));
                }
                loadTile(W, K) {
                  const oe = W.uid,
                    ye = (this.loading[oe] = new id(
                      W,
                      this.brightness,
                      this.worldview,
                    ));
                  r.br(W.request, (he, Se) => {
                    const ke = !this.loading[oe];
                    return (
                      delete this.loading[oe],
                      ke || he
                        ? ((ye.status = "done"),
                          ke || (this.loaded[oe] = ye),
                          K(he))
                        : Se && Se.byteLength !== 0
                          ? void ye.parse(Se, this.layerIndex, W, (Ee, Le) => {
                              ((ye.status = "done"),
                                (this.loaded = this.loaded || {}),
                                (this.loaded[oe] = ye),
                                Ee || !Le ? K(Ee) : K(null, Le));
                            })
                          : ((ye.status = "done"), (this.loaded[oe] = ye), K())
                    );
                  });
                }
                reloadTile(W, K) {
                  const oe = this.loaded,
                    ye = W.uid;
                  if (oe && oe[ye]) {
                    const he = oe[ye];
                    ((he.projection = W.projection),
                      (he.brightness = W.brightness));
                    const Se = (ke, Ee) => {
                      (he.reloadCallback &&
                        (delete he.reloadCallback, this.loadTile(W, K)),
                        K(ke, Ee));
                    };
                    he.status === "parsing"
                      ? (he.reloadCallback = Se)
                      : he.status === "done" && this.loadTile(W, K);
                  }
                }
                abortTile(W, K) {
                  const oe = W.uid;
                  (this.loading[oe] && delete this.loading[oe], K());
                }
                removeTile(W, K) {
                  const oe = this.loaded,
                    ye = W.uid;
                  (oe && oe[ye] && delete oe[ye], K());
                }
              }
              class Mi {
                constructor(W) {
                  ((this.self = W),
                    (this.actor = new r.fm(W, this)),
                    (this.layerIndexes = {}),
                    (this.availableImages = {}),
                    (this.availableModels = {}),
                    (this.isSpriteLoaded = {}),
                    (this.imageRasterizer = new r.y()),
                    (this.rtlPluginParsingListeners = []),
                    (this.projections = {}),
                    (this.defaultProjection = r.ce({ name: "mercator" })),
                    (this.workerSourceTypes = {
                      vector: we,
                      geojson: to,
                      "raster-dem": Ae,
                      "raster-array": gt,
                      "batched-model": rc,
                    }),
                    (this.workerSources = {}),
                    (this.self.registerWorkerSource = (K, oe) => {
                      if (this.workerSourceTypes[K])
                        throw new Error(
                          `Worker source with name "${K}" already registered.`,
                        );
                      this.workerSourceTypes[K] = oe;
                    }),
                    (this.self.registerRTLTextPlugin = (K) => {
                      if (r.fn.isParsed())
                        throw new Error("RTL text plugin already registered.");
                      (r.fn.setState({
                        pluginStatus: r.fo.parsed,
                        pluginURL: r.fn.getPluginURL(),
                      }),
                        (r.fn.applyArabicShaping = K.applyArabicShaping),
                        (r.fn.processBidirectionalText =
                          K.processBidirectionalText),
                        (r.fn.processStyledBidirectionalText =
                          K.processStyledBidirectionalText));
                      for (const oe of this.rtlPluginParsingListeners)
                        oe(null, !0);
                      this.rtlPluginParsingListeners = [];
                    }));
                }
                clearCaches(W, K, oe) {
                  (delete this.layerIndexes[W],
                    delete this.availableImages[W],
                    delete this.availableModels[W],
                    delete this.workerSources[W],
                    oe());
                }
                checkIfReady(W, K, oe) {
                  oe();
                }
                setReferrer(W, K) {
                  this.referrer = K;
                }
                spriteLoaded(W, K) {
                  this.isSpriteLoaded[W] || (this.isSpriteLoaded[W] = {});
                  const { scope: oe, isLoaded: ye } = K;
                  if (
                    ((this.isSpriteLoaded[W][oe] = ye),
                    this.workerSources[W] && this.workerSources[W][oe])
                  )
                    for (const he in this.workerSources[W][oe]) {
                      const Se = this.workerSources[W][oe][he];
                      for (const ke in Se) {
                        const Ee = Se[ke];
                        Ee instanceof we &&
                          ((Ee.isSpriteLoaded = ye),
                          Ee.fire(new r.A("isSpriteLoaded")));
                      }
                    }
                }
                setImages(W, K, oe) {
                  this.availableImages[W] || (this.availableImages[W] = {});
                  const { scope: ye, images: he } = K;
                  if (
                    ((this.availableImages[W][ye] = he),
                    this.workerSources[W] && this.workerSources[W][ye])
                  ) {
                    for (const Se in this.workerSources[W][ye]) {
                      const ke = this.workerSources[W][ye][Se];
                      for (const Ee in ke) ke[Ee].availableImages = he;
                    }
                    oe();
                  } else oe();
                }
                setModels(W, { scope: K, models: oe }, ye) {
                  if (
                    (this.availableModels[W] || (this.availableModels[W] = {}),
                    (this.availableModels[W][K] = oe),
                    this.workerSources[W] && this.workerSources[W][K])
                  ) {
                    for (const he in this.workerSources[W][K]) {
                      const Se = this.workerSources[W][K][he];
                      for (const ke in Se) Se[ke].availableModels = oe;
                    }
                    ye();
                  } else ye();
                }
                setProjection(W, K) {
                  this.projections[W] = r.ce(K);
                }
                setBrightness(W, K, oe) {
                  ((this.brightness = K), oe());
                }
                setWorldview(W, K, oe) {
                  ((this.worldview = K), oe());
                }
                setLayers(W, K, oe) {
                  (this.getLayerIndex(W, K.scope).replace(K.layers, K.options),
                    oe());
                }
                updateLayers(W, K, oe) {
                  (this.getLayerIndex(W, K.scope).update(
                    K.layers,
                    K.removedIds,
                    K.options,
                  ),
                    oe());
                }
                loadTile(W, K, oe) {
                  ((K.projection =
                    this.projections[W] || this.defaultProjection),
                    this.getWorkerSource(W, K.type, K.source, K.scope).loadTile(
                      K,
                      oe,
                    ));
                }
                decodeRasterArray(W, K, oe) {
                  this.getWorkerSource(
                    W,
                    K.type,
                    K.source,
                    K.scope,
                  ).decodeRasterArray(K, oe);
                }
                reloadTile(W, K, oe) {
                  ((K.projection =
                    this.projections[W] || this.defaultProjection),
                    this.getWorkerSource(
                      W,
                      K.type,
                      K.source,
                      K.scope,
                    ).reloadTile(K, oe));
                }
                abortTile(W, K, oe) {
                  this.getWorkerSource(W, K.type, K.source, K.scope).abortTile(
                    K,
                    oe,
                  );
                }
                removeTile(W, K, oe) {
                  this.getWorkerSource(W, K.type, K.source, K.scope).removeTile(
                    K,
                    oe,
                  );
                }
                removeSource(W, K, oe) {
                  if (
                    !(
                      this.workerSources[W] &&
                      this.workerSources[W][K.scope] &&
                      this.workerSources[W][K.scope][K.type] &&
                      this.workerSources[W][K.scope][K.type][K.source]
                    )
                  )
                    return;
                  const ye = this.workerSources[W][K.scope][K.type][K.source];
                  (delete this.workerSources[W][K.scope][K.type][K.source],
                    ye.removeSource !== void 0 ? ye.removeSource(K, oe) : oe());
                }
                loadWorkerSource(W, K, oe) {
                  try {
                    (this.self.importScripts(K.url), oe());
                  } catch (ye) {
                    oe(ye.toString());
                  }
                }
                syncRTLPluginState(W, K, oe) {
                  if (r.fn.isParsed()) oe(null, !0);
                  else if (r.fn.isParsing())
                    this.rtlPluginParsingListeners.push(oe);
                  else
                    try {
                      r.fn.setState(K);
                      const ye = r.fn.getPluginURL();
                      !r.fn.isLoaded() ||
                        r.fn.isParsed() ||
                        r.fn.isParsing() ||
                        ye == null ||
                        (r.fn.setState({
                          pluginStatus: r.fo.parsing,
                          pluginURL: r.fn.getPluginURL(),
                        }),
                        this.self.importScripts(ye),
                        r.fn.isParsed()
                          ? oe(null, !0)
                          : this.rtlPluginParsingListeners.push(oe));
                    } catch (ye) {
                      oe(ye.toString());
                    }
                }
                setDracoUrl(W, K) {
                  this.dracoUrl = K;
                }
                getAvailableImages(W, K) {
                  this.availableImages[W] || (this.availableImages[W] = {});
                  let oe = this.availableImages[W][K];
                  return (oe || (oe = []), oe);
                }
                getAvailableModels(W, K) {
                  this.availableModels[W] || (this.availableModels[W] = {});
                  let oe = this.availableModels[W][K];
                  return (oe || (oe = {}), oe);
                }
                getLayerIndex(W, K) {
                  this.layerIndexes[W] || (this.layerIndexes[W] = {});
                  let oe = this.layerIndexes[W][K];
                  return (
                    oe ||
                      ((oe = this.layerIndexes[W][K] = new ne()),
                      (oe.scope = K)),
                    oe
                  );
                }
                getWorkerSource(W, K, oe, ye) {
                  const he = this.workerSources;
                  return (
                    he[W] || (he[W] = {}),
                    he[W][ye] || (he[W][ye] = {}),
                    he[W][ye][K] || (he[W][ye][K] = {}),
                    this.isSpriteLoaded[W] || (this.isSpriteLoaded[W] = {}),
                    he[W][ye][K][oe] ||
                      (he[W][ye][K][oe] = new this.workerSourceTypes[K](
                        {
                          send: (Se, ke, Ee, Le, Ye, Be) =>
                            this.actor.send(Se, ke, Ee, W, Ye, Be),
                          scheduler: this.actor.scheduler,
                        },
                        this.getLayerIndex(W, ye),
                        this.getAvailableImages(W, ye),
                        this.getAvailableModels(W, ye),
                        this.isSpriteLoaded[W][ye],
                        void 0,
                        this.brightness,
                        this.worldview,
                      )),
                    he[W][ye][K][oe]
                  );
                }
                rasterizeImagesWorker(W, K, oe) {
                  const ye = new Map();
                  for (const [
                    he,
                    { image: Se, imageVariant: ke },
                  ] of K.tasks.entries()) {
                    const Ee = this.imageRasterizer.rasterize(
                      ke,
                      Se,
                      K.scope,
                      W,
                    );
                    ye.set(he, Ee);
                  }
                  oe(void 0, ye);
                }
                removeRasterizedImages(W, K, oe) {
                  (this.imageRasterizer.removeImagesFromCacheByIds(
                    K.imageIds,
                    K.scope,
                    W,
                  ),
                    oe());
                }
                enforceCacheSizeLimit(W, K) {
                  r.fp(K);
                }
                getWorkerPerformanceMetrics(W, K, oe) {
                  oe(void 0, void 0);
                }
              }
              return (r.fl(self) && (self.worker = new Mi(self)), Mi);
            }),
            I(["./shared"], function (r) {
              var F = "3.13.0";
              const B = {
                  create: "create",
                  load: "load",
                  fullLoad: "fullLoad",
                },
                q = {
                  mark(c) {
                    performance.mark(c);
                  },
                  measure(c, t, s) {
                    performance.measure(c, t, s);
                  },
                };
              function ne(c) {
                const t = c.name.split("?")[0];
                return r.a(t) && t.includes("mapbox-gl.js")
                  ? "javascript"
                  : r.a(t) && t.includes("mapbox-gl.css")
                    ? "css"
                    : r.b(t)
                      ? "fontRange"
                      : r.c(t)
                        ? "sprite"
                        : r.i(t)
                          ? "style"
                          : r.d(t)
                            ? "tilejson"
                            : "other";
              }
              var fe,
                de = {},
                Ie = (function () {
                  if (fe) return de;
                  function c(h) {
                    return !t(h);
                  }
                  function t(h) {
                    return typeof window > "u" || typeof document > "u"
                      ? "not a browser"
                      : (function () {
                            if (
                              !(
                                "Worker" in window &&
                                "Blob" in window &&
                                "URL" in window
                              )
                            )
                              return !1;
                            var g,
                              x,
                              w = new Blob([""], { type: "text/javascript" }),
                              S = URL.createObjectURL(w);
                            try {
                              ((x = new Worker(S)), (g = !0));
                            } catch {
                              g = !1;
                            }
                            return (
                              x && x.terminate(),
                              URL.revokeObjectURL(S),
                              g
                            );
                          })()
                        ? (function () {
                            var g = document.createElement("canvas");
                            g.width = g.height = 1;
                            var x = g.getContext("2d");
                            if (!x) return !1;
                            var w = x.getImageData(0, 0, 1, 1);
                            return w && w.width === g.width;
                          })()
                          ? (s[(p = h && h.failIfMajorPerformanceCaveat)] ===
                              void 0 &&
                              (s[p] = (function (g) {
                                var x,
                                  w = (function (S) {
                                    var C = document.createElement("canvas"),
                                      D = Object.create(
                                        c.webGLContextAttributes,
                                      );
                                    return (
                                      (D.failIfMajorPerformanceCaveat = S),
                                      C.getContext("webgl2", D)
                                    );
                                  })(g);
                                if (!w) return !1;
                                try {
                                  x = w.createShader(w.VERTEX_SHADER);
                                } catch {
                                  return !1;
                                }
                                return (
                                  !(!x || w.isContextLost()) &&
                                  (w.shaderSource(x, "void main() {}"),
                                  w.compileShader(x),
                                  w.getShaderParameter(x, w.COMPILE_STATUS) ===
                                    !0)
                                );
                              })(p)),
                            s[p]
                              ? document.documentMode
                                ? "insufficient ECMAScript 6 support"
                                : void 0
                              : "insufficient WebGL2 support")
                          : "insufficient Canvas/getImageData support"
                        : "insufficient worker support";
                    var p;
                  }
                  ((fe = 1), (de.supported = c), (de.notSupportedReason = t));
                  var s = {};
                  return (
                    (c.webGLContextAttributes = {
                      antialias: !1,
                      alpha: !0,
                      stencil: !0,
                      depth: !0,
                    }),
                    de
                  );
                })();
              function xe(c, t, s) {
                const h = document.createElement(c);
                return (
                  t != null && (h.className = t),
                  s && s.appendChild(h),
                  h
                );
              }
              function we(c, t, s) {
                const h = document.createElementNS(
                  "http://www.w3.org/2000/svg",
                  c,
                );
                for (const p of Object.keys(t))
                  h.setAttributeNS(null, p, String(t[p]));
                return (s && s.appendChild(h), h);
              }
              const Ae =
                  typeof document < "u"
                    ? document.documentElement && document.documentElement.style
                    : null,
                Qe =
                  Ae && Ae.userSelect !== void 0
                    ? "userSelect"
                    : "WebkitUserSelect";
              let gt;
              function Rt() {
                Ae && Qe && ((gt = Ae[Qe]), (Ae[Qe] = "none"));
              }
              function Mt() {
                Ae && Qe && (Ae[Qe] = gt);
              }
              function pt(c) {
                (c.preventDefault(),
                  c.stopPropagation(),
                  window.removeEventListener("click", pt, !0));
              }
              function Re() {
                (window.addEventListener("click", pt, !0),
                  window.setTimeout(() => {
                    window.removeEventListener("click", pt, !0);
                  }, 0));
              }
              function rt(c, t) {
                const s = c.getBoundingClientRect();
                return qt(c, s, t);
              }
              function Ot(c, t) {
                const s = c.getBoundingClientRect(),
                  h = [];
                for (let p = 0; p < t.length; p++) h.push(qt(c, s, t[p]));
                return h;
              }
              function _i(c) {
                return /firefox/i.test(navigator.userAgent) &&
                  /macintosh/i.test(navigator.userAgent) &&
                  c.button === 2 &&
                  c.ctrlKey
                  ? 0
                  : c.button;
              }
              function qt(c, t, s) {
                const h =
                  c.offsetWidth === t.width ? 1 : c.offsetWidth / t.width;
                return new r.P(
                  (s.clientX - t.left) * h,
                  (s.clientY - t.top) * h,
                );
              }
              const pi = "01",
                Ri = "NO_ACCESS_TOKEN";
              class wi {
                constructor(t, s, h) {
                  ((this._transformRequestFn = t),
                    (this._customAccessToken = s),
                    (this._silenceAuthErrors = !!h),
                    this._createSkuToken());
                }
                _createSkuToken() {
                  const t = (function () {
                    let s = "";
                    for (let h = 0; h < 10; h++)
                      s +=
                        "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[
                          Math.floor(62 * Math.random())
                        ];
                    return {
                      token: ["1", pi, s].join(""),
                      tokenExpiresAt: Date.now() + 432e5,
                    };
                  })();
                  ((this._skuToken = t.token),
                    (this._skuTokenExpiresAt = t.tokenExpiresAt));
                }
                _isSkuTokenExpired() {
                  return Date.now() > this._skuTokenExpiresAt;
                }
                transformRequest(t, s) {
                  return (
                    (this._transformRequestFn &&
                      this._transformRequestFn(t, s)) || { url: t }
                  );
                }
                normalizeStyleURL(t, s) {
                  if (!r.j(t)) return t;
                  const h = Ii(t);
                  return (
                    h.params.push(`sdk=js-${F}`),
                    (h.path = `/styles/v1${h.path}`),
                    this._makeAPIURL(h, this._customAccessToken || s)
                  );
                }
                normalizeGlyphsURL(t, s) {
                  if (!r.j(t)) return t;
                  const h = Ii(t);
                  return (
                    (h.path = `/fonts/v1${h.path}`),
                    this._makeAPIURL(h, this._customAccessToken || s)
                  );
                }
                normalizeModelURL(t, s) {
                  if (!r.j(t)) return t;
                  const h = Ii(t);
                  return (
                    (h.path = `/models/v1${h.path}`),
                    this._makeAPIURL(h, this._customAccessToken || s)
                  );
                }
                normalizeSourceURL(t, s, h, p) {
                  if (!r.j(t)) return t;
                  const g = Ii(t);
                  return (
                    (g.path = `/v4/${g.authority}.json`),
                    g.params.push("secure"),
                    h && g.params.push(`language=${h}`),
                    p && g.params.push(`worldview=${p}`),
                    this._makeAPIURL(g, this._customAccessToken || s)
                  );
                }
                normalizeIconsetURL(t, s) {
                  const h = Ii(t);
                  return r.j(t)
                    ? ((h.path = `/styles/v1${h.path}/iconset.pbf`),
                      this._makeAPIURL(h, this._customAccessToken || s))
                    : Ln(h);
                }
                normalizeSpriteURL(t, s, h, p) {
                  const g = Ii(t);
                  return r.j(t)
                    ? ((g.path = `/styles/v1${g.path}/sprite${s}${h}`),
                      this._makeAPIURL(g, this._customAccessToken || p))
                    : ((g.path += `${s}${h}`), Ln(g));
                }
                normalizeTileURL(t, s, h) {
                  if (
                    (this._isSkuTokenExpired() && this._createSkuToken(),
                    t && !r.j(t))
                  )
                    return t;
                  const p = Ii(t);
                  ((p.path = p.path.replace(
                    /(\.(png|jpg)\d*)(?=$)/,
                    `${s || (h && p.authority !== "raster" && h === 512) ? "@2x" : ""}${r.l.supported ? ".webp" : "$1"}`,
                  )),
                    p.authority === "raster"
                      ? (p.path = `/${r.e.RASTER_URL_PREFIX}${p.path}`)
                      : p.authority === "rasterarrays"
                        ? (p.path = `/${r.e.RASTERARRAYS_URL_PREFIX}${p.path}`)
                        : p.authority === "3dtiles"
                          ? (p.path = `/${r.e.TILES3D_URL_PREFIX}${p.path}`)
                          : ((p.path = p.path.replace(/^.+\/v4\//, "/")),
                            (p.path = `/${r.e.TILE_URL_VERSION}${p.path}`)));
                  const g =
                    this._customAccessToken ||
                    (function (x) {
                      for (const w of x) {
                        const S = w.match(/^access_token=(.*)$/);
                        if (S) return S[1];
                      }
                      return null;
                    })(p.params) ||
                    r.e.ACCESS_TOKEN;
                  return (
                    r.e.REQUIRE_ACCESS_TOKEN &&
                      g &&
                      this._skuToken &&
                      p.params.push(`sku=${this._skuToken}`),
                    this._makeAPIURL(p, g)
                  );
                }
                canonicalizeTileURL(t, s) {
                  const h = Ii(t);
                  if (
                    !h.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) ||
                    !h.path.match(/\.[\w]+$/)
                  )
                    return t;
                  let p = "mapbox://";
                  h.path.match(/^\/raster\/v1\//)
                    ? (p += `raster/${h.path.replace(`/${r.e.RASTER_URL_PREFIX}/`, "")}`)
                    : h.path.match(/^\/rasterarrays\/v1\//)
                      ? (p += `rasterarrays/${h.path.replace(`/${r.e.RASTERARRAYS_URL_PREFIX}/`, "")}`)
                      : (p += `tiles/${h.path.replace(`/${r.e.TILE_URL_VERSION}/`, "")}`);
                  let g = h.params;
                  return (
                    s && (g = g.filter((x) => !x.match(/^access_token=/))),
                    g.length && (p += `?${g.join("&")}`),
                    p
                  );
                }
                canonicalizeTileset(t, s) {
                  const h = !!s && r.j(s),
                    p = [];
                  for (const g of t.tiles || [])
                    r.k(g) ? p.push(this.canonicalizeTileURL(g, h)) : p.push(g);
                  return p;
                }
                _makeAPIURL(t, s) {
                  const h =
                      "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes",
                    p = Ii(r.e.API_URL);
                  if (
                    ((t.protocol = p.protocol),
                    (t.authority = p.authority),
                    t.protocol === "http")
                  ) {
                    const g = t.params.indexOf("secure");
                    g >= 0 && t.params.splice(g, 1);
                  }
                  if (
                    (p.path !== "/" && (t.path = `${p.path}${t.path}`),
                    !r.e.REQUIRE_ACCESS_TOKEN)
                  )
                    return Ln(t);
                  if (((s = s || r.e.ACCESS_TOKEN), !this._silenceAuthErrors)) {
                    if (!s)
                      throw new Error(
                        `An API access token is required to use Mapbox GL. ${h}`,
                      );
                    if (s[0] === "s")
                      throw new Error(
                        `Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${h}`,
                      );
                  }
                  return (
                    (t.params = t.params.filter(
                      (g) => g.indexOf("access_token") === -1,
                    )),
                    t.params.push(`access_token=${s || ""}`),
                    Ln(t)
                  );
                }
              }
              const ei = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
              function Ii(c) {
                const t = c.match(ei);
                if (!t) throw new Error("Unable to parse URL object");
                return {
                  protocol: t[1],
                  authority: t[2],
                  path: t[3] || "/",
                  params: t[4] ? t[4].split("&") : [],
                };
              }
              function Ln(c) {
                const t = c.params.length ? `?${c.params.join("&")}` : "";
                return `${c.protocol}://${c.authority}${c.path}${t}`;
              }
              const ir = "mapbox.eventData";
              function or(c) {
                if (!c) return null;
                const t = c.split(".");
                if (!t || t.length !== 3) return null;
                try {
                  return JSON.parse(r.m(t[1]));
                } catch {
                  return null;
                }
              }
              class Vi {
                constructor(t) {
                  ((this.type = t),
                    (this.anonId = null),
                    (this.eventData = {}),
                    (this.queue = []),
                    (this.pendingRequest = null));
                }
                getStorageKey(t) {
                  const s = or(r.e.ACCESS_TOKEN);
                  let h = "";
                  return (
                    (h = s && s.u ? r.f(s.u) : r.e.ACCESS_TOKEN || ""),
                    t ? `${ir}.${t}:${h}` : `${ir}:${h}`
                  );
                }
                fetchEventData() {
                  const t = r.s("localStorage"),
                    s = this.getStorageKey(),
                    h = this.getStorageKey("uuid");
                  if (t)
                    try {
                      const p = localStorage.getItem(s);
                      p && (this.eventData = JSON.parse(p));
                      const g = localStorage.getItem(h);
                      g && (this.anonId = g);
                    } catch {
                      r.w("Unable to read from LocalStorage");
                    }
                }
                saveEventData() {
                  const t = r.s("localStorage"),
                    s = this.getStorageKey(),
                    h = this.getStorageKey("uuid"),
                    p = this.anonId;
                  if (t && p)
                    try {
                      (localStorage.setItem(h, p),
                        Object.keys(this.eventData).length >= 1 &&
                          localStorage.setItem(
                            s,
                            JSON.stringify(this.eventData),
                          ));
                    } catch {
                      r.w("Unable to write to LocalStorage");
                    }
                }
                processRequests(t) {}
                postEvent(t, s, h, p) {
                  if (!r.e.EVENTS_URL) return;
                  const g = Ii(r.e.EVENTS_URL);
                  g.params.push(`access_token=${p || r.e.ACCESS_TOKEN || ""}`);
                  const x = {
                      event: this.type,
                      created: new Date(t).toISOString(),
                    },
                    w = s ? r.h(x, s) : x,
                    S = {
                      url: Ln(g),
                      headers: { "Content-Type": "text/plain" },
                      body: JSON.stringify([w]),
                    };
                  this.pendingRequest = r.p(S, (C) => {
                    ((this.pendingRequest = null),
                      h(C),
                      this.saveEventData(),
                      this.processRequests(p));
                  });
                }
                queueRequest(t, s) {
                  (this.queue.push(t), this.processRequests(s));
                }
              }
              const _r = new (class extends Vi {
                  constructor(c) {
                    (super("appUserTurnstile"), (this._customAccessToken = c));
                  }
                  postTurnstileEvent(c, t) {
                    r.e.EVENTS_URL &&
                      r.e.ACCESS_TOKEN &&
                      Array.isArray(c) &&
                      c.some((s) => r.j(s) || r.k(s)) &&
                      this.queueRequest(Date.now(), t);
                  }
                  processRequests(c) {
                    if (this.pendingRequest || this.queue.length === 0) return;
                    (this.anonId &&
                      this.eventData.lastSuccess &&
                      this.eventData.tokenU) ||
                      this.fetchEventData();
                    const t = or(r.e.ACCESS_TOKEN),
                      s = t ? t.u : r.e.ACCESS_TOKEN;
                    let h = s !== this.eventData.tokenU;
                    r.v(this.anonId) || ((this.anonId = r.u()), (h = !0));
                    const p = this.queue.shift();
                    if (this.eventData.lastSuccess) {
                      const g = new Date(this.eventData.lastSuccess),
                        x = new Date(p),
                        w = (p - this.eventData.lastSuccess) / 864e5;
                      h = h || w >= 1 || w < -1 || g.getDate() !== x.getDate();
                    } else h = !0;
                    h
                      ? this.postEvent(
                          p,
                          {
                            sdkIdentifier: "mapbox-gl-js",
                            sdkVersion: F,
                            skuId: pi,
                            "enabled.telemetry": !1,
                            userId: this.anonId,
                          },
                          (g) => {
                            g ||
                              ((this.eventData.lastSuccess = p),
                              (this.eventData.tokenU = s));
                          },
                          c,
                        )
                      : this.processRequests();
                  }
                })(),
                yr = _r.postTurnstileEvent.bind(_r),
                fs = new (class extends Vi {
                  constructor() {
                    (super("map.load"),
                      (this.success = {}),
                      (this.skuToken = ""));
                  }
                  postMapLoadEvent(c, t, s, h) {
                    ((this.skuToken = t),
                      (this.errorCb = h),
                      r.e.EVENTS_URL &&
                        (s || r.e.ACCESS_TOKEN
                          ? this.queueRequest(
                              { id: c, timestamp: Date.now() },
                              s,
                            )
                          : this.errorCb(new Error(Ri))));
                  }
                  processRequests(c) {
                    if (this.pendingRequest || this.queue.length === 0) return;
                    const { id: t, timestamp: s } = this.queue.shift();
                    (t && this.success[t]) ||
                      (this.anonId || this.fetchEventData(),
                      r.v(this.anonId) || (this.anonId = r.u()),
                      this.postEvent(
                        s,
                        {
                          sdkIdentifier: "mapbox-gl-js",
                          sdkVersion: F,
                          skuId: pi,
                          skuToken: this.skuToken,
                          userId: this.anonId,
                        },
                        (h) => {
                          h ? this.errorCb(h) : t && (this.success[t] = !0);
                        },
                        c,
                      ));
                  }
                  remove() {
                    this.errorCb = null;
                  }
                })(),
                qr = fs.postMapLoadEvent.bind(fs),
                tn = new (class extends Vi {
                  constructor() {
                    (super("style.load"),
                      (this.eventIdPerMapInstanceMap = new Map()),
                      (this.mapInstanceIdMap = new WeakMap()));
                  }
                  getMapInstanceId(c) {
                    let t = this.mapInstanceIdMap.get(c);
                    return (
                      t || ((t = r.u()), this.mapInstanceIdMap.set(c, t)),
                      t
                    );
                  }
                  getEventId(c) {
                    const t = this.eventIdPerMapInstanceMap.get(c) || 0;
                    return (this.eventIdPerMapInstanceMap.set(c, t + 1), t);
                  }
                  postStyleLoadEvent(c, t) {
                    const { map: s, style: h, importedStyles: p } = t;
                    if (!r.e.EVENTS_URL || (!c && !r.e.ACCESS_TOKEN)) return;
                    const g = this.getMapInstanceId(s),
                      x = {
                        mapInstanceId: g,
                        eventId: this.getEventId(g),
                        style: h,
                      };
                    (p.length && (x.importedStyles = p),
                      this.queueRequest(
                        { timestamp: Date.now(), payload: x },
                        c,
                      ));
                  }
                  processRequests(c) {
                    if (this.pendingRequest || this.queue.length === 0) return;
                    const { timestamp: t, payload: s } = this.queue.shift();
                    this.postEvent(t, s, () => {}, c);
                  }
                })(),
                wn = tn.postStyleLoadEvent.bind(tn),
                nr = new (class extends Vi {
                  constructor() {
                    super("gljs.performance");
                  }
                  postPerformanceEvent(c, t) {
                    r.e.EVENTS_URL &&
                      (c || r.e.ACCESS_TOKEN) &&
                      this.queueRequest(
                        { timestamp: Date.now(), performanceData: t },
                        c,
                      );
                  }
                  processRequests(c) {
                    if (this.pendingRequest || this.queue.length === 0) return;
                    const { timestamp: t, performanceData: s } =
                        this.queue.shift(),
                      h = (function (p) {
                        const g = performance.getEntriesByType("resource"),
                          x = performance.getEntriesByType("mark"),
                          w = (function (O) {
                            const G = {};
                            if (O) {
                              for (const U in O)
                                if (U !== "other")
                                  for (const $ of O[U]) {
                                    const Z = `${U}ResolveRangeMin`,
                                      Y = `${U}ResolveRangeMax`,
                                      ie = `${U}RequestCount`,
                                      ae = `${U}RequestCachedCount`;
                                    ((G[Z] = Math.min(
                                      G[Z] || 1 / 0,
                                      $.startTime,
                                    )),
                                      (G[Y] = Math.max(
                                        G[Y] || -1 / 0,
                                        $.responseEnd,
                                      )));
                                    const pe = (ue) => {
                                      (G[ue] === void 0 && (G[ue] = 0),
                                        ++G[ue]);
                                    };
                                    ($.transferSize !== void 0 &&
                                      $.transferSize === 0 &&
                                      pe(ae),
                                      pe(ie));
                                  }
                            }
                            return G;
                          })(
                            (function (O, G) {
                              const U = {};
                              if (O)
                                for (const $ of O) {
                                  const Z = G($);
                                  (U[Z] === void 0 && (U[Z] = []),
                                    U[Z].push($));
                                }
                              return U;
                            })(g, ne),
                          ),
                          S = window.devicePixelRatio,
                          C =
                            navigator.connection ||
                            navigator.mozConnection ||
                            navigator.webkitConnection,
                          D = C ? C.effectiveType : void 0,
                          L = { counters: [], metadata: [], attributes: [] },
                          z = (O, G, U) => {
                            U != null &&
                              O.push({ name: G, value: U.toString() });
                          };
                        for (const O in w) z(L.counters, O, w[O]);
                        if (
                          (p.interactionRange[0] !== 1 / 0 &&
                            p.interactionRange[1] !== -1 / 0 &&
                            (z(
                              L.counters,
                              "interactionRangeMin",
                              p.interactionRange[0],
                            ),
                            z(
                              L.counters,
                              "interactionRangeMax",
                              p.interactionRange[1],
                            )),
                          x)
                        )
                          for (const O of Object.keys(B)) {
                            const G = B[O],
                              U = x.find(($) => $.name === G);
                            U && z(L.counters, G, U.startTime);
                          }
                        return (
                          z(L.counters, "visibilityHidden", p.visibilityHidden),
                          z(
                            L.attributes,
                            "style",
                            (function (O) {
                              if (O)
                                for (const G of O) {
                                  const U = G.name.split("?")[0];
                                  if (r.i(U)) {
                                    const $ = U.split("/").slice(-2);
                                    if ($.length === 2)
                                      return `mapbox://styles/${$[0]}/${$[1]}`;
                                  }
                                }
                            })(g),
                          ),
                          z(
                            L.attributes,
                            "terrainEnabled",
                            p.terrainEnabled ? "true" : "false",
                          ),
                          z(
                            L.attributes,
                            "fogEnabled",
                            p.fogEnabled ? "true" : "false",
                          ),
                          z(L.attributes, "projection", p.projection),
                          z(L.attributes, "zoom", p.zoom),
                          z(L.metadata, "devicePixelRatio", S),
                          z(L.metadata, "connectionEffectiveType", D),
                          z(
                            L.metadata,
                            "navigatorUserAgent",
                            navigator.userAgent,
                          ),
                          z(L.metadata, "screenWidth", window.screen.width),
                          z(L.metadata, "screenHeight", window.screen.height),
                          z(L.metadata, "windowWidth", window.innerWidth),
                          z(L.metadata, "windowHeight", window.innerHeight),
                          z(L.metadata, "mapWidth", p.width / S),
                          z(L.metadata, "mapHeight", p.height / S),
                          z(L.metadata, "webglRenderer", p.renderer),
                          z(L.metadata, "webglVendor", p.vendor),
                          z(L.metadata, "sdkVersion", F),
                          z(L.metadata, "sdkIdentifier", "mapbox-gl-js"),
                          L
                        );
                      })(s);
                    for (const p of h.metadata);
                    for (const p of h.counters);
                    for (const p of h.attributes);
                    this.postEvent(t, h, () => {}, c);
                  }
                })(),
                ps = nr.postPerformanceEvent.bind(nr),
                mn = new (class extends Vi {
                  constructor() {
                    (super("map.auth"),
                      (this.success = {}),
                      (this.skuToken = ""));
                  }
                  getSession(c, t, s, h) {
                    if (!r.e.API_URL || !r.e.SESSION_PATH) return;
                    const p = Ii(r.e.API_URL + r.e.SESSION_PATH);
                    (p.params.push(`sku=${t || ""}`),
                      p.params.push(
                        `access_token=${h || r.e.ACCESS_TOKEN || ""}`,
                      ));
                    const g = {
                      url: Ln(p),
                      headers: { "Content-Type": "text/plain" },
                    };
                    this.pendingRequest = r.g(g, (x) => {
                      ((this.pendingRequest = null),
                        s(x),
                        this.saveEventData(),
                        this.processRequests(h));
                    });
                  }
                  getSessionAPI(c, t, s, h) {
                    ((this.skuToken = t),
                      (this.errorCb = h),
                      r.e.SESSION_PATH &&
                        r.e.API_URL &&
                        (s || r.e.ACCESS_TOKEN
                          ? this.queueRequest(
                              { id: c, timestamp: Date.now() },
                              s,
                            )
                          : this.errorCb(new Error(Ri))));
                  }
                  processRequests(c) {
                    if (this.pendingRequest || this.queue.length === 0) return;
                    const { id: t, timestamp: s } = this.queue.shift();
                    (t && this.success[t]) ||
                      this.getSession(
                        s,
                        this.skuToken,
                        (h) => {
                          h ? this.errorCb(h) : t && (this.success[t] = !0);
                        },
                        c,
                      );
                  }
                  remove() {
                    this.errorCb = null;
                  }
                })(),
                Za = mn.getSessionAPI.bind(mn),
                Qs = new Set();
              function Is(c, t) {
                t ? Qs.add(c) : Qs.delete(c);
              }
              class Gn {
                constructor() {
                  ((this._changed = !1),
                    (this._updatedLayers = {}),
                    (this._removedLayers = {}),
                    (this._updatedSourceCaches = {}),
                    (this._updatedPaintProps = new Set()),
                    (this._updatedImages = {}));
                }
                isDirty() {
                  return this._changed;
                }
                setDirty() {
                  this._changed = !0;
                }
                getUpdatedSourceCaches() {
                  return this._updatedSourceCaches;
                }
                updateSourceCache(t, s) {
                  ((this._updatedSourceCaches[t] = s), this.setDirty());
                }
                discardSourceCacheUpdate(t) {
                  delete this._updatedSourceCaches[t];
                }
                updateLayer(t) {
                  const s = t.scope;
                  ((this._updatedLayers[s] =
                    this._updatedLayers[s] || new Set()),
                    this._updatedLayers[s].add(t.id),
                    this.setDirty());
                }
                removeLayer(t) {
                  const s = t.scope;
                  ((this._removedLayers[s] = this._removedLayers[s] || {}),
                    (this._updatedLayers[s] =
                      this._updatedLayers[s] || new Set()),
                    (this._removedLayers[s][t.id] = t),
                    this._updatedLayers[s].delete(t.id),
                    this._updatedPaintProps.delete(t.fqid),
                    this.setDirty());
                }
                getRemovedLayer(t) {
                  return this._removedLayers[t.scope]
                    ? this._removedLayers[t.scope][t.id]
                    : null;
                }
                discardLayerRemoval(t) {
                  this._removedLayers[t.scope] &&
                    delete this._removedLayers[t.scope][t.id];
                }
                getLayerUpdatesByScope() {
                  const t = {};
                  for (const s in this._updatedLayers)
                    ((t[s] = t[s] || {}),
                      (t[s].updatedIds = Array.from(
                        this._updatedLayers[s].values(),
                      )));
                  for (const s in this._removedLayers)
                    ((t[s] = t[s] || {}),
                      (t[s].removedIds = Object.keys(this._removedLayers[s])));
                  return t;
                }
                getUpdatedPaintProperties() {
                  return this._updatedPaintProps;
                }
                updatePaintProperties(t) {
                  (this._updatedPaintProps.add(t.fqid), this.setDirty());
                }
                getUpdatedImages(t) {
                  return this._updatedImages[t]
                    ? Array.from(this._updatedImages[t].values())
                    : [];
                }
                updateImage(t, s) {
                  ((this._updatedImages[s] =
                    this._updatedImages[s] || new Set()),
                    this._updatedImages[s].add(r.I.toString(t)),
                    this.setDirty());
                }
                resetUpdatedImages(t) {
                  this._updatedImages[t] && this._updatedImages[t].clear();
                }
                reset() {
                  ((this._changed = !1),
                    (this._updatedLayers = {}),
                    (this._removedLayers = {}),
                    (this._updatedSourceCaches = {}),
                    this._updatedPaintProps.clear(),
                    (this._updatedImages = {}));
                }
              }
              function Xa(c) {
                const { userImage: t } = c;
                return (
                  !!(t && t.render && t.render()) &&
                  (c.data.replace(new Uint8Array(t.data.buffer)), !0)
                );
              }
              class To extends r.E {
                constructor(t) {
                  (super(),
                    (this.imageProviders = new Map()),
                    (this.images = new Map()),
                    (this.updatedImages = new Map()),
                    (this.callbackDispatchedThisFrame = new Map()),
                    (this.loaded = new Map()),
                    (this.requestors = []),
                    (this.patterns = new Map()),
                    (this.patternsInFlight = new Set()),
                    (this.atlasImage = new Map()),
                    (this.atlasTexture = new Map()),
                    (this.dirty = !0),
                    (this.spriteFormat = t),
                    t !== "raster" &&
                      r.t() &&
                      (this.imageRasterizerDispatcher = new r.D(
                        r.x(),
                        this,
                        "Image Rasterizer Worker",
                        1,
                      )));
                }
                addScope(t) {
                  (this.loaded.set(t, !1),
                    this.imageProviders.set(t, new Map()),
                    this.images.set(t, new Map()),
                    this.updatedImages.set(t, new Set()),
                    this.callbackDispatchedThisFrame.set(t, new Set()),
                    this.patterns.set(t, new Map()),
                    this.atlasImage.set(t, new r.r({ width: 1, height: 1 })));
                }
                removeScope(t) {
                  (this.loaded.delete(t),
                    this.imageProviders.delete(t),
                    this.images.delete(t),
                    this.updatedImages.delete(t),
                    this.callbackDispatchedThisFrame.delete(t),
                    this.patterns.delete(t),
                    this.atlasImage.delete(t));
                  const s = this.atlasTexture.get(t);
                  s && (s.destroy(), this.atlasTexture.delete(t));
                }
                addImageProvider(t, s) {
                  (this.imageProviders.has(s) ||
                    this.imageProviders.set(s, new Map()),
                    this.imageProviders.get(s).set(t.id, t));
                }
                removeImageProvider(t, s) {
                  this.imageProviders.has(s) &&
                    this.imageProviders.get(s).delete(t);
                }
                getPendingImageProviders() {
                  const t = [];
                  for (const s of this.imageProviders.values())
                    for (const h of s.values())
                      h.hasPendingRequests() && t.push(h);
                  return t;
                }
                get imageRasterizer() {
                  return (
                    this._imageRasterizer ||
                      (this._imageRasterizer = new r.y()),
                    this._imageRasterizer
                  );
                }
                isLoaded() {
                  for (const t of this.loaded.keys())
                    if (!this.loaded.get(t)) return !1;
                  return !0;
                }
                setLoaded(t, s) {
                  if (this.loaded.get(s) !== t && (this.loaded.set(s, t), t)) {
                    for (const { ids: h, callback: p } of this.requestors)
                      this._notify(h, s, p);
                    this.requestors = [];
                  }
                }
                hasImage(t, s) {
                  return !!this.getImage(t, s);
                }
                getImage(t, s) {
                  return this.images.get(s).get(t.toString());
                }
                addImage(t, s, h) {
                  this._validate(t, h) &&
                    this.images.get(s).set(t.toString(), h);
                }
                _validate(t, s) {
                  let h = !0;
                  return (
                    this._validateStretch(s.stretchX, s.data && s.data.width) ||
                      (this.fire(
                        new r.z(
                          new Error(
                            `Image "${t.name}" has invalid "stretchX" value`,
                          ),
                        ),
                      ),
                      (h = !1)),
                    this._validateStretch(
                      s.stretchY,
                      s.data && s.data.height,
                    ) ||
                      (this.fire(
                        new r.z(
                          new Error(
                            `Image "${t.name}" has invalid "stretchY" value`,
                          ),
                        ),
                      ),
                      (h = !1)),
                    this._validateContent(s.content, s) ||
                      (this.fire(
                        new r.z(
                          new Error(
                            `Image "${t.name}" has invalid "content" value`,
                          ),
                        ),
                      ),
                      (h = !1)),
                    h
                  );
                }
                _validateStretch(t, s) {
                  if (!t) return !0;
                  let h = 0;
                  for (const p of t) {
                    if (p[0] < h || p[1] < p[0] || s < p[1]) return !1;
                    h = p[1];
                  }
                  return !0;
                }
                _validateContent(t, s) {
                  return t
                    ? t.length !== 4 ||
                      (!s.usvg &&
                        (t[0] < 0 ||
                          s.data.width < t[0] ||
                          t[1] < 0 ||
                          s.data.height < t[1] ||
                          t[2] < 0 ||
                          s.data.width < t[2] ||
                          t[3] < 0 ||
                          s.data.height < t[3]))
                      ? !1
                      : !(t[2] < t[0] || t[3] < t[1])
                    : !0;
                }
                updateImage(t, s, h) {
                  const p = this.images.get(s).get(t.toString());
                  ((h.version = p.version + 1),
                    this.images.get(s).set(t.toString(), h),
                    this.updatedImages.get(s).add(t),
                    this.removeFromImageRasterizerCache(t, s));
                }
                clearUpdatedImages(t) {
                  this.updatedImages.get(t).clear();
                }
                removeFromImageRasterizerCache(t, s) {
                  this.spriteFormat !== "raster" &&
                    (r.t()
                      ? this.imageRasterizerDispatcher
                          .getActor()
                          .send("removeRasterizedImages", {
                            imageIds: [t],
                            scope: s,
                          })
                      : this.imageRasterizer.removeImagesFromCacheByIds(
                          [t],
                          s,
                        ));
                }
                removeImage(t, s) {
                  const h = this.images.get(s),
                    p = h.get(t.toString());
                  (h.delete(t.toString()),
                    this.patterns.get(s).delete(t.toString()),
                    this.removeFromImageRasterizerCache(t, s),
                    p.userImage &&
                      p.userImage.onRemove &&
                      p.userImage.onRemove());
                }
                listImages(t) {
                  return Array.from(this.images.get(t).keys()).map((s) =>
                    r.I.from(s),
                  );
                }
                getImages(t, s, h) {
                  const p = [],
                    g = [],
                    x = this.imageProviders.get(s);
                  for (const D of t) {
                    if (!D.iconsetId) {
                      p.push(D);
                      continue;
                    }
                    const L = x.get(D.iconsetId);
                    L &&
                      (this.getImage(D, s)
                        ? g.push(D)
                        : L.addPendingRequest(D));
                  }
                  if (p.length === 0) return void this._notify(g, s, h);
                  let w = !0;
                  const S = !!this.loaded.get(s),
                    C = this.images.get(s);
                  if (!S) for (const D of p) C.has(D.toString()) || (w = !1);
                  S || w
                    ? this._notify(p, s, h)
                    : this.requestors.push({ ids: p, scope: s, callback: h });
                }
                rasterizeImages(t, s) {
                  const h = new Map(),
                    { tasks: p, scope: g } = t;
                  for (const [x, w] of p.entries()) {
                    const S = this.getImage(w.id, g);
                    S && h.set(x, { image: S, imageVariant: w });
                  }
                  this._rasterizeImages(g, h, s);
                }
                _rasterizeImages(t, s, h) {
                  if (r.t())
                    this.imageRasterizerDispatcher
                      .getActor()
                      .send("rasterizeImagesWorker", { tasks: s, scope: t }, h);
                  else {
                    const p = new Map();
                    for (const [
                      g,
                      { image: x, imageVariant: w },
                    ] of s.entries())
                      p.set(g, this.imageRasterizer.rasterize(w, x, t, 0));
                    h(void 0, p);
                  }
                }
                getUpdatedImages(t) {
                  return this.updatedImages.get(t) || new Set();
                }
                _notify(t, s, h) {
                  const p = this.images.get(s),
                    g = new Map();
                  for (const x of t) {
                    if (!p.get(x.toString())) {
                      if (x.iconsetId) continue;
                      this.fire(new r.A("styleimagemissing", { id: x.name }));
                    }
                    const w = p.get(x.toString());
                    if (!w) {
                      r.w(
                        `Image "${x.name}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`,
                      );
                      continue;
                    }
                    const S = {
                      data: w.usvg ? null : w.data.clone(),
                      pixelRatio: w.pixelRatio,
                      sdf: w.sdf,
                      usvg: w.usvg,
                      version: w.version,
                      stretchX: w.stretchX,
                      stretchY: w.stretchY,
                      content: w.content,
                      hasRenderCallback: !!(w.userImage && w.userImage.render),
                    };
                    (w.usvg &&
                      Object.assign(S, {
                        width: w.icon.usvg_tree.width,
                        height: w.icon.usvg_tree.height,
                      }),
                      g.set(r.I.toString(x), S));
                  }
                  h(null, g);
                }
                getPixelSize(t) {
                  const { width: s, height: h } = this.atlasImage.get(t);
                  return { width: s, height: h };
                }
                getPattern(t, s, h) {
                  const p = t.toString(),
                    g = this.patterns.get(s),
                    x = g.get(p),
                    w = this.getImage(t, s);
                  if (!w) return null;
                  if (x) {
                    if (x.position.version === w.version) return x.position;
                    x.position.version = w.version;
                  } else {
                    if (w.usvg && !w.data) {
                      const S = this.getPatternInFlightId(p, s);
                      if (this.patternsInFlight.has(S)) return null;
                      this.patternsInFlight.add(S);
                      const C = new r.B(t).scaleSelf(r.q.devicePixelRatio),
                        D = new Map([
                          [C.toString(), { image: w, imageVariant: C }],
                        ]);
                      return (
                        this._rasterizeImages(s, D, (L, z) =>
                          this.storePatternImage(C, s, w, h, z),
                        ),
                        null
                      );
                    }
                    this.storePattern(t, s, w);
                  }
                  return (this._updatePatternAtlas(s, h), g.get(p).position);
                }
                getPatternInFlightId(t, s) {
                  return r.C(t, s);
                }
                hasPatternsInFlight() {
                  return this.patternsInFlight.size !== 0;
                }
                storePatternImage(t, s, h, p, g) {
                  const x = t.toString(),
                    w = g ? g.get(x) : void 0;
                  w &&
                    ((h.data = w),
                    this.storePattern(t.id, s, h),
                    this._updatePatternAtlas(s, p),
                    this.patternsInFlight.delete(
                      this.getPatternInFlightId(t.id.toString(), s),
                    ));
                }
                storePattern(t, s, h) {
                  const p = {
                      w: h.data.width + 2 * r.F,
                      h: h.data.height + 2 * r.F,
                      x: 0,
                      y: 0,
                    },
                    g = new r.G(p, h, r.F);
                  this.patterns
                    .get(s)
                    .set(t.toString(), { bin: p, position: g });
                }
                bind(t, s) {
                  const h = t.gl;
                  let p = this.atlasTexture.get(s);
                  (p
                    ? this.dirty &&
                      (p.update(this.atlasImage.get(s)), (this.dirty = !1))
                    : ((p = new r.T(t, this.atlasImage.get(s), h.RGBA8)),
                      this.atlasTexture.set(s, p)),
                    p.bind(h.LINEAR, h.CLAMP_TO_EDGE));
                }
                _updatePatternAtlas(t, s) {
                  const h = this.patterns.get(t),
                    p = Array.from(h.values()).map(({ bin: C }) => C),
                    { w: g, h: x } = r.H(p),
                    w = this.atlasImage.get(t);
                  w.resize({ width: g || 1, height: x || 1 });
                  const S = this.images.get(t);
                  for (const [C, { bin: D, position: L }] of h.entries()) {
                    let z = L.padding;
                    const O = D.x + z,
                      G = D.y + z,
                      U = S.get(C).data,
                      $ = U.width,
                      Z = U.height;
                    ((z = z > 1 ? z - 1 : z),
                      r.r.copy(
                        U,
                        w,
                        { x: 0, y: 0 },
                        { x: O, y: G },
                        { width: $, height: Z },
                        s,
                      ),
                      r.r.copy(
                        U,
                        w,
                        { x: 0, y: Z - z },
                        { x: O, y: G - z },
                        { width: $, height: z },
                        s,
                      ),
                      r.r.copy(
                        U,
                        w,
                        { x: 0, y: 0 },
                        { x: O, y: G + Z },
                        { width: $, height: z },
                        s,
                      ),
                      r.r.copy(
                        U,
                        w,
                        { x: $ - z, y: 0 },
                        { x: O - z, y: G },
                        { width: z, height: Z },
                        s,
                      ),
                      r.r.copy(
                        U,
                        w,
                        { x: 0, y: 0 },
                        { x: O + $, y: G },
                        { width: z, height: Z },
                        s,
                      ),
                      r.r.copy(
                        U,
                        w,
                        { x: $ - z, y: Z - z },
                        { x: O - z, y: G - z },
                        { width: z, height: z },
                        s,
                      ),
                      r.r.copy(
                        U,
                        w,
                        { x: 0, y: Z - z },
                        { x: O + $, y: G - z },
                        { width: z, height: z },
                        s,
                      ),
                      r.r.copy(
                        U,
                        w,
                        { x: 0, y: 0 },
                        { x: O + $, y: G + Z },
                        { width: z, height: z },
                        s,
                      ),
                      r.r.copy(
                        U,
                        w,
                        { x: $ - z, y: 0 },
                        { x: O - z, y: G + Z },
                        { width: z, height: z },
                        s,
                      ));
                  }
                  this.dirty = !0;
                }
                beginFrame() {
                  for (const t of this.images.keys())
                    this.callbackDispatchedThisFrame.set(t, new Set());
                }
                dispatchRenderCallbacks(t, s) {
                  const h = this.images.get(s);
                  for (const p of t) {
                    if (
                      this.callbackDispatchedThisFrame.get(s).has(p.toString())
                    )
                      continue;
                    this.callbackDispatchedThisFrame.get(s).add(p.toString());
                    const g = h.get(p.toString());
                    Xa(g) && this.updateImage(p, s, g);
                  }
                }
              }
              function Mr(c) {
                const t = c.key,
                  s = c.value,
                  h = c.valueSpec || {},
                  p = c.objectElementValidators || {},
                  g = c.style,
                  x = c.styleSpec;
                let w = [];
                const S = r.J(s);
                if (S !== "object")
                  return [new r.V(t, s, `object expected, ${S} found`)];
                for (const C in s) {
                  const D = C.split(".")[0];
                  let L;
                  (p[D]
                    ? (L = p[D])
                    : h[D]
                      ? (L = bn)
                      : p["*"]
                        ? (L = p["*"])
                        : h["*"] && (L = bn),
                    L
                      ? (w = w.concat(
                          L(
                            {
                              key: (t && `${t}.`) + C,
                              value: s[C],
                              valueSpec: h[D] || h["*"],
                              style: g,
                              styleSpec: x,
                              object: s,
                              objectKey: C,
                            },
                            s,
                          ),
                        ))
                      : w.push(new r.K(t, s[C], `unknown property "${C}"`)));
                }
                for (const C in h)
                  p[C] ||
                    (h[C].required &&
                      h[C].default === void 0 &&
                      s[C] === void 0 &&
                      w.push(
                        new r.V(t, s, `missing required property "${C}"`),
                      ));
                return w;
              }
              function la(c) {
                const t = c.value,
                  s = c.valueSpec,
                  h = c.style,
                  p = c.styleSpec,
                  g = c.key,
                  x = c.arrayElementValidator || bn;
                if (r.J(t) !== "array")
                  return [new r.V(g, t, `array expected, ${r.J(t)} found`)];
                if (s.length && t.length !== s.length)
                  return [
                    new r.V(
                      g,
                      t,
                      `array length ${s.length} expected, length ${t.length} found`,
                    ),
                  ];
                if (s["min-length"] && t.length < s["min-length"])
                  return [
                    new r.V(
                      g,
                      t,
                      `array length at least ${s["min-length"]} expected, length ${t.length} found`,
                    ),
                  ];
                let w = {
                  type: s.value,
                  values: s.values,
                  minimum: s.minimum,
                  maximum: s.maximum,
                  function: void 0,
                };
                (p.$version < 7 && (w.function = s.function),
                  r.J(s.value) === "object" && (w = s.value));
                let S = [];
                for (let C = 0; C < t.length; C++)
                  S = S.concat(
                    x(
                      {
                        array: t,
                        arrayIndex: C,
                        value: t[C],
                        valueSpec: w,
                        style: h,
                        styleSpec: p,
                        key: `${g}[${C}]`,
                      },
                      !0,
                    ),
                  );
                return S;
              }
              function ic(c) {
                const t = c.key,
                  s = c.value,
                  h = c.valueSpec;
                let p = r.J(s);
                if ((p === "number" && s != s && (p = "NaN"), p !== "number"))
                  return [new r.V(t, s, `number expected, ${p} found`)];
                if ("minimum" in h) {
                  let g = h.minimum;
                  if (
                    (r.J(h.minimum) === "array" &&
                      (g = h.minimum[c.arrayIndex]),
                    s < g)
                  )
                    return [
                      new r.V(t, s, `${s} is less than the minimum value ${g}`),
                    ];
                }
                if ("maximum" in h) {
                  let g = h.maximum;
                  if (
                    (r.J(h.maximum) === "array" &&
                      (g = h.maximum[c.arrayIndex]),
                    s > g)
                  )
                    return [
                      new r.V(
                        t,
                        s,
                        `${s} is greater than the maximum value ${g}`,
                      ),
                    ];
                }
                return [];
              }
              function Cr(c) {
                const t = c.valueSpec,
                  s = r.M(c.value.type);
                let h,
                  p,
                  g,
                  x = {};
                const w = s !== "categorical" && c.value.property === void 0,
                  S = !w,
                  C =
                    r.J(c.value.stops) === "array" &&
                    r.J(c.value.stops[0]) === "array" &&
                    r.J(c.value.stops[0][0]) === "object",
                  D = Mr({
                    key: c.key,
                    value: c.value,
                    valueSpec: c.styleSpec.function,
                    style: c.style,
                    styleSpec: c.styleSpec,
                    objectElementValidators: {
                      stops: function (O) {
                        if (s === "identity")
                          return [
                            new r.V(
                              O.key,
                              O.value,
                              'identity function may not have a "stops" property',
                            ),
                          ];
                        let G = [];
                        const U = O.value;
                        return (
                          (G = G.concat(
                            la({
                              key: O.key,
                              value: U,
                              valueSpec: O.valueSpec,
                              style: O.style,
                              styleSpec: O.styleSpec,
                              arrayElementValidator: L,
                            }),
                          )),
                          r.J(U) === "array" &&
                            U.length === 0 &&
                            G.push(
                              new r.V(
                                O.key,
                                U,
                                "array must have at least one stop",
                              ),
                            ),
                          G
                        );
                      },
                      default: function (O) {
                        return bn({
                          key: O.key,
                          value: O.value,
                          valueSpec: t,
                          style: O.style,
                          styleSpec: O.styleSpec,
                        });
                      },
                    },
                  });
                return (
                  s === "identity" &&
                    w &&
                    D.push(
                      new r.V(
                        c.key,
                        c.value,
                        'missing required property "property"',
                      ),
                    ),
                  s === "identity" ||
                    c.value.stops ||
                    D.push(
                      new r.V(
                        c.key,
                        c.value,
                        'missing required property "stops"',
                      ),
                    ),
                  s === "exponential" &&
                    c.valueSpec.expression &&
                    !r.N(c.valueSpec) &&
                    D.push(
                      new r.V(
                        c.key,
                        c.value,
                        "exponential functions not supported",
                      ),
                    ),
                  c.styleSpec.$version >= 8 &&
                    (S && !r.O(c.valueSpec)
                      ? D.push(
                          new r.V(
                            c.key,
                            c.value,
                            "property functions not supported",
                          ),
                        )
                      : w &&
                        !r.Q(c.valueSpec) &&
                        D.push(
                          new r.V(
                            c.key,
                            c.value,
                            "zoom functions not supported",
                          ),
                        )),
                  (s !== "categorical" && !C) ||
                    c.value.property !== void 0 ||
                    D.push(
                      new r.V(
                        c.key,
                        c.value,
                        '"property" property is required',
                      ),
                    ),
                  D
                );
                function L(O) {
                  let G = [];
                  const U = O.value,
                    $ = O.key;
                  if (r.J(U) !== "array")
                    return [new r.V($, U, `array expected, ${r.J(U)} found`)];
                  if (U.length !== 2)
                    return [
                      new r.V(
                        $,
                        U,
                        `array length 2 expected, length ${U.length} found`,
                      ),
                    ];
                  if (C) {
                    if (r.J(U[0]) !== "object")
                      return [
                        new r.V($, U, `object expected, ${r.J(U[0])} found`),
                      ];
                    if (U[0].zoom === void 0)
                      return [new r.V($, U, "object stop key must have zoom")];
                    if (U[0].value === void 0)
                      return [new r.V($, U, "object stop key must have value")];
                    const Z = r.M(U[0].zoom);
                    if (typeof Z != "number")
                      return [
                        new r.V(
                          $,
                          U[0].zoom,
                          "stop zoom values must be numbers",
                        ),
                      ];
                    if (g && g > Z)
                      return [
                        new r.V(
                          $,
                          U[0].zoom,
                          "stop zoom values must appear in ascending order",
                        ),
                      ];
                    (Z !== g && ((g = Z), (p = void 0), (x = {})),
                      (G = G.concat(
                        Mr({
                          key: `${$}[0]`,
                          value: U[0],
                          valueSpec: { zoom: {} },
                          style: O.style,
                          styleSpec: O.styleSpec,
                          objectElementValidators: { zoom: ic, value: z },
                        }),
                      )));
                  } else
                    G = G.concat(
                      z(
                        {
                          key: `${$}[0]`,
                          value: U[0],
                          style: O.style,
                          styleSpec: O.styleSpec,
                        },
                        U,
                      ),
                    );
                  return r.S(r.U(U[1]))
                    ? G.concat([
                        new r.V(
                          `${$}[1]`,
                          U[1],
                          "expressions are not allowed in function stops.",
                        ),
                      ])
                    : G.concat(
                        bn({
                          key: `${$}[1]`,
                          value: U[1],
                          valueSpec: t,
                          style: O.style,
                          styleSpec: O.styleSpec,
                        }),
                      );
                }
                function z(O, G) {
                  const U = r.J(O.value),
                    $ = r.M(O.value),
                    Z = O.value !== null ? O.value : G;
                  if (h) {
                    if (U !== h)
                      return [
                        new r.V(
                          O.key,
                          Z,
                          `${U} stop domain type must match previous stop domain type ${h}`,
                        ),
                      ];
                  } else h = U;
                  if (
                    U !== "number" &&
                    U !== "string" &&
                    U !== "boolean" &&
                    typeof $ != "number" &&
                    typeof $ != "string" &&
                    typeof $ != "boolean"
                  )
                    return [
                      new r.V(
                        O.key,
                        Z,
                        "stop domain value must be a number, string, or boolean",
                      ),
                    ];
                  if (U !== "number" && s !== "categorical") {
                    let Y = `number expected, ${U} found`;
                    return (
                      r.O(t) &&
                        s === void 0 &&
                        (Y +=
                          '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
                      [new r.V(O.key, Z, Y)]
                    );
                  }
                  return s !== "categorical" ||
                    U !== "number" ||
                    (typeof $ == "number" && isFinite($) && Math.floor($) === $)
                    ? s !== "categorical" &&
                      U === "number" &&
                      typeof $ == "number" &&
                      typeof p == "number" &&
                      p !== void 0 &&
                      $ < p
                      ? [
                          new r.V(
                            O.key,
                            Z,
                            "stop domain values must appear in ascending order",
                          ),
                        ]
                      : ((p = $),
                        s === "categorical" && $ in x
                          ? [
                              new r.V(
                                O.key,
                                Z,
                                "stop domain values must be unique",
                              ),
                            ]
                          : ((x[$] = !0), []))
                    : [
                        new r.V(
                          O.key,
                          Z,
                          `integer expected, found ${String($)}`,
                        ),
                      ];
                }
              }
              function Zr(c) {
                const t = (c.expressionContext === "property" ? r.W : r.X)(
                  r.U(c.value),
                  c.valueSpec,
                );
                if (t.result === "error")
                  return t.value.map(
                    (h) => new r.V(`${c.key}${h.key}`, c.value, h.message),
                  );
                const s =
                  t.value.expression || t.value._styleExpression.expression;
                if (
                  c.expressionContext === "property" &&
                  c.propertyKey === "text-font" &&
                  !s.outputDefined()
                )
                  return [
                    new r.V(
                      c.key,
                      c.value,
                      `Invalid data expression for "${c.propertyKey}". Output values must be contained as literals within the expression.`,
                    ),
                  ];
                if (
                  c.expressionContext === "property" &&
                  c.propertyType === "layout" &&
                  !r.Y(s)
                )
                  return [
                    new r.V(
                      c.key,
                      c.value,
                      '"feature-state" data expressions are not supported with layout properties.',
                    ),
                  ];
                if (c.expressionContext === "filter") return So(s, c);
                if (
                  c.expressionContext &&
                  c.expressionContext.indexOf("cluster") === 0
                ) {
                  if (!r.Z(s, ["zoom", "feature-state"]))
                    return [
                      new r.V(
                        c.key,
                        c.value,
                        '"zoom" and "feature-state" expressions are not supported with cluster properties.',
                      ),
                    ];
                  if (c.expressionContext === "cluster-initial" && !r._(s))
                    return [
                      new r.V(
                        c.key,
                        c.value,
                        "Feature data expressions are not supported with initial expression part of cluster properties.",
                      ),
                    ];
                }
                return [];
              }
              function So(c, t) {
                const s = new Set([
                  "zoom",
                  "feature-state",
                  "pitch",
                  "distance-from-center",
                ]);
                if (t.valueSpec && t.valueSpec.expression)
                  for (const p of t.valueSpec.expression.parameters)
                    s.delete(p);
                if (s.size === 0) return [];
                const h = [];
                return c instanceof r.$ && s.has(c.name)
                  ? [
                      new r.V(
                        t.key,
                        t.value,
                        `["${c.name}"] expression is not supported in a filter for a ${t.object.type} layer with id: ${t.object.id}`,
                      ),
                    ]
                  : (c.eachChild((p) => {
                      h.push(...So(p, t));
                    }),
                    h);
              }
              function Eo(c) {
                const t = c.key,
                  s = c.value,
                  h = c.valueSpec,
                  p = [];
                return (
                  Array.isArray(h.values)
                    ? h.values.indexOf(r.M(s)) === -1 &&
                      p.push(
                        new r.V(
                          t,
                          s,
                          `expected one of [${h.values.join(", ")}], ${JSON.stringify(s)} found`,
                        ),
                      )
                    : Object.keys(h.values).indexOf(r.M(s)) === -1 &&
                      p.push(
                        new r.V(
                          t,
                          s,
                          `expected one of [${Object.keys(h.values).join(", ")}], ${JSON.stringify(s)} found`,
                        ),
                      ),
                  p
                );
              }
              function Io(c) {
                return r.a1(r.U(c.value))
                  ? Zr(
                      r.L({}, c, {
                        expressionContext: "filter",
                        valueSpec:
                          c.styleSpec[`filter_${c.layerType || "fill"}`],
                      }),
                    )
                  : Pr(c);
              }
              function Pr(c) {
                const t = c.value,
                  s = c.key;
                if (r.J(t) !== "array")
                  return [new r.V(s, t, `array expected, ${r.J(t)} found`)];
                const h = c.styleSpec;
                let p,
                  g = [];
                if (t.length < 1)
                  return [
                    new r.V(s, t, "filter array must have at least 1 element"),
                  ];
                switch (
                  ((g = g.concat(
                    Eo({
                      key: `${s}[0]`,
                      value: t[0],
                      valueSpec: h.filter_operator,
                      style: c.style,
                      styleSpec: c.styleSpec,
                    }),
                  )),
                  r.M(t[0]))
                ) {
                  case "<":
                  case "<=":
                  case ">":
                  case ">=":
                    t.length >= 2 &&
                      r.M(t[1]) === "$type" &&
                      g.push(
                        new r.V(
                          s,
                          t,
                          `"$type" cannot be use with operator "${t[0]}"`,
                        ),
                      );
                  case "==":
                  case "!=":
                    t.length !== 3 &&
                      g.push(
                        new r.V(
                          s,
                          t,
                          `filter array for operator "${t[0]}" must have 3 elements`,
                        ),
                      );
                  case "in":
                  case "!in":
                    t.length >= 2 &&
                      ((p = r.J(t[1])),
                      p !== "string" &&
                        g.push(
                          new r.V(
                            `${s}[1]`,
                            t[1],
                            `string expected, ${p} found`,
                          ),
                        ));
                    for (let x = 2; x < t.length; x++)
                      ((p = r.J(t[x])),
                        r.M(t[1]) === "$type"
                          ? (g = g.concat(
                              Eo({
                                key: `${s}[${x}]`,
                                value: t[x],
                                valueSpec: h.geometry_type,
                                style: c.style,
                                styleSpec: c.styleSpec,
                              }),
                            ))
                          : p !== "string" &&
                            p !== "number" &&
                            p !== "boolean" &&
                            g.push(
                              new r.V(
                                `${s}[${x}]`,
                                t[x],
                                `string, number, or boolean expected, ${p} found`,
                              ),
                            ));
                    break;
                  case "any":
                  case "all":
                  case "none":
                    for (let x = 1; x < t.length; x++)
                      g = g.concat(
                        Pr({
                          key: `${s}[${x}]`,
                          value: t[x],
                          style: c.style,
                          styleSpec: c.styleSpec,
                        }),
                      );
                    break;
                  case "has":
                  case "!has":
                    ((p = r.J(t[1])),
                      t.length !== 2
                        ? g.push(
                            new r.V(
                              s,
                              t,
                              `filter array for "${t[0]}" operator must have 2 elements`,
                            ),
                          )
                        : p !== "string" &&
                          g.push(
                            new r.V(
                              `${s}[1]`,
                              t[1],
                              `string expected, ${p} found`,
                            ),
                          ));
                }
                return g;
              }
              function Ya(c, t) {
                const s = c.key,
                  h = c.style,
                  p = c.layer,
                  g = c.styleSpec,
                  x = c.value,
                  w = c.objectKey,
                  S = g[`${t}_${c.layerType}`];
                if (!S) return [];
                const C = w.match(/^(.*)-use-theme$/);
                if (t === "paint" && C && S[C[1]])
                  return r.S(x)
                    ? [].concat(
                        bn({
                          key: c.key,
                          value: x,
                          valueSpec: {
                            type: "string",
                            expression: {
                              interpolated: !1,
                              parameters: ["zoom", "feature"],
                            },
                            "property-type": "data-driven",
                          },
                          style: h,
                          styleSpec: g,
                          expressionContext: "property",
                          propertyType: t,
                          propertyKey: w,
                        }),
                      )
                    : bn({
                        key: s,
                        value: x,
                        valueSpec: { type: "string" },
                        style: h,
                        styleSpec: g,
                      });
                const D = w.match(/^(.*)-transition$/);
                if (t === "paint" && D && S[D[1]] && S[D[1]].transition)
                  return bn({
                    key: s,
                    value: x,
                    valueSpec: g.transition,
                    style: h,
                    styleSpec: g,
                  });
                const L = c.valueSpec || S[w];
                if (!L) return [new r.K(s, x, `unknown property "${w}"`)];
                let z;
                if (
                  r.J(x) === "string" &&
                  r.O(L) &&
                  !L.tokens &&
                  (z = /^{([^}]+)}$/.exec(x))
                ) {
                  const G = `\`{ "type": "identity", "property": ${z ? JSON.stringify(z[1]) : '"_"'} }\``;
                  return [
                    new r.V(
                      s,
                      x,
                      `"${w}" does not support interpolation syntax
Use an identity property function instead: ${G}.`,
                    ),
                  ];
                }
                const O = [];
                if (c.layerType === "symbol")
                  (w !== "text-field" ||
                    !h ||
                    h.glyphs ||
                    h.imports ||
                    O.push(
                      new r.V(
                        s,
                        x,
                        'use of "text-field" requires a style "glyphs" property',
                      ),
                    ),
                    w === "text-font" &&
                      r.a2(r.U(x)) &&
                      r.M(x.type) === "identity" &&
                      O.push(
                        new r.V(
                          s,
                          x,
                          '"text-font" does not support identity functions',
                        ),
                      ));
                else if (
                  c.layerType === "model" &&
                  t === "paint" &&
                  p &&
                  p.layout &&
                  p.layout.hasOwnProperty("model-id") &&
                  r.O(L) &&
                  (r.a3(L) || r.Q(L))
                ) {
                  const G = r.W(r.U(x), L),
                    U =
                      G.value.expression || G.value._styleExpression.expression;
                  U &&
                    !r.Z(U, ["measure-light"]) &&
                    ((w === "model-emissive-strength" && r._(U) && r.Y(U)) ||
                      O.push(
                        new r.V(
                          s,
                          x,
                          `${w} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`,
                        ),
                      ));
                }
                return O.concat(
                  bn({
                    key: c.key,
                    value: x,
                    valueSpec: L,
                    style: h,
                    styleSpec: g,
                    expressionContext: "property",
                    propertyType: t,
                    propertyKey: w,
                  }),
                );
              }
              function Ka(c) {
                return Ya(c, "paint");
              }
              function Xr(c) {
                return Ya(c, "layout");
              }
              function nc(c) {
                let t = [];
                const s = c.value,
                  h = c.key,
                  p = c.style,
                  g = c.styleSpec;
                s.type ||
                  s.ref ||
                  t.push(new r.V(h, s, 'either "type" or "ref" is required'));
                let x = r.M(s.type);
                const w = r.M(s.ref);
                if (s.id) {
                  const S = r.M(s.id);
                  for (let C = 0; C < c.arrayIndex; C++) {
                    const D = p.layers[C];
                    r.M(D.id) === S &&
                      t.push(
                        new r.V(
                          h,
                          s.id,
                          `duplicate layer id "${s.id}", previously used at line ${D.id.__line__}`,
                        ),
                      );
                  }
                }
                if ("ref" in s) {
                  let S;
                  ([
                    "type",
                    "source",
                    "source-layer",
                    "filter",
                    "layout",
                  ].forEach((C) => {
                    C in s &&
                      t.push(
                        new r.V(h, s[C], `"${C}" is prohibited for ref layers`),
                      );
                  }),
                    p.layers.forEach((C) => {
                      r.M(C.id) === w && (S = C);
                    }),
                    S
                      ? S.ref
                        ? t.push(
                            new r.V(
                              h,
                              s.ref,
                              "ref cannot reference another ref layer",
                            ),
                          )
                        : (x = r.M(S.type))
                      : typeof w == "string" &&
                        t.push(
                          new r.V(h, s.ref, `ref layer "${w}" not found`),
                        ));
                } else if (x !== "background" && x !== "sky" && x !== "slot")
                  if (s.source) {
                    const S = p.sources && p.sources[s.source],
                      C = S && r.M(S.type);
                    S
                      ? C === "vector" && x === "raster"
                        ? t.push(
                            new r.V(
                              h,
                              s.source,
                              `layer "${s.id}" requires a raster source`,
                            ),
                          )
                        : C === "raster" && x !== "raster"
                          ? t.push(
                              new r.V(
                                h,
                                s.source,
                                `layer "${s.id}" requires a vector source`,
                              ),
                            )
                          : C !== "vector" || s["source-layer"]
                            ? C === "raster-dem" && x !== "hillshade"
                              ? t.push(
                                  new r.V(
                                    h,
                                    s.source,
                                    "raster-dem source can only be used with layer type 'hillshade'.",
                                  ),
                                )
                              : C !== "raster-array" ||
                                  ["raster", "raster-particle"].includes(x)
                                ? x === "line" &&
                                  s.paint &&
                                  (s.paint["line-gradient"] ||
                                    s.paint["line-trim-offset"]) &&
                                  C === "geojson" &&
                                  !S.lineMetrics
                                  ? t.push(
                                      new r.V(
                                        h,
                                        s,
                                        `layer "${s.id}" specifies a line-gradient, which requires the GeoJSON source to have \`lineMetrics\` enabled.`,
                                      ),
                                    )
                                  : x === "raster-particle" &&
                                    C !== "raster-array" &&
                                    t.push(
                                      new r.V(
                                        h,
                                        s.source,
                                        `layer "${s.id}" requires a 'raster-array' source.`,
                                      ),
                                    )
                                : t.push(
                                    new r.V(
                                      h,
                                      s.source,
                                      "raster-array source can only be used with layer type 'raster'.",
                                    ),
                                  )
                            : t.push(
                                new r.V(
                                  h,
                                  s,
                                  `layer "${s.id}" must specify a "source-layer"`,
                                ),
                              )
                      : t.push(
                          new r.V(
                            h,
                            s.source,
                            `source "${s.source}" not found`,
                          ),
                        );
                  } else
                    t.push(new r.V(h, s, 'missing required property "source"'));
                return (
                  (t = t.concat(
                    Mr({
                      key: h,
                      value: s,
                      valueSpec: g.layer,
                      style: c.style,
                      styleSpec: c.styleSpec,
                      objectElementValidators: {
                        "*": () => [],
                        type: () =>
                          bn({
                            key: `${h}.type`,
                            value: s.type,
                            valueSpec: g.layer.type,
                            style: c.style,
                            styleSpec: c.styleSpec,
                            object: s,
                            objectKey: "type",
                          }),
                        filter: (S) => Io(r.L({ layerType: x }, S)),
                        layout: (S) =>
                          Mr({
                            layer: s,
                            key: S.key,
                            value: S.value,
                            valueSpec: {},
                            style: S.style,
                            styleSpec: S.styleSpec,
                            objectElementValidators: {
                              "*": (C) => Xr(r.L({ layerType: x }, C)),
                            },
                          }),
                        paint: (S) =>
                          Mr({
                            layer: s,
                            key: S.key,
                            value: S.value,
                            valueSpec: {},
                            style: S.style,
                            styleSpec: S.styleSpec,
                            objectElementValidators: {
                              "*": (C) =>
                                Ka(r.L({ layerType: x, layer: s }, C)),
                            },
                          }),
                      },
                    }),
                  )),
                  t
                );
              }
              function eo(c) {
                const t = c.value,
                  s = c.key,
                  h = r.J(t);
                return h !== "string"
                  ? [new r.V(s, t, `string expected, ${h} found`)]
                  : [];
              }
              const Ja = {
                promoteId: function c({ key: t, value: s }) {
                  if (r.J(s) === "string") return eo({ key: t, value: s });
                  if (Array.isArray(s)) {
                    const h = [],
                      p = r.U(s),
                      g = r.X(p);
                    return (
                      g.result === "error" &&
                        g.value.forEach((x) => {
                          h.push(new r.V(`${t}${x.key}`, null, `${x.message}`));
                        }),
                      r.Z(g.value.expression, [
                        "zoom",
                        "heatmap-density",
                        "line-progress",
                        "raster-value",
                        "sky-radial-progress",
                        "accumulated",
                        "is-supported-script",
                        "pitch",
                        "distance-from-center",
                        "measure-light",
                        "raster-particle-speed",
                      ]) ||
                        h.push(
                          new r.V(
                            `${t}`,
                            null,
                            "promoteId expression should be only feature dependent",
                          ),
                        ),
                      h
                    );
                  }
                  {
                    const h = [];
                    for (const p in s)
                      h.push(...c({ key: `${t}.${p}`, value: s[p] }));
                    return h;
                  }
                },
              };
              function wr(c) {
                const t = c.value,
                  s = c.key,
                  h = c.styleSpec,
                  p = c.style;
                if (!t.type) return [new r.V(s, t, '"type" is required')];
                const g = r.M(t.type);
                let x = [];
                switch (
                  (["vector", "raster", "raster-dem", "raster-array"].includes(
                    g,
                  ) &&
                    (t.url ||
                      t.tiles ||
                      x.push(
                        new r.K(s, t, 'Either "url" or "tiles" is required.'),
                      )),
                  g)
                ) {
                  case "vector":
                  case "raster":
                  case "raster-dem":
                  case "raster-array":
                    return (
                      (x = x.concat(
                        Mr({
                          key: s,
                          value: t,
                          valueSpec: h[`source_${g.replace("-", "_")}`],
                          style: c.style,
                          styleSpec: h,
                          objectElementValidators: Ja,
                        }),
                      )),
                      x
                    );
                  case "geojson":
                    if (
                      ((x = Mr({
                        key: s,
                        value: t,
                        valueSpec: h.source_geojson,
                        style: p,
                        styleSpec: h,
                        objectElementValidators: Ja,
                      })),
                      t.cluster)
                    )
                      for (const w in t.clusterProperties) {
                        const [S, C] = t.clusterProperties[w],
                          D =
                            typeof S == "string"
                              ? [S, ["accumulated"], ["get", w]]
                              : S;
                        (x.push(
                          ...Zr({
                            key: `${s}.${w}.map`,
                            value: C,
                            expressionContext: "cluster-map",
                          }),
                        ),
                          x.push(
                            ...Zr({
                              key: `${s}.${w}.reduce`,
                              value: D,
                              expressionContext: "cluster-reduce",
                            }),
                          ));
                      }
                    return x;
                  case "video":
                    return Mr({
                      key: s,
                      value: t,
                      valueSpec: h.source_video,
                      style: p,
                      styleSpec: h,
                    });
                  case "image":
                    return Mr({
                      key: s,
                      value: t,
                      valueSpec: h.source_image,
                      style: p,
                      styleSpec: h,
                    });
                  case "canvas":
                    return [
                      new r.V(
                        s,
                        null,
                        "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.",
                        "source.canvas",
                      ),
                    ];
                  default:
                    return Eo({
                      key: `${s}.type`,
                      value: t.type,
                      valueSpec: { values: ms(h) },
                    });
                }
              }
              function ms(c) {
                return c.source.reduce((t, s) => {
                  const h = c[s];
                  return (
                    h.type.type === "enum" &&
                      (t = t.concat(Object.keys(h.type.values))),
                    t
                  );
                }, []);
              }
              function ca(c) {
                const t = c.value,
                  s = c.styleSpec,
                  h = s.light,
                  p = c.style;
                let g = [];
                const x = r.J(t);
                if (t === void 0) return g;
                if (x !== "object")
                  return (
                    (g = g.concat([
                      new r.V("light", t, `object expected, ${x} found`),
                    ])),
                    g
                  );
                for (const w in t) {
                  const S = w.match(/^(.*)-transition$/),
                    C = w.match(/^(.*)-use-theme$/);
                  g = g.concat(
                    C && h[C[1]]
                      ? bn({
                          key: w,
                          value: t[w],
                          valueSpec: { type: "string" },
                          style: p,
                          styleSpec: s,
                        })
                      : S && h[S[1]] && h[S[1]].transition
                        ? bn({
                            key: w,
                            value: t[w],
                            valueSpec: s.transition,
                            style: p,
                            styleSpec: s,
                          })
                        : h[w]
                          ? bn({
                              key: w,
                              value: t[w],
                              valueSpec: h[w],
                              style: p,
                              styleSpec: s,
                            })
                          : [new r.V(w, t[w], `unknown property "${w}"`)],
                  );
                }
                return g;
              }
              function Ao(c) {
                const t = c.value;
                let s = [];
                if (!t) return s;
                const h = r.J(t);
                if (h !== "object")
                  return (
                    (s = s.concat([
                      new r.V("light-3d", t, `object expected, ${h} found`),
                    ])),
                    s
                  );
                const p = c.styleSpec,
                  g = p["light-3d"],
                  x = c.key,
                  w = c.style,
                  S = c.style.lights;
                for (const L of ["type", "id"])
                  if (!(L in t))
                    return (
                      (s = s.concat([
                        new r.V(
                          "light-3d",
                          t,
                          `missing property ${L} on light`,
                        ),
                      ])),
                      s
                    );
                if (t.type && S)
                  for (let L = 0; L < c.arrayIndex; L++) {
                    const z = r.M(t.type),
                      O = S[L];
                    r.M(O.type) === z &&
                      s.push(
                        new r.V(
                          x,
                          t.id,
                          `duplicate light type "${t.type}", previously defined at line ${O.id.__line__}`,
                        ),
                      );
                  }
                const C = `properties_light_${t.type}`;
                if (!(C in p))
                  return (
                    (s = s.concat([
                      new r.V("light-3d", t, `Invalid light type ${t.type}`),
                    ])),
                    s
                  );
                const D = p[C];
                for (const L in t)
                  if (L === "properties") {
                    const z = t[L],
                      O = r.J(z);
                    if (O !== "object")
                      return (
                        (s = s.concat([
                          new r.V(
                            "properties",
                            z,
                            `object expected, ${O} found`,
                          ),
                        ])),
                        s
                      );
                    for (const G in z) {
                      const U = G.match(/^(.*)-transition$/),
                        $ = G.match(/^(.*)-use-theme$/);
                      s = s.concat(
                        $ && D[$[1]]
                          ? bn({
                              key: L,
                              value: z[G],
                              valueSpec: { type: "string" },
                              style: w,
                              styleSpec: p,
                            })
                          : U && D[U[1]] && D[U[1]].transition
                            ? bn({
                                key: L,
                                value: t[L],
                                valueSpec: p.transition,
                                style: w,
                                styleSpec: p,
                              })
                            : D[G]
                              ? bn({
                                  key: G,
                                  value: z[G],
                                  valueSpec: D[G],
                                  style: w,
                                  styleSpec: p,
                                })
                              : [
                                  new r.K(
                                    c.key,
                                    z[G],
                                    `unknown property "${G}"`,
                                  ),
                                ],
                      );
                    }
                  } else
                    s = s.concat(
                      g[L]
                        ? bn({
                            key: L,
                            value: t[L],
                            valueSpec: g[L],
                            style: w,
                            styleSpec: p,
                          })
                        : [new r.K(L, t[L], `unknown property "${L}"`)],
                    );
                return s;
              }
              function ha(c) {
                const t = c.value,
                  s = c.key,
                  h = c.style,
                  p = c.styleSpec,
                  g = p.terrain;
                let x = [];
                const w = r.J(t);
                if (t === void 0 || w === "null") return x;
                if (w !== "object")
                  return (
                    (x = x.concat([
                      new r.V("terrain", t, `object expected, ${w} found`),
                    ])),
                    x
                  );
                for (const S in t) {
                  const C = S.match(/^(.*)-transition$/),
                    D = S.match(/^(.*)-use-theme$/);
                  x = x.concat(
                    D && g[D[1]]
                      ? bn({
                          key: S,
                          value: t[S],
                          valueSpec: { type: "string" },
                          style: h,
                          styleSpec: p,
                        })
                      : C && g[C[1]] && g[C[1]].transition
                        ? bn({
                            key: S,
                            value: t[S],
                            valueSpec: p.transition,
                            style: h,
                            styleSpec: p,
                          })
                        : g[S]
                          ? bn({
                              key: S,
                              value: t[S],
                              valueSpec: g[S],
                              style: h,
                              styleSpec: p,
                            })
                          : [new r.K(S, t[S], `unknown property "${S}"`)],
                  );
                }
                if (t.source) {
                  const S = h.sources && h.sources[t.source],
                    C = S && r.M(S.type);
                  S
                    ? C !== "raster-dem" &&
                      x.push(
                        new r.V(
                          s,
                          t.source,
                          `terrain cannot be used with a source of type ${String(C)}, it only be used with a "raster-dem" source type`,
                        ),
                      )
                    : x.push(
                        new r.V(s, t.source, `source "${t.source}" not found`),
                      );
                } else
                  x.push(
                    new r.V(
                      s,
                      t,
                      'terrain is missing required property "source"',
                    ),
                  );
                return x;
              }
              function Mo(c) {
                const t = c.value,
                  s = c.style,
                  h = c.styleSpec,
                  p = h.fog;
                let g = [];
                const x = r.J(t);
                if (t === void 0) return g;
                if (x !== "object")
                  return (
                    (g = g.concat([
                      new r.V("fog", t, `object expected, ${x} found`),
                    ])),
                    g
                  );
                for (const w in t) {
                  const S = w.match(/^(.*)-transition$/),
                    C = w.match(/^(.*)-use-theme$/);
                  g = g.concat(
                    C && p[C[1]]
                      ? bn({
                          key: w,
                          value: t[w],
                          valueSpec: { type: "string" },
                          style: s,
                          styleSpec: h,
                        })
                      : S && p[S[1]] && p[S[1]].transition
                        ? bn({
                            key: w,
                            value: t[w],
                            valueSpec: h.transition,
                            style: s,
                            styleSpec: h,
                          })
                        : p[w]
                          ? bn({
                              key: w,
                              value: t[w],
                              valueSpec: p[w],
                              style: s,
                              styleSpec: h,
                            })
                          : [new r.K(w, t[w], `unknown property "${w}"`)],
                  );
                }
                return g;
              }
              const Qa = {
                "*": () => [],
                array: la,
                boolean: function (c) {
                  const t = c.value,
                    s = c.key,
                    h = r.J(t);
                  return h !== "boolean"
                    ? [new r.V(s, t, `boolean expected, ${h} found`)]
                    : [];
                },
                number: ic,
                color: function (c) {
                  const t = c.key,
                    s = c.value,
                    h = r.J(s);
                  return h !== "string"
                    ? [new r.V(t, s, `color expected, ${h} found`)]
                    : r.a0.parseCSSColor(s) === null
                      ? [new r.V(t, s, `color expected, "${s}" found`)]
                      : [];
                },
                enum: Eo,
                filter: Io,
                function: Cr,
                layer: nc,
                object: Mr,
                source: wr,
                model: r.a4,
                light: ca,
                "light-3d": Ao,
                terrain: ha,
                fog: Mo,
                string: eo,
                formatted: function (c) {
                  return eo(c).length === 0 ? [] : Zr(c);
                },
                resolvedImage: function (c) {
                  return eo(c).length === 0 ? [] : Zr(c);
                },
                projection: function (c) {
                  const t = c.value,
                    s = c.styleSpec,
                    h = s.projection,
                    p = c.style;
                  let g = [];
                  const x = r.J(t);
                  if (x === "object")
                    for (const w in t)
                      g = g.concat(
                        bn({
                          key: w,
                          value: t[w],
                          valueSpec: h[w],
                          style: p,
                          styleSpec: s,
                        }),
                      );
                  else
                    x !== "string" &&
                      (g = g.concat([
                        new r.V(
                          "projection",
                          t,
                          `object or string expected, ${x} found`,
                        ),
                      ]));
                  return g;
                },
                import: function (c) {
                  const { value: t, styleSpec: s } = c,
                    { data: h, ...p } = t;
                  Object.defineProperty(p, "__line__", {
                    value: t.__line__,
                    enumerable: !1,
                  });
                  let g = Mr(r.L({}, c, { value: p, valueSpec: s.import }));
                  return (
                    r.M(p.id) === "" &&
                      g.push(
                        new r.V(
                          `${c.key}.id`,
                          p,
                          "import id can't be an empty string",
                        ),
                      ),
                    h && (g = g.concat(el(h, s, { key: `${c.key}.data` }))),
                    g
                  );
                },
                iconset: function (c) {
                  const t = c.value,
                    s = c.key,
                    h = c.styleSpec,
                    p = c.style;
                  if (!t.type) return [new r.V(s, t, '"type" is required')];
                  const g = r.M(t.type);
                  let x = [];
                  if (
                    ((x = x.concat(
                      Mr({
                        key: s,
                        value: t,
                        valueSpec: h[`iconset_${g}`],
                        style: p,
                        styleSpec: h,
                      }),
                    )),
                    g === "source" && t.source)
                  ) {
                    const w = p.sources && p.sources[t.source],
                      S = w && r.M(w.type);
                    w
                      ? S !== "raster-array" &&
                        x.push(
                          new r.V(
                            s,
                            t.source,
                            `iconset cannot be used with a source of type ${String(S)}, it only be used with a "raster-array" source type`,
                          ),
                        )
                      : x.push(
                          new r.V(
                            s,
                            t.source,
                            `source "${t.source}" not found`,
                          ),
                        );
                  }
                  return x;
                },
              };
              function bn(c, t = !1) {
                const s = c.value,
                  h = c.valueSpec,
                  p = c.styleSpec;
                if (h.expression && r.a2(r.M(s))) return Cr(c);
                if (h.expression && r.S(r.U(s))) return Zr(c);
                if (h.type && Qa[h.type]) {
                  const g = Qa[h.type](c);
                  return t === !0 && g.length > 0 && r.J(c.value) === "array"
                    ? Zr(c)
                    : g;
                }
                return Mr(r.L({}, c, { valueSpec: h.type ? p[h.type] : h }));
              }
              function Co(c) {
                const t = c.value,
                  s = c.key,
                  h = eo(c);
                return (
                  h.length ||
                    (t.indexOf("{fontstack}") === -1 &&
                      h.push(
                        new r.V(
                          s,
                          t,
                          '"glyphs" url must include a "{fontstack}" token',
                        ),
                      ),
                    t.indexOf("{range}") === -1 &&
                      h.push(
                        new r.V(
                          s,
                          t,
                          '"glyphs" url must include a "{range}" token',
                        ),
                      )),
                  h
                );
              }
              function el(c, t = r.a5, s = {}) {
                return bn({
                  key: s.key || "",
                  value: c,
                  valueSpec: t.$root,
                  styleSpec: t,
                  style: c,
                  objectElementValidators: { glyphs: Co, "*": () => [] },
                });
              }
              function Yr(c, t = r.a5) {
                return ye(el(c, t));
              }
              const td = (c) => ye(wr(c)),
                Sh = (c) => ye(ca(c)),
                ua = (c) => ye(Ao(c)),
                ft = (c) => ye(ha(c)),
                to = (c) => ye(Mo(c)),
                id = (c) =>
                  ye(
                    (function (t) {
                      const s = t.value,
                        h = t.style,
                        p = t.styleSpec,
                        g = p.snow;
                      let x = [];
                      const w = r.J(s);
                      if (s === void 0) return x;
                      if (w !== "object")
                        return (
                          (x = x.concat([
                            new r.V("snow", s, `object expected, ${w} found`),
                          ])),
                          x
                        );
                      for (const S in s) {
                        const C = S.match(/^(.*)-transition$/);
                        x = x.concat(
                          C && g[C[1]] && g[C[1]].transition
                            ? bn({
                                key: S,
                                value: s[S],
                                valueSpec: p.transition,
                                style: h,
                                styleSpec: p,
                              })
                            : g[S]
                              ? bn({
                                  key: S,
                                  value: s[S],
                                  valueSpec: g[S],
                                  style: h,
                                  styleSpec: p,
                                })
                              : [new r.K(S, s[S], `unknown property "${S}"`)],
                        );
                      }
                      return x;
                    })(c),
                  ),
                rc = (c) =>
                  ye(
                    (function (t) {
                      const s = t.value,
                        h = t.style,
                        p = t.styleSpec,
                        g = p.rain;
                      let x = [];
                      const w = r.J(s);
                      if (s === void 0) return x;
                      if (w !== "object")
                        return (
                          (x = x.concat([
                            new r.V("rain", s, `object expected, ${w} found`),
                          ])),
                          x
                        );
                      for (const S in s) {
                        const C = S.match(/^(.*)-transition$/);
                        x = x.concat(
                          C && g[C[1]] && g[C[1]].transition
                            ? bn({
                                key: S,
                                value: s[S],
                                valueSpec: p.transition,
                                style: h,
                                styleSpec: p,
                              })
                            : g[S]
                              ? bn({
                                  key: S,
                                  value: s[S],
                                  valueSpec: g[S],
                                  style: h,
                                  styleSpec: p,
                                })
                              : [new r.K(S, s[S], `unknown property "${S}"`)],
                        );
                      }
                      return x;
                    })(c),
                  ),
                Mi = (c) => ye(nc(c)),
                Fe = (c) => ye(Io(c)),
                W = (c) => ye(Ka(c)),
                K = (c) => ye(Xr(c)),
                oe = (c) => ye(r.a4(c));
              function ye(c) {
                return c
                  .slice()
                  .sort((t, s) => (t.line && s.line ? t.line - s.line : 0));
              }
              function he(c, t) {
                let s = !1;
                if (t && t.length)
                  for (const h of t)
                    h instanceof r.K
                      ? r.w(h.message)
                      : (c.fire(new r.z(new Error(h.message))), (s = !0));
                return s;
              }
              let Se;
              class ke extends r.E {
                constructor(t, s = "flat") {
                  (super(),
                    (this._transitionable = new r.a6(
                      Se ||
                        (Se = new r.a7({
                          anchor: new r.a8(r.a5.light.anchor),
                          position: new r.a9(r.a5.light.position),
                          color: new r.a8(r.a5.light.color),
                          intensity: new r.a8(r.a5.light.intensity),
                        })),
                    )),
                    this.setLight(t, s),
                    (this._transitioning =
                      this._transitionable.untransitioned()));
                }
                getLight() {
                  return this._transitionable.serialize();
                }
                setLight(t, s, h = {}) {
                  this._validate(Sh, t, h) ||
                    (this._transitionable.setTransitionOrValue(t),
                    (this.id = s));
                }
                updateTransitions(t) {
                  this._transitioning = this._transitionable.transitioned(
                    t,
                    this._transitioning,
                  );
                }
                hasTransition() {
                  return this._transitioning.hasTransition();
                }
                recalculate(t) {
                  this.properties = this._transitioning.possiblyEvaluate(t);
                }
                _validate(t, s, h) {
                  return (
                    (!h || h.validate !== !1) &&
                    he(
                      this,
                      t.call(
                        Yr,
                        r.h({
                          value: s,
                          style: { glyphs: !0, sprite: !0 },
                          styleSpec: r.a5,
                        }),
                      ),
                    )
                  );
                }
              }
              let Ee = class extends r.E {
                constructor(c, t, s, h, p) {
                  (super(),
                    (this.scope = s),
                    (this._transitionable = new r.a6(
                      new r.a7({
                        source: new r.a8(r.a5.terrain.source),
                        exaggeration: new r.a8(r.a5.terrain.exaggeration),
                      }),
                      s,
                      h,
                    )),
                    this._transitionable.setTransitionOrValue(c, h),
                    (this._transitioning =
                      this._transitionable.untransitioned()),
                    (this.drapeRenderMode = t),
                    (this.worldview = p));
                }
                get() {
                  return this._transitionable.serialize();
                }
                set(c, t) {
                  this._transitionable.setTransitionOrValue(c, t);
                }
                updateTransitions(c) {
                  this._transitioning = this._transitionable.transitioned(
                    c,
                    this._transitioning,
                  );
                }
                hasTransition() {
                  return this._transitioning.hasTransition();
                }
                recalculate(c) {
                  this.properties = this._transitioning.possiblyEvaluate(c);
                }
                getExaggeration(c) {
                  return this._transitioning
                    .possiblyEvaluate(
                      new r.aa(c, { worldview: this.worldview }),
                    )
                    .get("exaggeration");
                }
                getAttenuationRange() {
                  if (!this.isZoomDependent()) return null;
                  const c = this._transitionable._values.exaggeration;
                  if (!c) return null;
                  const t = c.value.expression;
                  if (!t) return null;
                  let s = -1,
                    h = -1,
                    p = 1;
                  for (const g of t.zoomStops)
                    ((p = t.evaluate(
                      new r.aa(g, { worldview: this.worldview }),
                    )),
                      p > 0.01 ? ((s = g), (h = -1)) : (h = g));
                  return p < 0.01 && s > 0 && h > s ? [s, h] : null;
                }
                isZoomDependent() {
                  const c = this._transitionable._values.exaggeration;
                  return (
                    c != null &&
                    c.value != null &&
                    c.value.expression != null &&
                    c.value.expression instanceof r.ab
                  );
                }
              };
              const Le = 45,
                Ye = 65,
                Be = 0.05;
              function dt(c, t, s, h) {
                const p = r.af(Le, Ye, s),
                  [g, x] = Pt(c, h);
                let w = 1 - Math.min(1, Math.exp(((t - g) / (x - g)) * -6));
                return (
                  (w *= w * w),
                  (w = Math.min(1, 1.00747 * w)),
                  w * p * c.alpha
                );
              }
              function Pt(c, t) {
                const s = 0.5 / Math.tan(0.5 * t);
                return [c.range[0] + s, c.range[1] + s];
              }
              function zt(c, t, s, h, p) {
                const g = r.ad([], [t, s, h], p.mercatorFogMatrix);
                return dt(c, r.ae(g), p.pitch, p._fov);
              }
              function Xt(c, t, s, h, p, g, x) {
                const w = [
                  [s, h, 0],
                  [p, h, 0],
                  [p, g, 0],
                  [s, g, 0],
                ];
                let S = Number.MAX_VALUE,
                  C = -Number.MAX_VALUE;
                for (const D of w) {
                  const L = r.ad([], D, t),
                    z = r.ae(L);
                  ((S = Math.min(S, z)), (C = Math.max(C, z)));
                }
                return [dt(c, S, x.pitch, x._fov), dt(c, C, x.pitch, x._fov)];
              }
              class Kt extends r.E {
                constructor(t, s, h, p) {
                  super();
                  const g = new r.a7({
                    range: new r.a8(r.a5.fog.range),
                    color: new r.a8(r.a5.fog.color),
                    "color-use-theme": new r.a8({
                      type: "string",
                      "property-type": "data-constant",
                      default: "default",
                    }),
                    "high-color": new r.a8(r.a5.fog["high-color"]),
                    "high-color-use-theme": new r.a8({
                      type: "string",
                      "property-type": "data-constant",
                      default: "default",
                    }),
                    "space-color": new r.a8(r.a5.fog["space-color"]),
                    "space-color-use-theme": new r.a8({
                      type: "string",
                      "property-type": "data-constant",
                      default: "default",
                    }),
                    "horizon-blend": new r.a8(r.a5.fog["horizon-blend"]),
                    "star-intensity": new r.a8(r.a5.fog["star-intensity"]),
                    "vertical-range": new r.a8(r.a5.fog["vertical-range"]),
                  });
                  ((this._transitionable = new r.a6(g, h, new Map(p))),
                    this.set(t, p),
                    (this._transitioning =
                      this._transitionable.untransitioned()),
                    (this._transform = s),
                    (this.properties = new r.ag(g)),
                    (this.scope = h));
                }
                get state() {
                  const t = this._transform,
                    s = t.projection.name === "globe",
                    h = r.ah(t.zoom),
                    p = this.properties.get("range"),
                    g = [0.5, 3];
                  return {
                    range: s ? [r.ai(g[0], p[0], h), r.ai(g[1], p[1], h)] : p,
                    horizonBlend: this.properties.get("horizon-blend"),
                    alpha: this.properties.get("color").a,
                  };
                }
                get() {
                  return this._transitionable.serialize();
                }
                set(t, s, h = {}) {
                  if (this._validate(to, t, h)) return;
                  const p = r.h({}, t);
                  for (const g of Object.keys(r.a5.fog))
                    p[g] === void 0 && (p[g] = r.a5.fog[g].default);
                  ((this._options = p),
                    this._transitionable.setTransitionOrValue(
                      this._options,
                      s,
                    ));
                }
                getOpacity(t) {
                  if (!this._transform.projection.supportsFog) return 0;
                  const s =
                    (this.properties && this.properties.get("color")) || 1;
                  return (
                    (this._transform.projection.name === "globe"
                      ? 1
                      : r.af(Le, Ye, t)) * s.a
                  );
                }
                getOpacityAtLatLng(t, s) {
                  return this._transform.projection.supportsFog
                    ? (function (h, p, g) {
                        const x = r.ac.fromLngLat(p),
                          w = g.elevation ? g.elevation.getAtPointOrZero(x) : 0;
                        return zt(h, x.x, x.y, w, g);
                      })(this.state, t, s)
                    : 0;
                }
                getOpacityForTile(t) {
                  if (!this._transform.projection.supportsFog) return [1, 1];
                  const s = this._transform.calculateFogTileMatrix(
                    t.toUnwrapped(),
                  );
                  return Xt(this.state, s, 0, 0, r.aj, r.aj, this._transform);
                }
                getOpacityForBounds(t, s, h, p, g) {
                  return this._transform.projection.supportsFog
                    ? Xt(this.state, t, s, h, p, g, this._transform)
                    : [1, 1];
                }
                getFovAdjustedRange(t) {
                  return this._transform.projection.supportsFog
                    ? Pt(this.state, t)
                    : [0, 1];
                }
                isVisibleOnFrustum(t) {
                  if (!this._transform.projection.supportsFog) return !1;
                  const s = [4, 5, 6, 7];
                  for (const h of s) {
                    const p = t.points[h];
                    let g;
                    if (p[2] >= 0) g = p;
                    else {
                      const x = t.points[h - 4];
                      g = r.ak(x, p, x[2] / (x[2] - p[2]));
                    }
                    if (zt(this.state, g[0], g[1], 0, this._transform) >= Be)
                      return !0;
                  }
                  return !1;
                }
                updateConfig(t) {
                  this._transitionable.setTransitionOrValue(
                    this._options,
                    new Map(t),
                  );
                }
                updateTransitions(t) {
                  this._transitioning = this._transitionable.transitioned(
                    t,
                    this._transitioning,
                  );
                }
                hasTransition() {
                  return this._transitioning.hasTransition();
                }
                recalculate(t) {
                  this.properties = this._transitioning.possiblyEvaluate(t);
                }
                _validate(t, s, h) {
                  return (
                    (!h || h.validate !== !1) &&
                    he(
                      this,
                      t.call(
                        Yr,
                        r.h({
                          value: s,
                          style: { glyphs: !0, sprite: !0 },
                          styleSpec: r.a5,
                        }),
                      ),
                    )
                  );
                }
              }
              let Qt,
                mi,
                ri,
                Ki,
                gn = class extends r.E {
                  constructor(c, t, s, h) {
                    super();
                    const p =
                      Qt ||
                      (Qt = new r.a7({
                        density: new r.a8(r.a5.snow.density),
                        intensity: new r.a8(r.a5.snow.intensity),
                        color: new r.a8(r.a5.snow.color),
                        opacity: new r.a8(r.a5.snow.opacity),
                        vignette: new r.a8(r.a5.snow.vignette),
                        "vignette-color": new r.a8(r.a5.snow["vignette-color"]),
                        "center-thinning": new r.a8(
                          r.a5.snow["center-thinning"],
                        ),
                        direction: new r.a8(r.a5.snow.direction),
                        "flake-size": new r.a8(r.a5.snow["flake-size"]),
                      }));
                    ((this._transitionable = new r.a6(p, s, new Map(h))),
                      this.set(c, h),
                      (this._transitioning =
                        this._transitionable.untransitioned()),
                      (this.properties = new r.ag(p)),
                      (this.scope = s));
                  }
                  get state() {
                    const c = this.properties.get("opacity"),
                      t = this.properties.get("color"),
                      s = this.properties.get("direction"),
                      h = r.al(s[0]),
                      p = -Math.max(r.al(s[1]), 0.01),
                      g = [
                        Math.cos(h) * Math.cos(p),
                        Math.sin(h) * Math.cos(p),
                        Math.sin(p),
                      ],
                      x = this.properties.get("vignette"),
                      w = this.properties.get("vignette-color");
                    return (
                      (w.a = x),
                      {
                        density: this.properties.get("density"),
                        intensity: this.properties.get("intensity"),
                        color: new r.am(t.r, t.g, t.b, t.a * c),
                        direction: g,
                        centerThinning: this.properties.get("center-thinning"),
                        flakeSize: this.properties.get("flake-size"),
                        vignetteColor: w,
                      }
                    );
                  }
                  get() {
                    return this._transitionable.serialize();
                  }
                  set(c, t, s = {}) {
                    if (this._validate(id, c, s)) return;
                    const h = r.h({}, c);
                    for (const p of Object.keys(r.a5.snow))
                      h[p] === void 0 && (h[p] = r.a5.snow[p].default);
                    ((this._options = h),
                      this._transitionable.setTransitionOrValue(
                        this._options,
                        t,
                      ));
                  }
                  updateConfig(c) {
                    this._transitionable.setTransitionOrValue(
                      this._options,
                      new Map(c),
                    );
                  }
                  updateTransitions(c) {
                    this._transitioning = this._transitionable.transitioned(
                      c,
                      this._transitioning,
                    );
                  }
                  hasTransition() {
                    return this._transitioning.hasTransition();
                  }
                  recalculate(c) {
                    this.properties = this._transitioning.possiblyEvaluate(c);
                  }
                  _validate(c, t, s) {
                    return (
                      (!s || s.validate !== !1) &&
                      he(
                        this,
                        c.call(
                          Yr,
                          r.h({
                            value: t,
                            style: { glyphs: !0, sprite: !0 },
                            styleSpec: r.a5,
                          }),
                        ),
                      )
                    );
                  }
                },
                _n = class extends r.E {
                  constructor(c, t, s, h) {
                    super();
                    const p =
                      mi ||
                      (mi = new r.a7({
                        density: new r.a8(r.a5.rain.density),
                        intensity: new r.a8(r.a5.rain.intensity),
                        color: new r.a8(r.a5.rain.color),
                        opacity: new r.a8(r.a5.rain.opacity),
                        vignette: new r.a8(r.a5.rain.vignette),
                        "vignette-color": new r.a8(r.a5.rain["vignette-color"]),
                        "center-thinning": new r.a8(
                          r.a5.rain["center-thinning"],
                        ),
                        direction: new r.a8(r.a5.rain.direction),
                        "droplet-size": new r.a8(r.a5.rain["droplet-size"]),
                        "distortion-strength": new r.a8(
                          r.a5.rain["distortion-strength"],
                        ),
                      }));
                    ((this._transitionable = new r.a6(p, s, new Map(h))),
                      this.set(c, h),
                      (this._transitioning =
                        this._transitionable.untransitioned()),
                      (this.properties = new r.ag(p)),
                      (this.scope = s));
                  }
                  get state() {
                    const c = this.properties.get("opacity"),
                      t = this.properties.get("color"),
                      s = this.properties.get("direction"),
                      h = r.al(s[0]),
                      p = -Math.max(r.al(s[1]), 0.01),
                      g = [
                        Math.cos(h) * Math.cos(p),
                        Math.sin(h) * Math.cos(p),
                        Math.sin(p),
                      ],
                      x = this.properties.get("vignette-color");
                    return (
                      (x.a = this.properties.get("vignette")),
                      {
                        density: this.properties.get("density"),
                        intensity: this.properties.get("intensity"),
                        color: new r.am(t.r, t.g, t.b, t.a * c),
                        direction: g,
                        centerThinning: this.properties.get("center-thinning"),
                        dropletSize: this.properties.get("droplet-size"),
                        distortionStrength: this.properties.get(
                          "distortion-strength",
                        ),
                        vignetteColor: x,
                      }
                    );
                  }
                  get() {
                    return this._transitionable.serialize();
                  }
                  set(c, t, s = {}) {
                    if (this._validate(rc, c, s)) return;
                    const h = r.h({}, c);
                    for (const p of Object.keys(r.a5.rain))
                      h[p] === void 0 && (h[p] = r.a5.rain[p].default);
                    ((this._options = h),
                      this._transitionable.setTransitionOrValue(
                        this._options,
                        t,
                      ));
                  }
                  updateConfig(c) {
                    this._transitionable.setTransitionOrValue(
                      this._options,
                      new Map(c),
                    );
                  }
                  updateTransitions(c) {
                    this._transitioning = this._transitionable.transitioned(
                      c,
                      this._transitioning,
                    );
                  }
                  hasTransition() {
                    return this._transitioning.hasTransition();
                  }
                  recalculate(c) {
                    this.properties = this._transitioning.possiblyEvaluate(c);
                  }
                  _validate(c, t, s) {
                    return (
                      (!s || s.validate !== !1) &&
                      he(
                        this,
                        c.call(
                          Yr,
                          r.h({
                            value: t,
                            style: { glyphs: !0, sprite: !0 },
                            styleSpec: r.a5,
                          }),
                        ),
                      )
                    );
                  }
                };
              class Ui extends r.E {
                constructor(t, s, h, p) {
                  (super(),
                    (this.scope = h),
                    (this._options = t),
                    (this.properties = new r.ag(s)),
                    (this._transitionable = new r.a6(s, h, new Map(p))),
                    this._transitionable.setTransitionOrValue(t.properties),
                    (this._transitioning =
                      this._transitionable.untransitioned()));
                }
                updateConfig(t) {
                  this._transitionable.setTransitionOrValue(
                    this._options.properties,
                    new Map(t),
                  );
                }
                updateTransitions(t) {
                  this._transitioning = this._transitionable.transitioned(
                    t,
                    this._transitioning,
                  );
                }
                hasTransition() {
                  return this._transitioning.hasTransition();
                }
                recalculate(t) {
                  this.properties = this._transitioning.possiblyEvaluate(t);
                }
                get() {
                  return (
                    (this._options.properties =
                      this._transitionable.serialize()),
                    this._options
                  );
                }
                set(t, s) {
                  ((this._options = t),
                    this._transitionable.setTransitionOrValue(t.properties, s));
                }
                shadowsEnabled() {
                  return (
                    !!this.properties &&
                    this.properties.get("cast-shadows") === !0
                  );
                }
              }
              class Pi {
                constructor(t, s, h, p) {
                  ((this.screenBounds = t),
                    (this.cameraPoint = s),
                    (this._screenRaycastCache = {}),
                    (this._cameraRaycastCache = {}),
                    (this.isAboveHorizon = h),
                    (this.screenGeometry = this.bufferedScreenGeometry(0)),
                    (this.screenGeometryMercator = this._bufferedScreenMercator(
                      0,
                      p,
                    )));
                }
                static createFromScreenPoints(t, s) {
                  let h, p;
                  if (t instanceof r.P || typeof t[0] == "number") {
                    const g = r.P.convert(t);
                    ((h = [g]), (p = s.isPointAboveHorizon(g)));
                  } else {
                    const g = r.P.convert(t[0]),
                      x = r.P.convert(t[1]),
                      w = g.add(x)._div(2);
                    ((h = [g, x]),
                      (p =
                        r.ao(g, x).every((S) => s.isPointAboveHorizon(S)) &&
                        s.isPointAboveHorizon(w)));
                  }
                  return new Pi(h, s.getCameraPoint(), p, s);
                }
                isPointQuery() {
                  return this.screenBounds.length === 1;
                }
                bufferedScreenGeometry(t) {
                  return r.ao(
                    this.screenBounds[0],
                    this.screenBounds.length === 1
                      ? this.screenBounds[0]
                      : this.screenBounds[1],
                    t,
                  );
                }
                bufferedCameraGeometry(t) {
                  const s = this.screenBounds[0],
                    h =
                      this.screenBounds.length === 1
                        ? this.screenBounds[0].add(new r.P(1, 1))
                        : this.screenBounds[1],
                    p = r.ao(s, h, 0, !1);
                  return (
                    this.cameraPoint.y > h.y &&
                      (this.cameraPoint.x > s.x && this.cameraPoint.x < h.x
                        ? p.splice(3, 0, this.cameraPoint)
                        : this.cameraPoint.x >= h.x
                          ? (p[2] = this.cameraPoint)
                          : this.cameraPoint.x <= s.x &&
                            (p[3] = this.cameraPoint)),
                    r.ap(p, t)
                  );
                }
                bufferedCameraGeometryGlobe(t) {
                  const s = this.screenBounds[0],
                    h =
                      this.screenBounds.length === 1
                        ? this.screenBounds[0].add(new r.P(1, 1))
                        : this.screenBounds[1],
                    p = r.ao(s, h, t),
                    g = this.cameraPoint.clone();
                  switch (
                    3 * ((g.y > s.y) + (g.y > h.y)) +
                    ((g.x > s.x) + (g.x > h.x))
                  ) {
                    case 0:
                      ((p[0] = g), (p[4] = g.clone()));
                      break;
                    case 1:
                      p.splice(1, 0, g);
                      break;
                    case 2:
                      p[1] = g;
                      break;
                    case 3:
                      p.splice(4, 0, g);
                      break;
                    case 5:
                      p.splice(2, 0, g);
                      break;
                    case 6:
                      p[3] = g;
                      break;
                    case 7:
                      p.splice(3, 0, g);
                      break;
                    case 8:
                      p[2] = g;
                  }
                  return p;
                }
                containsTile(t, s, h, p = 0) {
                  const g = t.queryPadding / s._pixelsPerMercatorPixel + 1,
                    x = h
                      ? this._bufferedCameraMercator(g, s)
                      : this._bufferedScreenMercator(g, s);
                  let w = t.tileID.wrap + (x.unwrapped ? p : 0);
                  const S = x.polygon.map(($) => r.aq(t.tileTransform, $, w));
                  if (!r.ar(S, 0, 0, r.aj, r.aj)) return;
                  w =
                    t.tileID.wrap +
                    (this.screenGeometryMercator.unwrapped ? p : 0);
                  const C = this.screenGeometryMercator.polygon.map(($) =>
                      r.as(t.tileTransform, $, w),
                    ),
                    D = C.map(($) => new r.P($[0], $[1])),
                    L = s.getFreeCameraOptions().position || new r.ac(0, 0, 0),
                    z = r.as(t.tileTransform, L, w),
                    O = C.map(($) => {
                      const Z = r.at($, $, z);
                      return (r.au(Z, Z), new r.av(z, Z));
                    }),
                    G = r.aw(t, 1, s.zoom) * s._pixelsPerMercatorPixel;
                  return {
                    queryGeometry: this,
                    tilespaceGeometry: D,
                    tilespaceRays: O,
                    bufferedTilespaceGeometry: S,
                    bufferedTilespaceBounds:
                      ((U = r.ax(S)),
                      (U.min.x = r.ay(U.min.x, 0, r.aj)),
                      (U.min.y = r.ay(U.min.y, 0, r.aj)),
                      (U.max.x = r.ay(U.max.x, 0, r.aj)),
                      (U.max.y = r.ay(U.max.y, 0, r.aj)),
                      U),
                    tile: t,
                    tileID: t.tileID,
                    pixelToTileUnitsFactor: G,
                  };
                  var U;
                }
                _bufferedScreenMercator(t, s) {
                  const h = Tn(t);
                  if (this._screenRaycastCache[h])
                    return this._screenRaycastCache[h];
                  {
                    let p;
                    return (
                      (p =
                        s.projection.name === "globe"
                          ? this._projectAndResample(
                              this.bufferedScreenGeometry(t),
                              s,
                            )
                          : {
                              polygon: this.bufferedScreenGeometry(t).map((g) =>
                                s.pointCoordinate3D(g),
                              ),
                              unwrapped: !0,
                            }),
                      (this._screenRaycastCache[h] = p),
                      p
                    );
                  }
                }
                _bufferedCameraMercator(t, s) {
                  const h = Tn(t);
                  if (this._cameraRaycastCache[h])
                    return this._cameraRaycastCache[h];
                  {
                    let p;
                    return (
                      (p =
                        s.projection.name === "globe"
                          ? this._projectAndResample(
                              this.bufferedCameraGeometryGlobe(t),
                              s,
                            )
                          : {
                              polygon: this.bufferedCameraGeometry(t).map((g) =>
                                s.pointCoordinate3D(g),
                              ),
                              unwrapped: !0,
                            }),
                      (this._cameraRaycastCache[h] = p),
                      p
                    );
                  }
                }
                _projectAndResample(t, s) {
                  const h = (function (g, x) {
                    const w = r.az([], x.pixelMatrix, x.globeMatrix),
                      S = [0, -r.aB, 0, 1],
                      C = [0, r.aB, 0, 1],
                      D = [0, 0, 0, 1];
                    (r.aA(S, S, w), r.aA(C, C, w), r.aA(D, D, w));
                    const L = new r.P(S[0] / S[3], S[1] / S[3]),
                      z = new r.P(C[0] / C[3], C[1] / C[3]),
                      O = r.aC(g, L) && S[3] < D[3],
                      G = r.aC(g, z) && C[3] < D[3];
                    if (!O && !G) return null;
                    const U = (function (ce, le, me) {
                      for (let _e = 1; _e < ce.length; _e++) {
                        const De = Mn(le.pointCoordinate3D(ce[_e - 1]).x),
                          ze = Mn(le.pointCoordinate3D(ce[_e]).x);
                        if (me < 0) {
                          if (De < ze)
                            return { idx: _e, t: -De / (ze - 1 - De) };
                        } else if (ze < De)
                          return { idx: _e, t: (1 - De) / (ze + 1 - De) };
                      }
                      return null;
                    })(g, x, O ? -1 : 1);
                    if (!U) return null;
                    const { idx: $, t: Z } = U;
                    let Y = $ > 1 ? On(g.slice(0, $), x) : [],
                      ie = $ < g.length ? On(g.slice($), x) : [];
                    ((Y = Y.map((ce) => new r.P(Mn(ce.x), ce.y))),
                      (ie = ie.map((ce) => new r.P(Mn(ce.x), ce.y))));
                    const ae = [...Y];
                    ae.length === 0 && ae.push(ie[ie.length - 1]);
                    const pe = r.ai(
                      ae[ae.length - 1].y,
                      (ie.length === 0 ? Y[0] : ie[0]).y,
                      Z,
                    );
                    let ue;
                    return (
                      (ue = O
                        ? [
                            new r.P(0, pe),
                            new r.P(0, 0),
                            new r.P(1, 0),
                            new r.P(1, pe),
                          ]
                        : [
                            new r.P(1, pe),
                            new r.P(1, 1),
                            new r.P(0, 1),
                            new r.P(0, pe),
                          ]),
                      ae.push(...ue),
                      ie.length === 0 ? ae.push(Y[0]) : ae.push(...ie),
                      {
                        polygon: ae.map((ce) => new r.ac(ce.x, ce.y)),
                        unwrapped: !1,
                      }
                    );
                  })(t, s);
                  if (h) return h;
                  const p = (function (g, x) {
                    let w = !1,
                      S = -1 / 0,
                      C = 0;
                    for (let L = 0; L < g.length - 1; L++)
                      g[L].x > S && ((S = g[L].x), (C = L));
                    for (let L = 0; L < g.length - 1; L++) {
                      const z = (C + L) % (g.length - 1),
                        O = g[z],
                        G = g[z + 1];
                      Math.abs(O.x - G.x) > 0.5 &&
                        (O.x < G.x
                          ? ((O.x += 1), z === 0 && (g[g.length - 1].x += 1))
                          : ((G.x += 1),
                            z + 1 === g.length - 1 && (g[0].x += 1)),
                        (w = !0));
                    }
                    const D = r.aD(x.center.lng);
                    return (
                      w &&
                        D < Math.abs(D - 1) &&
                        g.forEach((L) => {
                          L.x -= 1;
                        }),
                      { polygon: g, unwrapped: w }
                    );
                  })(
                    On(t, s).map((g) => new r.P(Mn(g.x), g.y)),
                    s,
                  );
                  return {
                    polygon: p.polygon.map((g) => new r.ac(g.x, g.y)),
                    unwrapped: p.unwrapped,
                  };
                }
              }
              function On(c, t) {
                return r.aE(
                  c,
                  (s) => {
                    const h = t.pointCoordinate3D(s);
                    ((s.x = h.x), (s.y = h.y));
                  },
                  1 / 256,
                );
              }
              function Mn(c) {
                return c < 0 ? 1 + (c % 1) : c % 1;
              }
              function Tn(c) {
                return (100 * c) | 0;
              }
              function ar(c, t, s, h, p) {
                const g = function (w, S) {
                    if (w) return p(w);
                    if (S) {
                      if (
                        (c.url && S.tiles && c.tiles && delete c.tiles,
                        S.variants)
                      ) {
                        if (!Array.isArray(S.variants))
                          return p(new Error("variants must be an array"));
                        for (const D of S.variants) {
                          if (
                            D == null ||
                            typeof D != "object" ||
                            D.constructor !== Object
                          )
                            return p(new Error("variant must be an object"));
                          if (!Array.isArray(D.capabilities))
                            return p(
                              new Error("capabilities must be an array"),
                            );
                          if (
                            D.capabilities.length === 1 &&
                            D.capabilities[0] === "meshopt"
                          ) {
                            S = r.h(S, D);
                            break;
                          }
                        }
                      }
                      const C = r.aF(r.h({}, S, c), [
                        "tilejson",
                        "tiles",
                        "minzoom",
                        "maxzoom",
                        "attribution",
                        "mapbox_logo",
                        "bounds",
                        "extra_bounds",
                        "scheme",
                        "tileSize",
                        "encoding",
                        "vector_layers",
                        "raster_layers",
                        "worldview_options",
                        "worldview_default",
                        "worldview",
                      ]);
                      ((C.tiles = t.canonicalizeTileset(C, c.url)), p(null, C));
                    }
                  },
                  x = (function (w, S, C) {
                    if (!w) return null;
                    if (!S && !C) return w;
                    C = C || w.worldview_default;
                    const D = Object.values(w.language || {});
                    if (D.length === 0) return null;
                    const L = Object.values(w.worldview || {});
                    if (L.length === 0) return null;
                    const z = D.every((G) => G === S),
                      O = L.every((G) => G === C);
                    return z && O
                      ? w
                      : S in (w.language_options || {}) ||
                          C in (w.worldview_options || {})
                        ? null
                        : w.language_options && w.worldview_options
                          ? w
                          : null;
                  })(c.data, s, h);
                return x
                  ? r.q.frame(() => g(null, x))
                  : c.url
                    ? r.n(
                        t.transformRequest(
                          t.normalizeSourceURL(c.url, null, s, h),
                          r.R.Source,
                        ),
                        g,
                      )
                    : r.q.frame(() => {
                        const { data: w, ...S } = c;
                        g(null, S);
                      });
              }
              function Ur(c, t) {
                const s = Math.pow(2, t.z),
                  h = Math.floor(r.aD(c.getWest()) * s),
                  p = Math.floor(r.aH(c.getNorth()) * s),
                  g = Math.ceil(r.aD(c.getEast()) * s),
                  x = Math.ceil(r.aH(c.getSouth()) * s);
                return t.x >= h && t.x < g && t.y >= p && t.y < x;
              }
              class Tr {
                constructor(t, s, h) {
                  ((this.bounds = t
                    ? r.aG.convert(this.validateBounds(t))
                    : null),
                    (this.minzoom = s || 0),
                    (this.maxzoom = h || 24));
                }
                validateBounds(t) {
                  return Array.isArray(t) && t.length === 4
                    ? [
                        Math.max(-180, t[0]),
                        Math.max(-90, t[1]),
                        Math.min(180, t[2]),
                        Math.min(90, t[3]),
                      ]
                    : [-180, -90, 180, 90];
                }
                addExtraBounds(t) {
                  if (t) {
                    this.extraBounds || (this.extraBounds = []);
                    for (const s of t)
                      this.extraBounds.push(
                        r.aG.convert(this.validateBounds(s)),
                      );
                  }
                }
                contains(t) {
                  if (
                    t.z > this.maxzoom ||
                    t.z < this.minzoom ||
                    (this.bounds && !Ur(this.bounds, t))
                  )
                    return !1;
                  if (!this.extraBounds) return !0;
                  for (const s of this.extraBounds) if (Ur(s, t)) return !0;
                  return !1;
                }
                static fromTileJSON(t) {
                  if (!t.bounds && !t.extra_bounds) return null;
                  const s = new Tr(t.bounds, t.minzoom, t.maxzoom);
                  return (s.addExtraBounds(t.extra_bounds), s);
                }
              }
              class sc extends r.E {
                constructor(t, s, h, p) {
                  if (
                    (super(),
                    (this.id = t),
                    (this.dispatcher = h),
                    (this.type = "vector"),
                    (this.minzoom = 0),
                    (this.maxzoom = 22),
                    (this.scheme = "xyz"),
                    (this.tileSize = 512),
                    (this.reparseOverscaled = !0),
                    (this.isTileClipped = !0),
                    (this._loaded = !1),
                    r.h(
                      this,
                      r.aF(s, ["url", "scheme", "tileSize", "promoteId"]),
                    ),
                    (this._options = r.h({ type: "vector" }, s)),
                    (this._collectResourceTiming = !!s.collectResourceTiming),
                    this.tileSize !== 512)
                  )
                    throw new Error(
                      "vector tile sources must have a tileSize of 512",
                    );
                  (this.setEventedParent(p),
                    (this._tileWorkers = {}),
                    (this._deduped = new r.aI()));
                }
                load(t) {
                  ((this._loaded = !1),
                    this.fire(new r.A("dataloading", { dataType: "source" })));
                  const s = Array.isArray(this.map._language)
                      ? this.map._language.join()
                      : this.map._language,
                    h = this.map.getWorldview();
                  this._tileJSONRequest = ar(
                    this._options,
                    this.map._requestManager,
                    s,
                    h,
                    (p, g) => {
                      if (
                        ((this._tileJSONRequest = null), (this._loaded = !0), p)
                      )
                        (s &&
                          console.warn(
                            `Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${s}`,
                          ),
                          h &&
                            console.warn(
                              `Requested worldview strings must be a valid ISO alpha-2 code. Found: ${h}`,
                            ),
                          this.fire(new r.z(p)));
                      else if (g) {
                        if (
                          (r.h(this, g),
                          (this.hasWorldviews = !!g.worldview_options),
                          g.worldview_default &&
                            (this.worldviewDefault = g.worldview_default),
                          g.vector_layers)
                        ) {
                          ((this.vectorLayers = g.vector_layers),
                            (this.vectorLayerIds = []),
                            (this.localizableLayerIds = new Set()));
                          for (const x of g.vector_layers)
                            (this.vectorLayerIds.push(x.id),
                              g.worldview &&
                                g.worldview[x.source] &&
                                this.localizableLayerIds.add(x.id));
                        }
                        ((this.tileBounds = Tr.fromTileJSON(g)),
                          yr(
                            g.tiles,
                            this.map._requestManager._customAccessToken,
                          ),
                          this.fire(
                            new r.A("data", {
                              dataType: "source",
                              sourceDataType: "metadata",
                            }),
                          ),
                          this.fire(
                            new r.A("data", {
                              dataType: "source",
                              sourceDataType: "content",
                            }),
                          ));
                      }
                      t && t(p);
                    },
                  );
                }
                loaded() {
                  return this._loaded;
                }
                hasTile(t) {
                  return (
                    !this.tileBounds || this.tileBounds.contains(t.canonical)
                  );
                }
                onAdd(t) {
                  ((this.map = t), this.load());
                }
                reload() {
                  this.cancelTileJSONRequest();
                  const t = r.C(this.id, this.scope);
                  this.load(() => this.map.style.clearSource(t));
                }
                setTiles(t) {
                  return ((this._options.tiles = t), this.reload(), this);
                }
                setUrl(t) {
                  return (
                    (this.url = t),
                    (this._options.url = t),
                    this.reload(),
                    this
                  );
                }
                onRemove(t) {
                  this.cancelTileJSONRequest();
                }
                serialize() {
                  return r.h({}, this._options);
                }
                loadTile(t, s) {
                  const h = t.tileID.canonical.url(this.tiles, this.scheme),
                    p = this.map._requestManager.normalizeTileURL(h),
                    g = this.map._requestManager.transformRequest(p, r.R.Tile),
                    x = this.map.style
                      ? this.map.style.getLut(this.scope)
                      : null,
                    w = x ? { image: x.image.clone() } : null,
                    S = {
                      request: g,
                      data: void 0,
                      uid: t.uid,
                      tileID: t.tileID,
                      tileZoom: t.tileZoom,
                      zoom: t.tileID.overscaledZ,
                      maxZoom: this.maxzoom,
                      lut: w,
                      tileSize: this.tileSize * t.tileID.overscaleFactor(),
                      type: this.type,
                      source: this.id,
                      scope: this.scope,
                      pixelRatio: r.q.devicePixelRatio,
                      showCollisionBoxes: this.map.showCollisionBoxes,
                      promoteId: this.promoteId,
                      isSymbolTile: t.isSymbolTile,
                      brightness:
                        (this.map.style && this.map.style.getBrightness()) || 0,
                      extraShadowCaster: t.isExtraShadowCaster,
                      tessellationStep: this.map._tessellationStep,
                      scaleFactor: this.map.getScaleFactor(),
                      worldview:
                        this.map.getWorldview() || this.worldviewDefault,
                    };
                  if (
                    (this.hasWorldviews &&
                      r.j(h) &&
                      (S.localizableLayerIds = this.localizableLayerIds),
                    (S.request.collectResourceTiming =
                      this._collectResourceTiming),
                    t.actor && t.state !== "expired")
                  )
                    t.state === "loading"
                      ? (t.reloadCallback = s)
                      : (t.request = t.actor.send(
                          "reloadTile",
                          S,
                          C.bind(this),
                        ));
                  else if (
                    ((t.actor = this._tileWorkers[p] =
                      this._tileWorkers[p] || this.dispatcher.getActor()),
                    this.dispatcher.ready)
                  )
                    t.request = t.actor.send(
                      "loadTile",
                      S,
                      C.bind(this),
                      void 0,
                      !0,
                    );
                  else {
                    const D = r.aJ.call(
                      { deduped: this._deduped },
                      S,
                      (L, z) => {
                        L || !z
                          ? C.call(this, L)
                          : ((S.data = {
                              cacheControl: z.cacheControl,
                              expires: z.expires,
                              rawData: z.rawData.slice(0),
                            }),
                            t.actor &&
                              t.actor.send(
                                "loadTile",
                                S,
                                C.bind(this),
                                void 0,
                                !0,
                              ));
                      },
                      !0,
                    );
                    t.request = { cancel: D };
                  }
                  function C(D, L) {
                    return (
                      delete t.request,
                      t.aborted
                        ? s(null)
                        : D && D.status !== 404
                          ? s(D)
                          : (L &&
                              L.resourceTiming &&
                              (t.resourceTiming = L.resourceTiming),
                            this.map._refreshExpiredTiles &&
                              L &&
                              t.setExpiryData(L),
                            t.loadVectorData(L, this.map.painter),
                            r.aK(this.dispatcher),
                            s(null),
                            void (
                              t.reloadCallback &&
                              (this.loadTile(t, t.reloadCallback),
                              (t.reloadCallback = null))
                            ))
                    );
                  }
                }
                abortTile(t) {
                  (t.request && (t.request.cancel(), delete t.request),
                    t.actor &&
                      t.actor.send("abortTile", {
                        uid: t.uid,
                        type: this.type,
                        source: this.id,
                        scope: this.scope,
                      }));
                }
                unloadTile(t, s) {
                  (t.actor &&
                    t.actor.send("removeTile", {
                      uid: t.uid,
                      type: this.type,
                      source: this.id,
                      scope: this.scope,
                    }),
                    t.destroy());
                }
                hasTransition() {
                  return !1;
                }
                afterUpdate() {
                  this._tileWorkers = {};
                }
                cancelTileJSONRequest() {
                  this._tileJSONRequest &&
                    (this._tileJSONRequest.cancel(),
                    (this._tileJSONRequest = null));
                }
              }
              class hr extends r.E {
                constructor(t, s, h, p) {
                  (super(),
                    (this.id = t),
                    (this.dispatcher = h),
                    this.setEventedParent(p),
                    (this.type = "raster"),
                    (this.minzoom = 0),
                    (this.maxzoom = 22),
                    (this.roundZoom = !0),
                    (this.scheme = "xyz"),
                    (this.tileSize = 512),
                    (this._loaded = !1),
                    (this._options = r.h({ type: "raster" }, s)),
                    r.h(this, r.aF(s, ["url", "scheme", "tileSize"])));
                }
                load(t) {
                  ((this._loaded = !1),
                    this.fire(new r.A("dataloading", { dataType: "source" })));
                  const s = this.map.getWorldview();
                  this._tileJSONRequest = ar(
                    this._options,
                    this.map._requestManager,
                    null,
                    s,
                    (h, p) => {
                      ((this._tileJSONRequest = null),
                        (this._loaded = !0),
                        h
                          ? this.fire(new r.z(h))
                          : p &&
                            (r.h(this, p),
                            p.raster_layers &&
                              ((this.rasterLayers = p.raster_layers),
                              (this.rasterLayerIds = this.rasterLayers.map(
                                (g) => g.id,
                              ))),
                            (this.tileBounds = Tr.fromTileJSON(p)),
                            yr(p.tiles),
                            this.fire(
                              new r.A("data", {
                                dataType: "source",
                                sourceDataType: "metadata",
                              }),
                            ),
                            this.fire(
                              new r.A("data", {
                                dataType: "source",
                                sourceDataType: "content",
                              }),
                            )),
                        t && t(h));
                    },
                  );
                }
                loaded() {
                  return this._loaded;
                }
                onAdd(t) {
                  ((this.map = t), this.load());
                }
                reload() {
                  this.cancelTileJSONRequest();
                  const t = r.C(this.id, this.scope);
                  this.load(() => this.map.style.clearSource(t));
                }
                setTiles(t) {
                  return ((this._options.tiles = t), this.reload(), this);
                }
                setUrl(t) {
                  return (
                    (this.url = t),
                    (this._options.url = t),
                    this.reload(),
                    this
                  );
                }
                onRemove(t) {
                  this.cancelTileJSONRequest();
                }
                serialize() {
                  return r.h({}, this._options);
                }
                hasTile(t) {
                  return (
                    !this.tileBounds || this.tileBounds.contains(t.canonical)
                  );
                }
                loadTile(t, s) {
                  const h = r.q.devicePixelRatio >= 2,
                    p = this.map._requestManager.normalizeTileURL(
                      t.tileID.canonical.url(this.tiles, this.scheme),
                      h,
                      this.tileSize,
                    );
                  t.request = r.o(
                    this.map._requestManager.transformRequest(p, r.R.Tile),
                    (g, x, w, S) => (
                      delete t.request,
                      t.aborted
                        ? ((t.state = "unloaded"), s(null))
                        : g
                          ? ((t.state = "errored"), s(g))
                          : x
                            ? (this.map._refreshExpiredTiles &&
                                t.setExpiryData({
                                  cacheControl: w,
                                  expires: S,
                                }),
                              t.setTexture(x, this.map.painter),
                              (t.state = "loaded"),
                              r.aK(this.dispatcher),
                              void s(null))
                            : s(null)
                    ),
                  );
                }
                abortTile(t, s) {
                  (t.request && (t.request.cancel(), delete t.request),
                    s && s());
                }
                unloadTile(t, s) {
                  (t.texture && t.texture instanceof r.T
                    ? (t.destroy(!0),
                      t.texture &&
                        t.texture instanceof r.T &&
                        this.map.painter.saveTileTexture(t.texture))
                    : t.destroy(),
                    s && s());
                }
                hasTransition() {
                  return !1;
                }
                cancelTileJSONRequest() {
                  this._tileJSONRequest &&
                    (this._tileJSONRequest.cancel(),
                    (this._tileJSONRequest = null));
                }
              }
              class Po extends hr {
                constructor(t, s, h, p) {
                  (super(t, s, h, p),
                    (this.type = "raster-array"),
                    (this.maxzoom = 22),
                    (this.partial = !0),
                    (this._options = r.h({ type: "raster-array" }, s)));
                }
                triggerRepaint(t) {
                  const s = this.map.painter._terrain,
                    h = this.map.style.getSourceCache(this.id);
                  (s &&
                    s.enabled &&
                    h &&
                    s._clearRenderCacheForTile(h.id, t.tileID),
                    this.map.triggerRepaint());
                }
                loadTile(t, s) {
                  const h = this.map._requestManager.normalizeTileURL(
                      t.tileID.canonical.url(this.tiles, this.scheme),
                      !1,
                      this.tileSize,
                    ),
                    p = this.map._requestManager.transformRequest(h, r.R.Tile),
                    g = {
                      request: p,
                      uid: t.uid,
                      tileID: t.tileID,
                      type: this.type,
                      source: this.id,
                      scope: this.scope,
                      partial: this.partial,
                    };
                  ((t.source = this.id),
                    (t.scope = this.scope),
                    (t.requestParams = p),
                    t.actor || (t.actor = this.dispatcher.getActor()));
                  const x = (w, S, C, D) => {
                    if ((delete t.request, t.aborted))
                      return ((t.state = "unloaded"), s(null));
                    if (w)
                      return w.name === "AbortError"
                        ? void 0
                        : ((t.state = "errored"), s(w));
                    if (
                      (this.map._refreshExpiredTiles &&
                        S &&
                        t.setExpiryData({ cacheControl: C, expires: D }),
                      this.partial)
                    )
                      t.state = "empty";
                    else {
                      if (!S) return s(null);
                      ((t.state = "loaded"),
                        (t._isHeaderLoaded = !0),
                        (t._mrt = S));
                    }
                    s(null);
                  };
                  t.request = this.partial
                    ? t.fetchHeader(void 0, x.bind(this))
                    : t.actor.send("loadTile", g, x.bind(this), void 0, !0);
                }
                abortTile(t) {
                  (t.request && (t.request.cancel(), delete t.request),
                    t.actor &&
                      t.actor.send("abortTile", {
                        uid: t.uid,
                        type: this.type,
                        source: this.id,
                        scope: this.scope,
                      }));
                }
                unloadTile(t, s) {
                  const h = t.texture;
                  (h && h instanceof r.T
                    ? (t.destroy(!0), this.map.painter.saveTileTexture(h))
                    : (t.destroy(),
                      t.flushQueues(),
                      (t._isHeaderLoaded = !1),
                      delete t._mrt,
                      delete t.textureDescriptor),
                    t.fbo && (t.fbo.destroy(), delete t.fbo),
                    delete t.request,
                    delete t.requestParams,
                    delete t.neighboringTiles,
                    (t.state = "unloaded"));
                }
                prepareTile(t, s, h) {
                  t._isHeaderLoaded &&
                    (t.state !== "empty" && (t.state = "reloading"),
                    t.fetchBand(s, h, (p, g) => {
                      if (p)
                        return (
                          (t.state = "errored"),
                          this.fire(new r.z(p)),
                          void this.triggerRepaint(t)
                        );
                      g &&
                        ((t._isHeaderLoaded = !0),
                        t.setTexture(g, this.map.painter),
                        (t.state = "loaded"),
                        this.triggerRepaint(t));
                    }));
                }
                getInitialBand(t) {
                  if (!this.rasterLayers) return 0;
                  const s = this.rasterLayers.find(({ id: g }) => g === t),
                    h = s && s.fields,
                    p = h && h.bands && h.bands;
                  return p ? p[0] : 0;
                }
                getTextureDescriptor(t, s, h) {
                  if (!t) return;
                  const p =
                    s.sourceLayer ||
                    (this.rasterLayerIds && this.rasterLayerIds[0]);
                  if (!p) return;
                  let g = null;
                  s instanceof r.aN
                    ? (g = s.paint.get("raster-array-band"))
                    : s instanceof r.aO &&
                      (g = s.paint.get("raster-particle-array-band"));
                  const x = g || this.getInitialBand(p);
                  if (x != null)
                    if (t.textureDescriptor) {
                      if (!t.updateNeeded(p, x) || h)
                        return Object.assign({}, t.textureDescriptor, {
                          texture: t.texture,
                        });
                    } else this.prepareTile(t, p, x);
                }
                getImages(t, s) {
                  const h = new Map();
                  for (const p of t)
                    for (const g of s) {
                      const [x, w] = g.split("/"),
                        S = p.getLayer(x);
                      if (!S || !S.hasBand(w) || !S.hasDataForBand(w)) continue;
                      const {
                          bytes: C,
                          tileSize: D,
                          buffer: L,
                        } = S.getBandView(w),
                        z = D + 2 * L,
                        O = {
                          data: new r.r({ width: z, height: z }, C),
                          pixelRatio: 2,
                          sdf: !1,
                          usvg: !1,
                          version: 0,
                        };
                      h.set(g, O);
                    }
                  return h;
                }
              }
              const Eh = {
                  vector: sc,
                  raster: hr,
                  "raster-dem": class extends hr {
                    constructor(c, t, s, h) {
                      (super(c, t, s, h),
                        (this.type = "raster-dem"),
                        (this.maxzoom = 22),
                        (this._options = r.h({ type: "raster-dem" }, t)),
                        (this.encoding = t.encoding || "mapbox"));
                    }
                    loadTile(c, t) {
                      const s = this.map._requestManager.normalizeTileURL(
                        c.tileID.canonical.url(this.tiles, this.scheme),
                        !1,
                        this.tileSize,
                      );
                      function h(p, g) {
                        (p && ((c.state = "errored"), t(p)),
                          g &&
                            ((c.dem = g),
                            c.dem.onDeserialize(),
                            (c.needsHillshadePrepare = !0),
                            (c.needsDEMTextureUpload = !0),
                            (c.state = "loaded"),
                            t(null)));
                      }
                      c.request = r.o(
                        this.map._requestManager.transformRequest(s, r.R.Tile),
                        function (p, g, x, w) {
                          if ((delete c.request, c.aborted))
                            ((c.state = "unloaded"), t(null));
                          else if (p) ((c.state = "errored"), t(p));
                          else if (g) {
                            this.map._refreshExpiredTiles &&
                              c.setExpiryData({ cacheControl: x, expires: w });
                            const S =
                                ImageBitmap &&
                                g instanceof ImageBitmap &&
                                r.t(),
                              C = 1 - (g.width - r.aL(g.width)) / 2;
                            C < 1 ||
                              c.neighboringTiles ||
                              (c.neighboringTiles = this._getNeighboringTiles(
                                c.tileID,
                              ));
                            const D = S ? g : r.q.getImageData(g, C),
                              L = {
                                uid: c.uid,
                                tileID: c.tileID,
                                source: this.id,
                                type: this.type,
                                scope: this.scope,
                                rawImageData: D,
                                encoding: this.encoding,
                                padding: C,
                              };
                            (c.actor && c.state !== "expired") ||
                              ((c.actor = this.dispatcher.getActor()),
                              c.actor.send(
                                "loadTile",
                                L,
                                h.bind(this),
                                void 0,
                                !0,
                              ));
                          }
                        }.bind(this),
                      );
                    }
                    _getNeighboringTiles(c) {
                      const t = c.canonical,
                        s = Math.pow(2, t.z),
                        h = (t.x - 1 + s) % s,
                        p = t.x === 0 ? c.wrap - 1 : c.wrap,
                        g = (t.x + 1 + s) % s,
                        x = t.x + 1 === s ? c.wrap + 1 : c.wrap,
                        w = {};
                      return (
                        (w[new r.aM(c.overscaledZ, p, t.z, h, t.y).key] = {
                          backfilled: !1,
                        }),
                        (w[new r.aM(c.overscaledZ, x, t.z, g, t.y).key] = {
                          backfilled: !1,
                        }),
                        t.y > 0 &&
                          ((w[new r.aM(c.overscaledZ, p, t.z, h, t.y - 1).key] =
                            { backfilled: !1 }),
                          (w[
                            new r.aM(
                              c.overscaledZ,
                              c.wrap,
                              t.z,
                              t.x,
                              t.y - 1,
                            ).key
                          ] = { backfilled: !1 }),
                          (w[new r.aM(c.overscaledZ, x, t.z, g, t.y - 1).key] =
                            { backfilled: !1 })),
                        t.y + 1 < s &&
                          ((w[new r.aM(c.overscaledZ, p, t.z, h, t.y + 1).key] =
                            { backfilled: !1 }),
                          (w[
                            new r.aM(
                              c.overscaledZ,
                              c.wrap,
                              t.z,
                              t.x,
                              t.y + 1,
                            ).key
                          ] = { backfilled: !1 }),
                          (w[new r.aM(c.overscaledZ, x, t.z, g, t.y + 1).key] =
                            { backfilled: !1 })),
                        w
                      );
                    }
                  },
                  "raster-array": Po,
                  geojson: class extends r.E {
                    constructor(c, t, s, h) {
                      (super(),
                        (this.id = c),
                        (this.type = "geojson"),
                        (this.minzoom = 0),
                        (this.maxzoom = 18),
                        (this.tileSize = 512),
                        (this.isTileClipped = !0),
                        (this.reparseOverscaled = !0),
                        (this._loaded = !1),
                        (this.actor = s.getActor()),
                        this.setEventedParent(h),
                        (this._data = t.data),
                        (this._options = r.h({}, t)),
                        (this._collectResourceTiming = t.collectResourceTiming),
                        t.maxzoom !== void 0 && (this.maxzoom = t.maxzoom),
                        t.minzoom !== void 0 && (this.minzoom = t.minzoom),
                        t.type && (this.type = t.type),
                        t.attribution && (this.attribution = t.attribution),
                        (this.promoteId = t.promoteId));
                      const p = r.aj / this.tileSize;
                      this.workerOptions = r.h(
                        {
                          source: this.id,
                          scope: this.scope,
                          cluster: t.cluster || !1,
                          geojsonVtOptions: {
                            buffer: (t.buffer !== void 0 ? t.buffer : 128) * p,
                            tolerance:
                              (t.tolerance !== void 0 ? t.tolerance : 0.375) *
                              p,
                            extent: r.aj,
                            maxZoom: this.maxzoom,
                            lineMetrics: t.lineMetrics || !1,
                            generateId: t.generateId || !1,
                          },
                          superclusterOptions: {
                            maxZoom:
                              t.clusterMaxZoom !== void 0
                                ? t.clusterMaxZoom
                                : this.maxzoom - 1,
                            minPoints: Math.max(2, t.clusterMinPoints || 2),
                            extent: r.aj,
                            radius:
                              (t.clusterRadius !== void 0
                                ? t.clusterRadius
                                : 50) * p,
                            log: !1,
                            generateId: t.generateId || !1,
                          },
                          clusterProperties: t.clusterProperties,
                          filter: t.filter,
                          dynamic: t.dynamic,
                        },
                        t.workerOptions,
                      );
                    }
                    onAdd(c) {
                      ((this.map = c), this.setData(this._data));
                    }
                    setData(c) {
                      return ((this._data = c), this._updateWorkerData(), this);
                    }
                    updateData(c) {
                      if (!this._options.dynamic)
                        return this.fire(
                          new r.z(
                            new Error(
                              "Can't call updateData on a GeoJSON source with dynamic set to false.",
                            ),
                          ),
                        );
                      if (
                        typeof c != "string" &&
                        (c.type === "Feature" &&
                          (c = { type: "FeatureCollection", features: [c] }),
                        c.type !== "FeatureCollection")
                      )
                        return this.fire(
                          new r.z(
                            new Error(
                              "Data to update should be a feature or a feature collection.",
                            ),
                          ),
                        );
                      if (
                        this._coalesce &&
                        typeof c != "string" &&
                        typeof this._data != "string" &&
                        this._data.type === "FeatureCollection"
                      ) {
                        const t = new Map();
                        for (const s of this._data.features) t.set(s.id, s);
                        for (const s of c.features) t.set(s.id, s);
                        this._data.features = [...t.values()];
                      } else this._data = c;
                      return (this._updateWorkerData(!0), this);
                    }
                    getClusterExpansionZoom(c, t) {
                      return (
                        this.actor.send(
                          "geojson.getClusterExpansionZoom",
                          { clusterId: c, source: this.id, scope: this.scope },
                          t,
                        ),
                        this
                      );
                    }
                    getClusterChildren(c, t) {
                      return (
                        this.actor.send(
                          "geojson.getClusterChildren",
                          { clusterId: c, source: this.id, scope: this.scope },
                          t,
                        ),
                        this
                      );
                    }
                    getClusterLeaves(c, t, s, h) {
                      return (
                        this.actor.send(
                          "geojson.getClusterLeaves",
                          {
                            source: this.id,
                            scope: this.scope,
                            clusterId: c,
                            limit: t,
                            offset: s,
                          },
                          h,
                        ),
                        this
                      );
                    }
                    _updateWorkerData(c = !1) {
                      if (this._pendingLoad) return void (this._coalesce = !0);
                      (this.fire(
                        new r.A("dataloading", { dataType: "source" }),
                      ),
                        (this._loaded = !1));
                      const t = r.h({ append: c }, this.workerOptions);
                      t.scope = this.scope;
                      const s = this._data;
                      (typeof s == "string"
                        ? ((t.request =
                            this.map._requestManager.transformRequest(
                              r.q.resolveURL(s),
                              r.R.Source,
                            )),
                          (t.request.collectResourceTiming =
                            this._collectResourceTiming))
                        : (t.data = JSON.stringify(s)),
                        (this._pendingLoad = this.actor.send(
                          `${this.type}.loadData`,
                          t,
                          (h, p) => {
                            if (
                              ((this._loaded = !0),
                              (this._pendingLoad = null),
                              h)
                            )
                              this.fire(new r.z(h));
                            else {
                              const g = {
                                dataType: "source",
                                sourceDataType: this._metadataFired
                                  ? "content"
                                  : "metadata",
                              };
                              (this._collectResourceTiming &&
                                p &&
                                p.resourceTiming &&
                                p.resourceTiming[this.id] &&
                                (g.resourceTiming = p.resourceTiming[this.id]),
                                c && (this._partialReload = !0),
                                this.fire(new r.A("data", g)),
                                (this._partialReload = !1),
                                (this._metadataFired = !0));
                            }
                            this._coalesce &&
                              (this._updateWorkerData(c),
                              (this._coalesce = !1));
                          },
                        )));
                    }
                    loaded() {
                      return this._loaded;
                    }
                    reload() {
                      const c = r.C(this.id, this.scope);
                      (this.map.style.clearSource(c), this._updateWorkerData());
                    }
                    loadTile(c, t) {
                      const s = c.actor ? "reloadTile" : "loadTile";
                      c.actor = this.actor;
                      const h = this.map.style
                          ? this.map.style.getLut(this.scope)
                          : null,
                        p = h ? { image: h.image.clone() } : null,
                        g = this._partialReload,
                        x = {
                          type: this.type,
                          uid: c.uid,
                          tileID: c.tileID,
                          tileZoom: c.tileZoom,
                          zoom: c.tileID.overscaledZ,
                          maxZoom: this.maxzoom,
                          tileSize: this.tileSize,
                          source: this.id,
                          lut: p,
                          scope: this.scope,
                          pixelRatio: r.q.devicePixelRatio,
                          showCollisionBoxes: this.map.showCollisionBoxes,
                          promoteId: this.promoteId,
                          brightness:
                            (this.map.style &&
                              this.map.style.getBrightness()) ||
                            0,
                          extraShadowCaster: c.isExtraShadowCaster,
                          scaleFactor: this.map.getScaleFactor(),
                          partial: g,
                          worldview: this.map.getWorldview(),
                        };
                      c.request = this.actor.send(
                        s,
                        x,
                        (w, S) =>
                          g && !S
                            ? ((c.state = "loaded"), t(null))
                            : (delete c.request,
                              c.destroy(),
                              c.aborted
                                ? t(null)
                                : w
                                  ? t(w)
                                  : (c.loadVectorData(
                                      S,
                                      this.map.painter,
                                      s === "reloadTile",
                                    ),
                                    t(null))),
                        void 0,
                        s === "loadTile",
                      );
                    }
                    abortTile(c) {
                      (c.request && (c.request.cancel(), delete c.request),
                        (c.aborted = !0));
                    }
                    unloadTile(c, t) {
                      (this.actor.send("removeTile", {
                        uid: c.uid,
                        type: this.type,
                        source: this.id,
                        scope: this.scope,
                      }),
                        c.destroy());
                    }
                    onRemove(c) {
                      this._pendingLoad && this._pendingLoad.cancel();
                    }
                    serialize() {
                      return r.h({}, this._options, {
                        type: this.type,
                        data: this._data,
                      });
                    }
                    hasTransition() {
                      return !1;
                    }
                  },
                  video: class extends r.aP {
                    constructor(c, t, s, h) {
                      (super(c, t, s, h),
                        (this.roundZoom = !0),
                        (this.type = "video"),
                        (this.options = t));
                    }
                    load() {
                      this._loaded = !1;
                      const c = this.options;
                      this.urls = [];
                      for (const t of c.urls)
                        this.urls.push(
                          this.map._requestManager.transformRequest(
                            t,
                            r.R.Source,
                          ).url,
                        );
                      r.aQ(this.urls, (t, s) => {
                        ((this._loaded = !0),
                          t
                            ? this.fire(new r.z(t))
                            : s &&
                              ((this.video = s),
                              (this.video.loop = !0),
                              this.video.setAttribute("playsinline", ""),
                              this.video.addEventListener("playing", () => {
                                this.map.triggerRepaint();
                              }),
                              this.map && this.video.play(),
                              this._finishLoading()));
                      });
                    }
                    pause() {
                      this.video && this.video.pause();
                    }
                    play() {
                      this.video && this.video.play();
                    }
                    seek(c) {
                      if (this.video) {
                        const t = this.video.seekable;
                        c < t.start(0) || c > t.end(0)
                          ? this.fire(
                              new r.z(
                                new r.V(
                                  `sources.${this.id}`,
                                  null,
                                  `Playback for this video can be set only between the ${t.start(0)} and ${t.end(0)}-second mark.`,
                                ),
                              ),
                            )
                          : (this.video.currentTime = c);
                      }
                    }
                    getVideo() {
                      return this.video;
                    }
                    onAdd(c) {
                      this.map ||
                        ((this.map = c),
                        this.load(),
                        this.video &&
                          (this.video.play(),
                          this.setCoordinates(this.coordinates)));
                    }
                    prepare() {
                      if (
                        Object.keys(this.tiles).length === 0 ||
                        this.video.readyState < 2
                      )
                        return;
                      const c = this.map.painter.context,
                        t = c.gl;
                      (this.texture
                        ? this.video.paused ||
                          (this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE),
                          t.texSubImage2D(
                            t.TEXTURE_2D,
                            0,
                            0,
                            0,
                            t.RGBA,
                            t.UNSIGNED_BYTE,
                            this.video,
                          ))
                        : ((this.texture = new r.T(c, this.video, t.RGBA8)),
                          this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE),
                          (this.width = this.video.videoWidth),
                          (this.height = this.video.videoHeight)),
                        this._prepareData(c));
                    }
                    serialize() {
                      return {
                        type: "video",
                        urls: this.urls,
                        coordinates: this.coordinates,
                      };
                    }
                    hasTransition() {
                      return this.video && !this.video.paused;
                    }
                  },
                  image: r.aP,
                  model: class extends r.E {
                    constructor(c, t, s, h) {
                      (super(),
                        (this.id = c),
                        (this.type = "model"),
                        (this.models = []),
                        (this._loaded = !1),
                        (this._options = t));
                    }
                    load() {
                      const c = [];
                      for (const t in this._options.models) {
                        const s = this._options.models[t],
                          h = r
                            .aS(
                              this.map._requestManager.transformRequest(
                                s.uri,
                                r.R.Model,
                              ).url,
                            )
                            .then((p) => {
                              if (!p) return;
                              const g = r.aT(p),
                                x = new r.aU(t, s.position, s.orientation, g);
                              (x.computeBoundsAndApplyParent(),
                                this.models.push(x));
                            })
                            .catch((p) => {
                              this.fire(
                                new r.z(
                                  new Error(
                                    `Could not load model ${t} from ${s.uri}: ${p.message}`,
                                  ),
                                ),
                              );
                            });
                        c.push(h);
                      }
                      Promise.allSettled(c)
                        .then(() => {
                          ((this._loaded = !0),
                            this.fire(
                              new r.A("data", {
                                dataType: "source",
                                sourceDataType: "metadata",
                              }),
                            ));
                        })
                        .catch((t) => {
                          ((this._loaded = !0),
                            this.fire(
                              new r.z(
                                new Error(
                                  `Could not load models: ${t.message}`,
                                ),
                              ),
                            ));
                        });
                    }
                    onAdd(c) {
                      ((this.map = c), this.load());
                    }
                    hasTransition() {
                      return !1;
                    }
                    loaded() {
                      return this._loaded;
                    }
                    getModels() {
                      return this.models;
                    }
                    loadTile(c, t) {}
                    serialize() {
                      return this._options;
                    }
                  },
                  "batched-model": class extends r.E {
                    constructor(c, t, s, h) {
                      (super(),
                        (this.type = "batched-model"),
                        (this.id = c),
                        (this.tileSize = 512),
                        (this._options = t),
                        (this.tiles = this._options.tiles),
                        (this.maxzoom = t.maxzoom || 19),
                        (this.minzoom = t.minzoom || 0),
                        (this.roundZoom = !0),
                        (this.usedInConflation = !0),
                        (this.dispatcher = s),
                        (this.reparseOverscaled = !1),
                        (this.scheme = "xyz"),
                        (this._loaded = !1),
                        this.setEventedParent(h));
                    }
                    onAdd(c) {
                      ((this.map = c), this.load());
                    }
                    reload() {
                      this.cancelTileJSONRequest();
                      const c = r.C(this.id, this.scope);
                      this.load(() => this.map.style.clearSource(c));
                    }
                    cancelTileJSONRequest() {
                      this._tileJSONRequest &&
                        (this._tileJSONRequest.cancel(),
                        (this._tileJSONRequest = null));
                    }
                    load(c) {
                      ((this._loaded = !1),
                        this.fire(
                          new r.A("dataloading", { dataType: "source" }),
                        ));
                      const t = Array.isArray(this.map._language)
                          ? this.map._language.join()
                          : this.map._language,
                        s = this.map.getWorldview();
                      this._tileJSONRequest = ar(
                        this._options,
                        this.map._requestManager,
                        t,
                        s,
                        (h, p) => {
                          ((this._tileJSONRequest = null),
                            (this._loaded = !0),
                            h
                              ? (t &&
                                  console.warn(
                                    `Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${t}`,
                                  ),
                                s &&
                                  s.length !== 2 &&
                                  console.warn(
                                    `Requested worldview strings must be a valid ISO alpha-2 code. Found: ${s}`,
                                  ),
                                this.fire(new r.z(h)))
                              : p &&
                                (r.h(this, p),
                                p.bounds &&
                                  (this.tileBounds = new Tr(
                                    p.bounds,
                                    this.minzoom,
                                    this.maxzoom,
                                  )),
                                yr(
                                  p.tiles,
                                  this.map._requestManager._customAccessToken,
                                ),
                                this.fire(
                                  new r.A("data", {
                                    dataType: "source",
                                    sourceDataType: "metadata",
                                  }),
                                ),
                                this.fire(
                                  new r.A("data", {
                                    dataType: "source",
                                    sourceDataType: "content",
                                  }),
                                )),
                            c && c(h));
                        },
                      );
                    }
                    hasTransition() {
                      return !1;
                    }
                    hasTile(c) {
                      return (
                        !this.tileBounds ||
                        this.tileBounds.contains(c.canonical)
                      );
                    }
                    loaded() {
                      return this._loaded;
                    }
                    loadTile(c, t) {
                      const s = this.map._requestManager.normalizeTileURL(
                          c.tileID.canonical.url(this.tiles, this.scheme),
                        ),
                        h = {
                          request: this.map._requestManager.transformRequest(
                            s,
                            r.R.Tile,
                          ),
                          data: void 0,
                          uid: c.uid,
                          tileID: c.tileID,
                          tileZoom: c.tileZoom,
                          zoom: c.tileID.overscaledZ,
                          tileSize: this.tileSize * c.tileID.overscaleFactor(),
                          type: this.type,
                          source: this.id,
                          scope: this.scope,
                          showCollisionBoxes: this.map.showCollisionBoxes,
                          isSymbolTile: c.isSymbolTile,
                          brightness:
                            (this.map.style &&
                              this.map.style.getBrightness()) ||
                            0,
                          pixelRatio: r.q.devicePixelRatio,
                          promoteId: this.promoteId,
                        };
                      if (c.actor && c.state !== "expired")
                        if (c.state === "loading") c.reloadCallback = t;
                        else {
                          if (c.buckets) {
                            const g = Object.values(c.buckets);
                            for (const x of g) x.dirty = !0;
                            return void (c.state = "loaded");
                          }
                          c.request = c.actor.send(
                            "reloadTile",
                            h,
                            p.bind(this),
                          );
                        }
                      else
                        ((c.actor = this.dispatcher.getActor()),
                          (c.request = c.actor.send(
                            "loadTile",
                            h,
                            p.bind(this),
                            void 0,
                            !0,
                          )));
                      function p(g, x) {
                        return c.aborted
                          ? t(null)
                          : g && g.status !== 404
                            ? t(g)
                            : (this.map._refreshExpiredTiles &&
                                x &&
                                c.setExpiryData(x),
                              c.loadModelData(x, this.map.painter),
                              (c.state = "loaded"),
                              void t(null));
                      }
                    }
                    serialize() {
                      return r.h({}, this._options);
                    }
                  },
                  canvas: class extends r.aP {
                    constructor(c, t, s, h) {
                      (super(c, t, s, h),
                        t.coordinates
                          ? (Array.isArray(t.coordinates) &&
                              t.coordinates.length === 4 &&
                              !t.coordinates.some(
                                (p) =>
                                  !Array.isArray(p) ||
                                  p.length !== 2 ||
                                  p.some((g) => typeof g != "number"),
                              )) ||
                            this.fire(
                              new r.z(
                                new r.V(
                                  `sources.${c}`,
                                  null,
                                  '"coordinates" property must be an array of 4 longitude/latitude array pairs',
                                ),
                              ),
                            )
                          : this.fire(
                              new r.z(
                                new r.V(
                                  `sources.${c}`,
                                  null,
                                  'missing required property "coordinates"',
                                ),
                              ),
                            ),
                        t.animate &&
                          typeof t.animate != "boolean" &&
                          this.fire(
                            new r.z(
                              new r.V(
                                `sources.${c}`,
                                null,
                                'optional "animate" property must be a boolean value',
                              ),
                            ),
                          ),
                        t.canvas
                          ? typeof t.canvas == "string" ||
                            t.canvas instanceof HTMLCanvasElement ||
                            this.fire(
                              new r.z(
                                new r.V(
                                  `sources.${c}`,
                                  null,
                                  '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance',
                                ),
                              ),
                            )
                          : this.fire(
                              new r.z(
                                new r.V(
                                  `sources.${c}`,
                                  null,
                                  'missing required property "canvas"',
                                ),
                              ),
                            ),
                        (this.options = t),
                        (this.animate = t.animate === void 0 || t.animate));
                    }
                    load() {
                      ((this._loaded = !0),
                        this.canvas ||
                          (this.canvas =
                            this.options.canvas instanceof HTMLCanvasElement
                              ? this.options.canvas
                              : document.getElementById(this.options.canvas)),
                        (this.width = this.canvas.width),
                        (this.height = this.canvas.height),
                        this._hasInvalidDimensions()
                          ? this.fire(
                              new r.z(
                                new Error(
                                  "Canvas dimensions cannot be less than or equal to zero.",
                                ),
                              ),
                            )
                          : ((this.play = function () {
                              ((this._playing = !0), this.map.triggerRepaint());
                            }),
                            (this.pause = function () {
                              this._playing &&
                                (this.prepare(), (this._playing = !1));
                            }),
                            this._finishLoading()));
                    }
                    getCanvas() {
                      return this.canvas;
                    }
                    onAdd(c) {
                      ((this.map = c),
                        this.load(),
                        this.canvas && this.animate && this.play());
                    }
                    onRemove(c) {
                      this.pause();
                    }
                    prepare() {
                      let c = !1;
                      if (
                        (this.canvas.width !== this.width &&
                          ((this.width = this.canvas.width), (c = !0)),
                        this.canvas.height !== this.height &&
                          ((this.height = this.canvas.height), (c = !0)),
                        this._hasInvalidDimensions() ||
                          Object.keys(this.tiles).length === 0)
                      )
                        return;
                      const t = this.map.painter.context;
                      (this.texture
                        ? (!c && !this._playing) ||
                          this.texture instanceof r.aR ||
                          this.texture.update(this.canvas, { premultiply: !0 })
                        : (this.texture = new r.T(t, this.canvas, t.gl.RGBA8, {
                            premultiply: !0,
                          })),
                        this._prepareData(t));
                    }
                    serialize() {
                      return { type: "canvas", coordinates: this.coordinates };
                    }
                    hasTransition() {
                      return this._playing;
                    }
                    _hasInvalidDimensions() {
                      for (const c of [this.canvas.width, this.canvas.height])
                        if (isNaN(c) || c <= 0) return !0;
                      return !1;
                    }
                  },
                  custom: class extends r.E {
                    constructor(c, t, s, h) {
                      (super(),
                        (this.id = c),
                        (this.type = "custom"),
                        (this._dataType = "raster"),
                        (this._dispatcher = s),
                        (this._implementation = t),
                        this.setEventedParent(h),
                        (this.scheme = "xyz"),
                        (this.minzoom = 0),
                        (this.maxzoom = 22),
                        (this.tileSize = 512),
                        (this._loaded = !1),
                        (this.roundZoom = !0),
                        this._implementation ||
                          this.fire(
                            new r.z(
                              new Error(
                                `Missing implementation for ${this.id} custom source`,
                              ),
                            ),
                          ),
                        this._implementation.loadTile ||
                          this.fire(
                            new r.z(
                              new Error(
                                `Missing loadTile implementation for ${this.id} custom source`,
                              ),
                            ),
                          ),
                        this._implementation.bounds &&
                          (this.tileBounds = new Tr(
                            this._implementation.bounds,
                            this.minzoom,
                            this.maxzoom,
                          )),
                        (t.update = this._update.bind(this)),
                        (t.clearTiles = this._clearTiles.bind(this)),
                        (t.coveringTiles = this._coveringTiles.bind(this)),
                        r.h(
                          this,
                          r.aF(t, [
                            "dataType",
                            "scheme",
                            "minzoom",
                            "maxzoom",
                            "tileSize",
                            "attribution",
                            "minTileCacheSize",
                            "maxTileCacheSize",
                          ]),
                        ));
                    }
                    serialize() {
                      return r.aF(this, [
                        "type",
                        "scheme",
                        "minzoom",
                        "maxzoom",
                        "tileSize",
                        "attribution",
                      ]);
                    }
                    load() {
                      ((this._loaded = !0),
                        this.fire(
                          new r.A("data", {
                            dataType: "source",
                            sourceDataType: "metadata",
                          }),
                        ),
                        this.fire(
                          new r.A("data", {
                            dataType: "source",
                            sourceDataType: "content",
                          }),
                        ));
                    }
                    loaded() {
                      return this._loaded;
                    }
                    onAdd(c) {
                      ((this.map = c),
                        (this._loaded = !1),
                        this.fire(
                          new r.A("dataloading", { dataType: "source" }),
                        ),
                        this._implementation.onAdd &&
                          this._implementation.onAdd(c),
                        this.load());
                    }
                    onRemove(c) {
                      this._implementation.onRemove &&
                        this._implementation.onRemove(c);
                    }
                    hasTile(c) {
                      if (this._implementation.hasTile) {
                        const { x: t, y: s, z: h } = c.canonical;
                        return this._implementation.hasTile({
                          x: t,
                          y: s,
                          z: h,
                        });
                      }
                      return (
                        !this.tileBounds ||
                        this.tileBounds.contains(c.canonical)
                      );
                    }
                    loadTile(c, t) {
                      const { x: s, y: h, z: p } = c.tileID.canonical,
                        g = new AbortController();
                      ((c.request = Promise.resolve(
                        this._implementation.loadTile(
                          { x: s, y: h, z: p },
                          { signal: g.signal },
                        ),
                      )
                        .then(
                          function (x) {
                            return (
                              delete c.request,
                              c.aborted
                                ? ((c.state = "unloaded"), t(null))
                                : x === void 0
                                  ? ((c.state = "errored"), t(null))
                                  : x === null
                                    ? (this.loadTileData(c, {
                                        width: this.tileSize,
                                        height: this.tileSize,
                                        data: null,
                                      }),
                                      (c.state = "loaded"),
                                      t(null))
                                    : (function (w) {
                                          return (
                                            w instanceof ImageData ||
                                            w instanceof HTMLCanvasElement ||
                                            w instanceof ImageBitmap ||
                                            w instanceof HTMLImageElement
                                          );
                                        })(x)
                                      ? (this.loadTileData(c, x),
                                        (c.state = "loaded"),
                                        void t(null))
                                      : ((c.state = "errored"),
                                        t(
                                          new Error(
                                            `Can't infer data type for ${this.id}, only raster data supported at the moment`,
                                          ),
                                        ))
                            );
                          }.bind(this),
                        )
                        .catch((x) => {
                          x.name !== "AbortError" &&
                            ((c.state = "errored"), t(x));
                        })),
                        (c.request.cancel = () => g.abort()));
                    }
                    loadTileData(c, t) {
                      c.setTexture(t, this.map.painter);
                    }
                    unloadTile(c, t) {
                      if (
                        (c.texture && c.texture instanceof r.T
                          ? (c.destroy(!0),
                            c.texture &&
                              c.texture instanceof r.T &&
                              this.map.painter.saveTileTexture(c.texture))
                          : c.destroy(),
                        this._implementation.unloadTile)
                      ) {
                        const { x: s, y: h, z: p } = c.tileID.canonical;
                        this._implementation.unloadTile({ x: s, y: h, z: p });
                      }
                      t && t();
                    }
                    abortTile(c, t) {
                      (c.request &&
                        c.request.cancel &&
                        (c.request.cancel(), delete c.request),
                        t && t());
                    }
                    hasTransition() {
                      return !1;
                    }
                    _coveringTiles() {
                      return this.map.transform
                        .coveringTiles({
                          tileSize: this.tileSize,
                          minzoom: this.minzoom,
                          maxzoom: this.maxzoom,
                          roundZoom: this.roundZoom,
                        })
                        .map((c) => ({
                          x: c.canonical.x,
                          y: c.canonical.y,
                          z: c.canonical.z,
                        }));
                    }
                    _clearTiles() {
                      const c = r.C(this.id, this.scope);
                      this.map.style.clearSource(c);
                    }
                    _update() {
                      this.fire(
                        new r.A("data", {
                          dataType: "source",
                          sourceDataType: "content",
                        }),
                      );
                    }
                  },
                },
                oc = function (c, t, s, h) {
                  const p = new Eh[t.type](c, t, s, h);
                  if (p.id !== c)
                    throw new Error(
                      `Expected Source id to be ${c} instead of ${p.id}`,
                    );
                  return (
                    r.aV(
                      ["load", "abort", "unload", "serialize", "prepare"],
                      p,
                    ),
                    p
                  );
                };
              function ac(c, t, s = "") {
                return `${s}:${t.id || ""}:${t.layer.id}:${(function (h) {
                  if ("layerId" in h) return `layer:${h.layerId}`;
                  {
                    const { featuresetId: p, importId: g } = h;
                    return `featureset:${p}${g ? `:import:${g}` : ""}`;
                  }
                })(c.target)}`;
              }
              function Ih(c, t, s, h = "") {
                if (c.uniqueFeatureID) {
                  const p = ac(c, t, h);
                  if (s.has(p)) return !0;
                  s.add(p);
                }
                return !1;
              }
              function Ah(c, t, s, h, p = !1) {
                const g = t.sourceCache.transform,
                  x = t.sourceCache.tilesIn(c, t.has3DLayers, p);
                x.sort(Mh);
                const w = [];
                for (const S of x) {
                  const C = S.tile.queryRenderedFeatures(t, S, s, h, g, p);
                  Object.keys(C).length &&
                    w.push({
                      wrappedTileID: S.tile.tileID.wrapped().key,
                      queryResults: C,
                    });
                }
                return w.length === 0
                  ? {}
                  : (function (S) {
                      const C = {},
                        D = {};
                      for (const L of S) {
                        const z = L.queryResults,
                          O = L.wrappedTileID,
                          G = (D[O] = D[O] || {});
                        for (const U in z) {
                          const $ = z[U],
                            Z = (G[U] = G[U] || {}),
                            Y = (C[U] = C[U] || []);
                          for (const ie of $)
                            Z[ie.featureIndex] ||
                              ((Z[ie.featureIndex] = !0), Y.push(ie));
                        }
                      }
                      return C;
                    })(w);
              }
              function da(c, t, s, h, p, g) {
                const x = {},
                  w = h.queryRenderedSymbols(c),
                  S = [];
                for (const C of Object.keys(w).map(Number)) S.push(p[C]);
                S.sort(Mh);
                for (const C of S) {
                  const D = C.featureIndex.lookupSymbolFeatures(
                    w[C.bucketInstanceId],
                    C.bucketIndex,
                    C.sourceLayerIndex,
                    t,
                    s,
                    g,
                  );
                  for (const L in D) {
                    const z = (x[L] = x[L] || []),
                      O = D[L];
                    O.sort((G, U) => {
                      const $ = C.featureSortOrder;
                      if ($) {
                        const Z = $.indexOf(G.featureIndex);
                        return $.indexOf(U.featureIndex) - Z;
                      }
                      return U.featureIndex - G.featureIndex;
                    });
                    for (const G of O) z.push(G);
                  }
                }
                return x;
              }
              function lc(c, t) {
                const s = c.getRenderableIds().map((g) => c.getTileByID(g)),
                  h = [],
                  p = {};
                for (let g = 0; g < s.length; g++) {
                  const x = s[g],
                    w = x.tileID.canonical.key;
                  p[w] || ((p[w] = !0), x.querySourceFeatures(h, t));
                }
                return h;
              }
              function Mh(c, t) {
                const s = c.tileID,
                  h = t.tileID;
                return (
                  s.overscaledZ - h.overscaledZ ||
                  s.canonical.y - h.canonical.y ||
                  s.wrap - h.wrap ||
                  s.canonical.x - h.canonical.x
                );
              }
              function As(c, t) {
                const s = {};
                if (!t) return s;
                for (const h of c) {
                  const p = h.layerIds
                    .map((g) => t.getLayer(g))
                    .filter(Boolean);
                  if (p.length !== 0) {
                    ((h.layers = p),
                      h.stateDependentLayerIds &&
                        (h.stateDependentLayers = h.stateDependentLayerIds.map(
                          (g) => p.filter((x) => x.id === g)[0],
                        )));
                    for (const g of p) s[g.fqid] = h;
                  }
                }
                return s;
              }
              const ss = 32,
                gs = 33,
                io = new Uint16Array(8184);
              for (let c = 0; c < 2046; c++) {
                let t = c + 2,
                  s = 0,
                  h = 0,
                  p = 0,
                  g = 0,
                  x = 0,
                  w = 0;
                for (
                  1 & t ? (p = g = x = ss) : (s = h = w = ss);
                  (t >>= 1) > 1;

                ) {
                  const C = (s + p) >> 1,
                    D = (h + g) >> 1;
                  (1 & t
                    ? ((p = s), (g = h), (s = x), (h = w))
                    : ((s = p), (h = g), (p = x), (g = w)),
                    (x = C),
                    (w = D));
                }
                const S = 4 * c;
                ((io[S + 0] = s),
                  (io[S + 1] = h),
                  (io[S + 2] = p),
                  (io[S + 3] = g));
              }
              const Ms = new Uint16Array(2178),
                no = new Uint8Array(1089),
                cc = new Uint16Array(1089);
              function Fs(c) {
                return c === 0 ? -0.03125 : c === 32 ? 0.03125 : 0;
              }
              const hc = {
                type: 2,
                extent: r.aj,
                loadGeometry: () => [
                  [
                    new r.P(0, 0),
                    new r.P(r.aj + 1, 0),
                    new r.P(r.aj + 1, r.aj + 1),
                    new r.P(0, r.aj + 1),
                    new r.P(0, 0),
                  ],
                ],
              };
              class fa {
                constructor(t, s, h, p, g, x) {
                  ((this.tileID = t),
                    (this.uid = r.a$()),
                    (this.uses = 0),
                    (this.tileSize = s),
                    (this.tileZoom = h),
                    (this.buckets = {}),
                    (this.expirationTime = null),
                    (this.queryPadding = 0),
                    (this.hasSymbolBuckets = !1),
                    (this.hasRTLText = !1),
                    (this.dependencies = {}),
                    (this.isRaster = g),
                    p &&
                      p.style &&
                      (this._lastUpdatedBrightness = p.style.getBrightness()),
                    (this.expiredRequestCount = 0),
                    (this.state = "loading"),
                    p &&
                      p.transform &&
                      (this.projection = p.transform.projection),
                    (this.worldview = x));
                }
                registerFadeDuration(t) {
                  const s = t + this.timeAdded;
                  s < r.q.now() ||
                    (this.fadeEndTime && s < this.fadeEndTime) ||
                    (this.fadeEndTime = s);
                }
                wasRequested() {
                  return (
                    this.state === "errored" ||
                    this.state === "loaded" ||
                    this.state === "reloading"
                  );
                }
                get tileTransform() {
                  return (
                    this._tileTransform ||
                      (this._tileTransform = r.aW(
                        this.tileID.canonical,
                        this.projection,
                      )),
                    this._tileTransform
                  );
                }
                loadVectorData(t, s, h) {
                  if ((this.unloadVectorData(), (this.state = "loaded"), t)) {
                    (t.featureIndex &&
                      ((this.latestFeatureIndex = t.featureIndex),
                      t.rawTileData
                        ? ((this.latestRawTileData = t.rawTileData),
                          (this.latestFeatureIndex.rawTileData = t.rawTileData))
                        : this.latestRawTileData &&
                          (this.latestFeatureIndex.rawTileData =
                            this.latestRawTileData)),
                      (this.collisionBoxArray = t.collisionBoxArray),
                      (this.buckets = As(t.buckets, s.style)),
                      (this.hasSymbolBuckets = !1));
                    for (const p in this.buckets) {
                      const g = this.buckets[p];
                      if (g instanceof r.b1) {
                        if (((this.hasSymbolBuckets = !0), !h)) break;
                        g.justReloaded = !0;
                      }
                    }
                    if (((this.hasRTLText = !1), this.hasSymbolBuckets))
                      for (const p in this.buckets) {
                        const g = this.buckets[p];
                        if (g instanceof r.b1 && g.hasRTLText) {
                          ((this.hasRTLText = !0), r.b2());
                          break;
                        }
                      }
                    this.queryPadding = 0;
                    for (const p in this.buckets) {
                      const g = this.buckets[p],
                        x = s.style.getOwnLayer(p);
                      if (!x) continue;
                      const w = x.queryRadius(g);
                      this.queryPadding = Math.max(this.queryPadding, w);
                    }
                    (t.imageAtlas && (this.imageAtlas = t.imageAtlas),
                      t.glyphAtlasImage &&
                        (this.glyphAtlasImage = t.glyphAtlasImage),
                      t.lineAtlas && (this.lineAtlas = t.lineAtlas),
                      (this._lastUpdatedBrightness = t.brightness));
                  } else this.collisionBoxArray = new r.b0();
                }
                unloadVectorData() {
                  if (this.hasData()) {
                    for (const t in this.buckets) this.buckets[t].destroy();
                    ((this.buckets = {}),
                      this.imageAtlas && (this.imageAtlas = null),
                      this.lineAtlas && (this.lineAtlas = null),
                      this.imageAtlasTexture &&
                        this.imageAtlasTexture.destroy(),
                      this.glyphAtlasTexture &&
                        this.glyphAtlasTexture.destroy(),
                      this.lineAtlasTexture && this.lineAtlasTexture.destroy(),
                      this._tileBoundsBuffer &&
                        (this._tileBoundsBuffer.destroy(),
                        this._tileBoundsIndexBuffer.destroy(),
                        this._tileBoundsSegments.destroy(),
                        (this._tileBoundsBuffer = null)),
                      this._tileDebugBuffer &&
                        (this._tileDebugBuffer.destroy(),
                        this._tileDebugSegments.destroy(),
                        (this._tileDebugBuffer = null)),
                      this._tileDebugIndexBuffer &&
                        (this._tileDebugIndexBuffer.destroy(),
                        (this._tileDebugIndexBuffer = null)),
                      this._globeTileDebugBorderBuffer &&
                        (this._globeTileDebugBorderBuffer.destroy(),
                        (this._globeTileDebugBorderBuffer = null)),
                      this._tileDebugTextBuffer &&
                        (this._tileDebugTextBuffer.destroy(),
                        this._tileDebugTextSegments.destroy(),
                        this._tileDebugTextIndexBuffer.destroy(),
                        (this._tileDebugTextBuffer = null)),
                      this._globeTileDebugTextBuffer &&
                        (this._globeTileDebugTextBuffer.destroy(),
                        (this._globeTileDebugTextBuffer = null)),
                      (this.latestFeatureIndex = null),
                      (this.state = "unloaded"));
                  }
                }
                loadModelData(t, s, h) {
                  t &&
                    (t.resourceTiming &&
                      (this.resourceTiming = t.resourceTiming),
                    (this.buckets = Object.assign(
                      {},
                      this.buckets,
                      As(t.buckets, s.style),
                    )),
                    t.featureIndex &&
                      (this.latestFeatureIndex = t.featureIndex));
                }
                getBucket(t) {
                  return this.buckets[t.fqid];
                }
                upload(t) {
                  for (const p in this.buckets) {
                    const g = this.buckets[p];
                    g.uploadPending() && g.upload(t);
                  }
                  const s = t.gl,
                    h = this.imageAtlas;
                  (h &&
                    !h.uploaded &&
                    ((this.imageAtlasTexture = new r.T(t, h.image, s.RGBA8, {
                      useMipmap: !!h.patternPositions.size,
                    })),
                    (this.imageAtlas.uploaded = !0)),
                    this.glyphAtlasImage &&
                      ((this.glyphAtlasTexture = new r.T(
                        t,
                        this.glyphAtlasImage,
                        s.R8,
                      )),
                      (this.glyphAtlasImage = null)),
                    this.lineAtlas &&
                      !this.lineAtlas.uploaded &&
                      ((this.lineAtlasTexture = new r.T(
                        t,
                        this.lineAtlas.image,
                        s.R8,
                      )),
                      (this.lineAtlas.uploaded = !0)));
                }
                prepare(t, s, h) {
                  if (
                    (this.imageAtlas &&
                      this.imageAtlasTexture &&
                      this.imageAtlas.patchUpdatedImages(
                        t,
                        this.imageAtlasTexture,
                        h,
                      ),
                    !s ||
                      !this.latestFeatureIndex ||
                      !this.latestFeatureIndex.rawTileData)
                  )
                    return;
                  const p = s.style.getBrightness();
                  (this._lastUpdatedBrightness || p) &&
                    ((this._lastUpdatedBrightness &&
                      p &&
                      Math.abs(this._lastUpdatedBrightness - p) < 0.001) ||
                      (this.updateBuckets(s, this._lastUpdatedBrightness !== p),
                      (this._lastUpdatedBrightness = p)));
                }
                queryRenderedFeatures(t, s, h, p, g, x) {
                  if (
                    !this.latestFeatureIndex ||
                    (!this.latestFeatureIndex.rawTileData &&
                      !this.latestFeatureIndex.is3DTile)
                  )
                    return {};
                  const w = (function (S, C) {
                    const D = r.bn([], [0.5 * S.width, 0.5 * -S.height, 1]);
                    return (
                      r.bo(D, D, [1, -1, 0]),
                      r.az(D, D, S.calculateProjMatrix(C.toUnwrapped())),
                      Float32Array.from(D)
                    );
                  })(g, this.tileID);
                  return this.latestFeatureIndex.query(t, {
                    tilespaceGeometry: s,
                    pixelPosMatrix: w,
                    transform: p,
                    availableImages: h,
                    tileTransform: this.tileTransform,
                    worldview: this.worldview,
                  });
                }
                querySourceFeatures(t, s) {
                  const h = this.latestFeatureIndex;
                  if (!h || !h.rawTileData) return;
                  const p = h.loadVTLayers(),
                    g = s ? s.sourceLayer : "",
                    x = p._geojsonTileLayer || p[g];
                  if (!x) return;
                  const w = r.b3(s && s.filter),
                    { z: S, x: C, y: D } = this.tileID.canonical,
                    L = { z: S, x: C, y: D };
                  for (let z = 0; z < x.length; z++) {
                    const O = x.feature(z);
                    if (w.needGeometry) {
                      const $ = r.b4(O, !0);
                      if (
                        !w.filter(
                          new r.aa(this.tileID.overscaledZ, {
                            worldview: this.worldview,
                          }),
                          $,
                          this.tileID.canonical,
                        )
                      )
                        continue;
                    } else if (
                      !w.filter(
                        new r.aa(this.tileID.overscaledZ, {
                          worldview: this.worldview,
                        }),
                        O,
                      )
                    )
                      continue;
                    const G = h.getId(O, g),
                      U = new r.b5(O, S, C, D, G);
                    ((U.tile = L), t.push(U));
                  }
                }
                loaded() {
                  return this.state === "loaded" || this.state === "errored";
                }
                hasData() {
                  return (
                    this.state === "loaded" ||
                    this.state === "reloading" ||
                    this.state === "expired"
                  );
                }
                patternsLoaded() {
                  return (
                    !!this.imageAtlas && !!this.imageAtlas.patternPositions.size
                  );
                }
                setExpiryData(t) {
                  const s = this.expirationTime;
                  if (t.cacheControl) {
                    const h = r.b6(t.cacheControl);
                    h["max-age"] &&
                      (this.expirationTime = Date.now() + 1e3 * h["max-age"]);
                  } else
                    t.expires &&
                      (this.expirationTime = new Date(t.expires).getTime());
                  if (this.expirationTime) {
                    const h = Date.now();
                    let p = !1;
                    if (this.expirationTime > h) p = !1;
                    else if (s)
                      if (this.expirationTime < s) p = !0;
                      else {
                        const g = this.expirationTime - s;
                        g
                          ? (this.expirationTime = h + Math.max(g, 3e4))
                          : (p = !0);
                      }
                    else p = !0;
                    p
                      ? (this.expiredRequestCount++, (this.state = "expired"))
                      : (this.expiredRequestCount = 0);
                  }
                }
                getExpiryTimeout() {
                  if (this.expirationTime)
                    return this.expiredRequestCount
                      ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31))
                      : Math.min(
                          this.expirationTime - new Date().getTime(),
                          Math.pow(2, 31) - 1,
                        );
                }
                refreshFeatureState(t) {
                  this.latestFeatureIndex &&
                    (this.latestFeatureIndex.rawTileData ||
                      this.latestFeatureIndex.is3DTile) &&
                    t &&
                    this.updateBuckets(t);
                }
                updateBuckets(t, s) {
                  if (!this.latestFeatureIndex || !t.style) return;
                  const h = this.latestFeatureIndex.loadVTLayers(),
                    p = t.style.listImages(),
                    g = t.style.getBrightness();
                  for (const x in this.buckets) {
                    if (!t.style.hasLayer(x)) continue;
                    const w = this.buckets[x],
                      S = w.layers[0],
                      C = S.sourceLayer || "_geojsonTileLayer",
                      D = h[C],
                      L = t.style.getLayerSourceCache(S);
                    let z = {};
                    L && (z = L._state.getState(C, void 0));
                    const O = this.imageAtlas
                        ? Object.fromEntries(this.imageAtlas.patternPositions)
                        : {},
                      G = Object.keys(z).length > 0 && !s;
                    ((G && !w.stateDependentLayers.length && !s) ||
                      w.update(
                        z,
                        D,
                        p,
                        O,
                        G ? w.stateDependentLayers : w.layers,
                        s,
                        g,
                      ),
                      (w instanceof r.b7 || w instanceof r.b8) &&
                        t._terrain &&
                        t._terrain.enabled &&
                        L &&
                        w.uploadPending() &&
                        t._terrain._clearRenderCacheForTile(L.id, this.tileID));
                    const U = t && t.style && t.style.getOwnLayer(x);
                    U &&
                      (this.queryPadding = Math.max(
                        this.queryPadding,
                        U.queryRadius(w),
                      ));
                  }
                }
                holdingForFade() {
                  return this.symbolFadeHoldUntil !== void 0;
                }
                symbolFadeFinished() {
                  return (
                    !this.symbolFadeHoldUntil ||
                    this.symbolFadeHoldUntil < r.q.now()
                  );
                }
                clearFadeHold() {
                  this.symbolFadeHoldUntil = void 0;
                }
                setHoldDuration(t) {
                  this.symbolFadeHoldUntil = r.q.now() + t;
                }
                setTexture(t, s) {
                  const h = s.context,
                    p = h.gl;
                  ((this.texture = this.texture || s.getTileTexture(t.width)),
                    this.texture && this.texture instanceof r.T
                      ? this.texture.update(t)
                      : ((this.texture = new r.T(h, t, p.RGBA8, {
                          useMipmap: !0,
                        })),
                        this.texture.bind(p.LINEAR, p.CLAMP_TO_EDGE)));
                }
                setDependencies(t, s) {
                  const h = {};
                  for (const p of s) h[p] = !0;
                  this.dependencies[t] = h;
                }
                hasDependency(t, s) {
                  for (const h of t) {
                    const p = this.dependencies[h];
                    if (p) {
                      for (const g of s) if (p[g]) return !0;
                    }
                  }
                  return !1;
                }
                clearQueryDebugViz() {}
                _makeDebugTileBoundsBuffers(t, s) {
                  if (!s || s.name === "mercator" || this._tileDebugBuffer)
                    return;
                  const h = r.b9(
                      hc,
                      this.tileID.canonical,
                      this.tileTransform,
                    )[0],
                    p = new r.ba(),
                    g = new r.bb();
                  for (let x = 0; x < h.length; x++) {
                    const { x: w, y: S } = h[x];
                    (p.emplaceBack(w, S), g.emplaceBack(x));
                  }
                  (g.emplaceBack(0),
                    (this._tileDebugIndexBuffer = t.createIndexBuffer(g)),
                    (this._tileDebugBuffer = t.createVertexBuffer(
                      p,
                      r.bc.members,
                    )),
                    (this._tileDebugSegments = r.bd.simpleSegment(
                      0,
                      0,
                      p.length,
                      g.length,
                    )));
                }
                _makeTileBoundsBuffers(t, s) {
                  if (this._tileBoundsBuffer || !s || s.name === "mercator")
                    return;
                  const h = r.b9(
                    hc,
                    this.tileID.canonical,
                    this.tileTransform,
                  )[0];
                  let p, g;
                  if (this.isRaster) {
                    const x = (function (w, S) {
                      const C = r.aW(w, S),
                        D = Math.pow(2, w.z);
                      for (let $ = 0; $ < gs; $++)
                        for (let Z = 0; Z < gs; Z++) {
                          const Y = r.aX((w.x + (Z + Fs(Z)) / ss) / D),
                            ie = r.aY((w.y + ($ + Fs($)) / ss) / D),
                            ae = S.project(Y, ie),
                            pe = $ * gs + Z;
                          ((Ms[2 * pe + 0] = Math.round(
                            (ae.x * C.scale - C.x) * r.aj,
                          )),
                            (Ms[2 * pe + 1] = Math.round(
                              (ae.y * C.scale - C.y) * r.aj,
                            )));
                        }
                      (no.fill(0), cc.fill(0));
                      for (let $ = 2045; $ >= 0; $--) {
                        const Z = 4 * $,
                          Y = io[Z + 0],
                          ie = io[Z + 1],
                          ae = io[Z + 2],
                          pe = io[Z + 3],
                          ue = (Y + ae) >> 1,
                          ce = (ie + pe) >> 1,
                          le = ue + ce - ie,
                          me = ce + Y - ue,
                          _e = ie * gs + Y,
                          De = pe * gs + ae,
                          ze = ce * gs + ue,
                          He =
                            Math.hypot(
                              (Ms[2 * _e + 0] + Ms[2 * De + 0]) / 2 -
                                Ms[2 * ze + 0],
                              (Ms[2 * _e + 1] + Ms[2 * De + 1]) / 2 -
                                Ms[2 * ze + 1],
                            ) >= 16;
                        ((no[ze] = no[ze] || (He ? 1 : 0)),
                          $ < 1022 &&
                            (no[ze] =
                              no[ze] ||
                              no[((ie + me) >> 1) * gs + ((Y + le) >> 1)] ||
                              no[((pe + me) >> 1) * gs + ((ae + le) >> 1)]));
                      }
                      const L = new r.aZ(),
                        z = new r.a_();
                      let O = 0;
                      function G($, Z) {
                        const Y = Z * gs + $;
                        return (
                          cc[Y] === 0 &&
                            (L.emplaceBack(
                              Ms[2 * Y + 0],
                              Ms[2 * Y + 1],
                              ($ * r.aj) / ss,
                              (Z * r.aj) / ss,
                            ),
                            (cc[Y] = ++O)),
                          cc[Y] - 1
                        );
                      }
                      function U($, Z, Y, ie, ae, pe) {
                        const ue = ($ + Y) >> 1,
                          ce = (Z + ie) >> 1;
                        if (
                          Math.abs($ - ae) + Math.abs(Z - pe) > 1 &&
                          no[ce * gs + ue]
                        )
                          (U(ae, pe, $, Z, ue, ce), U(Y, ie, ae, pe, ue, ce));
                        else {
                          const le = G($, Z),
                            me = G(Y, ie),
                            _e = G(ae, pe);
                          z.emplaceBack(le, me, _e);
                        }
                      }
                      return (
                        U(0, 0, ss, ss, ss, 0),
                        U(ss, ss, 0, 0, 0, ss),
                        { vertices: L, indices: z }
                      );
                    })(this.tileID.canonical, s);
                    ((p = x.vertices), (g = x.indices));
                  } else {
                    ((p = new r.aZ()), (g = new r.a_()));
                    for (const { x: w, y: S } of h) p.emplaceBack(w, S, 0, 0);
                    const x = r.be(
                      p.int16.subarray(0, 4 * p.length),
                      void 0,
                      4,
                    );
                    for (let w = 0; w < x.length; w += 3)
                      g.emplaceBack(x[w], x[w + 1], x[w + 2]);
                  }
                  ((this._tileBoundsBuffer = t.createVertexBuffer(
                    p,
                    r.bf.members,
                  )),
                    (this._tileBoundsIndexBuffer = t.createIndexBuffer(g)),
                    (this._tileBoundsSegments = r.bd.simpleSegment(
                      0,
                      0,
                      p.length,
                      g.length,
                    )));
                }
                _makeGlobeTileDebugBuffers(t, s) {
                  const h = s.projection;
                  if (!h || h.name !== "globe" || s.freezeTileCoverage) return;
                  const p = this.tileID.canonical,
                    g = r.bg(p, s),
                    x = r.bh(g),
                    w = r.ah(s.zoom);
                  let S;
                  (w > 0 && (S = r.bi(new Float64Array(16), s.globeMatrix)),
                    this._makeGlobeTileDebugBorderBuffer(t, p, s, x, S, w),
                    this._makeGlobeTileDebugTextBuffer(t, p, s, x, S, w));
                }
                _globePoint(t, s, h, p, g, x, w) {
                  let S = r.bj(t, s, h);
                  if (x) {
                    const C = 1 << h.z,
                      D = r.aD(p.center.lng),
                      L = r.aH(p.center.lat),
                      z = (h.x + 0.5) / C - D;
                    let O = 0;
                    z > 0.5 ? (O = -1) : z < -0.5 && (O = 1);
                    let G = (t / r.aj + h.x) / C + O,
                      U = (s / r.aj + h.y) / C;
                    ((G = (G - D) * p._pixelsPerMercatorPixel + D),
                      (U = (U - L) * p._pixelsPerMercatorPixel + L));
                    const $ = [G * p.worldSize, U * p.worldSize, 0];
                    (r.ad($, $, x), (S = r.bk(S, $, w)));
                  }
                  return r.ad(S, S, g);
                }
                _makeGlobeTileDebugBorderBuffer(t, s, h, p, g, x) {
                  const w = new r.ba(),
                    S = new r.bb(),
                    C = new r.bl(),
                    D = (z, O, G, U, $) => {
                      const Z = (G - z) / ($ - 1),
                        Y = (U - O) / ($ - 1),
                        ie = w.length;
                      for (let ae = 0; ae < $; ae++) {
                        const pe = z + ae * Z,
                          ue = O + ae * Y;
                        w.emplaceBack(pe, ue);
                        const ce = this._globePoint(pe, ue, s, h, p, g, x);
                        (C.emplaceBack(ce[0], ce[1], ce[2]),
                          S.emplaceBack(ie + ae));
                      }
                    },
                    L = r.aj;
                  (D(0, 0, L, 0, 16),
                    D(L, 0, L, L, 16),
                    D(L, L, 0, L, 16),
                    D(0, L, 0, 0, 16),
                    (this._tileDebugIndexBuffer = t.createIndexBuffer(S)),
                    (this._tileDebugBuffer = t.createVertexBuffer(
                      w,
                      r.bc.members,
                    )),
                    (this._globeTileDebugBorderBuffer = t.createVertexBuffer(
                      C,
                      r.bm.members,
                    )),
                    (this._tileDebugSegments = r.bd.simpleSegment(
                      0,
                      0,
                      w.length,
                      S.length,
                    )));
                }
                _makeGlobeTileDebugTextBuffer(t, s, h, p, g, x) {
                  const w = r.aj / 4,
                    S = new r.ba(),
                    C = new r.a_(),
                    D = new r.bl(),
                    L = 25;
                  (C.reserve(32), S.reserve(L), D.reserve(L));
                  const z = (O, G) => L * O + G;
                  for (let O = 0; O < L; O++) {
                    const G = O * w;
                    for (let U = 0; U < L; U++) {
                      const $ = U * w;
                      S.emplaceBack($, G);
                      const Z = this._globePoint($, G, s, h, p, g, x);
                      D.emplaceBack(Z[0], Z[1], Z[2]);
                    }
                  }
                  for (let O = 0; O < 4; O++)
                    for (let G = 0; G < 4; G++) {
                      const U = z(O, G),
                        $ = z(O, G + 1),
                        Z = z(O + 1, G),
                        Y = z(O + 1, G + 1);
                      (C.emplaceBack(U, $, Z), C.emplaceBack(Z, $, Y));
                    }
                  ((this._tileDebugTextIndexBuffer = t.createIndexBuffer(C)),
                    (this._tileDebugTextBuffer = t.createVertexBuffer(
                      S,
                      r.bc.members,
                    )),
                    (this._globeTileDebugTextBuffer = t.createVertexBuffer(
                      D,
                      r.bm.members,
                    )),
                    (this._tileDebugTextSegments = r.bd.simpleSegment(
                      0,
                      0,
                      L,
                      32,
                    )));
                }
                destroy(t = !1) {
                  for (const s in this.buckets) this.buckets[s].destroy();
                  ((this.buckets = {}),
                    this.imageAtlas && (this.imageAtlas = null),
                    this.lineAtlas && (this.lineAtlas = null),
                    this.imageAtlasTexture &&
                      (this.imageAtlasTexture.destroy(),
                      delete this.imageAtlasTexture),
                    this.glyphAtlasTexture &&
                      (this.glyphAtlasTexture.destroy(),
                      delete this.glyphAtlasTexture),
                    this.lineAtlasTexture &&
                      (this.lineAtlasTexture.destroy(),
                      delete this.lineAtlasTexture),
                    this._tileBoundsBuffer &&
                      (this._tileBoundsBuffer.destroy(),
                      this._tileBoundsIndexBuffer.destroy(),
                      this._tileBoundsSegments.destroy(),
                      (this._tileBoundsBuffer = null)),
                    this._tileDebugBuffer &&
                      (this._tileDebugBuffer.destroy(),
                      this._tileDebugSegments.destroy(),
                      (this._tileDebugBuffer = null)),
                    this._tileDebugIndexBuffer &&
                      (this._tileDebugIndexBuffer.destroy(),
                      (this._tileDebugIndexBuffer = null)),
                    this._globeTileDebugBorderBuffer &&
                      (this._globeTileDebugBorderBuffer.destroy(),
                      (this._globeTileDebugBorderBuffer = null)),
                    this._tileDebugTextBuffer &&
                      (this._tileDebugTextBuffer.destroy(),
                      this._tileDebugTextSegments.destroy(),
                      this._tileDebugTextIndexBuffer.destroy(),
                      (this._tileDebugTextBuffer = null)),
                    this._globeTileDebugTextBuffer &&
                      (this._globeTileDebugTextBuffer.destroy(),
                      (this._globeTileDebugTextBuffer = null)),
                    !t &&
                      this.texture &&
                      this.texture instanceof r.T &&
                      (this.texture.destroy(), delete this.texture),
                    this.hillshadeFBO &&
                      (this.hillshadeFBO.destroy(), delete this.hillshadeFBO),
                    this.dem && delete this.dem,
                    this.neighboringTiles && delete this.neighboringTiles,
                    this.demTexture &&
                      (this.demTexture.destroy(), delete this.demTexture),
                    this.rasterParticleState &&
                      (this.rasterParticleState.destroy(),
                      delete this.rasterParticleState),
                    (this.latestFeatureIndex = null),
                    (this.state = "unloaded"));
                }
              }
              r.bp.setPbf(r.bq);
              class tl extends fa {
                constructor(t, s, h, p, g) {
                  (super(t, s, h, p, g),
                    (this._workQueue = []),
                    (this._fetchQueue = []),
                    (this._isHeaderLoaded = !1));
                }
                getLayers() {
                  return this._mrt ? Object.values(this._mrt.layers) : [];
                }
                getLayer(t) {
                  return this._mrt && this._mrt.getLayer(t);
                }
                setTexture(t, s) {
                  const h = s.context,
                    p = h.gl;
                  ((this.texture = this.texture || s.getTileTexture(t.width)),
                    this.texture && this.texture instanceof r.T
                      ? this.texture.update(t, { premultiply: !1 })
                      : (this.texture = new r.T(h, t, p.RGBA8, {
                          premultiply: !1,
                        })));
                }
                flushQueues() {
                  for (; this._workQueue.length; ) this._workQueue.pop()();
                  for (; this._fetchQueue.length; ) this._fetchQueue.pop()();
                }
                fetchHeader(t = 16384, s) {
                  const h = (this._mrt = new r.bp(30)),
                    p = Object.assign({}, this.requestParams, {
                      headers: { Range: "bytes=0-" + (t - 1) },
                    });
                  return (
                    (this.entireBuffer = null),
                    (this.request = r.br(p, (g, x, w, S) => {
                      if (g) s(g);
                      else
                        try {
                          const C = h.getHeaderLength(x);
                          if (C > t)
                            return void (this.request = this.fetchHeader(C, s));
                          (h.parseHeader(x), (this._isHeaderLoaded = !0));
                          let D = 0;
                          for (const L of Object.values(h.layers))
                            D = Math.max(
                              D,
                              L.dataIndex[L.dataIndex.length - 1].lastByte,
                            );
                          (x.byteLength >= D && (this.entireBuffer = x),
                            s(null, this.entireBuffer || x, w, S));
                        } catch (C) {
                          s(C);
                        }
                    })),
                    this.request
                  );
                }
                fetchBand(t, s, h) {
                  const p = this._mrt;
                  if (!this._isHeaderLoaded || !p)
                    return void h(new Error("Tile header is not ready"));
                  const g = this.actor;
                  if (!g)
                    return void h(
                      new Error("Can't fetch tile band without an actor"),
                    );
                  let x;
                  const w = (L, z) => {
                      (x.complete(L, z),
                        L
                          ? h(L)
                          : (this.updateTextureDescriptor(t, s),
                            h(
                              null,
                              this.textureDescriptor &&
                                this.textureDescriptor.img,
                            )));
                    },
                    S = (L, z) => {
                      if (L) return h(L);
                      const O = g.send(
                        "decodeRasterArray",
                        {
                          type: "raster-array",
                          source: this.source,
                          scope: this.scope,
                          tileID: this.tileID,
                          uid: this.uid,
                          buffer: z,
                          task: x,
                        },
                        w,
                        void 0,
                        !0,
                      );
                      this._workQueue.push(() => {
                        (O && O.cancel(), x.cancel());
                      });
                    },
                    C = p.getLayer(t);
                  if (!C)
                    return void h(new Error(`Unknown sourceLayer "${t}"`));
                  if (C.hasDataForBand(s))
                    return (
                      this.updateTextureDescriptor(t, s),
                      void h(
                        null,
                        this.textureDescriptor
                          ? this.textureDescriptor.img
                          : null,
                      )
                    );
                  const D = C.getDataRange([s]);
                  if (((x = p.createDecodingTask(D)), !x || x.tasks.length))
                    if ((this.flushQueues(), this.entireBuffer))
                      S(
                        null,
                        this.entireBuffer.slice(D.firstByte, D.lastByte + 1),
                      );
                    else {
                      const L = Object.assign({}, this.requestParams, {
                          headers: {
                            Range: `bytes=${D.firstByte}-${D.lastByte}`,
                          },
                        }),
                        z = r.br(L, S);
                      this._fetchQueue.push(() => {
                        (z.cancel(), x.cancel());
                      });
                    }
                  else h(null);
                }
                updateNeeded(t, s) {
                  return (
                    (!this.textureDescriptor ||
                      this.textureDescriptor.band !== s ||
                      this.textureDescriptor.layer !== t) &&
                    this.state !== "errored"
                  );
                }
                updateTextureDescriptor(t, s) {
                  if (!this._mrt) return;
                  const h = this._mrt.getLayer(t);
                  if (!h || !h.hasBand(s) || !h.hasDataForBand(s)) return;
                  const {
                      bytes: p,
                      tileSize: g,
                      buffer: x,
                      offset: w,
                      scale: S,
                    } = h.getBandView(s),
                    C = g + 2 * x,
                    D = new r.r({ width: C, height: C }, p),
                    L = this.texture;
                  (L && L instanceof r.T && L.update(D, { premultiply: !1 }),
                    (this.textureDescriptor = {
                      layer: t,
                      band: s,
                      img: D,
                      buffer: x,
                      offset: w,
                      tileSize: g,
                      format: h.pixelFormat,
                      mix: [S, 256 * S, 65536 * S, 16777216 * S],
                    }));
                }
              }
              class nd {
                constructor(t, s) {
                  ((this.max = t), (this.onRemove = s), this.reset());
                }
                reset() {
                  for (const t in this.data)
                    for (const s of this.data[t])
                      (s.timeout && clearTimeout(s.timeout),
                        this.onRemove(s.value));
                  return ((this.data = {}), (this.order = []), this);
                }
                add(t, s, h) {
                  const p = t.wrapped().key;
                  this.data[p] === void 0 && (this.data[p] = []);
                  const g = { value: s, timeout: void 0 };
                  if (
                    (h !== void 0 &&
                      (g.timeout = setTimeout(() => {
                        this.remove(t, g);
                      }, h)),
                    this.data[p].push(g),
                    this.order.push(p),
                    this.order.length > this.max)
                  ) {
                    const x = this._getAndRemoveByKey(this.order[0]);
                    x && this.onRemove(x);
                  }
                  return this;
                }
                has(t) {
                  return t.wrapped().key in this.data;
                }
                getAndRemove(t) {
                  return this.has(t)
                    ? this._getAndRemoveByKey(t.wrapped().key)
                    : null;
                }
                _getAndRemoveByKey(t) {
                  const s = this.data[t].shift();
                  return (
                    s.timeout && clearTimeout(s.timeout),
                    this.data[t].length === 0 && delete this.data[t],
                    this.order.splice(this.order.indexOf(t), 1),
                    s.value
                  );
                }
                getByKey(t) {
                  const s = this.data[t];
                  return s ? s[0].value : null;
                }
                get(t) {
                  return this.has(t)
                    ? this.data[t.wrapped().key][0].value
                    : null;
                }
                remove(t, s) {
                  if (!this.has(t)) return this;
                  const h = t.wrapped().key,
                    p = s === void 0 ? 0 : this.data[h].indexOf(s),
                    g = this.data[h][p];
                  return (
                    this.data[h].splice(p, 1),
                    g.timeout && clearTimeout(g.timeout),
                    this.data[h].length === 0 && delete this.data[h],
                    this.onRemove(g.value),
                    this.order.splice(this.order.indexOf(h), 1),
                    this
                  );
                }
                setMaxSize(t) {
                  for (this.max = t; this.order.length > this.max; ) {
                    const s = this._getAndRemoveByKey(this.order[0]);
                    s && this.onRemove(s);
                  }
                  return this;
                }
                filter(t) {
                  const s = [];
                  for (const h in this.data)
                    for (const p of this.data[h]) t(p.value) || s.push(p);
                  for (const h of s) this.remove(h.value.tileID, h);
                }
              }
              class rd {
                constructor() {
                  ((this.state = {}),
                    (this.stateChanges = {}),
                    (this.deletedStates = {}));
                }
                updateState(t, s, h) {
                  const p = String(s);
                  if (
                    ((this.stateChanges[t] = this.stateChanges[t] || {}),
                    (this.stateChanges[t][p] = this.stateChanges[t][p] || {}),
                    r.h(this.stateChanges[t][p], h),
                    this.deletedStates[t] === null)
                  ) {
                    this.deletedStates[t] = {};
                    for (const g in this.state[t])
                      g !== p && (this.deletedStates[t][g] = null);
                  } else if (
                    this.deletedStates[t] &&
                    this.deletedStates[t][p] === null
                  ) {
                    this.deletedStates[t][p] = {};
                    for (const g in this.state[t][p])
                      h[g] || (this.deletedStates[t][p][g] = null);
                  } else
                    for (const g in h)
                      this.deletedStates[t] &&
                        this.deletedStates[t][p] &&
                        this.deletedStates[t][p][g] === null &&
                        delete this.deletedStates[t][p][g];
                }
                removeFeatureState(t, s, h) {
                  if (this.deletedStates[t] === null) return;
                  const p = String(s);
                  if (
                    ((this.deletedStates[t] = this.deletedStates[t] || {}),
                    h && s !== void 0)
                  )
                    this.deletedStates[t][p] !== null &&
                      ((this.deletedStates[t][p] =
                        this.deletedStates[t][p] || {}),
                      (this.deletedStates[t][p][h] = null));
                  else if (s !== void 0)
                    if (this.stateChanges[t] && this.stateChanges[t][p])
                      for (h in ((this.deletedStates[t][p] = {}),
                      this.stateChanges[t][p]))
                        this.deletedStates[t][p][h] = null;
                    else this.deletedStates[t][p] = null;
                  else this.deletedStates[t] = null;
                }
                getState(t, s) {
                  const h = this.state[t] || {},
                    p = this.stateChanges[t] || {},
                    g = this.deletedStates[t];
                  if (g === null) return {};
                  if (s !== void 0) {
                    const w = String(s),
                      S = r.h({}, h[w], p[w]);
                    if (g) {
                      const C = g[s];
                      if (C === null) return {};
                      for (const D in C) delete S[D];
                    }
                    return S;
                  }
                  const x = r.h({}, h, p);
                  if (g) for (const w in g) delete x[w];
                  return x;
                }
                initializeTileState(t, s) {
                  t.refreshFeatureState(s);
                }
                coalesceChanges(t, s) {
                  const h = {};
                  for (const p in this.stateChanges) {
                    this.state[p] = this.state[p] || {};
                    const g = {};
                    for (const x in this.stateChanges[p])
                      (this.state[p][x] || (this.state[p][x] = {}),
                        r.h(this.state[p][x], this.stateChanges[p][x]),
                        (g[x] = this.state[p][x]));
                    h[p] = g;
                  }
                  for (const p in this.deletedStates) {
                    this.state[p] = this.state[p] || {};
                    const g = {};
                    if (this.deletedStates[p] === null)
                      for (const x in this.state[p])
                        ((g[x] = {}), (this.state[p][x] = {}));
                    else
                      for (const x in this.deletedStates[p]) {
                        if (this.deletedStates[p][x] === null)
                          this.state[p][x] = {};
                        else if (this.state[p][x])
                          for (const w of Object.keys(this.deletedStates[p][x]))
                            delete this.state[p][x][w];
                        g[x] = this.state[p][x];
                      }
                    ((h[p] = h[p] || {}), r.h(h[p], g));
                  }
                  if (
                    ((this.stateChanges = {}),
                    (this.deletedStates = {}),
                    Object.keys(h).length !== 0)
                  )
                    for (const p in t) t[p].refreshFeatureState(s);
                }
              }
              class jr extends r.E {
                constructor(t, s, h) {
                  (super(),
                    (this.id = t),
                    (this._onlySymbols = h),
                    s.on("data", (p) => {
                      (p.dataType === "source" &&
                        p.sourceDataType === "metadata" &&
                        (this._sourceLoaded = !0),
                        this._sourceLoaded &&
                          !this._paused &&
                          p.dataType === "source" &&
                          p.sourceDataType === "content" &&
                          (this.reload(),
                          this.transform && this.update(this.transform)));
                    }),
                    s.on("error", () => {
                      this._sourceErrored = !0;
                    }),
                    (this._source = s),
                    (this._tiles = {}),
                    (this._cache = new nd(0, this._unloadTile.bind(this))),
                    (this._timers = {}),
                    (this._cacheTimers = {}),
                    (this._minTileCacheSize = s.minTileCacheSize),
                    (this._maxTileCacheSize = s.maxTileCacheSize),
                    (this._loadedParentTiles = {}),
                    (this.castsShadows = !1),
                    (this.tileCoverLift = 0),
                    (this._coveredTiles = {}),
                    (this._shadowCasterTiles = {}),
                    (this._state = new rd()),
                    (this._isRaster =
                      this._source.type === "raster" ||
                      this._source.type === "raster-dem" ||
                      this._source.type === "raster-array" ||
                      (this._source.type === "custom" &&
                        this._source._dataType === "raster")));
                }
                onAdd(t) {
                  ((this.map = t),
                    (this._minTileCacheSize =
                      this._minTileCacheSize === void 0 && t
                        ? t._minTileCacheSize
                        : this._minTileCacheSize),
                    (this._maxTileCacheSize =
                      this._maxTileCacheSize === void 0 && t
                        ? t._maxTileCacheSize
                        : this._maxTileCacheSize));
                }
                loaded() {
                  if (this._sourceErrored) return !0;
                  if (!this._sourceLoaded || !this._source.loaded()) return !1;
                  for (const t in this._tiles)
                    if (!this._tiles[t].loaded()) return !1;
                  return !0;
                }
                getSource() {
                  return this._source;
                }
                pause() {
                  this._paused = !0;
                }
                resume() {
                  if (!this._paused) return;
                  const t = this._shouldReloadOnResume;
                  ((this._paused = !1),
                    (this._shouldReloadOnResume = !1),
                    t && this.reload(),
                    this.transform && this.update(this.transform));
                }
                _loadTile(t, s) {
                  return (
                    (t.isSymbolTile = this._onlySymbols),
                    (t.isExtraShadowCaster =
                      this._shadowCasterTiles[t.tileID.key]),
                    this._source.loadTile(t, s)
                  );
                }
                _unloadTile(t) {
                  if (this._source.unloadTile)
                    return this._source.unloadTile(t);
                }
                _abortTile(t) {
                  if (this._source.abortTile) return this._source.abortTile(t);
                }
                serialize() {
                  return this._source.serialize();
                }
                prepare(t) {
                  (this._source.prepare && this._source.prepare(),
                    this._state.coalesceChanges(
                      this._tiles,
                      this.map ? this.map.painter : null,
                    ));
                  for (const s in this._tiles) {
                    const h = this._tiles[s];
                    (h.upload(t),
                      h.prepare(
                        this.map.style.imageManager,
                        this.map ? this.map.painter : null,
                        this._source.scope,
                      ));
                  }
                }
                getIds() {
                  return Object.values(this._tiles)
                    .map((t) => t.tileID)
                    .sort(pa)
                    .map((t) => t.key);
                }
                getRenderableIds(t, s) {
                  const h = [];
                  for (const p in this._tiles)
                    this._isIdRenderable(+p, t, s) && h.push(this._tiles[p]);
                  return t
                    ? h
                        .sort((p, g) => {
                          const x = p.tileID,
                            w = g.tileID,
                            S = new r.P(x.canonical.x, x.canonical.y)._rotate(
                              this.transform.angle,
                            ),
                            C = new r.P(w.canonical.x, w.canonical.y)._rotate(
                              this.transform.angle,
                            );
                          return (
                            x.overscaledZ - w.overscaledZ ||
                            C.y - S.y ||
                            C.x - S.x
                          );
                        })
                        .map((p) => p.tileID.key)
                    : h
                        .map((p) => p.tileID)
                        .sort(pa)
                        .map((p) => p.key);
                }
                hasRenderableParent(t) {
                  const s = this.findLoadedParent(t, 0);
                  return !!s && this._isIdRenderable(s.tileID.key);
                }
                _isIdRenderable(t, s, h) {
                  return (
                    this._tiles[t] &&
                    this._tiles[t].hasData() &&
                    !this._coveredTiles[t] &&
                    (s || !this._tiles[t].holdingForFade()) &&
                    (h || !this._shadowCasterTiles[t])
                  );
                }
                reload() {
                  if (this._paused) this._shouldReloadOnResume = !0;
                  else {
                    this._cache.reset();
                    for (const t in this._tiles)
                      this._tiles[t].state !== "errored" &&
                        this._reloadTile(+t, "reloading");
                  }
                }
                _reloadTile(t, s) {
                  const h = this._tiles[t];
                  h &&
                    (h.state !== "loading" && (h.state = s),
                    this._loadTile(h, this._tileLoaded.bind(this, h, t, s)));
                }
                _tileLoaded(t, s, h, p) {
                  if (p)
                    if (((t.state = "errored"), p.status !== 404))
                      this._source.fire(new r.z(p, { tile: t }));
                    else {
                      if (
                        (this._source.fire(
                          new r.A("data", {
                            dataType: "source",
                            sourceDataType: "error",
                            sourceId: this._source.id,
                            tile: t,
                          }),
                        ),
                        !(t.tileID.key in this._loadedParentTiles))
                      )
                        return;
                      if (
                        this._source.type === "raster-dem" &&
                        this.usedForTerrain &&
                        this.map.painter.terrain
                      ) {
                        const g = this.map.painter.terrain;
                        (this.update(
                          this.transform,
                          g.getScaledDemTileSize(),
                          !0,
                        ),
                          g.resetTileLookupCache(this.id));
                      } else this.update(this.transform);
                    }
                  else
                    ((t.timeAdded = r.q.now()),
                      h === "expired" && (t.refreshedUponExpiration = !0),
                      this._setTileReloadTimer(s, t),
                      this._source.type === "raster-dem" &&
                        t.dem &&
                        this._backfillDEM(t),
                      this._state.initializeTileState(
                        t,
                        this.map ? this.map.painter : null,
                      ),
                      this._source.fire(
                        new r.A("data", {
                          dataType: "source",
                          tile: t,
                          coord: t.tileID,
                          sourceCacheId: this.id,
                        }),
                      ));
                }
                _backfillDEM(t) {
                  const s = this.getRenderableIds();
                  for (let p = 0; p < s.length; p++) {
                    const g = s[p];
                    if (t.neighboringTiles && t.neighboringTiles[g]) {
                      const x = this.getTileByID(g);
                      (h(t, x), h(x, t));
                    }
                  }
                  function h(p, g) {
                    if (!p.dem || p.dem.borderReady) return;
                    ((p.needsHillshadePrepare = !0),
                      (p.needsDEMTextureUpload = !0));
                    let x = g.tileID.canonical.x - p.tileID.canonical.x;
                    const w = g.tileID.canonical.y - p.tileID.canonical.y,
                      S = Math.pow(2, p.tileID.canonical.z),
                      C = g.tileID.key;
                    (x === 0 && w === 0) ||
                      Math.abs(w) > 1 ||
                      (Math.abs(x) > 1 &&
                        (Math.abs(x + S) === 1
                          ? (x += S)
                          : Math.abs(x - S) === 1 && (x -= S)),
                      g.dem &&
                        p.dem &&
                        (p.dem.backfillBorder(g.dem, x, w),
                        p.neighboringTiles &&
                          p.neighboringTiles[C] &&
                          (p.neighboringTiles[C].backfilled = !0)));
                  }
                }
                getTile(t) {
                  return this.getTileByID(t.key);
                }
                getTileByID(t) {
                  return this._tiles[t];
                }
                _retainLoadedChildren(t, s, h, p) {
                  for (const g in this._tiles) {
                    let x = this._tiles[g];
                    if (
                      p[g] ||
                      !x.hasData() ||
                      x.tileID.overscaledZ <= s ||
                      x.tileID.overscaledZ > h
                    )
                      continue;
                    let w = x.tileID;
                    for (; x && x.tileID.overscaledZ > s + 1; ) {
                      const C = x.tileID.scaledTo(x.tileID.overscaledZ - 1);
                      ((x = this._tiles[C.key]), x && x.hasData() && (w = C));
                    }
                    let S = w;
                    for (; S.overscaledZ > s; )
                      if (((S = S.scaledTo(S.overscaledZ - 1)), t[S.key])) {
                        p[w.key] = w;
                        break;
                      }
                  }
                }
                findLoadedParent(t, s) {
                  if (t.key in this._loadedParentTiles) {
                    const h = this._loadedParentTiles[t.key];
                    return h && h.tileID.overscaledZ >= s ? h : null;
                  }
                  for (let h = t.overscaledZ - 1; h >= s; h--) {
                    const p = t.scaledTo(h),
                      g = this._getLoadedTile(p);
                    if (g) return g;
                  }
                }
                _getLoadedTile(t) {
                  const s = this._tiles[t.key];
                  return s && s.hasData()
                    ? s
                    : this._cache.getByKey(
                        this._source.reparseOverscaled
                          ? t.wrapped().key
                          : t.canonical.key,
                      );
                }
                updateCacheSize(t, s) {
                  s = s || this._source.tileSize;
                  const h = Math.ceil(t.width / s) + 1,
                    p = Math.ceil(t.height / s) + 1,
                    g = Math.floor(h * p * 5),
                    x =
                      typeof this._minTileCacheSize == "number"
                        ? Math.max(this._minTileCacheSize, g)
                        : g,
                    w =
                      typeof this._maxTileCacheSize == "number"
                        ? Math.min(this._maxTileCacheSize, x)
                        : x;
                  this._cache.setMaxSize(w);
                }
                handleWrapJump(t) {
                  const s = Math.round(
                    (t - (this._prevLng === void 0 ? t : this._prevLng)) / 360,
                  );
                  if (((this._prevLng = t), s)) {
                    const h = {};
                    for (const p in this._tiles) {
                      const g = this._tiles[p];
                      ((g.tileID = g.tileID.unwrapTo(g.tileID.wrap + s)),
                        (h[g.tileID.key] = g));
                    }
                    this._tiles = h;
                    for (const p in this._timers)
                      (clearTimeout(this._timers[p]), delete this._timers[p]);
                    for (const p in this._tiles)
                      this._setTileReloadTimer(+p, this._tiles[p]);
                  }
                }
                update(t, s, h, p, g) {
                  if (
                    ((this.transform = t),
                    !this._sourceLoaded ||
                      this._paused ||
                      this.transform.freezeTileCoverage ||
                      (this.usedForTerrain && !h))
                  )
                    return;
                  (this.updateCacheSize(t, s),
                    this.transform.projection.name !== "globe" &&
                      this.handleWrapJump(this.transform.center.lng),
                    (this._shadowCasterTiles = {}),
                    (this._coveredTiles = {}));
                  const x = this._source.type === "batched-model";
                  let w,
                    S = this._source.maxzoom;
                  const C =
                    this.map && this.map.painter
                      ? this.map.painter._terrain
                      : null;
                  if (C && C.sourceCache === this && C.attenuationRange()) {
                    const z = C.attenuationRange()[0],
                      O = Math.floor(z) - Math.log2(C.getDemUpscale());
                    S > O && (S = O);
                  }
                  if (this.used || this.usedForTerrain) {
                    if (this._source.tileID)
                      w = t
                        .getVisibleUnwrappedCoordinates(this._source.tileID)
                        .map(
                          (z) =>
                            new r.aM(
                              z.canonical.z,
                              z.wrap,
                              z.canonical.z,
                              z.canonical.x,
                              z.canonical.y,
                            ),
                        );
                    else if (this.tileCoverLift !== 0) {
                      const z = t.clone();
                      ((z.tileCoverLift = this.tileCoverLift),
                        (w = z.coveringTiles({
                          tileSize: s || this._source.tileSize,
                          minzoom: this._source.minzoom,
                          maxzoom: S,
                          roundZoom: this._source.roundZoom && !h,
                          reparseOverscaled: this._source.reparseOverscaled,
                          isTerrainDEM: this.usedForTerrain,
                          calculateQuadrantVisibility: x,
                        })),
                        this._source.minzoom <= 1 &&
                          t.projection.name === "globe" &&
                          (w.push(new r.aM(1, 0, 1, 0, 0)),
                          w.push(new r.aM(1, 0, 1, 1, 0)),
                          w.push(new r.aM(1, 0, 1, 0, 1)),
                          w.push(new r.aM(1, 0, 1, 1, 1))));
                    } else if (
                      ((w = t.coveringTiles({
                        tileSize: s || this._source.tileSize,
                        minzoom: this._source.minzoom,
                        maxzoom: S,
                        roundZoom: this._source.roundZoom && !h,
                        reparseOverscaled: this._source.reparseOverscaled,
                        isTerrainDEM: this.usedForTerrain,
                        calculateQuadrantVisibility: x,
                      })),
                      this._source.hasTile)
                    ) {
                      const z = this._source.hasTile.bind(this._source);
                      w = w.filter((O) => z(O));
                    }
                  } else w = [];
                  if (
                    w.length > 0 &&
                    this.transform.projection.name !== "globe" &&
                    !this.usedForTerrain &&
                    !uc(this._source.type)
                  ) {
                    const z = t.coveringZoomLevel({
                        tileSize: s || this._source.tileSize,
                        roundZoom: this._source.roundZoom && !h,
                      }),
                      O = Math.min(z, this._source.maxzoom);
                    if (x) {
                      const G = t.extendTileCover(w, O);
                      for (const U of G) w.push(U);
                    } else if (g) {
                      const G = t.extendTileCover(
                        w,
                        O,
                        this.transform._camera.forward(),
                      );
                      for (const U of G) w.push(U);
                    } else if (this.castsShadows && p) {
                      const G = t.extendTileCover(w, O, p);
                      for (const U of G)
                        ((this._shadowCasterTiles[U.key] = !0), w.push(U));
                    }
                  }
                  const D = this._updateRetainedTiles(w);
                  if (uc(this._source.type) && w.length !== 0) {
                    const z = {},
                      O = {},
                      G = Object.keys(D);
                    for (const $ of G) {
                      const Z = D[$],
                        Y = this._tiles[$];
                      if (!Y || (Y.fadeEndTime && Y.fadeEndTime <= r.q.now()))
                        continue;
                      const ie = this.findLoadedParent(
                        Z,
                        Math.max(
                          Z.overscaledZ - jr.maxOverzooming,
                          this._source.minzoom,
                        ),
                      );
                      (ie &&
                        (this._addTile(ie.tileID),
                        (z[ie.tileID.key] = ie.tileID)),
                        (O[$] = Z));
                    }
                    const U = w[w.length - 1].overscaledZ;
                    for (const $ in this._tiles) {
                      const Z = this._tiles[$];
                      if (D[$] || !Z.hasData()) continue;
                      let Y = Z.tileID;
                      for (; Y.overscaledZ > U; ) {
                        Y = Y.scaledTo(Y.overscaledZ - 1);
                        const ie = this._tiles[Y.key];
                        if (ie && ie.hasData() && O[Y.key]) {
                          D[$] = Z.tileID;
                          break;
                        }
                      }
                    }
                    for (const $ in z)
                      D[$] || ((this._coveredTiles[$] = !0), (D[$] = z[$]));
                  }
                  for (const z in D) this._tiles[z].clearFadeHold();
                  const L = r.bs(this._tiles, D);
                  for (const z of L) {
                    const O = this._tiles[z];
                    O.hasSymbolBuckets && !O.holdingForFade()
                      ? O.setHoldDuration(this.map._fadeDuration)
                      : (O.hasSymbolBuckets && !O.symbolFadeFinished()) ||
                        this._removeTile(+z);
                  }
                  (this._updateLoadedParentTileCache(),
                    this._onlySymbols &&
                      this._source.afterUpdate &&
                      this._source.afterUpdate());
                }
                releaseSymbolFadeTiles() {
                  for (const t in this._tiles)
                    this._tiles[t].holdingForFade() && this._removeTile(+t);
                }
                _updateRetainedTiles(t) {
                  const s = {};
                  if (t.length === 0) return s;
                  const h = {},
                    p = t.reduce((C, D) => Math.min(C, D.overscaledZ), 1 / 0),
                    g = t[0].overscaledZ,
                    x = Math.max(g - jr.maxOverzooming, this._source.minzoom),
                    w = Math.max(g + jr.maxUnderzooming, this._source.minzoom),
                    S = {};
                  for (const C of t) {
                    const D = this._addTile(C);
                    ((s[C.key] = C),
                      D.hasData() ||
                        (p < this._source.maxzoom && (S[C.key] = C)));
                  }
                  this._retainLoadedChildren(S, p, w, s);
                  for (const C of t) {
                    let D = this._tiles[C.key];
                    if (D.hasData()) continue;
                    if (C.canonical.z >= this._source.maxzoom) {
                      const z = C.children(this._source.maxzoom)[0],
                        O = this.getTile(z);
                      if (O && O.hasData()) {
                        s[z.key] = z;
                        continue;
                      }
                    } else {
                      const z = C.children(this._source.maxzoom);
                      if (
                        s[z[0].key] &&
                        s[z[1].key] &&
                        s[z[2].key] &&
                        s[z[3].key]
                      )
                        continue;
                    }
                    let L = D.wasRequested();
                    for (let z = C.overscaledZ - 1; z >= x; --z) {
                      const O = C.scaledTo(z);
                      if (
                        h[O.key] ||
                        ((h[O.key] = !0),
                        (D = this.getTile(O)),
                        !D && L && (D = this._addTile(O)),
                        D &&
                          ((s[O.key] = O), (L = D.wasRequested()), D.hasData()))
                      )
                        break;
                    }
                  }
                  return s;
                }
                _updateLoadedParentTileCache() {
                  this._loadedParentTiles = {};
                  for (const t in this._tiles) {
                    const s = [];
                    let h,
                      p = this._tiles[t].tileID;
                    for (; p.overscaledZ > 0; ) {
                      if (p.key in this._loadedParentTiles) {
                        h = this._loadedParentTiles[p.key];
                        break;
                      }
                      s.push(p.key);
                      const g = p.scaledTo(p.overscaledZ - 1);
                      if (((h = this._getLoadedTile(g)), h)) break;
                      p = g;
                    }
                    for (const g of s) this._loadedParentTiles[g] = h;
                  }
                }
                _addTile(t) {
                  let s = this._tiles[t.key];
                  if (s)
                    return (
                      s.isExtraShadowCaster !== !0 ||
                        this._shadowCasterTiles[t.key] ||
                        this._reloadTile(t.key, "reloading"),
                      s
                    );
                  ((s = this._cache.getAndRemove(t)),
                    s &&
                      (this._setTileReloadTimer(t.key, s),
                      (s.tileID = t),
                      this._state.initializeTileState(
                        s,
                        this.map ? this.map.painter : null,
                      ),
                      this._cacheTimers[t.key] &&
                        (clearTimeout(this._cacheTimers[t.key]),
                        delete this._cacheTimers[t.key],
                        this._setTileReloadTimer(t.key, s))));
                  const h = !!s;
                  if (!h) {
                    const p = this.map ? this.map.painter : null,
                      g = this._source.tileSize * t.overscaleFactor();
                    ((s =
                      this._source.type === "raster-array"
                        ? new tl(
                            t,
                            g,
                            this.transform.tileZoom,
                            p,
                            this._isRaster,
                          )
                        : new fa(
                            t,
                            g,
                            this.transform.tileZoom,
                            p,
                            this._isRaster,
                            this._source.worldview,
                          )),
                      this._loadTile(
                        s,
                        this._tileLoaded.bind(this, s, t.key, s.state),
                      ));
                  }
                  return (
                    s.uses++,
                    (this._tiles[t.key] = s),
                    h ||
                      this._source.fire(
                        new r.A("dataloading", {
                          tile: s,
                          coord: s.tileID,
                          dataType: "source",
                        }),
                      ),
                    s
                  );
                }
                _setTileReloadTimer(t, s) {
                  t in this._timers &&
                    (clearTimeout(this._timers[t]), delete this._timers[t]);
                  const h = s.getExpiryTimeout();
                  h &&
                    (this._timers[t] = setTimeout(() => {
                      (this._reloadTile(t, "expired"), delete this._timers[t]);
                    }, h));
                }
                _removeTile(t) {
                  const s = this._tiles[t];
                  s &&
                    (s.uses--,
                    delete this._tiles[t],
                    this._timers[t] &&
                      (clearTimeout(this._timers[t]), delete this._timers[t]),
                    s.uses > 0 ||
                      ((s.hasData() && s.state !== "reloading") ||
                      s.state === "empty"
                        ? this._cache.add(s.tileID, s, s.getExpiryTimeout())
                        : ((s.aborted = !0),
                          this._abortTile(s),
                          this._unloadTile(s))));
                }
                clearTiles() {
                  ((this._shouldReloadOnResume = !1), (this._paused = !1));
                  for (const t in this._tiles) this._removeTile(+t);
                  (this._source._clear && this._source._clear(),
                    this._cache.reset(),
                    this.map &&
                      this.usedForTerrain &&
                      this.map.painter.terrain &&
                      this.map.painter.terrain.resetTileLookupCache(this.id));
                }
                tilesIn(t, s, h) {
                  const p = [],
                    g = this.transform;
                  if (!g) return p;
                  const x = g.projection.name === "globe",
                    w = r.aD(g.center.lng);
                  for (const S in this._tiles) {
                    const C = this._tiles[S];
                    if ((h && C.clearQueryDebugViz(), C.holdingForFade()))
                      continue;
                    let D;
                    if (x) {
                      const L = C.tileID.canonical;
                      if (L.z === 0) {
                        const z = [
                          Math.abs(r.ay(w, ...il(L, -1)) - w),
                          Math.abs(r.ay(w, ...il(L, 1)) - w),
                        ];
                        D = [0, 2 * z.indexOf(Math.min(...z)) - 1];
                      } else {
                        const z = [
                          Math.abs(r.ay(w, ...il(L, -1)) - w),
                          Math.abs(r.ay(w, ...il(L, 0)) - w),
                          Math.abs(r.ay(w, ...il(L, 1)) - w),
                        ];
                        D = [z.indexOf(Math.min(...z)) - 1];
                      }
                    } else D = [0];
                    for (const L of D) {
                      const z = t.containsTile(C, g, s, L);
                      z && p.push(z);
                    }
                  }
                  return p;
                }
                getShadowCasterCoordinates() {
                  return this._getRenderableCoordinates(!1, !0);
                }
                getVisibleCoordinates(t) {
                  return this._getRenderableCoordinates(t);
                }
                _getRenderableCoordinates(t, s) {
                  const h = this.getRenderableIds(t, s).map(
                      (g) => this._tiles[g].tileID,
                    ),
                    p = this.transform.projection.name === "globe";
                  for (const g of h)
                    ((g.projMatrix = this.transform.calculateProjMatrix(
                      g.toUnwrapped(),
                    )),
                      (g.expandedProjMatrix = p
                        ? this.transform.calculateProjMatrix(
                            g.toUnwrapped(),
                            !1,
                            !0,
                          )
                        : g.projMatrix));
                  return h;
                }
                sortCoordinatesByDistance(t) {
                  const s = t.slice(),
                    h = this.transform._camera.position,
                    p = this.transform._camera.forward(),
                    g = {};
                  for (const x of s) {
                    const w = 1 / (1 << x.canonical.z);
                    g[x.key] =
                      ((x.canonical.x + 0.5) * w + x.wrap - h[0]) * p[0] +
                      ((x.canonical.y + 0.5) * w - h[1]) * p[1] -
                      h[2] * p[2];
                  }
                  return (s.sort((x, w) => g[x.key] - g[w.key]), s);
                }
                hasTransition() {
                  if (this._source.hasTransition()) return !0;
                  if (uc(this._source.type))
                    for (const t in this._tiles) {
                      const s = this._tiles[t];
                      if (
                        s.fadeEndTime !== void 0 &&
                        s.fadeEndTime >= r.q.now()
                      )
                        return !0;
                    }
                  return !1;
                }
                setFeatureState(t, s, h) {
                  this._state.updateState((t = t || "_geojsonTileLayer"), s, h);
                }
                removeFeatureState(t, s, h) {
                  this._state.removeFeatureState(
                    (t = t || "_geojsonTileLayer"),
                    s,
                    h,
                  );
                }
                getFeatureState(t, s) {
                  return this._state.getState(
                    (t = t || "_geojsonTileLayer"),
                    s,
                  );
                }
                setDependencies(t, s, h) {
                  const p = this._tiles[t];
                  p && p.setDependencies(s, h);
                }
                reloadTilesForDependencies(t, s) {
                  for (const h in this._tiles)
                    this._tiles[h].hasDependency(t, s) &&
                      this._reloadTile(+h, "reloading");
                  this._cache.filter((h) => !h.hasDependency(t, s));
                }
                _preloadTiles(t, s) {
                  if (!this._sourceLoaded) {
                    const S = () => {
                      this._sourceLoaded &&
                        (this._source.off("data", S), this._preloadTiles(t, s));
                    };
                    return void this._source.on("data", S);
                  }
                  const h = new Map(),
                    p = Array.isArray(t) ? t : [t],
                    g = this.map.painter.terrain,
                    x =
                      this.usedForTerrain && g
                        ? g.getScaledDemTileSize()
                        : this._source.tileSize;
                  for (const S of p) {
                    const C = S.coveringTiles({
                      tileSize: x,
                      minzoom: this._source.minzoom,
                      maxzoom: this._source.maxzoom,
                      roundZoom: this._source.roundZoom && !this.usedForTerrain,
                      reparseOverscaled: this._source.reparseOverscaled,
                      isTerrainDEM: this.usedForTerrain,
                    });
                    for (const D of C) h.set(D.key, D);
                    this.usedForTerrain && S.updateElevation(!1);
                  }
                  const w = Array.from(h.values());
                  r.bt(
                    w,
                    (S, C) => {
                      const D = new fa(
                        S,
                        this._source.tileSize * S.overscaleFactor(),
                        this.transform.tileZoom,
                        this.map.painter,
                        this._isRaster,
                        this._source.worldview,
                      );
                      this._loadTile(D, (L) => {
                        (this._source.type === "raster-dem" &&
                          D.dem &&
                          this._backfillDEM(D),
                          C(L, D));
                      });
                    },
                    s,
                  );
                }
              }
              function pa(c, t) {
                const s = Math.abs(2 * c.wrap) - +(c.wrap < 0),
                  h = Math.abs(2 * t.wrap) - +(t.wrap < 0);
                return (
                  c.overscaledZ - t.overscaledZ ||
                  h - s ||
                  t.canonical.y - c.canonical.y ||
                  t.canonical.x - c.canonical.x
                );
              }
              function uc(c) {
                return (
                  c === "raster" ||
                  c === "image" ||
                  c === "video" ||
                  c === "custom"
                );
              }
              function il(c, t) {
                const s = 1 << c.z;
                return [c.x / s + t, (c.x + 1) / s + t];
              }
              ((jr.maxOverzooming = 10), (jr.maxUnderzooming = 3));
              class Tp {
                constructor(t) {
                  ((this.style = t),
                    (this.layersGotHidden = !1),
                    (this.layers = []));
                }
                processLayersChanged() {
                  this.layers = [];
                  const t = !1,
                    s = !1;
                  for (const h in this.style._mergedLayers) {
                    const p = this.style._mergedLayers[h];
                    if (p.type === "fill-extrusion" || p.type === "building")
                      this.layers.push({
                        layer: p,
                        visible: t,
                        visibilityChanged: s,
                      });
                    else if (p.type === "model") {
                      const g = this.style.getLayerSource(p);
                      g &&
                        g.type === "batched-model" &&
                        this.layers.push({
                          layer: p,
                          visible: t,
                          visibilityChanged: s,
                        });
                    }
                  }
                }
                onNewFrame(t) {
                  this.layersGotHidden = !1;
                  for (const s of this.layers) {
                    const h = s.layer;
                    let p = !1;
                    (h.type === "fill-extrusion"
                      ? (p =
                          !h.isHidden(t) &&
                          h.paint.get("fill-extrusion-opacity") > 0)
                      : h.type === "building"
                        ? (p =
                            !h.isHidden(t) &&
                            h.paint.get("building-opacity") > 0)
                        : h.type === "model" &&
                          (p =
                            !h.isHidden(t) &&
                            h.paint.get("model-opacity").constantOr(1) > 0),
                      (this.layersGotHidden =
                        this.layersGotHidden || (!p && s.visible)),
                      (s.visible = p));
                  }
                }
                updateZOffset(t, s) {
                  this.currentBuildingBuckets = [];
                  for (const p of this.layers) {
                    const g = p.layer,
                      x = this.style.getLayerSourceCache(g);
                    let w = 1;
                    g.type === "fill-extrusion"
                      ? (w = p.visible
                          ? g.paint.get("fill-extrusion-vertical-scale")
                          : 0)
                      : g.type === "building" &&
                        (w = p.visible
                          ? g.paint.get("building-vertical-scale")
                          : 0);
                    let S = x ? x.getTile(s) : null;
                    if (!S && x && s.canonical.z > x.getSource().minzoom) {
                      let C = s.scaledTo(
                        Math.min(x.getSource().maxzoom, s.overscaledZ - 1),
                      );
                      for (
                        ;
                        C.overscaledZ >= x.getSource().minzoom &&
                        ((S = x.getTile(C)), !S && C.overscaledZ !== 0);

                      )
                        C = C.scaledTo(C.overscaledZ - 1);
                    }
                    this.currentBuildingBuckets.push({
                      bucket: S ? S.getBucket(g) : null,
                      tileID: S ? S.tileID : s,
                      verticalScale: w,
                    });
                  }
                  t.hasAnyZOffset = !1;
                  let h = !1;
                  for (let p = 0; p < t.symbolInstances.length; p++) {
                    const g = t.symbolInstances.get(p),
                      x = g.zOffset,
                      w = this._getHeightAtTileOffset(
                        s,
                        g.tileAnchorX,
                        g.tileAnchorY,
                      );
                    ((g.zOffset = w !== Number.NEGATIVE_INFINITY ? w : x),
                      h || x === g.zOffset || (h = !0),
                      t.hasAnyZOffset ||
                        g.zOffset === 0 ||
                        (t.hasAnyZOffset = !0));
                  }
                  h &&
                    ((t.zOffsetBuffersNeedUpload = !0),
                    (t.zOffsetSortDirty = !0));
                }
                _mapCoordToOverlappingTile(t, s, h, p) {
                  let g = s,
                    x = h;
                  if (t.canonical.z !== p.canonical.z) {
                    const w = p.canonical,
                      S = 1 / (1 << (t.canonical.z - w.z));
                    ((g = ((s + t.canonical.x * r.aj) * S - w.x * r.aj) | 0),
                      (x = ((h + t.canonical.y * r.aj) * S - w.y * r.aj) | 0));
                  }
                  return { tileX: g, tileY: x };
                }
                _getHeightAtTileOffset(t, s, h) {
                  let p, g;
                  for (let x = 0; x < this.layers.length; ++x) {
                    const w = this.layers[x].layer;
                    if (w.type !== "fill-extrusion" && w.type !== "building")
                      continue;
                    const {
                      bucket: S,
                      tileID: C,
                      verticalScale: D,
                    } = this.currentBuildingBuckets[x];
                    if (!S) continue;
                    const { tileX: L, tileY: z } =
                        this._mapCoordToOverlappingTile(t, s, h, C),
                      O = S.getHeightAtTileCoord(L, z);
                    O &&
                      O.height !== void 0 &&
                      (O.hidden
                        ? (p = O.height)
                        : (g = Math.max(O.height * D, g || 0)));
                  }
                  if (g !== void 0) return g;
                  for (let x = 0; x < this.layers.length; ++x) {
                    const w = this.layers[x];
                    if (w.layer.type !== "model" || !w.visible) continue;
                    const { bucket: S, tileID: C } =
                      this.currentBuildingBuckets[x];
                    if (!S) continue;
                    const { tileX: D, tileY: L } =
                        this._mapCoordToOverlappingTile(t, s, h, C),
                      z = S.getHeightAtTileCoord(D, L);
                    if (z && !z.hidden)
                      return z.height === void 0 && p !== void 0
                        ? Math.min(z.maxHeight, p) * z.verticalScale
                        : z.height
                          ? z.height * z.verticalScale
                          : Number.NEGATIVE_INFINITY;
                  }
                  return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;
                }
              }
              function Sp(c, t) {
                const s = {};
                for (const h in c) h !== "ref" && (s[h] = c[h]);
                return (
                  r.bu.forEach((h) => {
                    h in t && (s[h] = t[h]);
                  }),
                  s
                );
              }
              function dc(c) {
                c = c.slice();
                const t = Object.create(null);
                for (let s = 0; s < c.length; s++) t[c[s].id] = c[s];
                for (let s = 0; s < c.length; s++)
                  "ref" in c[s] && (c[s] = Sp(c[s], t[c[s].ref]));
                return c;
              }
              const Ei = {
                setStyle: "setStyle",
                addLayer: "addLayer",
                removeLayer: "removeLayer",
                setPaintProperty: "setPaintProperty",
                setLayoutProperty: "setLayoutProperty",
                setSlot: "setSlot",
                setFilter: "setFilter",
                addSource: "addSource",
                removeSource: "removeSource",
                setGeoJSONSourceData: "setGeoJSONSourceData",
                setLayerZoomRange: "setLayerZoomRange",
                setLayerProperty: "setLayerProperty",
                setCenter: "setCenter",
                setZoom: "setZoom",
                setBearing: "setBearing",
                setPitch: "setPitch",
                setSprite: "setSprite",
                setGlyphs: "setGlyphs",
                setTransition: "setTransition",
                setLight: "setLight",
                setTerrain: "setTerrain",
                setFog: "setFog",
                setSnow: "setSnow",
                setRain: "setRain",
                setCamera: "setCamera",
                setLights: "setLights",
                setProjection: "setProjection",
                addImport: "addImport",
                removeImport: "removeImport",
                updateImport: "updateImport",
                addIconset: "addIconset",
                removeIconset: "removeIconset",
              };
              function Ch(c, t, s) {
                s.push({ command: Ei.addSource, args: [c, t[c]] });
              }
              function nl(c, t, s) {
                (t.push({ command: Ei.removeSource, args: [c] }), (s[c] = !0));
              }
              function fc(c, t, s, h) {
                (nl(c, s, h), Ch(c, t, s));
              }
              function c_(c, t, s) {
                let h;
                for (h in c[s])
                  if (
                    c[s].hasOwnProperty(h) &&
                    h !== "data" &&
                    !r.bv(c[s][h], t[s][h])
                  )
                    return !1;
                for (h in t[s])
                  if (
                    t[s].hasOwnProperty(h) &&
                    h !== "data" &&
                    !r.bv(c[s][h], t[s][h])
                  )
                    return !1;
                return !0;
              }
              function pc(c, t, s, h, p, g) {
                let x;
                for (x in ((t = t || {}), (c = c || {})))
                  c.hasOwnProperty(x) &&
                    (r.bv(c[x], t[x]) ||
                      s.push({ command: g, args: [h, x, t[x], p] }));
                for (x in t)
                  t.hasOwnProperty(x) &&
                    !c.hasOwnProperty(x) &&
                    (r.bv(c[x], t[x]) ||
                      s.push({ command: g, args: [h, x, t[x], p] }));
              }
              function ma(c) {
                return c.id;
              }
              function Do(c, t) {
                return ((c[t.id] = t), c);
              }
              class sd {
                constructor(t, s) {
                  this.reset(t, s);
                }
                reset(t, s) {
                  ((this.points = t || []), (this._distances = [0]));
                  for (let h = 1; h < this.points.length; h++)
                    this._distances[h] =
                      this._distances[h - 1] +
                      this.points[h].dist(this.points[h - 1]);
                  ((this.length = this._distances[this._distances.length - 1]),
                    (this.padding = Math.min(s || 0, 0.5 * this.length)),
                    (this.paddedLength = this.length - 2 * this.padding));
                }
                lerp(t) {
                  if (this.points.length === 1) return this.points[0];
                  t = r.ay(t, 0, 1);
                  let s = 1,
                    h = this._distances[s];
                  const p = t * this.paddedLength + this.padding;
                  for (; h < p && s < this._distances.length; )
                    h = this._distances[++s];
                  const g = s - 1,
                    x = this._distances[g],
                    w = h - x,
                    S = w > 0 ? (p - x) / w : 0;
                  return this.points[g].mult(1 - S).add(this.points[s].mult(S));
                }
              }
              class od {
                constructor(t, s, h) {
                  const p = (this.boxCells = []),
                    g = (this.circleCells = []);
                  ((this.xCellCount = Math.ceil(t / h)),
                    (this.yCellCount = Math.ceil(s / h)));
                  for (let x = 0; x < this.xCellCount * this.yCellCount; x++)
                    (p.push([]), g.push([]));
                  ((this.circleKeys = []),
                    (this.boxKeys = []),
                    (this.bboxes = []),
                    (this.circles = []),
                    (this.width = t),
                    (this.height = s),
                    (this.xScale = this.xCellCount / t),
                    (this.yScale = this.yCellCount / s),
                    (this.boxUid = 0),
                    (this.circleUid = 0));
                }
                keysLength() {
                  return this.boxKeys.length + this.circleKeys.length;
                }
                insert(t, s, h, p, g) {
                  (this._forEachCell(
                    s,
                    h,
                    p,
                    g,
                    this._insertBoxCell,
                    this.boxUid++,
                  ),
                    this.boxKeys.push(t),
                    this.bboxes.push(s),
                    this.bboxes.push(h),
                    this.bboxes.push(p),
                    this.bboxes.push(g));
                }
                insertCircle(t, s, h, p) {
                  (this._forEachCell(
                    s - p,
                    h - p,
                    s + p,
                    h + p,
                    this._insertCircleCell,
                    this.circleUid++,
                  ),
                    this.circleKeys.push(t),
                    this.circles.push(s),
                    this.circles.push(h),
                    this.circles.push(p));
                }
                _insertBoxCell(t, s, h, p, g, x) {
                  this.boxCells[g].push(x);
                }
                _insertCircleCell(t, s, h, p, g, x) {
                  this.circleCells[g].push(x);
                }
                _query(t, s, h, p, g, x) {
                  if (h < 0 || t > this.width || p < 0 || s > this.height)
                    return !g && [];
                  const w = [];
                  if (t <= 0 && s <= 0 && this.width <= h && this.height <= p) {
                    if (g) return !0;
                    for (let S = 0; S < this.boxKeys.length; S++)
                      w.push({
                        key: this.boxKeys[S],
                        x1: this.bboxes[4 * S],
                        y1: this.bboxes[4 * S + 1],
                        x2: this.bboxes[4 * S + 2],
                        y2: this.bboxes[4 * S + 3],
                      });
                    for (let S = 0; S < this.circleKeys.length; S++) {
                      const C = this.circles[3 * S],
                        D = this.circles[3 * S + 1],
                        L = this.circles[3 * S + 2];
                      w.push({
                        key: this.circleKeys[S],
                        x1: C - L,
                        y1: D - L,
                        x2: C + L,
                        y2: D + L,
                      });
                    }
                    return x ? w.filter(x) : w;
                  }
                  return (
                    this._forEachCell(
                      t,
                      s,
                      h,
                      p,
                      this._queryCell,
                      w,
                      { hitTest: g, seenUids: { box: {}, circle: {} } },
                      x,
                    ),
                    g ? w.length > 0 : w
                  );
                }
                _queryCircle(t, s, h, p, g) {
                  const x = t - h,
                    w = t + h,
                    S = s - h,
                    C = s + h;
                  if (w < 0 || x > this.width || C < 0 || S > this.height)
                    return !p && [];
                  const D = [];
                  return (
                    this._forEachCell(
                      x,
                      S,
                      w,
                      C,
                      this._queryCellCircle,
                      D,
                      {
                        hitTest: p,
                        circle: { x: t, y: s, radius: h },
                        seenUids: { box: {}, circle: {} },
                      },
                      g,
                    ),
                    p ? D.length > 0 : D
                  );
                }
                query(t, s, h, p, g) {
                  return this._query(t, s, h, p, !1, g);
                }
                hitTest(t, s, h, p, g) {
                  return this._query(t, s, h, p, !0, g);
                }
                hitTestCircle(t, s, h, p) {
                  return this._queryCircle(t, s, h, !0, p);
                }
                _queryCell(t, s, h, p, g, x, w, S) {
                  const C = w.seenUids,
                    D = this.boxCells[g];
                  if (D !== null) {
                    const z = this.bboxes;
                    for (const O of D)
                      if (!C.box[O]) {
                        C.box[O] = !0;
                        const G = 4 * O;
                        if (
                          t <= z[G + 2] &&
                          s <= z[G + 3] &&
                          h >= z[G + 0] &&
                          p >= z[G + 1] &&
                          (!S || S(this.boxKeys[O]))
                        ) {
                          if (w.hitTest) return (x.push(!0), !0);
                          x.push({
                            key: this.boxKeys[O],
                            x1: z[G],
                            y1: z[G + 1],
                            x2: z[G + 2],
                            y2: z[G + 3],
                          });
                        }
                      }
                  }
                  const L = this.circleCells[g];
                  if (L !== null) {
                    const z = this.circles;
                    for (const O of L)
                      if (!C.circle[O]) {
                        C.circle[O] = !0;
                        const G = 3 * O;
                        if (
                          this._circleAndRectCollide(
                            z[G],
                            z[G + 1],
                            z[G + 2],
                            t,
                            s,
                            h,
                            p,
                          ) &&
                          (!S || S(this.circleKeys[O]))
                        ) {
                          if (w.hitTest) return (x.push(!0), !0);
                          {
                            const U = z[G],
                              $ = z[G + 1],
                              Z = z[G + 2];
                            x.push({
                              key: this.circleKeys[O],
                              x1: U - Z,
                              y1: $ - Z,
                              x2: U + Z,
                              y2: $ + Z,
                            });
                          }
                        }
                      }
                  }
                }
                _queryCellCircle(t, s, h, p, g, x, w, S) {
                  const C = w.circle,
                    D = w.seenUids,
                    L = this.boxCells[g];
                  if (L !== null) {
                    const O = this.bboxes;
                    for (const G of L)
                      if (!D.box[G]) {
                        D.box[G] = !0;
                        const U = 4 * G;
                        if (
                          this._circleAndRectCollide(
                            C.x,
                            C.y,
                            C.radius,
                            O[U + 0],
                            O[U + 1],
                            O[U + 2],
                            O[U + 3],
                          ) &&
                          (!S || S(this.boxKeys[G]))
                        )
                          return (x.push(!0), !0);
                      }
                  }
                  const z = this.circleCells[g];
                  if (z !== null) {
                    const O = this.circles;
                    for (const G of z)
                      if (!D.circle[G]) {
                        D.circle[G] = !0;
                        const U = 3 * G;
                        if (
                          this._circlesCollide(
                            O[U],
                            O[U + 1],
                            O[U + 2],
                            C.x,
                            C.y,
                            C.radius,
                          ) &&
                          (!S || S(this.circleKeys[G]))
                        )
                          return (x.push(!0), !0);
                      }
                  }
                }
                _forEachCell(t, s, h, p, g, x, w, S) {
                  const C = this._convertToXCellCoord(t),
                    D = this._convertToYCellCoord(s),
                    L = this._convertToXCellCoord(h),
                    z = this._convertToYCellCoord(p);
                  for (let O = C; O <= L; O++)
                    for (let G = D; G <= z; G++)
                      if (
                        g.call(
                          this,
                          t,
                          s,
                          h,
                          p,
                          this.xCellCount * G + O,
                          x,
                          w,
                          S,
                        )
                      )
                        return;
                }
                _convertToXCellCoord(t) {
                  return Math.max(
                    0,
                    Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)),
                  );
                }
                _convertToYCellCoord(t) {
                  return Math.max(
                    0,
                    Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)),
                  );
                }
                _circlesCollide(t, s, h, p, g, x) {
                  const w = p - t,
                    S = g - s,
                    C = h + x;
                  return C * C > w * w + S * S;
                }
                _circleAndRectCollide(t, s, h, p, g, x, w) {
                  const S = (x - p) / 2,
                    C = Math.abs(t - (p + S));
                  if (C > S + h) return !1;
                  const D = (w - g) / 2,
                    L = Math.abs(s - (g + D));
                  if (L > D + h) return !1;
                  if (C <= S || L <= D) return !0;
                  const z = C - S,
                    O = L - D;
                  return z * z + O * O <= h * h;
                }
              }
              const ga = { unknown: 0, flipRequired: 1, flipNotRequired: 2 },
                Ep = Math.tan((85 * Math.PI) / 180);
              function ro(c, t, s, h, p, g, x) {
                const w = r.bz();
                if (s)
                  if (g.name === "globe") {
                    const S = r.bA(p, t);
                    r.az(w, w, S);
                  } else {
                    const S = r.bB([], x);
                    ((w[0] = S[0]),
                      (w[1] = S[1]),
                      (w[4] = S[2]),
                      (w[5] = S[3]),
                      h || r.by(w, w, p.angle));
                  }
                else r.az(w, p.labelPlaneMatrix, c);
                return w;
              }
              function Ph(c, t, s, h, p, g, x) {
                const w = ro(c, t, s, h, p, g, x);
                return (
                  (g.name === "globe" && s) ||
                    (w[2] = w[6] = w[10] = w[14] = 0),
                  w
                );
              }
              function Dh(c, t, s, h, p, g, x) {
                if (s) {
                  if (g.name === "globe") {
                    const w = ro(c, t, s, h, p, g, x);
                    return (r.bi(w, w), r.az(w, c, w), w);
                  }
                  {
                    const w = r.bw(c),
                      S = r.bx([]);
                    return (
                      (S[0] = x[0]),
                      (S[1] = x[1]),
                      (S[4] = x[2]),
                      (S[5] = x[3]),
                      r.az(w, w, S),
                      h || r.by(w, w, -p.angle),
                      w
                    );
                  }
                }
                return p.glCoordMatrix;
              }
              function Cs(c, t, s, h) {
                const p = [c, t, s, 1];
                s ? r.aA(p, p, h) : Li(p, p, h);
                const g = p[3];
                return ((p[0] /= g), (p[1] /= g), (p[2] /= g), p);
              }
              function mc(c, t) {
                return Math.min(0.5 + (c / t) * 0.5, 1.5);
              }
              function _a(c, t) {
                const s = c[0] / c[3],
                  h = c[1] / c[3];
                return s >= -t[0] && s <= t[0] && h >= -t[1] && h <= t[1];
              }
              function Rh(c, t, s, h, p, g, x, w, S, C) {
                const D = s.transform,
                  L = h ? c.textSizeData : c.iconSizeData,
                  z = r.bH(L, s.transform.zoom),
                  O = D.projection.name === "globe",
                  G = [(256 / s.width) * 2 + 1, (256 / s.height) * 2 + 1],
                  U = h
                    ? c.text.dynamicLayoutVertexArray
                    : c.icon.dynamicLayoutVertexArray;
                U.clear();
                let $ = null;
                O &&
                  ($ = h
                    ? c.text.globeExtVertexArray
                    : c.icon.globeExtVertexArray);
                const Z = c.lineVertexArray,
                  Y = h ? c.text.placedSymbolArray : c.icon.placedSymbolArray,
                  ie = s.transform.width / s.transform.height;
                let ae,
                  pe = !1;
                for (let ue = 0; ue < Y.length; ue++) {
                  const ce = Y.get(ue),
                    { numGlyphs: le, writingMode: me } = ce;
                  if (
                    (me !== r.bI.vertical ||
                      pe ||
                      ae === r.bI.horizontal ||
                      (pe = !0),
                    (ae = me),
                    (ce.hidden || me === r.bI.vertical) && !pe)
                  ) {
                    xa(le, U);
                    continue;
                  }
                  pe = !1;
                  const _e = new r.P(ce.tileAnchorX, ce.tileAnchorY);
                  let {
                    x: De,
                    y: ze,
                    z: He,
                  } = D.projection.projectTilePoint(_e.x, _e.y, C.canonical);
                  if (S) {
                    const [St, Et, bt] = S(_e);
                    ((De += St), (ze += Et), (He += bt));
                  }
                  const We = [De, ze, He, 1];
                  if ((r.aA(We, We, t), !_a(We, G))) {
                    xa(le, U);
                    continue;
                  }
                  const et = We[3],
                    Ce = mc(
                      s.transform.getCameraToCenterDistance(D.projection),
                      et,
                    ),
                    Ve = r.bJ(L, z, ce),
                    Te = x ? Ve / Ce : Ve * Ce,
                    Ze = Cs(De, ze, He, p);
                  if (Ze[3] <= 0) {
                    xa(le, U);
                    continue;
                  }
                  let Oe = {};
                  const Ke = r.al(c.layers[0].layout.get("text-max-angle")),
                    ht = Math.cos(Ke),
                    qe = x ? null : S,
                    lt = ya(
                      ce,
                      Te,
                      !1,
                      w,
                      t,
                      p,
                      g,
                      c.glyphOffsetArray,
                      Z,
                      U,
                      $,
                      Ze,
                      _e,
                      Oe,
                      ie,
                      qe,
                      D.projection,
                      C,
                      x,
                      ht,
                    );
                  ((pe = lt.useVertical),
                    qe && lt.needsFlipping && (Oe = {}),
                    (lt.notEnoughRoom ||
                      pe ||
                      (lt.needsFlipping &&
                        ya(
                          ce,
                          Te,
                          !0,
                          w,
                          t,
                          p,
                          g,
                          c.glyphOffsetArray,
                          Z,
                          U,
                          $,
                          Ze,
                          _e,
                          Oe,
                          ie,
                          qe,
                          D.projection,
                          C,
                          x,
                          ht,
                        ).notEnoughRoom)) &&
                      xa(le, U));
                }
                h
                  ? (c.text.dynamicLayoutVertexBuffer.updateData(U),
                    $ &&
                      c.text.globeExtVertexBuffer &&
                      c.text.globeExtVertexBuffer.updateData($))
                  : (c.icon.dynamicLayoutVertexBuffer.updateData(U),
                    $ &&
                      c.icon.globeExtVertexBuffer &&
                      c.icon.globeExtVertexBuffer.updateData($));
              }
              function ad(c, t, s, h, p, g, x, w, S, C, D, L, z, O, G, U, $) {
                const {
                    lineStartIndex: Z,
                    glyphStartIndex: Y,
                    segment: ie,
                  } = w,
                  ae = Y + w.numGlyphs,
                  pe = Z + w.lineLength,
                  ue = t.getoffsetX(Y),
                  ce = t.getoffsetX(ae - 1),
                  le = rl(
                    c * ue,
                    s,
                    h,
                    p,
                    g,
                    x,
                    ie,
                    Z,
                    pe,
                    S,
                    C,
                    D,
                    L,
                    z,
                    !0,
                    O,
                    G,
                    U,
                    $,
                  );
                if (!le) return null;
                const me = rl(
                  c * ce,
                  s,
                  h,
                  p,
                  g,
                  x,
                  ie,
                  Z,
                  pe,
                  S,
                  C,
                  D,
                  L,
                  z,
                  !0,
                  O,
                  G,
                  U,
                  $,
                );
                return me ? { first: le, last: me } : null;
              }
              function zh(c, t, s, h) {
                return c === r.bI.horizontal && Math.abs(h) > Math.abs(s)
                  ? { useVertical: !0 }
                  : c === r.bI.vertical
                    ? h > 0
                      ? { needsFlipping: !0 }
                      : null
                    : t !== ga.unknown &&
                        (function (p, g) {
                          return p === 0 || Math.abs(g / p) > Ep;
                        })(s, h)
                      ? t === ga.flipRequired
                        ? { needsFlipping: !0 }
                        : null
                      : s < 0
                        ? { needsFlipping: !0 }
                        : null;
              }
              function ya(
                c,
                t,
                s,
                h,
                p,
                g,
                x,
                w,
                S,
                C,
                D,
                L,
                z,
                O,
                G,
                U,
                $,
                Z,
                Y,
                ie,
              ) {
                const ae = t / 24,
                  pe = c.lineOffsetX * ae,
                  ue = c.lineOffsetY * ae,
                  {
                    lineStartIndex: ce,
                    glyphStartIndex: le,
                    numGlyphs: me,
                    segment: _e,
                    writingMode: De,
                    flipState: ze,
                  } = c,
                  He = ce + c.lineLength,
                  We = (et) => {
                    if (D) {
                      const [Ze, Oe, Ke] = et.up,
                        ht = C.length;
                      (r.bK(D, ht + 0, Ze, Oe, Ke),
                        r.bK(D, ht + 1, Ze, Oe, Ke),
                        r.bK(D, ht + 2, Ze, Oe, Ke),
                        r.bK(D, ht + 3, Ze, Oe, Ke));
                    }
                    const [Ce, Ve, Te] = et.point;
                    r.bL(C, Ce, Ve, Te, et.angle);
                  };
                if (me > 1) {
                  const et = ad(
                    ae,
                    w,
                    pe,
                    ue,
                    s,
                    L,
                    z,
                    c,
                    S,
                    g,
                    O,
                    U,
                    !1,
                    $,
                    Z,
                    Y,
                    ie,
                  );
                  if (!et) return { notEnoughRoom: !0 };
                  if (h && !s) {
                    let [Ce, Ve, Te] = et.first.point,
                      [Ze, Oe, Ke] = et.last.point;
                    (([Ce, Ve] = Cs(Ce, Ve, Te, x)),
                      ([Ze, Oe] = Cs(Ze, Oe, Ke, x)));
                    const ht = zh(De, ze, (Ze - Ce) * G, Oe - Ve);
                    if (
                      ((c.flipState =
                        ht && ht.needsFlipping
                          ? ga.flipRequired
                          : ga.flipNotRequired),
                      ht)
                    )
                      return ht;
                  }
                  We(et.first);
                  for (let Ce = le + 1; Ce < le + me - 1; Ce++) {
                    const Ve = rl(
                      ae * w.getoffsetX(Ce),
                      pe,
                      ue,
                      s,
                      L,
                      z,
                      _e,
                      ce,
                      He,
                      S,
                      g,
                      O,
                      U,
                      !1,
                      !1,
                      $,
                      Z,
                      Y,
                      ie,
                    );
                    if (!Ve)
                      return (
                        (C.length -= 4 * (Ce - le)),
                        { notEnoughRoom: !0 }
                      );
                    We(Ve);
                  }
                  We(et.last);
                } else {
                  if (h && !s) {
                    const Ce = Cs(z.x, z.y, 0, p),
                      Ve = ce + _e + 1,
                      Te = new r.P(S.getx(Ve), S.gety(Ve)),
                      Ze = Cs(Te.x, Te.y, 0, p),
                      Oe =
                        Ze[3] > 0
                          ? Ze
                          : ld(z, Te, Ce, 1, p, void 0, $, Z.canonical),
                      Ke = zh(De, ze, (Oe[0] - Ce[0]) * G, Oe[1] - Ce[1]);
                    if (
                      ((c.flipState =
                        Ke && Ke.needsFlipping
                          ? ga.flipRequired
                          : ga.flipNotRequired),
                      Ke)
                    )
                      return Ke;
                  }
                  const et = rl(
                    ae * w.getoffsetX(le),
                    pe,
                    ue,
                    s,
                    L,
                    z,
                    _e,
                    ce,
                    He,
                    S,
                    g,
                    O,
                    U,
                    !1,
                    !1,
                    $,
                    Z,
                    Y,
                    ie,
                  );
                  if (!et) return { notEnoughRoom: !0 };
                  We(et);
                }
                return {};
              }
              function Kr(c, t, s, h, p) {
                const { x: g, y: x, z: w } = h.projectTilePoint(c.x, c.y, t);
                if (!p) return Cs(g, x, w, s);
                const [S, C, D] = p(c);
                return Cs(g + S, x + C, w + D, s);
              }
              function ld(c, t, s, h, p, g, x, w) {
                const S = Kr(c.sub(t)._unit()._add(c), w, p, x, g);
                return (r.at(S, s, S), r.au(S, S), r.bE(S, s, S, h));
              }
              function rl(
                c,
                t,
                s,
                h,
                p,
                g,
                x,
                w,
                S,
                C,
                D,
                L,
                z,
                O,
                G,
                U,
                $,
                Z,
                Y,
              ) {
                const ie = h ? c - t : c + t;
                let ae = ie > 0 ? 1 : -1,
                  pe = 0;
                (h && ((ae *= -1), (pe = Math.PI)), ae < 0 && (pe += Math.PI));
                let ue = (w + x + (ae > 0 ? 0 : 1)) | 0,
                  ce = p,
                  le = p,
                  me = 0,
                  _e = 0;
                const De = Math.abs(ie),
                  ze = [],
                  He = [];
                let We = g,
                  et = We,
                  Ce = r.bC([]);
                const Ve = () =>
                  ld(et, We, le, De - me + 1, D, z, U, $.canonical);
                for (; me + _e <= De; ) {
                  if (((ue += ae), ue < w || ue >= S)) return null;
                  if (
                    ((le = ce),
                    (et = We),
                    ze.push(le),
                    O && He.push(et),
                    (We = new r.P(C.getx(ue), C.gety(ue))),
                    (ce = L[ue]),
                    !ce)
                  ) {
                    const bt = Kr(We, $.canonical, D, U, z);
                    ce = bt[3] > 0 ? (L[ue] = bt) : Ve();
                  }
                  me += _e;
                  const St = r.at([], ce, le),
                    Et = r.bD(le, ce);
                  if (s && Et > 0 && _e > 0 && r.bG(Ce, St) / (_e * Et) < Y)
                    return null;
                  ((_e = Et), (Ce = St));
                }
                G &&
                  z &&
                  (L[ue] &&
                    ((ce = Ve()), (_e = r.bD(le, ce)), (Ce = r.at([], ce, le))),
                  (L[ue] = ce));
                const Te = (De - me) / _e,
                  Ze = We.sub(et)._mult(Te)._add(et),
                  Oe = r.bE([], le, Ce, Te);
                let Ke = [0, 0, 1],
                  ht = Ce[0],
                  qe = Ce[1];
                if (
                  Z &&
                  ((Ke = U.upVector($.canonical, Ze.x, Ze.y)),
                  Ke[0] !== 0 || Ke[1] !== 0 || Ke[2] !== 1)
                ) {
                  const St = [Ke[2], 0, -Ke[0]],
                    Et = r.bF([], Ke, St);
                  (r.au(St, St),
                    r.au(Et, Et),
                    (ht = r.bG(Ce, St)),
                    (qe = r.bG(Ce, Et)));
                }
                if (s) {
                  const St = r.bF([], Ke, Ce);
                  (r.au(St, St), r.bE(Oe, Oe, St, s * ae));
                }
                const lt = pe + Math.atan2(qe, ht);
                return (
                  ze.push(Oe),
                  O && He.push(Ze),
                  { point: Oe, angle: lt, path: ze, tilePath: He, up: Ke }
                );
              }
              function xa(c, t) {
                const s = t.length,
                  h = s + 4 * c;
                (t.resize(h), t.float32.fill(-1 / 0, 4 * s, 4 * h));
              }
              function Li(c, t, s) {
                const h = t[0],
                  p = t[1];
                return (
                  (c[0] = s[0] * h + s[4] * p + s[12]),
                  (c[1] = s[1] * h + s[5] * p + s[13]),
                  (c[3] = s[3] * h + s[7] * p + s[15]),
                  c
                );
              }
              const Ps = 100;
              class h_ {
                constructor(
                  t,
                  s,
                  h = new od(t.width + 200, t.height + 200, 25),
                  p = new od(t.width + 200, t.height + 200, 25),
                ) {
                  ((this.transform = t),
                    (this.grid = h),
                    (this.ignoredGrid = p),
                    (this.pitchfactor =
                      Math.cos(t._pitch) * t.cameraToCenterDistance),
                    (this.screenRightBoundary = t.width + Ps),
                    (this.screenBottomBoundary = t.height + Ps),
                    (this.gridRightBoundary = t.width + 200),
                    (this.gridBottomBoundary = t.height + 200),
                    (this.fogState = s));
                }
                placeCollisionBox(t, s, h, p, g, x, w, S) {
                  let C = h.projectedAnchorX,
                    D = h.projectedAnchorY,
                    L = h.projectedAnchorZ;
                  const z = h.elevation,
                    O = h.tileID,
                    G = t.getProjection();
                  if (z && O) {
                    const [ue, ce, le] = G.upVector(
                        O.canonical,
                        h.tileAnchorX,
                        h.tileAnchorY,
                      ),
                      me = G.upVectorScale(
                        O.canonical,
                        this.transform.center.lat,
                        this.transform.worldSize,
                      ).metersToTile;
                    ((C += ue * z * me),
                      (D += ce * z * me),
                      (L += le * z * me));
                  }
                  const U = this.projectAndGetPerspectiveRatio(
                      w,
                      C,
                      D,
                      L,
                      h.tileID,
                      G.name === "globe" || !!z || this.transform.pitch > 0,
                      G,
                    ),
                    $ = x * U.perspectiveRatio,
                    Z = (h.x1 * s + p.x - h.padding) * $ + U.point.x,
                    Y = (h.y1 * s + p.y - h.padding) * $ + U.point.y,
                    ie = (h.x2 * s + p.x + h.padding) * $ + U.point.x,
                    ae = (h.y2 * s + p.y + h.padding) * $ + U.point.y,
                    pe = U.perspectiveRatio <= 0.55 || U.occluded;
                  return !this.isInsideGrid(Z, Y, ie, ae) ||
                    (!g && this.grid.hitTest(Z, Y, ie, ae, S)) ||
                    pe
                    ? { box: [], offscreen: !1, occluded: U.occluded }
                    : {
                        box: [Z, Y, ie, ae],
                        offscreen: this.isOffscreen(Z, Y, ie, ae),
                        occluded: !1,
                      };
                }
                placeCollisionCircles(
                  t,
                  s,
                  h,
                  p,
                  g,
                  x,
                  w,
                  S,
                  C,
                  D,
                  L,
                  z,
                  O,
                  G,
                  U,
                ) {
                  const $ = [],
                    Z = this.transform.elevation,
                    Y = t.getProjection(),
                    ie = Z
                      ? Z.getAtTileOffsetFunc(
                          U,
                          this.transform.center.lat,
                          this.transform.worldSize,
                          Y,
                        )
                      : null,
                    ae = new r.P(h.tileAnchorX, h.tileAnchorY);
                  let {
                    x: pe,
                    y: ue,
                    z: ce,
                  } = Y.projectTilePoint(ae.x, ae.y, U.canonical);
                  if (ie) {
                    const [Ke, ht, qe] = ie(ae);
                    ((pe += Ke), (ue += ht), (ce += qe));
                  }
                  const le = Y.name === "globe",
                    me = this.projectAndGetPerspectiveRatio(
                      w,
                      pe,
                      ue,
                      ce,
                      U,
                      le || !!Z || this.transform.pitch > 0,
                      Y,
                    ),
                    { perspectiveRatio: _e } = me,
                    De = (L ? x / _e : x * _e) / r.bO,
                    ze = Cs(pe, ue, ce, S),
                    He = h.lineOffsetX * De,
                    We = h.lineOffsetY * De,
                    et = r.al(t.layers[0].layout.get("text-max-angle")),
                    Ce = Math.cos(et),
                    Ve =
                      me.signedDistanceFromCamera > 0
                        ? ad(
                            De,
                            g,
                            He,
                            We,
                            !1,
                            ze,
                            ae,
                            h,
                            p,
                            S,
                            {},
                            Z && !L ? ie : null,
                            L && !!Z,
                            Y,
                            U,
                            L,
                            Ce,
                          )
                        : null;
                  let Te = !1,
                    Ze = !1,
                    Oe = !0;
                  if (Ve && !me.occluded) {
                    const Ke = 0.5 * O * _e + G,
                      ht = new r.P(-100, -100),
                      qe = new r.P(
                        this.screenRightBoundary,
                        this.screenBottomBoundary,
                      ),
                      lt = new sd(),
                      { first: St, last: Et } = Ve,
                      bt = St.path.length;
                    let kt = [];
                    for (let Zt = bt - 1; Zt >= 1; Zt--) kt.push(St.path[Zt]);
                    for (let Zt = 1; Zt < Et.path.length; Zt++)
                      kt.push(Et.path[Zt]);
                    const Bt = 2.5 * Ke;
                    C &&
                      ((kt = kt.map(
                        ([Zt, si, Fi], nn) => (
                          ie &&
                            !le &&
                            (Fi = ie(
                              nn < bt - 1
                                ? St.tilePath[bt - 1 - nn]
                                : Et.tilePath[nn - bt + 2],
                            )[2]),
                          Cs(Zt, si, Fi, C)
                        ),
                      )),
                      kt.some((Zt) => Zt[3] <= 0) && (kt = []));
                    let Vt = [];
                    if (kt.length > 0) {
                      let Zt = 1 / 0,
                        si = -1 / 0,
                        Fi = 1 / 0,
                        nn = -1 / 0;
                      for (const ji of kt)
                        ((Zt = Math.min(Zt, ji[0])),
                          (Fi = Math.min(Fi, ji[1])),
                          (si = Math.max(si, ji[0])),
                          (nn = Math.max(nn, ji[1])));
                      si >= ht.x &&
                        Zt <= qe.x &&
                        nn >= ht.y &&
                        Fi <= qe.y &&
                        ((Vt = [kt.map((ji) => new r.P(ji[0], ji[1]))]),
                        (Zt < ht.x || si > qe.x || Fi < ht.y || nn > qe.y) &&
                          (Vt = r.bM(Vt, ht.x, ht.y, qe.x, qe.y)));
                    }
                    for (const Zt of Vt) {
                      lt.reset(Zt, 0.25 * Ke);
                      let si = 0;
                      si =
                        lt.length <= 0.5 * Ke
                          ? 1
                          : Math.ceil(lt.paddedLength / Bt) + 1;
                      for (let Fi = 0; Fi < si; Fi++) {
                        const nn = Fi / Math.max(si - 1, 1),
                          ji = lt.lerp(nn),
                          Hi = ji.x + Ps,
                          Fn = ji.y + Ps;
                        $.push(Hi, Fn, Ke, 0);
                        const ti = Hi - Ke,
                          li = Fn - Ke,
                          gi = Hi + Ke,
                          cn = Fn + Ke;
                        if (
                          ((Oe = Oe && this.isOffscreen(ti, li, gi, cn)),
                          (Ze = Ze || this.isInsideGrid(ti, li, gi, cn)),
                          !s &&
                            this.grid.hitTestCircle(Hi, Fn, Ke, z) &&
                            ((Te = !0), !D))
                        )
                          return {
                            circles: [],
                            offscreen: !1,
                            collisionDetected: Te,
                            occluded: !1,
                          };
                      }
                    }
                  }
                  return {
                    circles: (!D && Te) || !Ze ? [] : $,
                    offscreen: Oe,
                    collisionDetected: Te,
                    occluded: me.occluded,
                  };
                }
                queryRenderedSymbols(t) {
                  if (
                    t.length === 0 ||
                    (this.grid.keysLength() === 0 &&
                      this.ignoredGrid.keysLength() === 0)
                  )
                    return {};
                  const s = [];
                  let h = 1 / 0,
                    p = 1 / 0,
                    g = -1 / 0,
                    x = -1 / 0;
                  for (const D of t) {
                    const L = new r.P(D.x + Ps, D.y + Ps);
                    ((h = Math.min(h, L.x)),
                      (p = Math.min(p, L.y)),
                      (g = Math.max(g, L.x)),
                      (x = Math.max(x, L.y)),
                      s.push(L));
                  }
                  const w = this.grid
                      .query(h, p, g, x)
                      .concat(this.ignoredGrid.query(h, p, g, x)),
                    S = {},
                    C = {};
                  for (const D of w) {
                    const L = D.key;
                    if (
                      (S[L.bucketInstanceId] === void 0 &&
                        (S[L.bucketInstanceId] = {}),
                      S[L.bucketInstanceId][L.featureIndex])
                    )
                      continue;
                    const z = [
                      new r.P(D.x1, D.y1),
                      new r.P(D.x2, D.y1),
                      new r.P(D.x2, D.y2),
                      new r.P(D.x1, D.y2),
                    ];
                    r.bN(s, z) &&
                      ((S[L.bucketInstanceId][L.featureIndex] = !0),
                      C[L.bucketInstanceId] === void 0 &&
                        (C[L.bucketInstanceId] = []),
                      C[L.bucketInstanceId].push(L.featureIndex));
                  }
                  return C;
                }
                insertCollisionBox(t, s, h, p, g) {
                  (s ? this.ignoredGrid : this.grid).insert(
                    {
                      bucketInstanceId: h,
                      featureIndex: p,
                      collisionGroupID: g,
                    },
                    t[0],
                    t[1],
                    t[2],
                    t[3],
                  );
                }
                insertCollisionCircles(t, s, h, p, g) {
                  const x = s ? this.ignoredGrid : this.grid,
                    w = {
                      bucketInstanceId: h,
                      featureIndex: p,
                      collisionGroupID: g,
                    };
                  for (let S = 0; S < t.length; S += 4)
                    x.insertCircle(w, t[S], t[S + 1], t[S + 2]);
                }
                projectAndGetPerspectiveRatio(t, s, h, p, g, x, w) {
                  const S = [s, h, p, 1];
                  let C = !1;
                  p || this.transform.pitch > 0
                    ? (r.aA(S, S, t),
                      this.fogState &&
                        g &&
                        w.name !== "globe" &&
                        (C =
                          (function (z, O, G, U, $, Z) {
                            const Y = Z.calculateFogTileMatrix($),
                              ie = [O, G, U];
                            return (
                              r.ad(ie, ie, Y),
                              dt(z, r.ae(ie), Z.pitch, Z._fov)
                            );
                          })(
                            this.fogState,
                            s,
                            h,
                            p,
                            g.toUnwrapped(),
                            this.transform,
                          ) > 0.9))
                    : Li(S, S, t);
                  const D = S[3];
                  return {
                    point: new r.P(
                      ((S[0] / D + 1) / 2) * this.transform.width + Ps,
                      ((-S[1] / D + 1) / 2) * this.transform.height + Ps,
                    ),
                    perspectiveRatio: Math.min(
                      0.5 +
                        (this.transform.getCameraToCenterDistance(w) / D) * 0.5,
                      1.5,
                    ),
                    signedDistanceFromCamera: D,
                    occluded: (x && S[2] > D) || C,
                  };
                }
                isOffscreen(t, s, h, p) {
                  return (
                    h < Ps ||
                    t >= this.screenRightBoundary ||
                    p < Ps ||
                    s > this.screenBottomBoundary
                  );
                }
                isInsideGrid(t, s, h, p) {
                  return (
                    h >= 0 &&
                    t < this.gridRightBoundary &&
                    p >= 0 &&
                    s < this.gridBottomBoundary
                  );
                }
                getViewportMatrix() {
                  const t = r.bx([]);
                  return (r.bo(t, t, [-100, -100, 0]), t);
                }
              }
              function cd(c, t, s) {
                const h = t.createTileMatrix(c, c.worldSize, s.toUnwrapped());
                return r.az(new Float32Array(16), c.projMatrix, h);
              }
              function Ht(c, t, s) {
                if (t.projection.name === s.projection.name)
                  return c.projMatrix;
                const h = s.clone();
                return (
                  h.setProjection(t.projection),
                  cd(h, t.getProjection(), c)
                );
              }
              function kh(c, t, s) {
                return t.name === s.projection.name
                  ? c.projMatrix
                  : cd(s, t, c);
              }
              class gc {
                constructor(t, s, h, p) {
                  ((this.opacity = t
                    ? Math.max(0, Math.min(1, t.opacity + (t.placed ? s : -s)))
                    : p && h
                      ? 1
                      : 0),
                    (this.placed = h));
                }
                isHidden() {
                  return this.opacity === 0 && !this.placed;
                }
              }
              class va {
                constructor(t, s, h, p, g, x = !1) {
                  ((this.text = new gc(t ? t.text : null, s, h, g)),
                    (this.icon = new gc(t ? t.icon : null, s, p, g)),
                    (this.clipped = x));
                }
                isHidden() {
                  return this.text.isHidden() && this.icon.isHidden();
                }
              }
              class os {
                constructor(t, s, h, p = !1) {
                  ((this.text = t),
                    (this.icon = s),
                    (this.skipFade = h),
                    (this.clipped = p));
                }
              }
              class hd {
                constructor() {
                  ((this.invProjMatrix = r.bz()),
                    (this.viewportMatrix = r.bz()),
                    (this.circles = []));
                }
              }
              class sl {
                constructor(t, s, h, p, g) {
                  ((this.bucketInstanceId = t),
                    (this.featureIndex = s),
                    (this.sourceLayerIndex = h),
                    (this.bucketIndex = p),
                    (this.tileID = g));
                }
              }
              class Ft {
                constructor(t) {
                  ((this.crossSourceCollisions = t),
                    (this.maxGroupID = 0),
                    (this.collisionGroups = {}));
                }
                get(t) {
                  if (this.crossSourceCollisions)
                    return { ID: 0, predicate: null };
                  if (!this.collisionGroups[t]) {
                    const s = ++this.maxGroupID;
                    this.collisionGroups[t] = {
                      ID: s,
                      predicate: (h) => h.collisionGroupID === s,
                    };
                  }
                  return this.collisionGroups[t];
                }
              }
              function $i(c, t, s, h, p) {
                const { horizontalAlign: g, verticalAlign: x } = r.bT(c),
                  w = -(g - 0.5) * t,
                  S = -(x - 0.5) * s,
                  C = r.bU(c, h);
                return new r.P(w + C[0] * p, S + C[1] * p);
              }
              function zi(c, t, s, h, p) {
                const g = new r.P(c, t);
                return (s && g._rotate(h ? p : -p), g);
              }
              class Jr {
                constructor(t, s, h, p, g, x) {
                  ((this.transform = t.clone()),
                    (this.projection = t.projection.name),
                    (this.collisionIndex = new h_(this.transform, g)),
                    (this.buildingIndex = x),
                    (this.placements = {}),
                    (this.opacities = {}),
                    (this.variableOffsets = {}),
                    (this.stale = !1),
                    (this.commitTime = 0),
                    (this.fadeDuration = s),
                    (this.retainedQueryData = {}),
                    (this.collisionGroups = new Ft(h)),
                    (this.collisionCircleArrays = {}),
                    (this.prevPlacement = p),
                    p && (p.prevPlacement = void 0),
                    (this.placedOrientations = {}));
                }
                getBucketParts(t, s, h, p, g = 1) {
                  const x = h.getBucket(s),
                    w = h.latestFeatureIndex;
                  if (!x || !w || s.fqid !== x.layerIds[0]) return;
                  const S = x.layers[0].layout,
                    C = x.layers[0].paint,
                    D = h.collisionBoxArray,
                    L = Math.pow(2, this.transform.zoom - h.tileID.overscaledZ),
                    z = h.tileSize / r.aj,
                    O = h.tileID.toUnwrapped();
                  this.transform.setProjection(x.projection);
                  const G =
                    ((U = h.tileID),
                    ($ = x.getProjection()),
                    (Z = this.transform),
                    $.name === this.projection
                      ? Z.calculateProjMatrix(U.toUnwrapped())
                      : cd(Z, $, U));
                  var U, $, Z;
                  const Y = S.get("text-pitch-alignment") === "map",
                    ie = S.get("text-rotation-alignment") === "map";
                  s.compileFilter(s.options);
                  const ae = s.dynamicFilter(),
                    pe = s.dynamicFilterNeedsFeature(),
                    ue = this.transform.calculatePixelsToTileUnitsMatrix(h),
                    ce = Ph(
                      G,
                      h.tileID.canonical,
                      Y,
                      ie,
                      this.transform,
                      x.getProjection(),
                      ue,
                    );
                  let le = null;
                  if (Y) {
                    const Ve = Dh(
                      G,
                      h.tileID.canonical,
                      Y,
                      ie,
                      this.transform,
                      x.getProjection(),
                      ue,
                    );
                    le = r.az([], this.transform.labelPlaneMatrix, Ve);
                  }
                  let me = null;
                  (ae &&
                    h.latestFeatureIndex &&
                    (me = {
                      unwrappedTileID: O,
                      dynamicFilter: ae,
                      dynamicFilterNeedsFeature: pe,
                    }),
                    (this.retainedQueryData[x.bucketInstanceId] = new sl(
                      x.bucketInstanceId,
                      w,
                      x.sourceLayerIndex,
                      x.index,
                      h.tileID,
                    )));
                  const [_e, De] = x.layers[0].layout.get(
                      "text-size-scale-range",
                    ),
                    ze = r.ay(g, _e, De),
                    [He, We] = S.get("icon-size-scale-range"),
                    et = r.ay(g, He, We),
                    Ce = {
                      bucket: x,
                      layout: S,
                      paint: C,
                      posMatrix: G,
                      textLabelPlaneMatrix: ce,
                      labelToScreenMatrix: le,
                      clippingData: me,
                      scale: L,
                      textPixelRatio: z,
                      holdingForFade: h.holdingForFade(),
                      collisionBoxArray: D,
                      partiallyEvaluatedTextSize: r.bH(
                        x.textSizeData,
                        this.transform.zoom,
                        ze,
                      ),
                      partiallyEvaluatedIconSize: r.bH(
                        x.iconSizeData,
                        this.transform.zoom,
                        et,
                      ),
                      collisionGroup: this.collisionGroups.get(x.sourceID),
                      latestFeatureIndex: h.latestFeatureIndex,
                    };
                  if (p)
                    for (const Ve of x.sortKeyRanges) {
                      const {
                        sortKey: Te,
                        symbolInstanceStart: Ze,
                        symbolInstanceEnd: Oe,
                      } = Ve;
                      t.push({
                        sortKey: Te,
                        symbolInstanceStart: Ze,
                        symbolInstanceEnd: Oe,
                        parameters: Ce,
                      });
                    }
                  else
                    t.push({
                      symbolInstanceStart: 0,
                      symbolInstanceEnd: x.symbolInstances.length,
                      parameters: Ce,
                    });
                }
                attemptAnchorPlacement(
                  t,
                  s,
                  h,
                  p,
                  g,
                  x,
                  w,
                  S,
                  C,
                  D,
                  L,
                  z,
                  O,
                  G,
                  U,
                  $,
                  Z,
                  Y,
                ) {
                  const {
                      textOffset0: ie,
                      textOffset1: ae,
                      crossTileID: pe,
                    } = z,
                    ue = [ie, ae],
                    ce = $i(t, h, p, ue, g),
                    le = this.collisionIndex.placeCollisionBox(
                      G,
                      g,
                      s,
                      zi(ce.x, ce.y, x, w, this.transform.angle),
                      L,
                      S,
                      C,
                      D.predicate,
                    );
                  if ($) {
                    const me = G.getSymbolInstanceIconSize(
                      Y,
                      this.transform.zoom,
                      z.placedIconSymbolIndex,
                    );
                    if (
                      this.collisionIndex.placeCollisionBox(
                        G,
                        me,
                        $,
                        zi(ce.x, ce.y, x, w, this.transform.angle),
                        L,
                        S,
                        C,
                        D.predicate,
                      ).box.length === 0
                    )
                      return;
                  }
                  if (le.box.length > 0) {
                    let me;
                    return (
                      this.prevPlacement &&
                        this.prevPlacement.variableOffsets[pe] &&
                        this.prevPlacement.placements[pe] &&
                        this.prevPlacement.placements[pe].text &&
                        (me = this.prevPlacement.variableOffsets[pe].anchor),
                      (this.variableOffsets[pe] = {
                        textOffset: ue,
                        width: h,
                        height: p,
                        anchor: t,
                        textScale: g,
                        prevAnchor: me,
                      }),
                      this.markUsedJustification(G, t, z, U),
                      G.allowVerticalPlacement &&
                        (this.markUsedOrientation(G, U, z),
                        (this.placedOrientations[pe] = U)),
                      { shift: ce, placedGlyphBoxes: le }
                    );
                  }
                }
                placeLayerBucketPart(t, s, h, p, g = 1) {
                  const {
                      bucket: x,
                      layout: w,
                      paint: S,
                      posMatrix: C,
                      textLabelPlaneMatrix: D,
                      labelToScreenMatrix: L,
                      clippingData: z,
                      textPixelRatio: O,
                      holdingForFade: G,
                      collisionBoxArray: U,
                      partiallyEvaluatedTextSize: $,
                      partiallyEvaluatedIconSize: Z,
                      collisionGroup: Y,
                      latestFeatureIndex: ie,
                    } = t.parameters,
                    ae = w.get("text-optional"),
                    pe = w.get("icon-optional"),
                    ue = w.get("text-allow-overlap"),
                    ce = w.get("icon-allow-overlap"),
                    le = w.get("text-rotation-alignment") === "map",
                    me = w.get("text-pitch-alignment") === "map",
                    _e = S.get("symbol-z-offset"),
                    De = w.get("symbol-elevation-reference") === "sea",
                    [ze, He] = w.get("text-size-scale-range"),
                    [We, et] = w.get("icon-size-scale-range"),
                    Ce = r.ay(g, ze, He),
                    Ve = r.ay(g, We, et);
                  this.transform.setProjection(x.projection);
                  let Te = ue && (ce || !x.hasIconData() || pe),
                    Ze = ce && (ue || !x.hasTextData() || ae);
                  const Oe = !_e.isConstant();
                  (!x.collisionArrays && U && x.deserializeCollisionBoxes(U),
                    h &&
                      p &&
                      x.updateCollisionDebugBuffers(
                        this.transform.zoom,
                        U,
                        Ce,
                        Ve,
                      ));
                  const Ke = (qe, lt, St) => {
                      const { crossTileID: Et, numVerticalGlyphVertices: bt } =
                        qe;
                      let kt = null;
                      if ((z && z.dynamicFilterNeedsFeature) || Oe) {
                        const Ji = this.retainedQueryData[x.bucketInstanceId];
                        kt = ie.loadFeature({
                          featureIndex: qe.featureIndex,
                          bucketIndex: Ji.bucketIndex,
                          sourceLayerIndex: Ji.sourceLayerIndex,
                          layoutVertexArrayOffset: 0,
                        });
                      }
                      if (
                        z &&
                        !(0, z.dynamicFilter)(
                          {
                            zoom: this.transform.zoom,
                            pitch: this.transform.pitch,
                          },
                          kt,
                          this.retainedQueryData[x.bucketInstanceId].tileID
                            .canonical,
                          new r.P(qe.tileAnchorX, qe.tileAnchorY),
                          this.transform.calculateDistanceTileData(
                            z.unwrappedTileID,
                          ),
                        )
                      )
                        return (
                          (this.placements[Et] = new os(!1, !1, !1, !0)),
                          void s.add(Et)
                        );
                      const Bt = _e.evaluate(kt, {});
                      if (s.has(Et)) return;
                      if (G)
                        return void (this.placements[Et] = new os(!1, !1, !1));
                      let Vt = !1,
                        Zt = !1,
                        si = !0,
                        Fi = !1,
                        nn = !1,
                        ji = null,
                        Hi = { box: null, offscreen: null, occluded: null },
                        Fn = { box: null },
                        ti = null,
                        li = null,
                        gi = null,
                        cn = 0,
                        qn = 0,
                        rn = 0;
                      (St.textFeatureIndex
                        ? (cn = St.textFeatureIndex)
                        : qe.useRuntimeCollisionCircles &&
                          (cn = qe.featureIndex),
                        St.verticalTextFeatureIndex &&
                          (qn = St.verticalTextFeatureIndex));
                      const Di = (Ji) => {
                          Ji.tileID =
                            this.retainedQueryData[x.bucketInstanceId].tileID;
                          const un = this.transform.elevation;
                          ((Ji.elevation = De
                            ? Bt
                            : Bt +
                              (un
                                ? un.getAtTileOffset(
                                    Ji.tileID,
                                    Ji.tileAnchorX,
                                    Ji.tileAnchorY,
                                  )
                                : 0)),
                            (Ji.elevation += qe.zOffset));
                        },
                        Pn = St.textBox;
                      if (Pn) {
                        Di(Pn);
                        const Ji = (ki) => {
                            let zn = r.bI.horizontal;
                            if (
                              x.allowVerticalPlacement &&
                              !ki &&
                              this.prevPlacement
                            ) {
                              const fr =
                                this.prevPlacement.placedOrientations[Et];
                              fr &&
                                ((this.placedOrientations[Et] = fr),
                                (zn = fr),
                                this.markUsedOrientation(x, zn, qe));
                            }
                            return zn;
                          },
                          un = (ki, zn) => {
                            if (
                              x.allowVerticalPlacement &&
                              bt > 0 &&
                              St.verticalTextBox
                            ) {
                              for (const fr of x.writingModes)
                                if (
                                  (fr === r.bI.vertical
                                    ? ((Hi = zn()), (Fn = Hi))
                                    : (Hi = ki()),
                                  Hi && Hi.box && Hi.box.length)
                                )
                                  break;
                            } else Hi = ki();
                          };
                        if (w.get("text-variable-anchor")) {
                          let ki = w.get("text-variable-anchor");
                          if (
                            this.prevPlacement &&
                            this.prevPlacement.variableOffsets[Et]
                          ) {
                            const xn = this.prevPlacement.variableOffsets[Et];
                            ki.indexOf(xn.anchor) > 0 &&
                              ((ki = ki.filter((Ci) => Ci !== xn.anchor)),
                              ki.unshift(xn.anchor));
                          }
                          const zn = (xn, Ci, es) => {
                            const $r = x.getSymbolInstanceTextSize(
                                $,
                                qe,
                                this.transform.zoom,
                                lt,
                              ),
                              cs = (xn.x2 - xn.x1) * $r + 2 * xn.padding,
                              zs = (xn.y2 - xn.y1) * $r + 2 * xn.padding,
                              ws = qe.hasIconTextFit && !ce ? Ci : null;
                            ws && Di(ws);
                            let Hr = { box: [], offscreen: !1, occluded: !1 };
                            const qo = ue ? 2 * ki.length : ki.length;
                            for (let ks = 0; ks < qo; ++ks) {
                              const Zo = this.attemptAnchorPlacement(
                                ki[ks % ki.length],
                                xn,
                                cs,
                                zs,
                                $r,
                                le,
                                me,
                                O,
                                C,
                                Y,
                                ks >= ki.length,
                                qe,
                                lt,
                                x,
                                es,
                                ws,
                                $,
                                Z,
                              );
                              if (
                                Zo &&
                                ((Hr = Zo.placedGlyphBoxes),
                                Hr && Hr.box && Hr.box.length)
                              ) {
                                ((Vt = !0), (ji = Zo.shift));
                                break;
                              }
                            }
                            return Hr;
                          };
                          (un(
                            () => zn(Pn, St.iconBox, r.bI.horizontal),
                            () => {
                              const xn = St.verticalTextBox;
                              return (
                                xn && Di(xn),
                                x.allowVerticalPlacement &&
                                !(Hi && Hi.box && Hi.box.length) &&
                                bt > 0 &&
                                xn
                                  ? zn(xn, St.verticalIconBox, r.bI.vertical)
                                  : {
                                      box: null,
                                      offscreen: null,
                                      occluded: null,
                                    }
                              );
                            },
                          ),
                            Hi &&
                              ((Vt = Hi.box),
                              (si = Hi.offscreen),
                              (Fi = Hi.occluded)));
                          const fr = Ji(!(!Hi || !Hi.box));
                          if (!Vt && this.prevPlacement) {
                            const xn = this.prevPlacement.variableOffsets[Et];
                            xn &&
                              ((this.variableOffsets[Et] = xn),
                              this.markUsedJustification(x, xn.anchor, qe, fr));
                          }
                        } else {
                          const ki = (zn, fr) => {
                            const xn = x.getSymbolInstanceTextSize(
                                $,
                                qe,
                                this.transform.zoom,
                                lt,
                                g,
                              ),
                              Ci = this.collisionIndex.placeCollisionBox(
                                x,
                                xn,
                                zn,
                                new r.P(0, 0),
                                ue,
                                O,
                                C,
                                Y.predicate,
                              );
                            return (
                              Ci &&
                                Ci.box &&
                                Ci.box.length &&
                                (this.markUsedOrientation(x, fr, qe),
                                (this.placedOrientations[Et] = fr)),
                              Ci
                            );
                          };
                          (un(
                            () => ki(Pn, r.bI.horizontal),
                            () => {
                              const zn = St.verticalTextBox;
                              return x.allowVerticalPlacement && bt > 0 && zn
                                ? (Di(zn), ki(zn, r.bI.vertical))
                                : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null,
                                  };
                            },
                          ),
                            Ji(!!(Hi && Hi.box && Hi.box.length)));
                        }
                      }
                      if (
                        ((ti = Hi),
                        (Vt = ti && ti.box && ti.box.length > 0),
                        (si = ti && ti.offscreen),
                        (Fi = ti && ti.occluded),
                        qe.useRuntimeCollisionCircles)
                      ) {
                        const Ji = x.text.placedSymbolArray.get(
                            qe.centerJustifiedTextSymbolIndex >= 0
                              ? qe.centerJustifiedTextSymbolIndex
                              : qe.verticalPlacedTextSymbolIndex,
                          ),
                          un = r.bJ(x.textSizeData, $, Ji),
                          ki = w.get("text-padding");
                        ((li = this.collisionIndex.placeCollisionCircles(
                          x,
                          ue,
                          Ji,
                          x.lineVertexArray,
                          x.glyphOffsetArray,
                          un,
                          C,
                          D,
                          L,
                          h,
                          me,
                          Y.predicate,
                          (qe.collisionCircleDiameter * un) / r.bO,
                          ki,
                          this.retainedQueryData[x.bucketInstanceId].tileID,
                        )),
                          (Vt =
                            ue ||
                            (li.circles.length > 0 && !li.collisionDetected)),
                          (si = si && li.offscreen),
                          (Fi = li.occluded));
                      }
                      if (
                        (St.iconFeatureIndex && (rn = St.iconFeatureIndex),
                        St.iconBox)
                      ) {
                        const Ji = (un) => {
                          Di(un);
                          const ki =
                              qe.hasIconTextFit && ji
                                ? zi(ji.x, ji.y, le, me, this.transform.angle)
                                : new r.P(0, 0),
                            zn = x.getSymbolInstanceIconSize(
                              Z,
                              this.transform.zoom,
                              qe.placedIconSymbolIndex,
                            );
                          return this.collisionIndex.placeCollisionBox(
                            x,
                            zn,
                            un,
                            ki,
                            ce,
                            O,
                            C,
                            Y.predicate,
                          );
                        };
                        (Fn && Fn.box && Fn.box.length && St.verticalIconBox
                          ? ((gi = Ji(St.verticalIconBox)),
                            (Zt = gi.box.length > 0))
                          : ((gi = Ji(St.iconBox)), (Zt = gi.box.length > 0)),
                          (si = si && gi.offscreen),
                          (nn = gi.occluded));
                      }
                      const Ti =
                          ae ||
                          (qe.numHorizontalGlyphVertices === 0 && bt === 0),
                        Un = pe || qe.numIconVertices === 0;
                      if (
                        (Ti || Un
                          ? Un
                            ? Ti || (Zt = Zt && Vt)
                            : (Vt = Zt && Vt)
                          : (Zt = Vt = Zt && Vt),
                        Vt &&
                          ti &&
                          ti.box &&
                          this.collisionIndex.insertCollisionBox(
                            ti.box,
                            w.get("text-ignore-placement"),
                            x.bucketInstanceId,
                            Fn && Fn.box && qn ? qn : cn,
                            Y.ID,
                          ),
                        Zt &&
                          gi &&
                          this.collisionIndex.insertCollisionBox(
                            gi.box,
                            w.get("icon-ignore-placement"),
                            x.bucketInstanceId,
                            rn,
                            Y.ID,
                          ),
                        li &&
                          (Vt &&
                            this.collisionIndex.insertCollisionCircles(
                              li.circles,
                              w.get("text-ignore-placement"),
                              x.bucketInstanceId,
                              cn,
                              Y.ID,
                            ),
                          h))
                      ) {
                        const Ji = x.bucketInstanceId;
                        let un = this.collisionCircleArrays[Ji];
                        un === void 0 &&
                          (un = this.collisionCircleArrays[Ji] = new hd());
                        for (let ki = 0; ki < li.circles.length; ki += 4)
                          (un.circles.push(li.circles[ki + 0]),
                            un.circles.push(li.circles[ki + 1]),
                            un.circles.push(li.circles[ki + 2]),
                            un.circles.push(li.collisionDetected ? 1 : 0));
                      }
                      const hn = x.projection.name !== "globe";
                      ((Te = Te && (hn || !Fi)),
                        (Ze = Ze && (hn || !nn)),
                        (this.placements[Et] = new os(
                          Vt || Te,
                          Zt || Ze,
                          si || x.justReloaded,
                        )),
                        s.add(Et));
                    },
                    ht = this.retainedQueryData[x.bucketInstanceId].tileID;
                  if (
                    (x.elevationType === "offset" &&
                      this.buildingIndex &&
                      this.buildingIndex.updateZOffset(x, ht),
                    x.elevationType === "road" &&
                      x.updateRoadElevation(ht.canonical),
                    x.updateZOffset(),
                    x.sortFeaturesByY)
                  ) {
                    const qe = x.getSortedSymbolIndexes(this.transform.angle);
                    for (let lt = qe.length - 1; lt >= 0; --lt) {
                      const St = qe[lt];
                      Ke(x.symbolInstances.get(St), St, x.collisionArrays[St]);
                    }
                    x.hasAnyZOffset &&
                      r.w(
                        `${x.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`,
                      );
                  } else if (x.hasAnyZOffset) {
                    const qe = x.getSortedIndexesByZOffset();
                    for (let lt = 0; lt < qe.length; ++lt) {
                      const St = qe[lt];
                      Ke(x.symbolInstances.get(St), St, x.collisionArrays[St]);
                    }
                  } else
                    for (
                      let qe = t.symbolInstanceStart;
                      qe < t.symbolInstanceEnd;
                      qe++
                    )
                      Ke(x.symbolInstances.get(qe), qe, x.collisionArrays[qe]);
                  if (h && x.bucketInstanceId in this.collisionCircleArrays) {
                    const qe = this.collisionCircleArrays[x.bucketInstanceId];
                    (r.bi(qe.invProjMatrix, C),
                      (qe.viewportMatrix =
                        this.collisionIndex.getViewportMatrix()));
                  }
                  x.justReloaded = !1;
                }
                markUsedJustification(t, s, h, p) {
                  const {
                      leftJustifiedTextSymbolIndex: g,
                      centerJustifiedTextSymbolIndex: x,
                      rightJustifiedTextSymbolIndex: w,
                      verticalPlacedTextSymbolIndex: S,
                      crossTileID: C,
                    } = h,
                    D = r.bV(s),
                    L =
                      p === r.bI.vertical
                        ? S
                        : D === "left"
                          ? g
                          : D === "center"
                            ? x
                            : D === "right"
                              ? w
                              : -1;
                  (g >= 0 &&
                    (t.text.placedSymbolArray.get(g).crossTileID =
                      L >= 0 && g !== L ? 0 : C),
                    x >= 0 &&
                      (t.text.placedSymbolArray.get(x).crossTileID =
                        L >= 0 && x !== L ? 0 : C),
                    w >= 0 &&
                      (t.text.placedSymbolArray.get(w).crossTileID =
                        L >= 0 && w !== L ? 0 : C),
                    S >= 0 &&
                      (t.text.placedSymbolArray.get(S).crossTileID =
                        L >= 0 && S !== L ? 0 : C));
                }
                markUsedOrientation(t, s, h) {
                  const p =
                      s === r.bI.horizontal || s === r.bI.horizontalOnly
                        ? s
                        : 0,
                    g = s === r.bI.vertical ? s : 0,
                    {
                      leftJustifiedTextSymbolIndex: x,
                      centerJustifiedTextSymbolIndex: w,
                      rightJustifiedTextSymbolIndex: S,
                      verticalPlacedTextSymbolIndex: C,
                    } = h,
                    D = t.text.placedSymbolArray;
                  (x >= 0 && (D.get(x).placedOrientation = p),
                    w >= 0 && (D.get(w).placedOrientation = p),
                    S >= 0 && (D.get(S).placedOrientation = p),
                    C >= 0 && (D.get(C).placedOrientation = g));
                }
                commit(t) {
                  ((this.commitTime = t),
                    (this.zoomAtLastRecencyCheck = this.transform.zoom));
                  const s = this.prevPlacement;
                  let h = !1;
                  this.prevZoomAdjustment = s
                    ? s.zoomAdjustment(this.transform.zoom)
                    : 0;
                  const p = s ? s.symbolFadeChange(t) : 1,
                    g = s ? s.opacities : {},
                    x = s ? s.variableOffsets : {},
                    w = s ? s.placedOrientations : {};
                  for (const S in this.placements) {
                    const C = this.placements[S],
                      D = g[S];
                    D
                      ? ((this.opacities[S] = new va(
                          D,
                          p,
                          C.text,
                          C.icon,
                          null,
                          C.clipped,
                        )),
                        (h =
                          h ||
                          C.text !== D.text.placed ||
                          C.icon !== D.icon.placed))
                      : ((this.opacities[S] = new va(
                          null,
                          p,
                          C.text,
                          C.icon,
                          C.skipFade,
                          C.clipped,
                        )),
                        (h = h || C.text || C.icon));
                  }
                  for (const S in g) {
                    const C = g[S];
                    if (!this.opacities[S]) {
                      const D = new va(C, p, !1, !1);
                      D.isHidden() ||
                        ((this.opacities[S] = D),
                        (h = h || C.text.placed || C.icon.placed));
                    }
                  }
                  for (const S in x)
                    this.variableOffsets[S] ||
                      !this.opacities[S] ||
                      this.opacities[S].isHidden() ||
                      (this.variableOffsets[S] = x[S]);
                  for (const S in w)
                    this.placedOrientations[S] ||
                      !this.opacities[S] ||
                      this.opacities[S].isHidden() ||
                      (this.placedOrientations[S] = w[S]);
                  h
                    ? (this.lastPlacementChangeTime = t)
                    : typeof this.lastPlacementChangeTime != "number" &&
                      (this.lastPlacementChangeTime = s
                        ? s.lastPlacementChangeTime
                        : t);
                }
                updateLayerOpacities(t, s, h, p) {
                  const g = new Set();
                  for (const x of s) {
                    const w = x.getBucket(t);
                    w &&
                      x.latestFeatureIndex &&
                      t.fqid === w.layerIds[0] &&
                      (this.updateBucketOpacities(
                        w,
                        g,
                        x,
                        x.collisionBoxArray,
                        h,
                        p,
                        x.tileID,
                        t.scope,
                      ),
                      w.elevationType === "offset" &&
                        this.buildingIndex &&
                        this.buildingIndex.updateZOffset(w, x.tileID),
                      w.elevationType === "road" &&
                        w.updateRoadElevation(x.tileID.canonical),
                      w.updateZOffset());
                  }
                }
                updateBucketOpacities(t, s, h, p, g, x, w, S) {
                  (t.hasTextData() && t.text.opacityVertexArray.clear(),
                    t.hasIconData() && t.icon.opacityVertexArray.clear(),
                    t.hasIconCollisionBoxData() &&
                      t.iconCollisionBox.collisionVertexArray.clear(),
                    t.hasTextCollisionBoxData() &&
                      t.textCollisionBox.collisionVertexArray.clear());
                  const C = t.layers[0].layout,
                    D = t.layers[0].paint,
                    L = !!t.layers[0].dynamicFilter(),
                    z = new va(null, 0, !1, !1, !0),
                    O = C.get("text-allow-overlap"),
                    G = C.get("icon-allow-overlap"),
                    U = C.get("text-variable-anchor"),
                    $ = C.get("text-rotation-alignment") === "map",
                    Z = C.get("text-pitch-alignment") === "map",
                    Y = D.get("symbol-z-offset"),
                    ie = C.get("symbol-elevation-reference") === "sea",
                    ae = !Y.isConstant(),
                    pe = new va(
                      null,
                      0,
                      O && (G || !t.hasIconData() || C.get("icon-optional")),
                      G && (O || !t.hasTextData() || C.get("text-optional")),
                      !0,
                    );
                  !t.collisionArrays &&
                    p &&
                    (t.hasIconCollisionBoxData() ||
                      t.hasTextCollisionBoxData()) &&
                    t.deserializeCollisionBoxes(p);
                  const ue = (le, me, _e) => {
                    for (let De = 0; De < me / 4; De++)
                      le.opacityVertexArray.emplaceBack(_e);
                  };
                  let ce = 0;
                  x && t.updateReplacement(w, x);
                  for (let le = 0; le < t.symbolInstances.length; le++) {
                    const me = t.symbolInstances.get(le),
                      {
                        numHorizontalGlyphVertices: _e,
                        numVerticalGlyphVertices: De,
                        crossTileID: ze,
                        numIconVertices: He,
                        tileAnchorX: We,
                        tileAnchorY: et,
                      } = me;
                    let Ce = null;
                    const Ve = this.retainedQueryData[t.bucketInstanceId];
                    ae &&
                      me &&
                      Ve &&
                      (Ce = h.latestFeatureIndex.loadFeature({
                        featureIndex: me.featureIndex,
                        bucketIndex: Ve.bucketIndex,
                        sourceLayerIndex: Ve.sourceLayerIndex,
                        layoutVertexArrayOffset: 0,
                      }));
                    const Te = Y.evaluate(Ce, {}),
                      Ze = s.has(ze);
                    let Oe = this.opacities[ze];
                    (Ze
                      ? (Oe = z)
                      : Oe || ((Oe = pe), (this.opacities[ze] = Oe)),
                      s.add(ze));
                    const Ke = _e > 0 || De > 0,
                      ht = He > 0,
                      qe = this.placedOrientations[ze],
                      lt = qe === r.bI.vertical,
                      St = qe === r.bI.horizontal || qe === r.bI.horizontalOnly;
                    (!Ke && !ht) || Oe.isHidden() || ce++;
                    let Et = !1;
                    if ((Ke || ht) && x)
                      for (const bt of t.activeReplacements) {
                        if (
                          r.bP(bt, g, r.bQ.Symbol, S) ||
                          bt.min.x > We ||
                          We > bt.max.x ||
                          bt.min.y > et ||
                          et > bt.max.y
                        )
                          continue;
                        const kt = r.bR(
                          We,
                          et,
                          w.canonical,
                          bt.footprintTileId.canonical,
                        );
                        if (((Et = r.bS(kt, bt.footprint)), Et)) break;
                      }
                    if (Ke) {
                      const bt = Et ? Ro : ol(Oe.text);
                      (ue(t.text, _e, lt ? Ro : bt),
                        ue(t.text, De, St ? Ro : bt));
                      const kt = Oe.text.isHidden(),
                        {
                          leftJustifiedTextSymbolIndex: Bt,
                          centerJustifiedTextSymbolIndex: Vt,
                          rightJustifiedTextSymbolIndex: Zt,
                          verticalPlacedTextSymbolIndex: si,
                        } = me,
                        Fi = t.text.placedSymbolArray,
                        nn = kt || lt ? 1 : 0;
                      (Bt >= 0 && (Fi.get(Bt).hidden = nn),
                        Vt >= 0 && (Fi.get(Vt).hidden = nn),
                        Zt >= 0 && (Fi.get(Zt).hidden = nn),
                        si >= 0 && (Fi.get(si).hidden = kt || St ? 1 : 0));
                      const ji = this.variableOffsets[ze];
                      ji && this.markUsedJustification(t, ji.anchor, me, qe);
                      const Hi = this.placedOrientations[ze];
                      Hi &&
                        (this.markUsedJustification(t, "left", me, Hi),
                        this.markUsedOrientation(t, Hi, me));
                    }
                    if (ht) {
                      const bt = Et ? Ro : ol(Oe.icon),
                        {
                          placedIconSymbolIndex: kt,
                          verticalPlacedIconSymbolIndex: Bt,
                        } = me,
                        Vt = t.icon.placedSymbolArray,
                        Zt = Oe.icon.isHidden() ? 1 : 0;
                      (kt >= 0 &&
                        (ue(t.icon, He, lt ? Ro : bt),
                        (Vt.get(kt).hidden = Zt)),
                        Bt >= 0 &&
                          (ue(t.icon, me.numVerticalIconVertices, St ? Ro : bt),
                          (Vt.get(Bt).hidden = Zt)));
                    }
                    if (
                      t.hasIconCollisionBoxData() ||
                      t.hasTextCollisionBoxData()
                    ) {
                      const bt = t.collisionArrays[le];
                      if (bt) {
                        let kt = new r.P(0, 0),
                          Bt = !0;
                        if (bt.textBox || bt.verticalTextBox) {
                          if (U) {
                            const Zt = this.variableOffsets[ze];
                            Zt
                              ? ((kt = $i(
                                  Zt.anchor,
                                  Zt.width,
                                  Zt.height,
                                  Zt.textOffset,
                                  Zt.textScale,
                                )),
                                $ &&
                                  kt._rotate(
                                    Z
                                      ? this.transform.angle
                                      : -this.transform.angle,
                                  ))
                              : (Bt = !1);
                          }
                          (L && (Bt = !Oe.clipped),
                            bt.textBox &&
                              so(
                                t.textCollisionBox.collisionVertexArray,
                                Oe.text.placed,
                                !Bt || lt,
                                Te,
                                ie,
                                kt.x,
                                kt.y,
                              ),
                            bt.verticalTextBox &&
                              so(
                                t.textCollisionBox.collisionVertexArray,
                                Oe.text.placed,
                                !Bt || St,
                                Te,
                                ie,
                                kt.x,
                                kt.y,
                              ));
                        }
                        const Vt = Bt && !!(!St && bt.verticalIconBox);
                        (bt.iconBox &&
                          so(
                            t.iconCollisionBox.collisionVertexArray,
                            Oe.icon.placed,
                            Vt,
                            Te,
                            ie,
                            me.hasIconTextFit ? kt.x : 0,
                            me.hasIconTextFit ? kt.y : 0,
                          ),
                          bt.verticalIconBox &&
                            so(
                              t.iconCollisionBox.collisionVertexArray,
                              Oe.icon.placed,
                              !Vt,
                              Te,
                              ie,
                              me.hasIconTextFit ? kt.x : 0,
                              me.hasIconTextFit ? kt.y : 0,
                            ));
                      }
                    }
                  }
                  if (
                    ((t.fullyClipped = ce === 0),
                    t.sortFeatures(this.transform.angle),
                    this.retainedQueryData[t.bucketInstanceId] &&
                      (this.retainedQueryData[
                        t.bucketInstanceId
                      ].featureSortOrder = t.featureSortOrder),
                    t.hasTextData() &&
                      t.text.opacityVertexBuffer &&
                      t.text.opacityVertexBuffer.updateData(
                        t.text.opacityVertexArray,
                      ),
                    t.hasIconData() &&
                      t.icon.opacityVertexBuffer &&
                      t.icon.opacityVertexBuffer.updateData(
                        t.icon.opacityVertexArray,
                      ),
                    t.hasIconCollisionBoxData() &&
                      t.iconCollisionBox.collisionVertexBuffer &&
                      t.iconCollisionBox.collisionVertexBuffer.updateData(
                        t.iconCollisionBox.collisionVertexArray,
                      ),
                    t.hasTextCollisionBoxData() &&
                      t.textCollisionBox.collisionVertexBuffer &&
                      t.textCollisionBox.collisionVertexBuffer.updateData(
                        t.textCollisionBox.collisionVertexArray,
                      ),
                    t.bucketInstanceId in this.collisionCircleArrays)
                  ) {
                    const le = this.collisionCircleArrays[t.bucketInstanceId];
                    ((t.placementInvProjMatrix = le.invProjMatrix),
                      (t.placementViewportMatrix = le.viewportMatrix),
                      (t.collisionCircleArray = le.circles),
                      delete this.collisionCircleArrays[t.bucketInstanceId]);
                  }
                }
                symbolFadeChange(t) {
                  return this.fadeDuration === 0
                    ? 1
                    : (t - this.commitTime) / this.fadeDuration +
                        this.prevZoomAdjustment;
                }
                zoomAdjustment(t) {
                  return Math.max(0, (this.transform.zoom - t) / 1.5);
                }
                hasTransitions(t) {
                  return (
                    this.stale ||
                    t - this.lastPlacementChangeTime < this.fadeDuration
                  );
                }
                stillRecent(t, s) {
                  const h =
                    this.zoomAtLastRecencyCheck === s
                      ? 1 - this.zoomAdjustment(s)
                      : 1;
                  return (
                    (this.zoomAtLastRecencyCheck = s),
                    this.commitTime + this.fadeDuration * h > t
                  );
                }
                setStale() {
                  this.stale = !0;
                }
              }
              function so(c, t, s, h, p, g, x) {
                (c.emplaceBack(
                  t ? 1 : 0,
                  s ? 1 : 0,
                  g || 0,
                  x || 0,
                  h,
                  p ? 1 : 0,
                ),
                  c.emplaceBack(
                    t ? 1 : 0,
                    s ? 1 : 0,
                    g || 0,
                    x || 0,
                    h,
                    p ? 1 : 0,
                  ),
                  c.emplaceBack(
                    t ? 1 : 0,
                    s ? 1 : 0,
                    g || 0,
                    x || 0,
                    h,
                    p ? 1 : 0,
                  ),
                  c.emplaceBack(
                    t ? 1 : 0,
                    s ? 1 : 0,
                    g || 0,
                    x || 0,
                    h,
                    p ? 1 : 0,
                  ));
              }
              const Oi = Math.pow(2, 25),
                Lh = Math.pow(2, 24),
                _c = Math.pow(2, 17),
                yc = Math.pow(2, 16),
                Dr = Math.pow(2, 9),
                Xn = Math.pow(2, 8),
                u_ = Math.pow(2, 1);
              function ol(c) {
                if (c.opacity === 0 && !c.placed) return 0;
                if (c.opacity === 1 && c.placed) return 4294967295;
                const t = c.placed ? 1 : 0,
                  s = Math.floor(127 * c.opacity);
                return (
                  s * Oi +
                  t * Lh +
                  s * _c +
                  t * yc +
                  s * Dr +
                  t * Xn +
                  s * u_ +
                  t
                );
              }
              const Ro = 0;
              class xc {
                constructor(t) {
                  ((this._sortAcrossTiles =
                    t.layout.get("symbol-z-order") !== "viewport-y" &&
                    t.layout.get("symbol-sort-key").constantOr(1) !== void 0),
                    (this._currentTileIndex = 0),
                    (this._currentPartIndex = 0),
                    (this._seenCrossTileIDs = new Set()),
                    (this._bucketParts = []));
                }
                continuePlacement(t, s, h, p, g, x) {
                  const w = this._bucketParts;
                  for (; this._currentTileIndex < t.length; )
                    if (
                      (s.getBucketParts(
                        w,
                        p,
                        t[this._currentTileIndex],
                        this._sortAcrossTiles,
                        x,
                      ),
                      this._currentTileIndex++,
                      g())
                    )
                      return !0;
                  for (
                    this._sortAcrossTiles &&
                    ((this._sortAcrossTiles = !1),
                    w.sort((S, C) => S.sortKey - C.sortKey));
                    this._currentPartIndex < w.length;

                  ) {
                    const S = w[this._currentPartIndex];
                    if (
                      (s.placeLayerBucketPart(
                        S,
                        this._seenCrossTileIDs,
                        h,
                        S.symbolInstanceStart === 0,
                        x,
                      ),
                      this._currentPartIndex++,
                      g())
                    )
                      return !0;
                  }
                  return !1;
                }
              }
              class Oh {
                constructor(t, s, h, p, g, x, w, S, C) {
                  ((this.placement = new Jr(t, g, x, w, S, C)),
                    (this._currentPlacementIndex = s.length - 1),
                    (this._forceFullPlacement = h),
                    (this._showCollisionBoxes = p),
                    (this._done = !1));
                }
                isDone() {
                  return this._done;
                }
                continuePlacement(t, s, h, p, g) {
                  const x = r.q.now(),
                    w = () => {
                      const S = r.q.now() - x;
                      return !this._forceFullPlacement && S > 2;
                    };
                  for (; this._currentPlacementIndex >= 0; ) {
                    const S = s[t[this._currentPlacementIndex]],
                      C = this.placement.collisionIndex.transform.zoom;
                    if (
                      S.type === "symbol" &&
                      (!S.minzoom || S.minzoom <= C) &&
                      (!S.maxzoom || S.maxzoom > C)
                    ) {
                      const D = S,
                        L = D.layout.get("symbol-z-elevate"),
                        z =
                          D.layout.get("symbol-sort-key").constantOr(1) !==
                          void 0,
                        O = D.layout.get("symbol-z-order"),
                        G =
                          O === "viewport-y" ||
                          (O === "auto" && !(O !== "viewport-y" && z)),
                        U =
                          D.layout.get("text-allow-overlap") ||
                          D.layout.get("icon-allow-overlap") ||
                          D.layout.get("text-ignore-placement") ||
                          D.layout.get("icon-ignore-placement"),
                        $ = G && U,
                        Z = (this._inProgressLayer =
                          this._inProgressLayer || new xc(D)),
                        Y = r.C(S.source, S.scope);
                      if (
                        Z.continuePlacement(
                          L || $ ? p[Y] : h[Y],
                          this.placement,
                          this._showCollisionBoxes,
                          S,
                          w,
                          g,
                        )
                      )
                        return;
                      delete this._inProgressLayer;
                    }
                    this._currentPlacementIndex--;
                  }
                  this._done = !0;
                }
                commit(t) {
                  return (this.placement.commit(t), this.placement);
                }
              }
              const vc = 512 / r.aj / 2;
              class Fh {
                constructor(t, s, h) {
                  ((this.tileID = t),
                    (this.bucketInstanceId = h),
                    (this.index = new r.bW(s.length, 16, Int32Array)),
                    (this.keys = []),
                    (this.crossTileIDs = []));
                  const p = t.canonical.x * r.aj,
                    g = t.canonical.y * r.aj;
                  for (let x = 0; x < s.length; x++) {
                    const {
                        key: w,
                        crossTileID: S,
                        tileAnchorX: C,
                        tileAnchorY: D,
                      } = s.get(x),
                      L = Math.floor((p + C) * vc),
                      z = Math.floor((g + D) * vc);
                    (this.index.add(L, z),
                      this.keys.push(w),
                      this.crossTileIDs.push(S));
                  }
                  this.index.finish();
                }
                findMatches(t, s, h) {
                  const p =
                      this.tileID.canonical.z < s.canonical.z
                        ? 1
                        : Math.pow(2, this.tileID.canonical.z - s.canonical.z),
                    g =
                      vc / Math.pow(2, s.canonical.z - this.tileID.canonical.z),
                    x = s.canonical.x * r.aj,
                    w = s.canonical.y * r.aj;
                  for (let S = 0; S < t.length; S++) {
                    const C = t.get(S);
                    if (C.crossTileID) continue;
                    const { key: D, tileAnchorX: L, tileAnchorY: z } = C,
                      O = Math.floor((x + L) * g),
                      G = Math.floor((w + z) * g),
                      U = this.index
                        .range(O - p, G - p, O + p, G + p)
                        .sort(($, Z) => $ - Z);
                    for (const $ of U) {
                      const Z = this.crossTileIDs[$];
                      if (this.keys[$] === D && !h.has(Z)) {
                        (h.add(Z), (C.crossTileID = Z));
                        break;
                      }
                    }
                  }
                }
              }
              class Rr {
                constructor() {
                  this.maxCrossTileID = 0;
                }
                generate() {
                  return ++this.maxCrossTileID;
                }
              }
              class oo {
                constructor() {
                  ((this.indexes = {}),
                    (this.usedCrossTileIDs = {}),
                    (this.lng = 0));
                }
                handleWrapJump(t) {
                  const s = Math.round((t - this.lng) / 360);
                  if (s !== 0)
                    for (const h in this.indexes) {
                      const p = this.indexes[h],
                        g = {};
                      for (const x in p) {
                        const w = p[x];
                        ((w.tileID = w.tileID.unwrapTo(w.tileID.wrap + s)),
                          (g[w.tileID.key] = w));
                      }
                      this.indexes[h] = g;
                    }
                  this.lng = t;
                }
                addBucket(t, s, h) {
                  if (
                    this.indexes[t.overscaledZ] &&
                    this.indexes[t.overscaledZ][t.key]
                  ) {
                    if (
                      this.indexes[t.overscaledZ][t.key].bucketInstanceId ===
                      s.bucketInstanceId
                    )
                      return !1;
                    this.removeBucketCrossTileIDs(
                      t.overscaledZ,
                      this.indexes[t.overscaledZ][t.key],
                    );
                  }
                  for (let g = 0; g < s.symbolInstances.length; g++)
                    s.symbolInstances.get(g).crossTileID = 0;
                  this.usedCrossTileIDs[t.overscaledZ] ||
                    (this.usedCrossTileIDs[t.overscaledZ] = new Set());
                  const p = this.usedCrossTileIDs[t.overscaledZ];
                  for (const g in this.indexes) {
                    const x = this.indexes[g];
                    if (Number(g) > t.overscaledZ)
                      for (const w in x) {
                        const S = x[w];
                        S.tileID.isChildOf(t) &&
                          S.findMatches(s.symbolInstances, t, p);
                      }
                    else {
                      const w = x[t.scaledTo(Number(g)).key];
                      w && w.findMatches(s.symbolInstances, t, p);
                    }
                  }
                  for (let g = 0; g < s.symbolInstances.length; g++) {
                    const x = s.symbolInstances.get(g);
                    x.crossTileID ||
                      ((x.crossTileID = h.generate()), p.add(x.crossTileID));
                  }
                  return (
                    this.indexes[t.overscaledZ] === void 0 &&
                      (this.indexes[t.overscaledZ] = {}),
                    (this.indexes[t.overscaledZ][t.key] = new Fh(
                      t,
                      s.symbolInstances,
                      s.bucketInstanceId,
                    )),
                    !0
                  );
                }
                removeBucketCrossTileIDs(t, s) {
                  for (const h of s.crossTileIDs)
                    this.usedCrossTileIDs[t].delete(h);
                }
                removeStaleBuckets(t) {
                  let s = !1;
                  for (const h in this.indexes) {
                    const p = this.indexes[h];
                    for (const g in p)
                      t[p[g].bucketInstanceId] ||
                        (this.removeBucketCrossTileIDs(h, p[g]),
                        delete p[g],
                        (s = !0));
                  }
                  return s;
                }
              }
              class Gr {
                constructor() {
                  ((this.layerIndexes = {}),
                    (this.crossTileIDs = new Rr()),
                    (this.maxBucketInstanceId = 0),
                    (this.bucketsInCurrentPlacement = {}));
                }
                addLayer(t, s, h, p) {
                  let g = this.layerIndexes[t.fqid];
                  g === void 0 && (g = this.layerIndexes[t.fqid] = new oo());
                  let x = !1;
                  const w = {};
                  p.name !== "globe" && g.handleWrapJump(h);
                  for (const S of s) {
                    const C = S.getBucket(t);
                    C &&
                      t.fqid === C.layerIds[0] &&
                      (C.bucketInstanceId ||
                        (C.bucketInstanceId = ++this.maxBucketInstanceId),
                      g.addBucket(S.tileID, C, this.crossTileIDs) && (x = !0),
                      (w[C.bucketInstanceId] = !0));
                  }
                  return (g.removeStaleBuckets(w) && (x = !0), x);
                }
                pruneUnusedLayers(t) {
                  const s = {};
                  t.forEach((h) => {
                    s[h] = !0;
                  });
                  for (const h in this.layerIndexes)
                    s[h] || delete this.layerIndexes[h];
                }
              }
              const ba = 771;
              class ui {
                constructor(t, s, h, p) {
                  ((this.blendFunction = t),
                    (this.blendColor = s.toNonPremultipliedRenderColor(null)),
                    (this.mask = h),
                    (this.blendEquation = p));
                }
              }
              ((ui.Replace = [1, 0, 1, 0]),
                (ui.disabled = new ui(ui.Replace, r.am.transparent, [
                  !1,
                  !1,
                  !1,
                  !1,
                ])),
                (ui.unblended = new ui(ui.Replace, r.am.transparent, [
                  !0,
                  !0,
                  !0,
                  !0,
                ])),
                (ui.alphaBlended = new ui([1, ba, 1, ba], r.am.transparent, [
                  !0,
                  !0,
                  !0,
                  !0,
                ])),
                (ui.alphaBlendedNonPremultiplied = new ui(
                  [770, ba, 770, ba],
                  r.am.transparent,
                  [!0, !0, !0, !0],
                )),
                (ui.multiply = new ui([774, 0, 774, 0], r.am.transparent, [
                  !0,
                  !0,
                  !0,
                  !0,
                ])));
              class wt {
                constructor(t, s, h) {
                  ((this.func = t), (this.mask = s), (this.range = h));
                }
              }
              ((wt.ReadOnly = !1),
                (wt.ReadWrite = !0),
                (wt.disabled = new wt(519, wt.ReadOnly, [0, 1])));
              const _s = 7680;
              class Yt {
                constructor(t, s, h, p, g, x) {
                  ((this.test = t),
                    (this.ref = s),
                    (this.mask = h),
                    (this.fail = p),
                    (this.depthFail = g),
                    (this.pass = x));
                }
              }
              Yt.disabled = new Yt({ func: 519, mask: 0 }, 0, 0, _s, _s, _s);
              const Wn = 1029,
                bc = 2305;
              class Gt {
                constructor(t, s, h) {
                  ((this.enable = t), (this.mode = s), (this.frontFace = h));
                }
              }
              function al(c, t) {
                const s = r.c1(c, 3);
                (r.c3(c, t), r.c7(c, 3, s));
              }
              function ll(c, t) {
                const s = r.b_([]);
                return (r.b$(s, s, -t), r.c0(s, s, -c), s);
              }
              function zo(c, t) {
                const s = [c[0], c[1], 0],
                  h = [t[0], t[1], 0];
                if (r.ae(s) >= 1e-15) {
                  const x = r.au([], s);
                  (r.bY(h, x, r.bG(h, x)), (t[0] = h[0]), (t[1] = h[1]));
                }
                const p = r.bF([], t, c);
                if (r.bZ(p) < 1e-15) return null;
                const g = Math.atan2(-p[1], p[0]);
                return ll(
                  Math.atan2(Math.sqrt(c[0] * c[0] + c[1] * c[1]), -c[2]),
                  g,
                );
              }
              ((Gt.disabled = new Gt(!1, Wn, bc)),
                (Gt.backCCW = new Gt(!0, Wn, bc)),
                (Gt.backCW = new Gt(!0, Wn, 2304)),
                (Gt.frontCW = new Gt(!0, 1028, 2304)),
                (Gt.frontCCW = new Gt(!0, 1028, bc)));
              class Ip {
                constructor(t, s) {
                  ((this.position = t), (this.orientation = s));
                }
                get position() {
                  return this._position;
                }
                set position(t) {
                  if (t) {
                    const s =
                      t instanceof r.ac ? t : new r.ac(t[0], t[1], t[2]);
                    (this._renderWorldCopies && (s.x = r.bX(s.x, 0, 1)),
                      (this._position = s));
                  } else this._position = null;
                }
                lookAtPoint(t, s) {
                  if (((this.orientation = null), !this.position)) return;
                  const h = this.position,
                    p = this._elevation
                      ? this._elevation.getAtPointOrZero(r.ac.fromLngLat(t))
                      : 0,
                    g = r.ac.fromLngLat(t, p),
                    x = [g.x - h.x, g.y - h.y, g.z - h.z];
                  (s || (s = [0, 0, 1]),
                    (s[2] = Math.abs(s[2])),
                    (this.orientation = zo(x, s)));
                }
                setPitchBearing(t, s) {
                  this.orientation = ll(r.al(t), r.al(-s));
                }
              }
              class ys {
                constructor(t, s) {
                  ((this._transform = r.bx([])),
                    (this.orientation = s),
                    (this.position = t));
                }
                get mercatorPosition() {
                  const t = this.position;
                  return new r.ac(t[0], t[1], t[2]);
                }
                get position() {
                  const t = r.c1(this._transform, 3);
                  return [t[0], t[1], t[2]];
                }
                set position(t) {
                  var s;
                  t && r.c7(this._transform, 3, [(s = t)[0], s[1], s[2], 1]);
                }
                get orientation() {
                  return this._orientation;
                }
                set orientation(t) {
                  ((this._orientation = t || r.b_([])),
                    t && al(this._transform, this._orientation));
                }
                getPitchBearing() {
                  const t = this.forward(),
                    s = this.right();
                  return {
                    bearing: Math.atan2(-s[1], s[0]),
                    pitch: Math.atan2(
                      Math.sqrt(t[0] * t[0] + t[1] * t[1]),
                      -t[2],
                    ),
                  };
                }
                setPitchBearing(t, s) {
                  ((this._orientation = ll(t, s)),
                    al(this._transform, this._orientation));
                }
                forward() {
                  const t = r.c1(this._transform, 2);
                  return [-t[0], -t[1], -t[2]];
                }
                up() {
                  const t = r.c1(this._transform, 1);
                  return [-t[0], -t[1], -t[2]];
                }
                right() {
                  const t = r.c1(this._transform, 0);
                  return [t[0], t[1], t[2]];
                }
                getCameraToWorld(t, s) {
                  const h = new Float64Array(16);
                  return (r.bi(h, this.getWorldToCamera(t, s)), h);
                }
                getCameraToWorldMercator() {
                  return this._transform;
                }
                getWorldToCameraPosition(t, s, h) {
                  const p = this.position;
                  r.bY(p, p, -t);
                  const g = new Float64Array(16);
                  return (r.bn(g, [h, h, h]), r.bo(g, g, p), (g[10] *= s), g);
                }
                getWorldToCamera(t, s) {
                  const h = new Float64Array(16),
                    p = new Float64Array(4),
                    g = this.position;
                  return (
                    r.c2(p, this._orientation),
                    r.bY(g, g, -t),
                    r.c3(h, p),
                    r.bo(h, h, g),
                    (h[1] *= -1),
                    (h[5] *= -1),
                    (h[9] *= -1),
                    (h[13] *= -1),
                    (h[8] *= s),
                    (h[9] *= s),
                    (h[10] *= s),
                    (h[11] *= s),
                    h
                  );
                }
                getCameraToClipPerspective(t, s, h, p) {
                  const g = new Float64Array(16);
                  return (r.c4(g, t, s, h, p), g);
                }
                getCameraToClipOrthographic(t, s, h, p, g, x) {
                  const w = new Float64Array(16);
                  return (r.c5(w, t, s, h, p, g, x), w);
                }
                getDistanceToElevation(t, s = !1) {
                  const h =
                      t === 0
                        ? 0
                        : r.c6(
                            t,
                            s ? r.aY(this.position[1]) : this.position[1],
                          ),
                    p = this.forward();
                  return (h - this.position[2]) / p[2];
                }
                clone() {
                  return new ys([...this.position], [...this.orientation]);
                }
              }
              const zr = {
                BaseColor: 5,
                MetallicRoughness: 6,
                Normal: 7,
                Occlusion: 8,
                Emission: 9,
                LUT: 10,
                ShadowMap0: 11,
              };
              class wc {
                constructor(t = 0, s = 0, h = 0, p = 0) {
                  if (
                    isNaN(t) ||
                    t < 0 ||
                    isNaN(s) ||
                    s < 0 ||
                    isNaN(h) ||
                    h < 0 ||
                    isNaN(p) ||
                    p < 0
                  )
                    throw new Error(
                      "Invalid value for edge-insets, top, bottom, left and right must all be numbers",
                    );
                  ((this.top = t),
                    (this.bottom = s),
                    (this.left = h),
                    (this.right = p));
                }
                interpolate(t, s, h) {
                  return (
                    s.top != null &&
                      t.top != null &&
                      (this.top = r.ai(t.top, s.top, h)),
                    s.bottom != null &&
                      t.bottom != null &&
                      (this.bottom = r.ai(t.bottom, s.bottom, h)),
                    s.left != null &&
                      t.left != null &&
                      (this.left = r.ai(t.left, s.left, h)),
                    s.right != null &&
                      t.right != null &&
                      (this.right = r.ai(t.right, s.right, h)),
                    this
                  );
                }
                getCenter(t, s) {
                  const h = r.ay((this.left + t - this.right) / 2, 0, t),
                    p = r.ay((this.top + s - this.bottom) / 2, 0, s);
                  return new r.P(h, p);
                }
                equals(t) {
                  return (
                    this.top === t.top &&
                    this.bottom === t.bottom &&
                    this.left === t.left &&
                    this.right === t.right
                  );
                }
                clone() {
                  return new wc(this.top, this.bottom, this.left, this.right);
                }
                toJSON() {
                  return {
                    top: this.top,
                    bottom: this.bottom,
                    left: this.left,
                    right: this.right,
                  };
                }
              }
              const lr = 15;
              class ud {
                constructor(t, s, h, p, g, x, w) {
                  ((this.tileSize = 512),
                    (this._renderWorldCopies = g === void 0 || g),
                    (this._minZoom = t || 0),
                    (this._maxZoom = s || 22),
                    (this._minPitch = h ?? 0),
                    (this._maxPitch = p ?? 60),
                    this.setProjection(x),
                    this.setMaxBounds(w),
                    (this.width = 0),
                    (this.height = 0),
                    (this._center = new r.cd(0, 0)),
                    (this.zoom = 0),
                    (this.angle = 0),
                    (this._fov = 0.6435011087932844),
                    (this._pitch = 0),
                    (this._nearZ = 0),
                    (this._farZ = 0),
                    (this._unmodified = !0),
                    (this._edgeInsets = new wc()),
                    (this._projMatrixCache = {}),
                    (this._alignedProjMatrixCache = {}),
                    (this._fogTileMatrixCache = {}),
                    (this._expandedProjMatrixCache = {}),
                    (this._distanceTileDataCache = {}),
                    (this._camera = new ys()),
                    (this._centerAltitude = 0),
                    (this._averageElevation = 0),
                    (this.cameraElevationReference = "ground"),
                    (this._pixelsPerMercatorPixel = 1),
                    (this.globeRadius = 0),
                    (this.globeCenterInViewSpace = [0, 0, 0]),
                    (this._tileCoverLift = 0),
                    (this.freezeTileCoverage = !1),
                    (this._horizonShift = 0.1),
                    (this._orthographicProjectionAtLowPitch = !1),
                    (this._allowWorldUnderZoom = !1));
                }
                clone() {
                  const t = new ud(
                    this._minZoom,
                    this._maxZoom,
                    this._minPitch,
                    this.maxPitch,
                    this._renderWorldCopies,
                    this.getProjection(),
                    this.maxBounds,
                  );
                  return (
                    (t._elevation = this._elevation),
                    (t._centerAltitude = this._centerAltitude),
                    (t._centerAltitudeValidForExaggeration =
                      this._centerAltitudeValidForExaggeration),
                    (t.tileSize = this.tileSize),
                    (t.mercatorFromTransition = this.mercatorFromTransition),
                    (t.width = this.width),
                    (t.height = this.height),
                    (t.cameraElevationReference =
                      this.cameraElevationReference),
                    (t._center = this._center),
                    t._setZoom(this.zoom),
                    (t._seaLevelZoom = this._seaLevelZoom),
                    (t.angle = this.angle),
                    (t._fov = this._fov),
                    (t._pitch = this._pitch),
                    (t._nearZ = this._nearZ),
                    (t._farZ = this._farZ),
                    (t._averageElevation = this._averageElevation),
                    (t._orthographicProjectionAtLowPitch =
                      this._orthographicProjectionAtLowPitch),
                    (t._unmodified = this._unmodified),
                    (t._edgeInsets = this._edgeInsets.clone()),
                    (t._camera = this._camera.clone()),
                    t._calcMatrices(),
                    (t.freezeTileCoverage = this.freezeTileCoverage),
                    (t.frustumCorners = this.frustumCorners),
                    (t._allowWorldUnderZoom = this._allowWorldUnderZoom),
                    t
                  );
                }
                get isOrthographic() {
                  return (
                    this.projection.name !== "globe" &&
                    this._orthographicProjectionAtLowPitch &&
                    this.pitch < lr
                  );
                }
                get elevation() {
                  return this._elevation;
                }
                set elevation(t) {
                  this._elevation !== t &&
                    ((this._elevation = t),
                    this._updateCameraOnTerrain(),
                    this._calcMatrices());
                }
                get depthOcclusionForSymbolsAndCircles() {
                  return (
                    this.projection.name !== "globe" && !this.isOrthographic
                  );
                }
                updateElevation(t, s = !1) {
                  const h =
                    this._elevation &&
                    this._elevation.exaggeration() !==
                      this._centerAltitudeValidForExaggeration;
                  ((this._seaLevelZoom == null || h) &&
                    this._updateCameraOnTerrain(),
                    (t || h) && this._constrainCamera(s),
                    this._calcMatrices());
                }
                getProjection() {
                  return r.aF(this.projection, ["name", "center", "parallels"]);
                }
                setProjection(t) {
                  this.projectionOptions = t || { name: "mercator" };
                  const s = this.projection ? this.getProjection() : void 0;
                  this.projection = r.ce(this.projectionOptions);
                  const h = this.getProjection(),
                    p = !r.bv(s, h);
                  return (
                    p && this._calcMatrices(),
                    (this.mercatorFromTransition = !1),
                    p
                  );
                }
                setOrthographicProjectionAtLowPitch(t) {
                  return (
                    this._orthographicProjectionAtLowPitch !== t &&
                    ((this._orthographicProjectionAtLowPitch = t),
                    this._calcMatrices(),
                    !0)
                  );
                }
                setMercatorFromTransition() {
                  const t = this.projection.name;
                  ((this.mercatorFromTransition = !0),
                    (this.projectionOptions = { name: "mercator" }),
                    (this.projection = r.ce({ name: "mercator" })));
                  const s = t !== this.projection.name;
                  return (s && this._calcMatrices(), s);
                }
                get minZoom() {
                  return this._minZoom;
                }
                set minZoom(t) {
                  this._minZoom !== t &&
                    ((this._minZoom = t), (this.zoom = Math.max(this.zoom, t)));
                }
                get maxZoom() {
                  return this._maxZoom;
                }
                set maxZoom(t) {
                  this._maxZoom !== t &&
                    ((this._maxZoom = t), (this.zoom = Math.min(this.zoom, t)));
                }
                get minPitch() {
                  return this._minPitch;
                }
                set minPitch(t) {
                  this._minPitch !== t &&
                    ((this._minPitch = t),
                    (this.pitch = Math.max(this.pitch, t)));
                }
                get maxPitch() {
                  return this._maxPitch;
                }
                set maxPitch(t) {
                  this._maxPitch !== t &&
                    ((this._maxPitch = t),
                    (this.pitch = Math.min(this.pitch, t)));
                }
                get renderWorldCopies() {
                  return (
                    this._renderWorldCopies &&
                    this.projection.supportsWorldCopies === !0
                  );
                }
                set renderWorldCopies(t) {
                  (t === void 0 ? (t = !0) : t === null && (t = !1),
                    (this._renderWorldCopies = t));
                }
                get worldSize() {
                  return this.tileSize * this.scale;
                }
                get cameraWorldSizeForFog() {
                  const t = Math.max(
                    this._camera.getDistanceToElevation(this._averageElevation),
                    Number.EPSILON,
                  );
                  return this._worldSizeFromZoom(this._zoomFromMercatorZ(t));
                }
                get cameraWorldSize() {
                  const t = Math.max(
                    this._camera.getDistanceToElevation(
                      this._averageElevation,
                      !0,
                    ),
                    Number.EPSILON,
                  );
                  return this._worldSizeFromZoom(this._zoomFromMercatorZ(t));
                }
                get pixelsPerMeter() {
                  return this.projection.pixelsPerMeter(
                    this.center.lat,
                    this.worldSize,
                  );
                }
                get cameraPixelsPerMeter() {
                  return r.c6(1, this.center.lat) * this.cameraWorldSizeForFog;
                }
                get centerOffset() {
                  return this.centerPoint._sub(this.size._div(2));
                }
                get size() {
                  return new r.P(this.width, this.height);
                }
                get bearing() {
                  return r.bX(this.rotation, -180, 180);
                }
                set bearing(t) {
                  this.rotation = t;
                }
                get rotation() {
                  return (-this.angle / Math.PI) * 180;
                }
                set rotation(t) {
                  const s = (-t * Math.PI) / 180;
                  this.angle !== s &&
                    ((this._unmodified = !1),
                    (this.angle = s),
                    this._calcMatrices(),
                    (this.rotationMatrix = r.cf()),
                    r.cg(this.rotationMatrix, this.rotationMatrix, this.angle));
                }
                get pitch() {
                  return (this._pitch / Math.PI) * 180;
                }
                set pitch(t) {
                  const s =
                    (r.ay(t, this.minPitch, this.maxPitch) / 180) * Math.PI;
                  this._pitch !== s &&
                    ((this._unmodified = !1),
                    (this._pitch = s),
                    this._calcMatrices());
                }
                get aspect() {
                  return this.width / this.height;
                }
                get fov() {
                  return (this._fov / Math.PI) * 180;
                }
                set fov(t) {
                  ((t = Math.max(0.01, Math.min(60, t))),
                    this._fov !== t &&
                      ((this._unmodified = !1),
                      (this._fov = r.al(t)),
                      this._calcMatrices()));
                }
                get fovX() {
                  return this._fov;
                }
                get fovY() {
                  const t = 1 / Math.tan(0.5 * this.fovX);
                  return 2 * Math.atan(1 / this.aspect / t);
                }
                get averageElevation() {
                  return this._averageElevation;
                }
                set averageElevation(t) {
                  ((this._averageElevation = t),
                    this._calcFogMatrices(),
                    (this._distanceTileDataCache = {}));
                }
                get zoom() {
                  return this._zoom;
                }
                set zoom(t) {
                  const s = Math.min(Math.max(t, this.minZoom), this.maxZoom);
                  this._zoom !== s &&
                    ((this._unmodified = !1),
                    this._setZoom(s),
                    this._updateSeaLevelZoom(),
                    this._constrain(),
                    this._calcMatrices());
                }
                _setZoom(t) {
                  ((this._zoom = t),
                    (this.scale = this.zoomScale(t)),
                    (this.tileZoom = Math.floor(t)),
                    (this.zoomFraction = t - this.tileZoom));
                }
                get tileCoverLift() {
                  return this._tileCoverLift;
                }
                set tileCoverLift(t) {
                  this._tileCoverLift !== t && (this._tileCoverLift = t);
                }
                _updateCameraOnTerrain() {
                  const t = this.elevation
                      ? this.elevation.getAtPoint(
                          this.locationCoordinate(this.center),
                          Number.NEGATIVE_INFINITY,
                        )
                      : Number.NEGATIVE_INFINITY,
                    s =
                      this.elevation &&
                      t === Number.NEGATIVE_INFINITY &&
                      this.elevation.visibleDemTiles.length > 0 &&
                      this.elevation.exaggeration() > 0 &&
                      this._centerAltitudeValidForExaggeration;
                  if (
                    !this._elevation ||
                    (t === Number.NEGATIVE_INFINITY &&
                      (!s || !this._centerAltitude))
                  )
                    return (
                      (this._centerAltitude = 0),
                      (this._seaLevelZoom = null),
                      void (this._centerAltitudeValidForExaggeration = void 0)
                    );
                  const h = this._elevation;
                  (s ||
                  (this._centerAltitude &&
                    this._centerAltitudeValidForExaggeration &&
                    h.exaggeration() &&
                    this._centerAltitudeValidForExaggeration !==
                      h.exaggeration())
                    ? ((this._centerAltitude =
                        (this._centerAltitude /
                          this._centerAltitudeValidForExaggeration) *
                        h.exaggeration()),
                      (this._centerAltitudeValidForExaggeration =
                        h.exaggeration()))
                    : ((this._centerAltitude = t || 0),
                      (this._centerAltitudeValidForExaggeration =
                        h.exaggeration())),
                    this._updateSeaLevelZoom());
                }
                _updateSeaLevelZoom() {
                  if (this._centerAltitudeValidForExaggeration === void 0)
                    return;
                  const t = Math.max(
                    0,
                    (this.pixelsPerMeter * this._centerAltitude +
                      this.cameraToCenterDistance) /
                      this.worldSize,
                  );
                  this._seaLevelZoom = this._zoomFromMercatorZ(t);
                }
                sampleAverageElevation() {
                  if (!this._elevation) return 0;
                  const t = this._elevation,
                    s = [
                      [0.5, 0.2],
                      [0.3, 0.5],
                      [0.5, 0.5],
                      [0.7, 0.5],
                      [0.5, 0.8],
                    ],
                    h = this.horizonLineFromTop();
                  let p = 0,
                    g = 0;
                  for (let x = 0; x < s.length; x++) {
                    const w = new r.P(
                        s[x][0] * this.width,
                        h + s[x][1] * (this.height - h),
                      ),
                      S = t.pointCoordinate(w);
                    if (!S) continue;
                    const C =
                      1 /
                      Math.hypot(
                        S[0] - this._camera.position[0],
                        S[1] - this._camera.position[1],
                      );
                    ((p += S[3] * C), (g += C));
                  }
                  return g === 0 ? NaN : p / g;
                }
                get center() {
                  return this._center;
                }
                set center(t) {
                  (t.lat === this._center.lat && t.lng === this._center.lng) ||
                    ((this._unmodified = !1),
                    (this._center = t),
                    this._terrainEnabled() &&
                      (this.cameraElevationReference === "ground"
                        ? this._updateCameraOnTerrain()
                        : this._updateZoomFromElevation()),
                    this._constrain(),
                    this._calcMatrices());
                }
                _updateZoomFromElevation() {
                  if (this._seaLevelZoom == null || !this._elevation) return;
                  const t = this._seaLevelZoom,
                    s = this._elevation.getAtPointOrZero(
                      this.locationCoordinate(this.center),
                    ),
                    h = (this.pixelsPerMeter / this.worldSize) * s,
                    p = this._mercatorZfromZoom(t),
                    g = this._mercatorZfromZoom(this._maxZoom),
                    x = Math.max(p - h, g);
                  this._setZoom(this._zoomFromMercatorZ(x));
                }
                get padding() {
                  return this._edgeInsets.toJSON();
                }
                set padding(t) {
                  this._edgeInsets.equals(t) ||
                    ((this._unmodified = !1),
                    this._edgeInsets.interpolate(this._edgeInsets, t, 1),
                    this._calcMatrices());
                }
                computeZoomRelativeTo(t) {
                  const s = this.rayIntersectionCoordinate(
                    this.pointRayIntersection(this.centerPoint, t.toAltitude()),
                  );
                  let h;
                  h =
                    t.z < this._camera.position[2]
                      ? [s.x, s.y, s.z]
                      : [t.x, t.y, t.z];
                  const p = r.ae(r.at([], this._camera.position, h));
                  return r.ay(
                    this._zoomFromMercatorZ(p),
                    this._minZoom,
                    this._maxZoom,
                  );
                }
                setFreeCameraOptions(t) {
                  if (!this.height || (!t.position && !t.orientation)) return;
                  this._updateCameraState();
                  let s = !1;
                  if (
                    (t.orientation &&
                      !r.ch(t.orientation, this._camera.orientation) &&
                      (s = this._setCameraOrientation(t.orientation)),
                    t.position)
                  ) {
                    const h = [t.position.x, t.position.y, t.position.z];
                    r.ci(h, this._camera.position) ||
                      (this._setCameraPosition(h), (s = !0));
                  }
                  s &&
                    (this._updateStateFromCamera(), this.recenterOnTerrain());
                }
                getFreeCameraOptions() {
                  this._updateCameraState();
                  const t = this._camera.position,
                    s = new Ip();
                  return (
                    (s.position = new r.ac(t[0], t[1], t[2])),
                    (s.orientation = this._camera.orientation),
                    (s._elevation = this.elevation),
                    (s._renderWorldCopies = this.renderWorldCopies),
                    s
                  );
                }
                _setCameraOrientation(t) {
                  if (!r.cj(t)) return !1;
                  r.ck(t, t);
                  const s = r.cl([], [0, 0, -1], t),
                    h = r.cl([], [0, -1, 0], t);
                  if (h[2] < 0) return !1;
                  const p = zo(s, h);
                  return !!p && ((this._camera.orientation = p), !0);
                }
                _setCameraPosition(t) {
                  const s = this.zoomScale(this.minZoom) * this.tileSize,
                    h = this.zoomScale(this.maxZoom) * this.tileSize,
                    p = this.cameraToCenterDistance;
                  ((t[2] = r.ay(t[2], p / h, p / s)),
                    (this._camera.position = t));
                }
                get centerPoint() {
                  return this._edgeInsets.getCenter(this.width, this.height);
                }
                get fovAboveCenter() {
                  return this._fov * (0.5 + this.centerOffset.y / this.height);
                }
                isPaddingEqual(t) {
                  return this._edgeInsets.equals(t);
                }
                interpolatePadding(t, s, h) {
                  ((this._unmodified = !1),
                    this._edgeInsets.interpolate(t, s, h),
                    this._constrain(),
                    this._calcMatrices());
                }
                coveringZoomLevel(t) {
                  const s = (t.roundZoom ? Math.round : Math.floor)(
                    this.zoom + this.scaleZoom(this.tileSize / t.tileSize),
                  );
                  return Math.max(0, s);
                }
                getVisibleUnwrappedCoordinates(t) {
                  const s = [new r.cm(0, t)];
                  if (this.renderWorldCopies) {
                    const h = this.pointCoordinate(new r.P(0, 0)),
                      p = this.pointCoordinate(new r.P(this.width, 0)),
                      g = this.pointCoordinate(
                        new r.P(this.width, this.height),
                      ),
                      x = this.pointCoordinate(new r.P(0, this.height)),
                      w = Math.floor(Math.min(h.x, p.x, g.x, x.x)),
                      S = Math.floor(Math.max(h.x, p.x, g.x, x.x)),
                      C = 1;
                    for (let D = w - C; D <= S + C; D++)
                      D !== 0 && s.push(new r.cm(D, t));
                  }
                  return s;
                }
                isLODDisabled(t) {
                  return (
                    (!t || this.pitch <= 60) &&
                    this._edgeInsets.top <= this._edgeInsets.bottom &&
                    !this._elevation &&
                    !this.projection.isReprojectedInTileSpace
                  );
                }
                extendTileCover(t, s, h) {
                  let p = [];
                  const g = h != null,
                    x = !g;
                  if ((x && this.zoom < s) || (g && h[0] === 0 && h[1] === 0))
                    return p;
                  const w = new Set(),
                    S = (D, L, z, O, G) => {
                      const U = r.cK(L, D, z, O, G);
                      w.has(U) || (p.push(new r.aM(D, L, z, O, G)), w.add(U));
                    };
                  for (let D = 0; D < t.length; D++) {
                    const L = t[D];
                    if (x && L.canonical.z !== s) continue;
                    const z = L.canonical,
                      O = L.overscaledZ,
                      G = L.wrap,
                      U = 1 << z.z,
                      $ = z.x + 1 < U,
                      Z = z.x > 0,
                      Y = z.y + 1 < U,
                      ie = z.y > 0,
                      ae = L.wrap - (Z ? 0 : 1),
                      pe = L.wrap + ($ ? 0 : 1),
                      ue = Z ? z.x - 1 : U - 1,
                      ce = $ ? z.x + 1 : 0;
                    if (g)
                      h[0] < 0
                        ? (S(O, pe, z.z, ce, z.y),
                          h[1] < 0 &&
                            Y &&
                            (S(O, G, z.z, z.x, z.y + 1),
                            S(O, pe, z.z, ce, z.y + 1)),
                          h[1] > 0 &&
                            ie &&
                            (S(O, G, z.z, z.x, z.y - 1),
                            S(O, pe, z.z, ce, z.y - 1)))
                        : h[0] > 0
                          ? (S(O, ae, z.z, ue, z.y),
                            h[1] < 0 &&
                              Y &&
                              (S(O, G, z.z, z.x, z.y + 1),
                              S(O, ae, z.z, ue, z.y + 1)),
                            h[1] > 0 &&
                              ie &&
                              (S(O, G, z.z, z.x, z.y - 1),
                              S(O, ae, z.z, ue, z.y - 1)))
                          : h[1] < 0 && Y
                            ? S(O, G, z.z, z.x, z.y + 1)
                            : ie && S(O, G, z.z, z.x, z.y - 1);
                    else {
                      const le = L.visibleQuadrants;
                      (1 & le &&
                        (S(O, ae, z.z, ue, z.y),
                        ie &&
                          (S(O, G, z.z, z.x, z.y - 1),
                          S(O, ae, z.z, ue, z.y - 1))),
                        2 & le &&
                          (S(O, pe, z.z, ce, z.y),
                          ie &&
                            (S(O, G, z.z, z.x, z.y - 1),
                            S(O, pe, z.z, ce, z.y - 1))),
                        4 & le &&
                          (S(O, ae, z.z, ue, z.y),
                          Y &&
                            (S(O, G, z.z, z.x, z.y + 1),
                            S(O, ae, z.z, ue, z.y + 1))),
                        8 & le &&
                          (S(O, pe, z.z, ce, z.y),
                          Y &&
                            (S(O, G, z.z, z.x, z.y + 1),
                            S(O, pe, z.z, ce, z.y + 1))));
                    }
                  }
                  const C = [];
                  for (const D of p) p.some((L) => D.isChildOf(L)) || C.push(D);
                  if (
                    ((p = C.filter(
                      (D) =>
                        !t.some(
                          (L) =>
                            !!(D.overscaledZ < s && L.isChildOf(D)) ||
                            D.equals(L) ||
                            D.isChildOf(L),
                        ),
                    )),
                    x)
                  ) {
                    const D = 1 << s,
                      L =
                        this.projection.name === "globe"
                          ? this._camera.mercatorPosition
                          : this.pointCoordinate(this.getCameraPoint()),
                      z = [D * L.x, D * L.y],
                      O = 4,
                      G = O * O;
                    p = p.filter((U) => {
                      const $ = U.canonical.x + 0.5 - z[0],
                        Z = U.canonical.y + 0.5 - z[1];
                      return $ * $ + Z * Z < G;
                    });
                  }
                  return p;
                }
                coveringTiles(t) {
                  let s = this.coveringZoomLevel(t);
                  const h = s,
                    p = this.elevation && this.elevation.exaggeration(),
                    g = p && !t.isTerrainDEM,
                    x = this.projection.name === "mercator";
                  if (t.minzoom !== void 0 && s < t.minzoom) return [];
                  t.maxzoom !== void 0 && s > t.maxzoom && (s = t.maxzoom);
                  const w = this.locationCoordinate(this.center),
                    S = this.center.lat,
                    C = 1 << s,
                    D = [C * w.x, C * w.y, 0],
                    L = this.projection.name === "globe",
                    z = !L,
                    O = r.cn.fromInvProjectionMatrix(
                      this.invProjMatrix,
                      this.worldSize,
                      s,
                      z,
                    ),
                    G = L
                      ? this._camera.mercatorPosition
                      : this.pointCoordinate(this.getCameraPoint()),
                    U = C * r.c6(1, this.center.lat),
                    $ = this._camera.position[2] / r.c6(1, this.center.lat),
                    Z = [C * G.x, C * G.y, $ * (z ? 1 : U)],
                    Y = L || p,
                    ie =
                      (this.cameraToCenterDistance / t.tileSize) *
                      (t.roundZoom ? 1 : 0.502),
                    ae = this.isLODDisabled(!0) ? s : 0;
                  let pe;
                  if (this._elevation && t.isTerrainDEM)
                    pe = 1e4 * this._elevation.exaggeration();
                  else if (this._elevation) {
                    const Te = this._elevation.getMinMaxForVisibleTiles();
                    pe = Te ? Te.max : this._centerAltitude;
                  } else pe = this._centerAltitude;
                  const ue = t.isTerrainDEM
                      ? -pe
                      : this._elevation
                        ? this._elevation.getMinElevationBelowMSL()
                        : 0,
                    ce = this.projection.isReprojectedInTileSpace
                      ? r.co(this)
                      : 1,
                    le = (Te) => {
                      const Oe = new r.ac(Te.x + 25e-6, Te.y, Te.z),
                        Ke = new r.ac(Te.x, Te.y + 25e-6, Te.z),
                        ht = Te.toLngLat(),
                        qe = Oe.toLngLat(),
                        lt = Ke.toLngLat(),
                        St = this.locationCoordinate(ht),
                        Et = this.locationCoordinate(qe),
                        bt = this.locationCoordinate(lt),
                        kt = Math.hypot(Et.x - St.x, Et.y - St.y),
                        Bt = Math.hypot(bt.x - St.x, bt.y - St.y);
                      return (Math.sqrt(kt * Bt) * ce) / 25e-6;
                    },
                    me = (Te) => {
                      const Ze = pe,
                        Oe = ue;
                      return {
                        aabb: r.cr(
                          this,
                          C,
                          0,
                          0,
                          0,
                          Te,
                          Oe,
                          Ze,
                          this.projection,
                        ),
                        zoom: 0,
                        x: 0,
                        y: 0,
                        minZ: Oe,
                        maxZ: Ze,
                        wrap: Te,
                        fullyVisible: !1,
                      };
                    },
                    _e = [];
                  let De = [];
                  const ze = s,
                    He = t.reparseOverscaled ? h : s,
                    We = ($ - this._centerAltitude) * U,
                    et = (Te) => {
                      if (!this._elevation || !Te.tileID || !x) return;
                      const Ze = this._elevation.getMinMaxForTile(Te.tileID),
                        Oe = Te.aabb;
                      Ze
                        ? ((Oe.min[2] = Ze.min),
                          (Oe.max[2] = Ze.max),
                          (Oe.center[2] = (Oe.min[2] + Oe.max[2]) / 2))
                        : ((Te.shouldSplit = Ve(Te)),
                          Te.shouldSplit ||
                            (Oe.min[2] =
                              Oe.max[2] =
                              Oe.center[2] =
                                this._centerAltitude));
                    },
                    Ce = (Te, Ze) => {
                      if (0.707 * Ze < Te) return 1;
                      const Oe = Ze / Te;
                      return (
                        Oe /
                        (1.4144271570014144 +
                          (Math.pow(1.1, Oe - 1.4144271570014144 + 1) - 1) /
                            (1.1 - 1) -
                          1)
                      );
                    },
                    Ve = (Te) => {
                      if (Te.zoom < ae) return !0;
                      if (Te.zoom === ze) return !1;
                      if (Te.shouldSplit != null) return Te.shouldSplit;
                      const Ze = Te.aabb.distanceX(Z),
                        Oe = Te.aabb.distanceY(Z);
                      let Ke = We,
                        ht = 1;
                      if (L) {
                        Ke = Te.aabb.distanceZ(Z);
                        const Bt = Math.pow(2, Te.zoom),
                          Vt = r.aY((Te.y + 1) / Bt),
                          Zt = r.aY(Te.y / Bt),
                          si = Math.min(Math.max(S, Vt), Zt),
                          Fi = r.cO(si) / r.cO(S);
                        if (
                          ((ht =
                            si === S
                              ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3)
                              : Math.min(1, Fi / this._mercatorScaleRatio)),
                          this.zoom <= r.cL && Te.zoom === ze - 1 && Fi >= 0.9)
                        )
                          return !0;
                      } else if (
                        (g && (Ke = Te.aabb.distanceZ(Z) * U),
                        this.projection.isReprojectedInTileSpace && h <= 5)
                      ) {
                        const Bt = Math.pow(2, Te.zoom),
                          Vt = le(
                            new r.ac((Te.x + 0.5) / Bt, (Te.y + 0.5) / Bt),
                          );
                        ht = Vt > 0.85 ? 1 : Vt;
                      }
                      if (!x) {
                        const Bt = Math.sqrt(Ze * Ze + Oe * Oe + Ke * Ke);
                        let Vt = (1 << (ze - Te.zoom)) * ie * ht;
                        return ((Vt *= Ce(Math.max(Ke, We), Bt)), Bt < Vt);
                      }
                      let qe = Number.MAX_VALUE,
                        lt = 0;
                      const St = Te.aabb.getCorners(),
                        Et = [];
                      for (const Bt of St) {
                        (r.at(Et, Bt, Z),
                          L || (g ? (Et[2] *= U) : (Et[2] = We)));
                        const Vt = r.bG(Et, this._camera.forward());
                        Vt < qe && ((qe = Vt), (lt = Math.abs(Et[2])));
                      }
                      let bt = (1 << (ze - Te.zoom)) * ie * ht;
                      if (((bt *= Ce(Math.max(lt, We), qe)), qe < bt))
                        return !0;
                      const kt = Te.aabb.closestPoint(D);
                      return kt[0] === D[0] && kt[1] === D[1];
                    };
                  if (this.renderWorldCopies)
                    for (let Te = 1; Te <= 3; Te++)
                      (_e.push(me(-Te)), _e.push(me(Te)));
                  for (_e.push(me(0)); _e.length > 0; ) {
                    const Te = _e.pop(),
                      Ze = Te.x,
                      Oe = Te.y;
                    let Ke = Te.fullyVisible;
                    const ht = () =>
                      this.projection.name === "globe" &&
                      (Te.y === 0 || Te.y === (1 << Te.zoom) - 1);
                    if (!Ke) {
                      let qe = Y
                        ? Te.aabb.intersects(O)
                        : Te.aabb.intersectsFlat(O);
                      if (qe === 0 && ht()) {
                        const lt = new r.cp(Te.zoom, Ze, Oe);
                        qe = r.cq(this, C, lt, !0).intersects(O);
                      }
                      if (qe === 0) continue;
                      Ke = qe === 2;
                    }
                    if (Te.zoom !== ze && Ve(Te))
                      for (let qe = 0; qe < 4; qe++) {
                        const lt = (Ze << 1) + (qe % 2),
                          St = (Oe << 1) + (qe >> 1),
                          Et = {
                            aabb: x
                              ? Te.aabb.quadrant(qe)
                              : r.cr(
                                  this,
                                  C,
                                  Te.zoom + 1,
                                  lt,
                                  St,
                                  Te.wrap,
                                  Te.minZ,
                                  Te.maxZ,
                                  this.projection,
                                ),
                            zoom: Te.zoom + 1,
                            x: lt,
                            y: St,
                            wrap: Te.wrap,
                            fullyVisible: Ke,
                            tileID: void 0,
                            shouldSplit: void 0,
                            minZ: Te.minZ,
                            maxZ: Te.maxZ,
                          };
                        (g &&
                          !L &&
                          ((Et.tileID = new r.aM(
                            Te.zoom + 1 === ze ? He : Te.zoom + 1,
                            Te.wrap,
                            Te.zoom + 1,
                            lt,
                            St,
                          )),
                          et(Et)),
                          _e.push(Et));
                      }
                    else {
                      const qe = Te.zoom === ze ? He : Te.zoom;
                      if (t.minzoom && t.minzoom > qe) continue;
                      let lt = 0;
                      if (!Ke) {
                        let kt = Y
                          ? Te.aabb.intersectsPrecise(O)
                          : Te.aabb.intersectsPreciseFlat(O);
                        if (kt === 0 && ht()) {
                          const Bt = new r.cp(Te.zoom, Ze, Oe);
                          kt = r.cq(this, C, Bt, !0).intersectsPrecise(O);
                        }
                        if (kt === 0) continue;
                        if (t.calculateQuadrantVisibility)
                          if (O.containsPoint(Te.aabb.center)) lt = 15;
                          else
                            for (let Bt = 0; Bt < 4; Bt++)
                              Te.aabb.quadrant(Bt).intersects(O) !== 0 &&
                                (lt |= 1 << Bt);
                      }
                      const St =
                          D[0] -
                          (0.5 + Ze + (Te.wrap << Te.zoom)) *
                            (1 << (s - Te.zoom)),
                        Et = D[1] - 0.5 - Oe,
                        bt = Te.tileID
                          ? Te.tileID
                          : new r.aM(qe, Te.wrap, Te.zoom, Ze, Oe);
                      (t.calculateQuadrantVisibility &&
                        (bt.visibleQuadrants = lt),
                        De.push({ tileID: bt, distanceSq: St * St + Et * Et }));
                    }
                  }
                  if (this.fogCullDistSq) {
                    const Te = this.fogCullDistSq,
                      Ze = this.horizonLineFromTop();
                    De = De.filter((Oe) => {
                      const Ke = [0, 0, 0, 1],
                        ht = [r.aj, r.aj, 0, 1],
                        qe = this.calculateFogTileMatrix(
                          Oe.tileID.toUnwrapped(),
                        );
                      (r.aA(Ke, Ke, qe), r.aA(ht, ht, qe));
                      const lt = r.cs([], Ke, ht),
                        St = r.ct([], Ke, ht),
                        Et = r.cM(lt, St);
                      if (Et === 0) return !0;
                      let bt = !1;
                      const kt = this._elevation;
                      if (kt && Et > Te && Ze !== 0) {
                        const Bt = this.calculateProjMatrix(
                          Oe.tileID.toUnwrapped(),
                        );
                        let Vt;
                        (t.isTerrainDEM ||
                          (Vt = kt.getMinMaxForTile(Oe.tileID)),
                          Vt || (Vt = { min: ue, max: pe }));
                        const Zt = r.cu(this.rotation),
                          si = [Zt[0] * r.aj, Zt[1] * r.aj, Vt.max];
                        (r.ad(si, si, Bt),
                          (bt = (1 - si[1]) * this.height * 0.5 < Ze));
                      }
                      return Et < Te || bt;
                    });
                  }
                  return De.sort((Te, Ze) => Te.distanceSq - Ze.distanceSq).map(
                    (Te) => Te.tileID,
                  );
                }
                resize(t, s) {
                  ((this.width = t),
                    (this.height = s),
                    (this.pixelsToGLUnits = [2 / t, -2 / s]),
                    this._constrain(),
                    this._calcMatrices());
                }
                get unmodified() {
                  return this._unmodified;
                }
                zoomScale(t) {
                  return Math.pow(2, t);
                }
                scaleZoom(t) {
                  return Math.log(t) / Math.LN2;
                }
                project(t) {
                  const s = r.ay(t.lat, -85.051129, r.cv),
                    h = this.projection.project(t.lng, s);
                  return new r.P(h.x * this.worldSize, h.y * this.worldSize);
                }
                unproject(t) {
                  return this.projection.unproject(
                    t.x / this.worldSize,
                    t.y / this.worldSize,
                  );
                }
                get point() {
                  return this.project(this.center);
                }
                get pointMerc() {
                  return this.point._div(this.worldSize);
                }
                get pixelsPerMeterRatio() {
                  return (
                    this.pixelsPerMeter /
                    r.c6(1, this.center.lat) /
                    this.worldSize
                  );
                }
                setLocationAtPoint(t, s) {
                  let h, p;
                  const g = this.centerPoint;
                  if (this.projection.name === "globe") {
                    const w = this.worldSize;
                    ((h = (s.x - g.x) / w), (p = (s.y - g.y) / w));
                  } else {
                    const w = this.pointCoordinate(s),
                      S = this.pointCoordinate(g);
                    ((h = w.x - S.x), (p = w.y - S.y));
                  }
                  const x = this.locationCoordinate(t);
                  this.setLocation(new r.ac(x.x - h, x.y - p));
                }
                setLocation(t) {
                  ((this.center = this.coordinateLocation(t)),
                    this.projection.wrap && (this.center = this.center.wrap()));
                }
                locationPoint(t, s) {
                  return this.projection.locationPoint(this, t, s);
                }
                locationPoint3D(t, s) {
                  return this.projection.locationPoint(this, t, s, !0);
                }
                pointLocation(t) {
                  return this.coordinateLocation(this.pointCoordinate(t));
                }
                pointLocation3D(t, s) {
                  return this.coordinateLocation(this.pointCoordinate3D(t, s));
                }
                locationCoordinate(t, s) {
                  const h = s ? r.c6(s, t.lat) : void 0,
                    p = this.projection.project(t.lng, t.lat);
                  return new r.ac(p.x, p.y, h);
                }
                coordinateLocation(t) {
                  return this.projection.unproject(t.x, t.y);
                }
                pointRayIntersection(t, s) {
                  const h = s ?? this._centerAltitude,
                    p = [t.x, t.y, 0, 1],
                    g = [t.x, t.y, 1, 1];
                  (r.aA(p, p, this.pixelMatrixInverse),
                    r.aA(g, g, this.pixelMatrixInverse));
                  const x = g[3];
                  (r.cw(p, p, 1 / p[3]), r.cw(g, g, 1 / x));
                  const w = p[2],
                    S = g[2];
                  return { p0: p, p1: g, t: w === S ? 0 : (h - w) / (S - w) };
                }
                screenPointToMercatorRay(t) {
                  const s = [t.x, t.y, 0, 1],
                    h = [t.x, t.y, 1, 1];
                  return (
                    r.aA(s, s, this.pixelMatrixInverse),
                    r.aA(h, h, this.pixelMatrixInverse),
                    r.cw(s, s, 1 / s[3]),
                    r.cw(h, h, 1 / h[3]),
                    (s[2] = r.c6(s[2], this._center.lat) * this.worldSize),
                    (h[2] = r.c6(h[2], this._center.lat) * this.worldSize),
                    r.cw(s, s, 1 / this.worldSize),
                    r.cw(h, h, 1 / this.worldSize),
                    new r.av([s[0], s[1], s[2]], r.au([], r.at([], h, s)))
                  );
                }
                rayIntersectionCoordinate(t) {
                  const { p0: s, p1: h, t: p } = t,
                    g = r.c6(s[2], this._center.lat),
                    x = r.c6(h[2], this._center.lat);
                  return new r.ac(
                    r.ai(s[0], h[0], p) / this.worldSize,
                    r.ai(s[1], h[1], p) / this.worldSize,
                    r.ai(g, x, p),
                  );
                }
                pointCoordinate(t, s = this._centerAltitude) {
                  return this.projection.pointCoordinate(this, t.x, t.y, s);
                }
                pointCoordinate3D(t, s) {
                  if (!this.elevation) return this.pointCoordinate(t, s);
                  let h = this.projection.pointCoordinate3D(this, t.x, t.y);
                  if (h) return new r.ac(h[0], h[1], h[2]);
                  let p = 0,
                    g = this.horizonLineFromTop();
                  if (t.y > g) return this.pointCoordinate(t, s);
                  const x = 0.02 * g,
                    w = t.clone();
                  for (let S = 0; S < 10 && g - p > x; S++) {
                    w.y = r.ai(p, g, 0.66);
                    const C = this.projection.pointCoordinate3D(this, w.x, w.y);
                    C ? ((g = w.y), (h = C)) : (p = w.y);
                  }
                  return h
                    ? new r.ac(h[0], h[1], h[2])
                    : this.pointCoordinate(t);
                }
                isPointAboveHorizon(t) {
                  return this.projection.isPointAboveHorizon(this, t);
                }
                isPointOnSurface(t) {
                  if (
                    t.y < 0 ||
                    t.y > this.height ||
                    t.x < 0 ||
                    t.x > this.width
                  )
                    return !1;
                  if (this.elevation || this.zoom >= r.cx)
                    return !this.isPointAboveHorizon(t);
                  const s = this.pointCoordinate(t);
                  return s.y >= 0 && s.y <= 1;
                }
                _coordinatePoint(t, s) {
                  const h =
                      s && this.elevation
                        ? this.elevation.getAtPointOrZero(
                            t,
                            this._centerAltitude,
                          )
                        : this._centerAltitude,
                    p = [
                      t.x * this.worldSize,
                      t.y * this.worldSize,
                      h + t.toAltitude(),
                      1,
                    ];
                  return (
                    r.aA(p, p, this.pixelMatrix),
                    p[3] > 0
                      ? new r.P(p[0] / p[3], p[1] / p[3])
                      : new r.P(Number.MAX_VALUE, Number.MAX_VALUE)
                  );
                }
                _getBoundsNonRectangular() {
                  const { top: t, left: s } = this._edgeInsets,
                    h = this.height - this._edgeInsets.bottom,
                    p = this.width - this._edgeInsets.right,
                    g = this.pointLocation3D(new r.P(s, t)),
                    x = this.pointLocation3D(new r.P(p, t)),
                    w = this.pointLocation3D(new r.P(p, h)),
                    S = this.pointLocation3D(new r.P(s, h));
                  let C = Math.min(g.lng, x.lng, w.lng, S.lng),
                    D = Math.max(g.lng, x.lng, w.lng, S.lng),
                    L = Math.min(g.lat, x.lat, w.lat, S.lat),
                    z = Math.max(g.lat, x.lat, w.lat, S.lat);
                  const O = (Math.pow(2, -this.zoom) / 16) * 270,
                    G = this.projection.name === "globe" ? 1 : 4,
                    U = ($, Z, Y, ie, ae) => {
                      const pe = ($ + Y) / 2,
                        ue = (Z + ie) / 2,
                        ce = new r.P(pe, ue),
                        { lng: le, lat: me } = this.pointLocation3D(ce),
                        _e = Math.max(0, C - le, L - me, le - D, me - z);
                      ((C = Math.min(C, le)),
                        (D = Math.max(D, le)),
                        (L = Math.min(L, me)),
                        (z = Math.max(z, me)),
                        (ae < G || _e > O) &&
                          (U($, Z, pe, ue, ae + 1), U(pe, ue, Y, ie, ae + 1)));
                    };
                  if (
                    (U(s, t, p, t, 1),
                    U(p, t, p, h, 1),
                    U(p, h, s, h, 1),
                    U(s, h, s, t, 1),
                    this.projection.name === "globe")
                  ) {
                    const [$, Z] = r.cy(this);
                    $
                      ? ((z = 90), (D = 180), (C = -180))
                      : Z && ((L = -90), (D = 180), (C = -180));
                  }
                  return new r.aG(new r.cd(C, L), new r.cd(D, z));
                }
                _getBoundsRectangular(t, s) {
                  const { top: h, left: p } = this._edgeInsets,
                    g = this.height - this._edgeInsets.bottom,
                    x = this.width - this._edgeInsets.right,
                    w = new r.P(p, h),
                    S = new r.P(x, h),
                    C = new r.P(x, g),
                    D = new r.P(p, g);
                  let L = this.pointCoordinate(w, t),
                    z = this.pointCoordinate(S, t);
                  const O = this.pointCoordinate(C, s),
                    G = this.pointCoordinate(D, s),
                    U = ($, Z) => (Z.y - $.y) / (Z.x - $.x);
                  return (
                    L.y > 1 && z.y >= 0
                      ? (L = new r.ac((1 - G.y) / U(G, L) + G.x, 1))
                      : L.y < 0 &&
                        z.y <= 1 &&
                        (L = new r.ac(-G.y / U(G, L) + G.x, 0)),
                    z.y > 1 && L.y >= 0
                      ? (z = new r.ac((1 - O.y) / U(O, z) + O.x, 1))
                      : z.y < 0 &&
                        L.y <= 1 &&
                        (z = new r.ac(-O.y / U(O, z) + O.x, 0)),
                    new r.aG()
                      .extend(this.coordinateLocation(L))
                      .extend(this.coordinateLocation(z))
                      .extend(this.coordinateLocation(G))
                      .extend(this.coordinateLocation(O))
                  );
                }
                _getBoundsRectangularTerrain() {
                  const t = this.elevation;
                  if (!t.visibleDemTiles.length || t.isUsingMockSource())
                    return this._getBoundsRectangular(0, 0);
                  const s = t.visibleDemTiles.reduce(
                    (h, p) => {
                      if (p.dem) {
                        const g = p.dem.tree;
                        ((h.min = Math.min(h.min, g.minimums[0])),
                          (h.max = Math.max(h.max, g.maximums[0])));
                      }
                      return h;
                    },
                    { min: Number.MAX_VALUE, max: 0 },
                  );
                  return this._getBoundsRectangular(
                    s.min * t.exaggeration(),
                    s.max * t.exaggeration(),
                  );
                }
                getBounds() {
                  return this.projection.name === "mercator" ||
                    this.projection.name === "equirectangular"
                    ? this._terrainEnabled()
                      ? this._getBoundsRectangularTerrain()
                      : this._getBoundsRectangular(0, 0)
                    : this._getBoundsNonRectangular();
                }
                horizonLineFromTop(t = !0) {
                  const s =
                      this.height /
                        2 /
                        Math.tan(this._fov / 2) /
                        Math.tan(Math.max(this._pitch, 0.1)) -
                      this.centerOffset.y,
                    h = this.height / 2 - s * (1 - this._horizonShift);
                  return t ? Math.max(0, h) : h;
                }
                getMaxBounds() {
                  return this.maxBounds;
                }
                setMaxBounds(t) {
                  ((this.maxBounds = t),
                    (this.minLat = -85.051129),
                    (this.maxLat = r.cv),
                    (this.minLng = -180),
                    (this.maxLng = 180),
                    t &&
                      ((this.minLat = t.getSouth()),
                      (this.maxLat = t.getNorth()),
                      (this.minLng = t.getWest()),
                      (this.maxLng = t.getEast()),
                      this.maxLng < this.minLng && (this.maxLng += 360)),
                    (this.worldMinX = r.aD(this.minLng) * this.tileSize),
                    (this.worldMaxX = r.aD(this.maxLng) * this.tileSize),
                    (this.worldMinY = r.aH(this.maxLat) * this.tileSize),
                    (this.worldMaxY = r.aH(this.minLat) * this.tileSize),
                    this._constrain());
                }
                calculatePosMatrix(t, s) {
                  return this.projection.createTileMatrix(this, s, t);
                }
                calculateDistanceTileData(t) {
                  const s = t.key,
                    h = this._distanceTileDataCache;
                  if (h[s]) return h[s];
                  const p = t.canonical,
                    g = 1 / this.height,
                    x = this.cameraWorldSize,
                    w = x / this.zoomScale(p.z),
                    S = (p.x + Math.pow(2, p.z) * t.wrap) * w,
                    C = p.y * w,
                    D = this.point;
                  ((D.x *= x / this.worldSize), (D.y *= x / this.worldSize));
                  const L = this.angle,
                    z = Math.sin(-L),
                    O = -Math.cos(-L);
                  return (
                    (h[s] = {
                      bearing: [z, O],
                      center: [(D.x - S) * g, (D.y - C) * g],
                      scale: (w / r.aj) * g,
                    }),
                    h[s]
                  );
                }
                calculateFogTileMatrix(t) {
                  const s = t.key,
                    h = this._fogTileMatrixCache;
                  if (h[s]) return h[s];
                  const p = this.projection.createTileMatrix(
                    this,
                    this.cameraWorldSizeForFog,
                    t,
                  );
                  return (
                    r.az(p, this.worldToFogMatrix, p),
                    (h[s] = new Float32Array(p)),
                    h[s]
                  );
                }
                calculateProjMatrix(t, s = !1, h = !1) {
                  const p = t.key;
                  let g;
                  if (
                    ((g = h
                      ? this._expandedProjMatrixCache
                      : s
                        ? this._alignedProjMatrixCache
                        : this._projMatrixCache),
                    g[p])
                  )
                    return g[p];
                  const x = this.calculatePosMatrix(t, this.worldSize);
                  let w;
                  return (
                    (w = this.projection.isReprojectedInTileSpace
                      ? this.mercatorMatrix
                      : h
                        ? this.expandedFarZProjMatrix
                        : s
                          ? this.alignedProjMatrix
                          : this.projMatrix),
                    r.az(x, w, x),
                    (g[p] = new Float32Array(x)),
                    g[p]
                  );
                }
                calculatePixelsToTileUnitsMatrix(t) {
                  const s = t.tileID.key,
                    h = this._pixelsToTileUnitsCache;
                  if (h[s]) return h[s];
                  const p = r.cz(t, this);
                  return ((h[s] = p), h[s]);
                }
                customLayerMatrix() {
                  return this.mercatorMatrix.slice();
                }
                globeToMercatorMatrix() {
                  if (this.projection.name === "globe") {
                    const t = 1 / this.worldSize,
                      s = r.bn([], [t, t, t]);
                    return (r.az(s, s, this.globeMatrix), s);
                  }
                }
                recenterOnTerrain() {
                  if (!this._elevation || this.projection.name === "globe")
                    return;
                  const t = this._elevation;
                  this._updateCameraState();
                  const s = r.c6(1, this._center.lat) * this.worldSize,
                    h = this._computeCameraPosition(s),
                    p = this._camera.forward(),
                    g = r.c6(1, this._center.lat);
                  ((h[2] /= g), (p[2] /= g), r.au(p, p));
                  const x = t.raycast(h, p, t.exaggeration());
                  if (x) {
                    const w = r.bE([], h, p, x),
                      S = new r.ac(w[0], w[1], r.c6(w[2], r.aY(w[1]))),
                      C =
                        (S.z + r.ae([S.x - h[0], S.y - h[1], S.z - h[2] * g])) *
                        this._pixelsPerMercatorPixel;
                    ((this._seaLevelZoom = this._zoomFromMercatorZ(C)),
                      (this._centerAltitude = S.toAltitude()),
                      (this._center = this.coordinateLocation(S)),
                      this._updateZoomFromElevation(),
                      this._constrain(),
                      this._calcMatrices());
                  }
                }
                _constrainCamera(t = !1) {
                  if (!this._elevation) return;
                  const s = this._elevation,
                    h = r.c6(1, this._center.lat) * this.worldSize,
                    p = this._computeCameraPosition(h),
                    g = s.getAtPointOrZero(new r.ac(...p)),
                    x = (this.pixelsPerMeter / this.worldSize) * g,
                    w = this._minimumHeightOverTerrain(),
                    S = p[2] - x;
                  if (S <= w)
                    if (S < 0 || t) {
                      const C = this.locationCoordinate(
                          this._center,
                          this._centerAltitude,
                        ),
                        D = [p[0], p[1], C.z - p[2]],
                        L = r.ae(D);
                      D[2] -= (w - S) / this._pixelsPerMercatorPixel;
                      const z = r.ae(D);
                      if (z === 0) return;
                      (r.bY(D, D, (L / z) * this._pixelsPerMercatorPixel),
                        (this._camera.position = [
                          p[0],
                          p[1],
                          C.z * this._pixelsPerMercatorPixel - D[2],
                        ]),
                        this._updateStateFromCamera());
                    } else this._isCameraConstrained = !0;
                }
                _constrain() {
                  if (
                    !this.center ||
                    !this.width ||
                    !this.height ||
                    this._constraining
                  )
                    return;
                  this._constraining = !0;
                  const t =
                    this.projection.name === "globe" ||
                    this.mercatorFromTransition;
                  if (this.projection.isReprojectedInTileSpace || t) {
                    const z = this.center;
                    return (
                      (z.lat = r.ay(z.lat, this.minLat, this.maxLat)),
                      (this.maxBounds || (!this.renderWorldCopies && !t)) &&
                        (z.lng = r.ay(z.lng, this.minLng, this.maxLng)),
                      (this.center = z),
                      void (this._constraining = !1)
                    );
                  }
                  const s = this._unmodified,
                    { x: h, y: p } = this.point;
                  let g = 0,
                    x = h,
                    w = p;
                  const S = this.width / 2,
                    C = this.height / 2,
                    D = this.worldMinY * this.scale,
                    L = this.worldMaxY * this.scale;
                  if (
                    (p - C < D && (w = D + C),
                    p + C > L && (w = L - C),
                    L - D < this.height &&
                      ((g = Math.max(g, this.height / (L - D))),
                      (w = (L + D) / 2)),
                    this.maxBounds ||
                      !this._renderWorldCopies ||
                      !this.projection.wrap)
                  ) {
                    const z = this.worldMinX * this.scale,
                      O = this.worldMaxX * this.scale,
                      G = this.worldSize / 2 - (z + O) / 2;
                    ((x = ((h + G + this.worldSize) % this.worldSize) - G),
                      x - S < z && (x = z + S),
                      x + S > O && (x = O - S),
                      O - z < this.width &&
                        ((g = Math.max(g, this.width / (O - z))),
                        (x = (O + z) / 2)));
                  }
                  ((x === h && w === p) ||
                    this._allowWorldUnderZoom ||
                    (this.center = this.unproject(new r.P(x, w))),
                    g &&
                      !this._allowWorldUnderZoom &&
                      (this.zoom += this.scaleZoom(g)),
                    this._constrainCamera(),
                    (this._unmodified = s),
                    (this._constraining = !1));
                }
                _minZoomForBounds() {
                  let t = Math.max(
                    0,
                    this.scaleZoom(
                      Math.max(0, this.height) /
                        (this.worldMaxY - this.worldMinY),
                    ),
                  );
                  return (
                    this.maxBounds &&
                      (t = Math.max(
                        t,
                        this.scaleZoom(
                          this.width / (this.worldMaxX - this.worldMinX),
                        ),
                      )),
                    t
                  );
                }
                _maxCameraBoundsDistance() {
                  return this._mercatorZfromZoom(this._minZoomForBounds());
                }
                _calcMatrices() {
                  if (!this.height) return;
                  const t = this.centerOffset,
                    s = this.projection.name === "globe",
                    h = this.pixelsPerMeter;
                  this.projection.name === "globe" &&
                    (this._mercatorScaleRatio =
                      r.c6(1, this.center.lat) / r.c6(1, r.cP));
                  const p = r.cA(
                    this.projection,
                    this.zoom,
                    this.width,
                    this.height,
                    1024,
                  );
                  ((this._pixelsPerMercatorPixel =
                    this.projection.pixelSpaceConversion(
                      this.center.lat,
                      this.worldSize,
                      p,
                    )),
                    (this.cameraToCenterDistance =
                      (0.5 / Math.tan(0.5 * this._fov)) *
                      this.height *
                      this._pixelsPerMercatorPixel),
                    this._updateCameraState(),
                    (this._farZ = this.projection.farthestPixelDistance(this)),
                    (this._nearZ = this.height / 50));
                  const g = this.projection.zAxisUnit === "meters" ? h : 1,
                    x = this._camera.getWorldToCamera(this.worldSize, g);
                  let w;
                  const S = this._camera.getCameraToClipPerspective(
                    this._fov,
                    this.width / this.height,
                    this._nearZ,
                    this._farZ,
                  );
                  if (
                    ((S[8] = (2 * -t.x) / this.width),
                    (S[9] = (2 * t.y) / this.height),
                    this.isOrthographic)
                  ) {
                    let me =
                        ((0.5 * this.height) / Math.tan(this._fov / 2)) *
                        1 *
                        Math.tan(0.5 * this._fov),
                      _e = me * this.aspect,
                      De = -_e,
                      ze = -me;
                    ((_e -= t.x),
                      (De -= t.x),
                      (me += t.y),
                      (ze += t.y),
                      (w = this._camera.getCameraToClipOrthographic(
                        De,
                        _e,
                        ze,
                        me,
                        this._nearZ,
                        this._farZ,
                      )),
                      ((He, We, et, Ce) => {
                        for (let Ve = 0; Ve < 16; Ve++)
                          He[Ve] = r.ai(We[Ve], et[Ve], Ce);
                      })(
                        w,
                        w,
                        S,
                        r.cN(this.pitch >= lr ? 1 : this.pitch / lr),
                      ));
                  } else w = S;
                  const C = r.cB([], S, x);
                  let D = r.cB([], w, x);
                  if (this.projection.isReprojectedInTileSpace) {
                    const me = this.locationCoordinate(this.center),
                      _e = r.bx([]);
                    (r.bo(_e, _e, [
                      me.x * this.worldSize,
                      me.y * this.worldSize,
                      0,
                    ]),
                      r.az(_e, _e, r.cC(this)),
                      r.bo(_e, _e, [
                        -me.x * this.worldSize,
                        -me.y * this.worldSize,
                        0,
                      ]),
                      r.az(D, D, _e),
                      r.az(C, C, _e),
                      (this.inverseAdjustmentMatrix = r.cD(this)));
                  } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];
                  if (
                    ((this.mercatorMatrix = r.cE([], D, [
                      this.worldSize,
                      this.worldSize,
                      this.worldSize / g,
                      1,
                    ])),
                    (this.projMatrix = D),
                    (this.invProjMatrix = r.bi(
                      new Float64Array(16),
                      this.projMatrix,
                    )),
                    s)
                  ) {
                    const me = this._camera.getCameraToClipPerspective(
                      this._fov,
                      this.width / this.height,
                      this._nearZ,
                      1 / 0,
                    );
                    ((me[8] = (2 * -t.x) / this.width),
                      (me[9] = (2 * t.y) / this.height),
                      (this.expandedFarZProjMatrix = r.cB([], me, x)));
                  } else this.expandedFarZProjMatrix = this.projMatrix;
                  const L = r.bi([], w);
                  ((this.frustumCorners = r.cF.fromInvProjectionMatrix(
                    L,
                    this.horizonLineFromTop(),
                    this.height,
                  )),
                    (this.cameraFrustum = r.cn.fromInvProjectionMatrix(
                      this.invProjMatrix,
                      this.worldSize,
                      0,
                      !s,
                    )));
                  const z = new Float32Array(16);
                  (r.bx(z),
                    r.cE(z, z, [1, -1, 1]),
                    r.cG(z, z, this._pitch),
                    r.by(z, z, this.angle));
                  const O = r.c4(
                    new Float32Array(16),
                    this._fov,
                    this.width / this.height,
                    this._nearZ,
                    this._farZ,
                  );
                  this.starsProjMatrix = r.bw(O);
                  const G =
                    (Math.PI / 2 - this._pitch) *
                    (this.height / this._fov) *
                    this._horizonShift;
                  ((O[8] = (2 * -t.x) / this.width),
                    (O[9] = (2 * (t.y + G)) / this.height),
                    (this.skyboxMatrix = r.az(z, O, z)));
                  const U = this.point,
                    $ = U.x,
                    Z = U.y,
                    Y = (this.width % 2) / 2,
                    ie = (this.height % 2) / 2,
                    ae = Math.cos(this.angle),
                    pe = Math.sin(this.angle),
                    ue = $ - Math.round($) + ae * Y + pe * ie,
                    ce = Z - Math.round(Z) + ae * ie + pe * Y,
                    le = new Float64Array(D);
                  if (
                    (r.bo(le, le, [
                      ue > 0.5 ? ue - 1 : ue,
                      ce > 0.5 ? ce - 1 : ce,
                      0,
                    ]),
                    (this.alignedProjMatrix = le),
                    (D = r.bz()),
                    r.cE(D, D, [this.width / 2, -this.height / 2, 1]),
                    r.bo(D, D, [1, -1, 0]),
                    (this.labelPlaneMatrix = D),
                    (D = r.bz()),
                    r.cE(D, D, [1, -1, 1]),
                    r.bo(D, D, [-1, -1, 0]),
                    r.cE(D, D, [2 / this.width, 2 / this.height, 1]),
                    (this.glCoordMatrix = D),
                    (this.pixelMatrix = r.az(
                      new Float64Array(16),
                      this.labelPlaneMatrix,
                      C,
                    )),
                    this._calcFogMatrices(),
                    (this._distanceTileDataCache = {}),
                    (D = r.bi(new Float64Array(16), this.pixelMatrix)),
                    !D)
                  )
                    throw new Error("failed to invert matrix");
                  if (
                    ((this.pixelMatrixInverse = D),
                    this.projection.name === "globe" ||
                      this.mercatorFromTransition)
                  ) {
                    this.globeMatrix = r.cH(this);
                    const me = [
                      this.globeMatrix[12],
                      this.globeMatrix[13],
                      this.globeMatrix[14],
                    ];
                    ((this.globeCenterInViewSpace = r.ad(me, me, x)),
                      (this.globeRadius = this.worldSize / 2 / Math.PI - 1));
                  } else this.globeMatrix = D;
                  ((this._projMatrixCache = {}),
                    (this._alignedProjMatrixCache = {}),
                    (this._pixelsToTileUnitsCache = {}),
                    (this._expandedProjMatrixCache = {}));
                }
                _calcFogMatrices() {
                  this._fogTileMatrixCache = {};
                  const t = this.cameraWorldSizeForFog,
                    s = this.cameraPixelsPerMeter,
                    h = this._camera.position,
                    p = 1 / this.height / this._pixelsPerMercatorPixel,
                    g = [t, t, s];
                  (r.bY(g, g, p), r.bY(h, h, -1), r.cI(h, h, g));
                  const x = r.bz();
                  (r.bo(x, x, h),
                    r.cE(x, x, g),
                    (this.mercatorFogMatrix = x),
                    (this.worldToFogMatrix =
                      this._camera.getWorldToCameraPosition(t, s, p)));
                }
                _computeCameraPosition(t) {
                  const s =
                      (t = t || this.pixelsPerMeter) / this.pixelsPerMeter,
                    h = this._camera.forward(),
                    p = this.point,
                    g =
                      this._mercatorZfromZoom(
                        this._seaLevelZoom ? this._seaLevelZoom : this._zoom,
                      ) *
                        s -
                      (t / this.worldSize) * this._centerAltitude;
                  return [
                    p.x / this.worldSize - h[0] * g,
                    p.y / this.worldSize - h[1] * g,
                    (t / this.worldSize) * this._centerAltitude - h[2] * g,
                  ];
                }
                _updateCameraState() {
                  this.height &&
                    (this._camera.setPitchBearing(this._pitch, this.angle),
                    (this._camera.position = this._computeCameraPosition()));
                }
                _translateCameraConstrained(t) {
                  const s =
                      this._maxCameraBoundsDistance() * Math.cos(this._pitch),
                    h = this._camera.position[2],
                    p = t[2];
                  let g = 1;
                  (this.projection.wrap && (this.center = this.center.wrap()),
                    p > 0 && (g = Math.min((s - h) / p, 1)),
                    (this._camera.position = r.bE(
                      [],
                      this._camera.position,
                      t,
                      g,
                    )),
                    this._updateStateFromCamera());
                }
                _updateStateFromCamera() {
                  const t = this._camera.position,
                    s = this._camera.forward(),
                    { pitch: h, bearing: p } = this._camera.getPitchBearing(),
                    g =
                      r.c6(this._centerAltitude, this.center.lat) *
                      this._pixelsPerMercatorPixel,
                    x =
                      this._mercatorZfromZoom(this._maxZoom) *
                      Math.cos(r.al(this._maxPitch)),
                    w = Math.max((t[2] - g) / Math.cos(h), x),
                    S = this._zoomFromMercatorZ(w);
                  (r.bE(t, t, s, w),
                    (this._pitch = r.ay(
                      h,
                      r.al(this.minPitch),
                      r.al(this.maxPitch),
                    )),
                    (this.angle = r.bX(p, -Math.PI, Math.PI)),
                    this._setZoom(r.ay(S, this._minZoom, this._maxZoom)),
                    this._updateSeaLevelZoom(),
                    (this._center = this.coordinateLocation(
                      new r.ac(t[0], t[1], t[2]),
                    )),
                    (this._unmodified = !1),
                    this._constrain(),
                    this._calcMatrices());
                }
                _worldSizeFromZoom(t) {
                  return Math.pow(2, t) * this.tileSize;
                }
                _mercatorZfromZoom(t) {
                  return (
                    this.cameraToCenterDistance / this._worldSizeFromZoom(t)
                  );
                }
                _minimumHeightOverTerrain() {
                  const t =
                    Math.min(
                      this._seaLevelZoom != null
                        ? this._seaLevelZoom
                        : this._zoom,
                      this._maxZoom,
                    ) + 4;
                  return this._mercatorZfromZoom(t);
                }
                _zoomFromMercatorZ(t) {
                  return this.scaleZoom(
                    this.cameraToCenterDistance /
                      (Math.max(0, t) * this.tileSize),
                  );
                }
                zoomFromMercatorZAdjusted(t) {
                  let s = 0,
                    h = r.cx,
                    p = 0,
                    g = 1 / 0;
                  for (; h - s > 1e-6 && h > s; ) {
                    const x = s + 0.5 * (h - s),
                      w = this.tileSize * Math.pow(2, x),
                      S = this.getCameraToCenterDistance(this.projection, x, w),
                      C = this.scaleZoom(S / (Math.max(0, t) * this.tileSize)),
                      D = Math.abs(x - C);
                    (D < g && ((g = D), (p = x)), x < C ? (s = x) : (h = x));
                  }
                  return p;
                }
                _terrainEnabled() {
                  return !(
                    !this._elevation ||
                    (!this.projection.supportsTerrain &&
                      (r.w(
                        "Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain.",
                      ),
                      1))
                  );
                }
                anyCornerOffEdge(t, s) {
                  const h = Math.min(t.x, s.x),
                    p = Math.max(t.x, s.x),
                    g = Math.min(t.y, s.y),
                    x = Math.max(t.y, s.y);
                  if (g < this.horizonLineFromTop(!1)) return !0;
                  if (this.projection.name !== "mercator") return !1;
                  const w = [
                      new r.P(h, g),
                      new r.P(p, x),
                      new r.P(h, x),
                      new r.P(p, g),
                    ],
                    S = this.renderWorldCopies ? -3 : 0,
                    C = this.renderWorldCopies ? 4 : 1;
                  for (const D of w) {
                    const L = this.pointRayIntersection(D);
                    if (L.t < 0) return !0;
                    const z = this.rayIntersectionCoordinate(L);
                    if (z.x < S || z.y < 0 || z.x > C || z.y > 1) return !0;
                  }
                  return !1;
                }
                isHorizonVisible() {
                  return (
                    this.pitch + r.cJ(this.fovAboveCenter) > 88 ||
                    this.anyCornerOffEdge(
                      new r.P(0, 0),
                      new r.P(this.width, this.height),
                    )
                  );
                }
                zoomDeltaToMovement(t, s) {
                  const h = r.ae(r.at([], this._camera.position, t)),
                    p = this._zoomFromMercatorZ(h) + s;
                  return h - this._mercatorZfromZoom(p);
                }
                getCameraPoint() {
                  if (this.projection.name === "globe") {
                    const t = (function ([s, h, p], g) {
                      const x = [s, h, p, 1];
                      r.aA(x, x, g);
                      const w = (x[3] = Math.max(x[3], 1e-6));
                      return ((x[0] /= w), (x[1] /= w), (x[2] /= w), x);
                    })(
                      [
                        this.globeMatrix[12],
                        this.globeMatrix[13],
                        this.globeMatrix[14],
                      ],
                      this.pixelMatrix,
                    );
                    return new r.P(t[0], t[1]);
                  }
                  {
                    const t =
                      Math.tan(this._pitch) *
                      (this.cameraToCenterDistance || 1);
                    return this.centerPoint.add(new r.P(0, t));
                  }
                }
                getCameraToCenterDistance(
                  t,
                  s = this.zoom,
                  h = this.worldSize,
                ) {
                  const p = r.cA(t, s, this.width, this.height, 1024),
                    g = t.pixelSpaceConversion(this.center.lat, h, p);
                  let x = (0.5 / Math.tan(0.5 * this._fov)) * this.height * g;
                  return (
                    this.isOrthographic &&
                      (x = r.ai(
                        1,
                        x,
                        r.cN(this.pitch >= lr ? 1 : this.pitch / lr),
                      )),
                    x
                  );
                }
                getWorldToCameraMatrix() {
                  const t = this._camera.getWorldToCamera(
                    this.worldSize,
                    this.projection.zAxisUnit === "meters"
                      ? this.pixelsPerMeter
                      : 1,
                  );
                  return (
                    this.projection.name === "globe" &&
                      r.az(t, t, this.globeMatrix),
                    t
                  );
                }
                getFrustum(t) {
                  return r.cn.fromInvProjectionMatrix(
                    this.invProjMatrix,
                    this.worldSize,
                    t,
                    this.projection.zAxisUnit === "meters",
                  );
                }
              }
              const Bs = (c, t) => {
                  if (
                    (t > 0 &&
                      c.terrain &&
                      r.w("Cutoff is currently disabled on terrain"),
                    t <= 0 || c.terrain)
                  )
                    return {
                      shouldRenderCutoff: !1,
                      uniformValues: { u_cutoff_params: [0, 0, 0, 1] },
                    };
                  const s = c.transform,
                    h = Math.max(Math.abs(s._zoom - (c.minCutoffZoom - 1)), 1),
                    p = s.isLODDisabled(!1)
                      ? r.af(60, 45, s.pitch)
                      : r.af(30, 15, s.pitch),
                    g = s._farZ - s._nearZ,
                    x = t * s.height,
                    w =
                      ((1 - (S = p)) * s.cameraToCenterDistance +
                        S * (s._farZ + x)) *
                      h;
                  var S;
                  return {
                    shouldRenderCutoff: p < 1,
                    uniformValues: {
                      u_cutoff_params: [
                        s._nearZ,
                        s._farZ,
                        (w - s._nearZ) / g,
                        (w - x - s._nearZ) / g,
                      ],
                    },
                  };
                },
                Sr = {
                  cascadeCount: 2,
                  normalOffset: 3,
                  shadowMapResolution: 2048,
                };
              class Tc {
                constructor(t, s) {
                  ((this.aabb = t), (this.lastCascade = s));
                }
              }
              class d_ {
                add(t, s) {
                  const h = this.receivers[t.key];
                  h !== void 0
                    ? ((h.aabb.min[0] = Math.min(h.aabb.min[0], s.min[0])),
                      (h.aabb.min[1] = Math.min(h.aabb.min[1], s.min[1])),
                      (h.aabb.min[2] = Math.min(h.aabb.min[2], s.min[2])),
                      (h.aabb.max[0] = Math.max(h.aabb.max[0], s.max[0])),
                      (h.aabb.max[1] = Math.max(h.aabb.max[1], s.max[1])),
                      (h.aabb.max[2] = Math.max(h.aabb.max[2], s.max[2])))
                    : (this.receivers[t.key] = new Tc(s, null));
                }
                clear() {
                  this.receivers = {};
                }
                get(t) {
                  return this.receivers[t.key];
                }
                computeRequiredCascades(t, s, h) {
                  const p = r.cW.fromPoints(t.points);
                  let g = 0;
                  for (const x in this.receivers) {
                    const w = this.receivers[x];
                    if (!w || !p.intersectsAabb(w.aabb)) continue;
                    ((w.aabb.min = p.closestPoint(w.aabb.min)),
                      (w.aabb.max = p.closestPoint(w.aabb.max)));
                    const S = w.aabb.getCorners();
                    for (let C = 0; C < h.length; C++) {
                      let D = !0;
                      for (const L of S) {
                        const z = [L[0] * s, L[1] * s, L[2]];
                        if (
                          (r.ad(z, z, h[C].matrix),
                          z[0] < -1 || z[0] > 1 || z[1] < -1 || z[1] > 1)
                        ) {
                          D = !1;
                          break;
                        }
                      }
                      if (((w.lastCascade = C), (g = Math.max(g, C)), D)) break;
                    }
                  }
                  return g + 1;
                }
              }
              class f_ {
                constructor(t) {
                  ((this.painter = t),
                    (this._enabled = !1),
                    (this._shadowLayerCount = 0),
                    (this._numCascadesToRender = 0),
                    (this._cascades = []),
                    (this._groundShadowTiles = []),
                    (this._receivers = new d_()),
                    (this._depthMode = new wt(
                      t.context.gl.LEQUAL,
                      wt.ReadWrite,
                      [0, 1],
                    )),
                    (this._uniformValues = {
                      u_light_matrix_0: new Float32Array(16),
                      u_light_matrix_1: new Float32Array(16),
                      u_shadow_intensity: 0,
                      u_fade_range: [0, 0],
                      u_shadow_normal_offset: [1, 1, 1],
                      u_shadow_texel_size: 1,
                      u_shadow_map_resolution: 1,
                      u_shadow_direction: [0, 0, 1],
                      u_shadow_bias: [36e-5, 0.0012, 0.012],
                      u_shadowmap_0: 0,
                      u_shadowmap_1: 0,
                    }),
                    (this._forceDisable = !1),
                    (this.useNormalOffset = !1),
                    t.tp.registerParameter(
                      this,
                      ["Shadows"],
                      "_forceDisable",
                      { label: "forceDisable" },
                      () => {
                        this.painter.style.map.triggerRepaint();
                      },
                    ),
                    t.tp.registerParameter(Sr, ["Shadows"], "cascadeCount", {
                      min: 1,
                      max: 2,
                      step: 1,
                    }),
                    t.tp.registerParameter(Sr, ["Shadows"], "normalOffset", {
                      min: 0,
                      max: 10,
                      step: 0.05,
                    }),
                    t.tp.registerParameter(
                      Sr,
                      ["Shadows"],
                      "shadowMapResolution",
                      { min: 32, max: 2048, step: 32 },
                    ),
                    t.tp.registerBinding(
                      this,
                      ["Shadows"],
                      "_numCascadesToRender",
                      { readonly: !0, label: "numCascadesToRender" },
                    ));
                }
                destroy() {
                  for (const t of this._cascades)
                    (t.texture.destroy(), t.framebuffer.destroy());
                  this._cascades = [];
                }
                updateShadowParameters(t, s) {
                  const h = this.painter;
                  if (
                    ((this._enabled = !1),
                    (this._shadowLayerCount = 0),
                    this._receivers.clear(),
                    !s || !s.properties)
                  )
                    return;
                  const p = s.properties.get("shadow-intensity");
                  if (
                    !s.shadowsEnabled() ||
                    p <= 0 ||
                    ((this._shadowLayerCount = h.style.order.reduce((G, U) => {
                      const $ = h.style._mergedLayers[U];
                      return (
                        G + ($.hasShadowPass() && !$.isHidden(t.zoom) ? 1 : 0)
                      );
                    }, 0)),
                    (this._enabled = this._shadowLayerCount > 0),
                    !this.enabled)
                  )
                    return;
                  const g = h.context,
                    x = Sr.shadowMapResolution,
                    w = Sr.shadowMapResolution;
                  if (
                    this._cascades.length === 0 ||
                    Sr.shadowMapResolution !== this._cascades[0].texture.size[0]
                  ) {
                    this._cascades = [];
                    for (let G = 0; G < Sr.cascadeCount; ++G) {
                      const U = h._shadowMapDebug,
                        $ = g.gl,
                        Z = g.createFramebuffer(x, w, U, "texture"),
                        Y = new r.T(
                          g,
                          { width: x, height: w, data: null },
                          $.DEPTH_COMPONENT16,
                        );
                      if ((Z.depthAttachment.set(Y.texture), U)) {
                        const ie = new r.T(
                          g,
                          { width: x, height: w, data: null },
                          $.RGBA8,
                        );
                        Z.colorAttachment.set(ie.texture);
                      }
                      this._cascades.push({
                        framebuffer: Z,
                        texture: Y,
                        matrix: [],
                        far: 0,
                        boundingSphereRadius: 0,
                        frustum: new r.cn(),
                        scale: 0,
                      });
                    }
                  }
                  this.shadowDirection = cl(s);
                  let S = 0;
                  if (t.elevation) {
                    const G = t.elevation,
                      U = [1e4, -1e4];
                    (G.visibleDemTiles
                      .filter(($) => $.dem)
                      .forEach(($) => {
                        const Z = $.dem.tree;
                        ((U[0] = Math.min(U[0], Z.minimums[0])),
                          (U[1] = Math.max(U[1], Z.maximums[0])));
                      }),
                      U[0] !== 1e4 && (S = (U[1] - U[0]) * G.exaggeration()));
                  }
                  const C = 1.5 * t.cameraToCenterDistance,
                    D = 3 * C,
                    L = new Float64Array(16);
                  for (let G = 0; G < this._cascades.length; ++G) {
                    const U = this._cascades[G];
                    let $ = t.height / 50,
                      Z = 1;
                    Sr.cascadeCount === 1
                      ? (Z = D)
                      : G === 0
                        ? (Z = C)
                        : (($ = C), (Z = D));
                    const [Y, ie] = hl(
                      t,
                      this.shadowDirection,
                      $,
                      Z,
                      Sr.shadowMapResolution,
                      S,
                    );
                    ((U.scale = t.scale),
                      (U.matrix = Y),
                      (U.boundingSphereRadius = ie),
                      r.bi(L, U.matrix),
                      (U.frustum = r.cn.fromInvProjectionMatrix(L, 1, 0, !0)),
                      (U.far = Z));
                  }
                  const z = this._cascades.length - 1;
                  ((this._uniformValues.u_fade_range = [
                    0.75 * this._cascades[z].far,
                    this._cascades[z].far,
                  ]),
                    (this._uniformValues.u_shadow_intensity = p),
                    (this._uniformValues.u_shadow_direction = [
                      this.shadowDirection[0],
                      this.shadowDirection[1],
                      this.shadowDirection[2],
                    ]),
                    (this._uniformValues.u_shadow_texel_size =
                      1 / Sr.shadowMapResolution),
                    (this._uniformValues.u_shadow_map_resolution =
                      Sr.shadowMapResolution),
                    (this._uniformValues.u_shadowmap_0 = zr.ShadowMap0),
                    (this._uniformValues.u_shadowmap_1 = zr.ShadowMap0 + 1),
                    (this._groundShadowTiles = h.transform.coveringTiles({
                      tileSize: 512,
                      renderWorldCopies: !0,
                    })));
                  const O = h.transform.elevation;
                  for (const G of this._groundShadowTiles) {
                    let U = { min: 0, max: 0 };
                    if (O) {
                      const $ = O.getMinMaxForTile(G);
                      $ && (U = $);
                    }
                    this.addShadowReceiver(G.toUnwrapped(), U.min, U.max);
                  }
                }
                get enabled() {
                  return this._enabled && !this._forceDisable;
                }
                set enabled(t) {
                  this._enabled = t;
                }
                drawShadowPass(t, s) {
                  if (!this.enabled) return;
                  const h = this.painter,
                    p = h.context;
                  ((this._numCascadesToRender =
                    this._receivers.computeRequiredCascades(
                      h.transform.getFrustum(0),
                      h.transform.worldSize,
                      this._cascades,
                    )),
                    p.viewport.set([
                      0,
                      0,
                      Sr.shadowMapResolution,
                      Sr.shadowMapResolution,
                    ]));
                  for (let g = 0; g < this._numCascadesToRender; ++g) {
                    ((h.currentShadowCascade = g),
                      p.bindFramebuffer.set(
                        this._cascades[g].framebuffer.framebuffer,
                      ),
                      p.clear({ color: r.am.white, depth: 1 }));
                    for (const x of t.order) {
                      const w = t._mergedLayers[x];
                      if (!w.hasShadowPass() || w.isHidden(h.transform.zoom))
                        continue;
                      const S = t.getLayerSourceCache(w),
                        C = S ? s[S.id] : void 0;
                      (w.type === "model" || (C && C.length)) &&
                        h.renderLayer(h, S, w, C);
                    }
                  }
                  h.currentShadowCascade = 0;
                }
                drawGroundShadows() {
                  if (!this.enabled) return;
                  const t = this.painter,
                    s = t.style,
                    h = t.context,
                    p = h.gl,
                    g = s.directionalLight,
                    x = s.ambientLight;
                  if (!g || !x) return;
                  const w = [],
                    S = Bs(t, t.longestCutoffRange);
                  (S.shouldRenderCutoff && w.push("RENDER_CUTOFF"),
                    w.push("RENDER_SHADOWS", "DEPTH_TEXTURE"),
                    this.useNormalOffset && w.push("NORMAL_OFFSET"));
                  const C = wa(s, g, x),
                    D = new wt(p.LEQUAL, wt.ReadOnly, t.depthRangeFor3D),
                    L = new Yt(
                      { func: p.EQUAL, mask: 255 },
                      0,
                      255,
                      p.KEEP,
                      p.KEEP,
                      p.KEEP,
                    );
                  for (const z of this._groundShadowTiles) {
                    const O = z.toUnwrapped(),
                      G = t.isTileAffectedByFog(z),
                      U = t.getOrCreateProgram("groundShadow", {
                        defines: w,
                        overrideFog: G,
                      });
                    (this.setupShadows(O, U),
                      t.uploadCommonUniforms(h, U, O, null, S));
                    const $ = {
                      u_matrix: t.transform.calculateProjMatrix(O),
                      u_ground_shadow_factor: C,
                    };
                    U.draw(
                      t,
                      p.TRIANGLES,
                      D,
                      L,
                      ui.multiply,
                      Gt.disabled,
                      $,
                      "ground_shadow",
                      t.tileExtentBuffer,
                      t.quadTriangleIndexBuffer,
                      t.tileExtentSegments,
                      null,
                      t.transform.zoom,
                      null,
                      null,
                    );
                  }
                }
                getShadowPassColorMode() {
                  return this.painter._shadowMapDebug
                    ? ui.unblended
                    : ui.disabled;
                }
                getShadowPassDepthMode() {
                  return this._depthMode;
                }
                getShadowCastingLayerCount() {
                  return this._shadowLayerCount;
                }
                calculateShadowPassMatrixFromTile(t) {
                  const s = this.painter.transform,
                    h = s.calculatePosMatrix(t, s.worldSize);
                  return (
                    r.az(
                      h,
                      this._cascades[this.painter.currentShadowCascade].matrix,
                      h,
                    ),
                    Float32Array.from(h)
                  );
                }
                calculateShadowPassMatrixFromMatrix(t) {
                  return (
                    r.az(
                      t,
                      this._cascades[this.painter.currentShadowCascade].matrix,
                      t,
                    ),
                    Float32Array.from(t)
                  );
                }
                setupShadows(t, s, h, p = 0) {
                  if (!this.enabled) return;
                  const g = this.painter.transform,
                    x = this.painter.context,
                    w = x.gl,
                    S = this._uniformValues,
                    C = new Float64Array(16),
                    D = g.calculatePosMatrix(t, g.worldSize);
                  for (let L = 0; L < this._cascades.length; L++)
                    (r.az(C, this._cascades[L].matrix, D),
                      (S[L === 0 ? "u_light_matrix_0" : "u_light_matrix_1"] =
                        Float32Array.from(C)),
                      x.activeTexture.set(w.TEXTURE0 + zr.ShadowMap0 + L),
                      this._cascades[L].texture.bindExtraParam(
                        w.LINEAR,
                        w.LINEAR,
                        w.CLAMP_TO_EDGE,
                        w.CLAMP_TO_EDGE,
                        w.GREATER,
                      ));
                  if (((this.useNormalOffset = !!h), this.useNormalOffset)) {
                    const L = r.cU(t.canonical),
                      z = ((2 / g.tileSize) * r.aj) / Sr.shadowMapResolution,
                      O = z * this._cascades[0].boundingSphereRadius,
                      G =
                        z *
                        this._cascades[this._cascades.length - 1]
                          .boundingSphereRadius,
                      U =
                        (h === "vector-tile" ? 1 : 3) /
                        Math.pow(
                          2,
                          p - t.canonical.z - (1 - g.zoom + Math.floor(g.zoom)),
                        );
                    ((S.u_shadow_normal_offset = [L, O * U, G * U]),
                      (S.u_shadow_bias = [6e-5, 0.0012, 0.012]));
                  } else S.u_shadow_bias = [36e-5, 0.0012, 0.012];
                  s.setShadowUniformValues(x, S);
                }
                setupShadowsFromMatrix(t, s, h = !1) {
                  if (!this.enabled) return;
                  const p = this.painter.context,
                    g = p.gl,
                    x = this._uniformValues,
                    w = new Float64Array(16);
                  for (let S = 0; S < Sr.cascadeCount; S++)
                    (r.az(w, this._cascades[S].matrix, t),
                      (x[S === 0 ? "u_light_matrix_0" : "u_light_matrix_1"] =
                        Float32Array.from(w)),
                      p.activeTexture.set(g.TEXTURE0 + zr.ShadowMap0 + S),
                      this._cascades[S].texture.bindExtraParam(
                        g.LINEAR,
                        g.LINEAR,
                        g.CLAMP_TO_EDGE,
                        g.CLAMP_TO_EDGE,
                        g.GREATER,
                      ));
                  if (((this.useNormalOffset = h), h)) {
                    const S = Sr.normalOffset;
                    ((x.u_shadow_normal_offset = [1, S, S]),
                      (x.u_shadow_bias = [6e-5, 0.0012, 0.012]));
                  } else x.u_shadow_bias = [36e-5, 0.0012, 0.012];
                  s.setShadowUniformValues(p, x);
                }
                getShadowUniformValues() {
                  return this._uniformValues;
                }
                getCurrentCascadeFrustum() {
                  return this._cascades[this.painter.currentShadowCascade]
                    .frustum;
                }
                computeSimplifiedTileShadowVolume(t, s, h, p) {
                  if (p[2] >= 0) return {};
                  const g = (function (S, C, D) {
                      const L = D / (1 << S.canonical.z);
                      return new r.cW(
                        [
                          S.canonical.x * L + S.wrap * D,
                          S.canonical.y * L + S.wrap * D,
                          0,
                        ],
                        [
                          (S.canonical.x + 1) * L + S.wrap * D,
                          (S.canonical.y + 1) * L + S.wrap * D,
                          C,
                        ],
                      );
                    })(t, s, h).getCorners(),
                    x = s / -p[2];
                  (p[0] < 0
                    ? (r.cV(g[0], g[0], [p[0] * x, 0, 0]),
                      r.cV(g[3], g[3], [p[0] * x, 0, 0]))
                    : p[0] > 0 &&
                      (r.cV(g[1], g[1], [p[0] * x, 0, 0]),
                      r.cV(g[2], g[2], [p[0] * x, 0, 0])),
                    p[1] < 0
                      ? (r.cV(g[0], g[0], [0, p[1] * x, 0]),
                        r.cV(g[1], g[1], [0, p[1] * x, 0]))
                      : p[1] > 0 &&
                        (r.cV(g[2], g[2], [0, p[1] * x, 0]),
                        r.cV(g[3], g[3], [0, p[1] * x, 0])));
                  const w = {};
                  return (
                    (w.vertices = g),
                    (w.planes = [
                      ko(g[1], g[0], g[4]),
                      ko(g[2], g[1], g[5]),
                      ko(g[3], g[2], g[6]),
                      ko(g[0], g[3], g[7]),
                    ]),
                    w
                  );
                }
                addShadowReceiver(t, s, h) {
                  this._receivers.add(t, r.cW.fromTileIdAndHeight(t, s, h));
                }
                getMaxCascadeForTile(t) {
                  const s = this._receivers.get(t);
                  return s && s.lastCascade ? s.lastCascade : 0;
                }
              }
              function ko(c, t, s) {
                const h = r.at([], s, t),
                  p = r.at([], c, t),
                  g = r.bF([], h, p),
                  x = r.ae(g);
                return x === 0
                  ? [0, 0, 1, 0]
                  : (r.bY(g, g, 1 / x), [g[0], g[1], g[2], -r.bG(g, t)]);
              }
              function cl(c) {
                const t = c.properties.get("direction"),
                  s = r.cR(t.x, t.y, t.z);
                s[2] = r.ay(s[2], 0, 75);
                const h = r.cT([s[0], s[1], s[2]]);
                return r.cS(h.x, h.y, h.z);
              }
              function wa(c, t, s) {
                const h = t.properties.get("color-use-theme") === "none",
                  p = t.properties.get("color"),
                  g = t.properties.get("intensity"),
                  x = t.properties.get("direction"),
                  w = [x.x, x.y, x.z],
                  S = s.properties.get("color-use-theme") === "none",
                  C = s.properties.get("color"),
                  D = s.properties.get("intensity"),
                  L = Math.max(r.bG([0, 0, 1], w), 0),
                  z = [0, 0, 0];
                r.bY(
                  z,
                  C.toPremultipliedRenderColor(S ? null : c.getLut(t.scope))
                    .toArray01Linear()
                    .slice(0, 3),
                  D,
                );
                const O = [0, 0, 0];
                return (
                  r.bY(
                    O,
                    p
                      .toPremultipliedRenderColor(h ? null : c.getLut(s.scope))
                      .toArray01Linear()
                      .slice(0, 3),
                    L * g,
                  ),
                  r.cY([
                    z[0] > 0 ? z[0] / (z[0] + O[0]) : 0,
                    z[1] > 0 ? z[1] / (z[1] + O[1]) : 0,
                    z[2] > 0 ? z[2] / (z[2] + O[2]) : 0,
                  ])
                );
              }
              function hl(c, t, s, h, p, g) {
                const x = c.zoom,
                  w = c.scale,
                  S = c.worldSize,
                  C = 1 / S,
                  D = c.aspect,
                  L = Math.sqrt(1 + D * D) * Math.tan(0.5 * c.fovX),
                  z = L * L,
                  O = h - s,
                  G = h + s;
                let U, $;
                z > O / G
                  ? ((U = h), ($ = h * L))
                  : ((U = 0.5 * G * (1 + z)),
                    ($ =
                      0.5 *
                      Math.sqrt(
                        O * O + 2 * (h * h + s * s) * z + G * G * z * z,
                      )));
                const Z = c.projection.pixelsPerMeter(c.center.lat, S),
                  Y = c._camera.getCameraToWorldMercator(),
                  ie = [0, 0, -U * C];
                r.ad(ie, ie, Y);
                let ae = $ * C;
                const pe = c._edgeInsets;
                if (
                  !(
                    (pe.left === 0 &&
                      pe.top === 0 &&
                      pe.right === 0 &&
                      pe.bottom === 0) ||
                    (pe.left === pe.right && pe.top === pe.bottom)
                  )
                ) {
                  const Ke = c._camera.getWorldToCamera(
                      c.worldSize,
                      c.projection.zAxisUnit === "meters" ? Z : 1,
                    ),
                    ht = c._camera.getCameraToClipPerspective(
                      c._fov,
                      c.width / c.height,
                      s,
                      h,
                    );
                  ((ht[8] = (2 * -c.centerOffset.x) / c.width),
                    (ht[9] = (2 * c.centerOffset.y) / c.height));
                  const qe = new Float64Array(16);
                  r.cB(qe, ht, Ke);
                  const lt = new Float64Array(16);
                  r.bi(lt, qe);
                  const St = r.cn.fromInvProjectionMatrix(lt, S, x, !0);
                  for (const Et of St.points) {
                    const bt =
                      (((ue = Et)[0] /= w),
                      (ue[1] /= w),
                      (ue[2] = r.c6(ue[2], c._center.lat)),
                      ue);
                    ae = Math.max(ae, r.bZ(r.cX([], ie, bt)));
                  }
                }
                var ue;
                ae *= p / (p - 1);
                const ce = Math.acos(t[2]),
                  le = Math.atan2(-t[0], -t[1]),
                  me = new ys();
                ((me.position = ie), me.setPitchBearing(ce, le));
                const _e = me.getWorldToCamera(S, Z),
                  De = ae * S,
                  ze = Math.min(c._mercatorZfromZoom(17) * S * -2, -2 * De),
                  He = me.getCameraToClipOrthographic(
                    -De,
                    De,
                    -De,
                    De,
                    ze,
                    (De + g * Z) / t[2],
                  ),
                  We = new Float64Array(16);
                r.az(We, He, _e);
                const et = r.cS(
                    (Math.floor(1e6 * ie[0]) / 1e6) * S,
                    (Math.floor(1e6 * ie[1]) / 1e6) * S,
                    0,
                  ),
                  Ce = 0.5 * p,
                  Ve = [0, 0, 0];
                (r.ad(Ve, et, We), r.bY(Ve, Ve, Ce));
                const Te = [
                    Math.floor(Ve[0]),
                    Math.floor(Ve[1]),
                    Math.floor(Ve[2]),
                  ],
                  Ze = [0, 0, 0];
                (r.at(Ze, Ve, Te), r.bY(Ze, Ze, -1 / Ce));
                const Oe = new Float64Array(16);
                return (r.bx(Oe), r.bo(Oe, Oe, Ze), r.az(We, Oe, We), [We, De]);
              }
              class Ap extends r.E {
                constructor(t) {
                  (super(),
                    (this.requestManager = t),
                    (this.models = { "": {} }),
                    (this.modelUris = { "": {} }),
                    (this.modelByURL = {}),
                    (this.numModelsLoading = {}));
                }
                loadModel(t, s) {
                  return r
                    .aS(this.requestManager.transformRequest(s, r.R.Model).url)
                    .then((h) => {
                      if (!h) return;
                      const p = r.aT(h),
                        g = new r.aU(t, void 0, void 0, p);
                      return (g.computeBoundsAndApplyParent(), g);
                    })
                    .catch((h) => {
                      if (h && h.status === 404) return null;
                      this.fire(
                        new r.z(
                          new Error(
                            `Could not load model ${t} from ${s}: ${h.message}`,
                          ),
                        ),
                      );
                    });
                }
                load(t, s, h = { forceReload: !1 }) {
                  this.models[s] || (this.models[s] = {});
                  const p = Object.keys(t),
                    g = [],
                    x = [];
                  for (const w of p) {
                    const S = t[w];
                    ((this.hasURLBeenRequested(S) && !h.forceReload) ||
                      ((this.modelByURL[S] = { modelId: w, scope: s }),
                      g.push(this.loadModel(w, S)),
                      x.push(w)),
                      this.models[s][w] ||
                        (this.models[s][w] = {
                          model: null,
                          numReferences: 1,
                        }));
                  }
                  ((this.numModelsLoading[s] =
                    (this.numModelsLoading[s] || 0) + x.length),
                    Promise.allSettled(g)
                      .then((w) => {
                        for (let S = 0; S < w.length; S++) {
                          const { status: C } = w[S];
                          if (C === "rejected") continue;
                          const { value: D } = w[S];
                          (this.models[s][x[S]] ||
                            (this.models[s][x[S]] = {
                              model: null,
                              numReferences: 1,
                            }),
                            (this.models[s][x[S]].model = D));
                        }
                        ((this.numModelsLoading[s] -= x.length),
                          this.fire(new r.A("data", { dataType: "style" })));
                      })
                      .catch((w) => {
                        this.fire(
                          new r.z(
                            new Error(`Could not load models: ${w.message}`),
                          ),
                        );
                      }));
                }
                isLoaded() {
                  for (const t in this.numModelsLoading)
                    if (this.numModelsLoading[t] > 0) return !1;
                  return !0;
                }
                hasModel(t, s, h = { exactIdMatch: !1 }) {
                  return !!(h.exactIdMatch
                    ? this.getModel(t, s)
                    : this.getModelByURL(this.modelUris[s][t]));
                }
                getModel(t, s) {
                  return (
                    this.models[s] || (this.models[s] = {}),
                    this.models[s][t] ? this.models[s][t].model : void 0
                  );
                }
                getModelByURL(t) {
                  if (!t) return null;
                  const s = this.modelByURL[t];
                  return s ? this.models[s.scope][s.modelId].model : null;
                }
                hasModelBeenAdded(t, s) {
                  return this.models[s] && this.models[s][t] !== void 0;
                }
                getModelURIs(t) {
                  return this.modelUris[t] || {};
                }
                addModel(t, s, h) {
                  (this.models[h] || (this.models[h] = {}),
                    this.modelUris[h] || (this.modelUris[h] = {}));
                  const p = this.requestManager.normalizeModelURL(s);
                  if (
                    (this.hasModel(t, h, { exactIdMatch: !0 }) ||
                      this.hasModelBeenAdded(t, h)) &&
                    this.modelUris[h][t] === p
                  )
                    this.models[h][t].numReferences++;
                  else if (this.hasURLBeenRequested(p)) {
                    const { scope: g, modelId: x } = this.modelByURL[p];
                    this.models[g][x].numReferences++;
                  } else
                    ((this.modelUris[h][t] = p),
                      this.load({ [t]: this.modelUris[h][t] }, h));
                }
                addModelURLs(t, s) {
                  (this.models[s] || (this.models[s] = {}),
                    this.modelUris[s] || (this.modelUris[s] = {}));
                  const h = this.modelUris[s];
                  for (const p in t)
                    h[p] = this.requestManager.normalizeModelURL(t[p]);
                }
                reloadModels(t) {
                  this.load(this.modelUris[t], t, { forceReload: !0 });
                }
                addModelsFromBucket(t, s) {
                  (this.models[s] || (this.models[s] = {}),
                    this.modelUris[s] || (this.modelUris[s] = {}));
                  const h = {};
                  for (const p of t)
                    this.hasModel(p, s, { exactIdMatch: !0 }) ||
                    this.hasURLBeenRequested(p)
                      ? this.models[s][p].numReferences++
                      : this.modelUris[s][p] && !this.hasURLBeenRequested(p)
                        ? (h[p] = this.modelUris[s][p])
                        : !this.hasURLBeenRequested(p) &&
                          r.cZ(p, !1) &&
                          ((this.modelUris[s][p] =
                            this.requestManager.normalizeModelURL(p)),
                          (h[p] = this.modelUris[s][p]));
                  this.load(h, s);
                }
                hasURLBeenRequested(t) {
                  return this.modelByURL[t] !== void 0;
                }
                removeModel(t, s, h = !1) {
                  if (
                    this.models[s] &&
                    this.models[s][t] &&
                    (this.models[s][t].numReferences--,
                    this.models[s][t].numReferences === 0)
                  ) {
                    const p = this.modelUris[s][t];
                    (h || delete this.modelUris[s][t],
                      delete this.modelByURL[p]);
                    const g = this.models[s][t].model;
                    if (!g) return;
                    (delete this.models[s][t], g.destroy());
                  }
                }
                destroy() {
                  for (const t of Object.keys(this.models))
                    for (const s of Object.keys(this.models[t])) {
                      const h = this.models[t][s].model;
                      (delete this.models[t][s], h && h.destroy());
                    }
                  ((this.models = { "": {} }),
                    (this.modelUris = { "": {} }),
                    (this.modelByURL = {}),
                    (this.numModelsLoading = {}));
                }
                listModels(t) {
                  return (
                    this.models[t] || (this.models[t] = {}),
                    Object.keys(this.models[t])
                  );
                }
                upload(t, s) {
                  this.models[s] || (this.models[s] = {});
                  for (const h in this.models[s])
                    this.models[s][h].model &&
                      this.models[s][h].model.upload(t.context);
                }
              }
              const Bh = new r.a7({ data: new r.a8(r.a5.colorTheme.data) }),
                dd = {
                  "mbx-indoor-active-floorplans": { default: ["literal", []] },
                  "mbx-indoor-underground": { default: ["literal", !1] },
                  "mbx-indoor-loaded-levels": { default: ["literal", []] },
                  "mbx-indoor-level-height": { default: ["literal", {}] },
                  "mbx-indoor-level-base": { default: ["literal", {}] },
                  "mbx-indoor-level-selected": { default: ["literal", {}] },
                  "mbx-indoor-level-overlapped": { default: ["literal", {}] },
                };
              function ao(c) {
                return ((c = c || {}), Object.assign(c, dd));
              }
              class p_ extends r.E {
                constructor(t) {
                  (super(),
                    (this.mergeFloors = !0),
                    (this._scope = void 0),
                    (this._queryFeatureSetId = void 0),
                    (this._buildingEntryFeatureSetId = void 0),
                    (this._selectedFloorplan = void 0),
                    (this._indoorData = void 0),
                    (this._floorplanStates = {}),
                    r.aV(
                      ["_onLoad", "_onMove", "_checkFloorplanVisible"],
                      this,
                    ),
                    (this._map = t),
                    this._checkFloorplanVisible(),
                    this._map.on("load", this._onLoad),
                    this._map.on("move", this._onMove));
                }
                destroy() {
                  (this._map.indoor.off("load", this._onLoad),
                    this._map.indoor.off("move", this._onMove),
                    (this._map = void 0));
                }
                _onLoad() {
                  (this._map.style.forEachFragmentStyle((t) => {
                    t.stylesheet.indoor &&
                      (this._queryFeatureSetId
                        ? this.fire(
                            new r.z(
                              new Error(
                                "Multiple indoor map styles detected, simultaneous usage is not allowed currently.",
                              ),
                            ),
                          )
                        : ((this._queryFeatureSetId =
                            t.stylesheet.indoor.floorplanFeaturesetId),
                          (this._buildingEntryFeatureSetId =
                            t.stylesheet.indoor.buildingFeaturesetId),
                          (this._scope = t.scope)));
                  }),
                    this._queryFeatureSetId &&
                      this._buildingEntryFeatureSetId &&
                      this._map.addInteraction("mbx-indoor-buildingclick", {
                        type: "click",
                        target: {
                          featuresetId: this._buildingEntryFeatureSetId,
                          importId: this._scope,
                        },
                        handler: (t) => (
                          t.feature &&
                            t.feature.properties.floorplan &&
                            this.selectFloorplan(
                              t.feature.properties.floorplan,
                            ),
                          !0
                        ),
                      }),
                    this._checkFloorplanVisible());
                }
                _onMove() {
                  this._checkFloorplanVisible();
                }
                _checkFloorplanVisible() {
                  if (!this._queryFeatureSetId || !this._map.isStyleLoaded())
                    return;
                  const t = () => {
                    ((this._indoorData = void 0),
                      (this._selectedFloorplan = void 0),
                      this._map.setConfigProperty(
                        this._scope,
                        "mbx-indoor-underground",
                        !1,
                      ),
                      this._map.setConfigProperty(
                        this._scope,
                        "mbx-indoor-active-floorplans",
                        ["literal", []],
                      ),
                      this.fire(new r.A("floorplangone")));
                  };
                  if (this._map.transform.zoom < 13) return void t();
                  const s = {
                      target: {
                        featuresetId: this._queryFeatureSetId,
                        importId: this._scope,
                      },
                    },
                    h = this._map.transform.width,
                    p = this._map.transform.height,
                    g = h * (2 / 3),
                    x = p * (2 / 3),
                    w = 0.5 * (h - g),
                    S = 0.5 * (p - x),
                    C = [new r.P(w, S), new r.P(w + g, S + x)],
                    D = this._map.queryRenderedFeatures(C, s);
                  D.length > 0
                    ? (this._selectedFloorplan &&
                        D[0].properties.id ===
                          this._selectedFloorplan.properties.id) ||
                      ((this._selectedFloorplan = D[0]),
                      this._floorplanSelected())
                    : t();
                }
                _floorplanSelected() {
                  ((this._indoorData = JSON.parse(
                    this._selectedFloorplan.properties["indoor-data"],
                  )),
                    (this._indoorData.id =
                      this._selectedFloorplan.properties.id),
                    (this._floorplanStates[this._indoorData.id] =
                      this._floorplanStates[this._indoorData.id] || {}),
                    this._map.setConfigProperty(
                      this._scope,
                      "mbx-indoor-active-floorplans",
                      ["literal", [this._indoorData.id]],
                    ));
                  const t =
                      this._floorplanStates[this._indoorData.id]
                        .selectedBuilding,
                    s = t
                      ? this._indoorData.buildings.find((w) => w.id === t)
                      : this._indoorData.buildings.length > 0
                        ? this._indoorData.buildings[0]
                        : null,
                    h =
                      this._floorplanStates[this._indoorData.id].selectedLevel,
                    p = this._indoorData.levels.find((w) => w.id === h),
                    g = this._indoorData.levels.find(
                      (w) =>
                        !(!s || !s.levels) &&
                        Number(w.levelOrder) === 0 &&
                        s.levels.includes(w.id),
                    ),
                    x = p ? p.id : g ? g.id : void 0;
                  (this.fire(
                    new r.A("floorplanselected", {
                      buildings: this._indoorData.buildings,
                      levels: this._indoorData.levels,
                      selectedLevelId: x,
                    }),
                  ),
                    s && this._buildingSelected(s, !1),
                    x && this._levelSelected(x));
                }
                _buildingSelected(t, s) {
                  if (!t || !t.id)
                    return void console.warn(
                      "IndoorManager: Building or building id is undefined",
                    );
                  (s &&
                    t.extent &&
                    this._map.fitBounds(t.extent, {
                      pitch: this._map.getPitch(),
                      bearing: this._map.getBearing(),
                    }),
                    (this._floorplanStates[
                      this._indoorData.id
                    ].selectedBuilding = t ? t.id : void 0));
                  const h = this._indoorData.levels.filter((p) =>
                    t.levels.includes(p.id),
                  );
                  this.fire(
                    new r.A("buildingselected", {
                      buildingId: t.id,
                      levels: h,
                    }),
                  );
                }
                _levelSelected(t) {
                  const s = this._indoorData.levels.find((h) => h.id === t);
                  s
                    ? (this._updateLevels(s, !0),
                      this.fire(new r.A("levelselected", { levelId: s.id })))
                    : console.warn(
                        `IndoorManager: Level with ID ${t} not found in the current floorplan.`,
                      );
                }
                _updateLevels(t, s) {
                  if (!t || !t.id)
                    throw new Error(
                      "IndoorManager: Selected level or level ID is undefined",
                    );
                  function h(C) {
                    const D = C.indexOf("/floor/");
                    if (D === -1) return C;
                    const L = D + 7,
                      z = C.indexOf("/", L);
                    return z === -1 ? C.slice(L) : C.slice(L, z);
                  }
                  this._floorplanStates[this._indoorData.id].selectedLevel =
                    t.id;
                  const p = [],
                    g = {},
                    x = {},
                    w = {},
                    S = {};
                  for (const C of this._indoorData.levels) {
                    if (
                      (p.push(C.id),
                      (g[C.id] =
                        C.levelOrder >= 0
                          ? 3 * Math.abs(C.levelOrder + 1)
                          : 3 * Math.abs(C.levelOrder)),
                      (x[C.id] = C.levelOrder >= 0 ? 3 * C.levelOrder : 0),
                      this.mergeFloors)
                    ) {
                      const D = h(t.id),
                        L = h(C.id);
                      w[C.id] = L === D ? "true" : "false";
                    } else w[C.id] = C.id === t.id ? "true" : "false";
                    S[C.id] = C.levelOrder < t.levelOrder ? "true" : "false";
                  }
                  (this._map.setConfigProperty(
                    this._scope,
                    "mbx-indoor-loaded-levels",
                    ["literal", p],
                  ),
                    this._map.setConfigProperty(
                      this._scope,
                      "mbx-indoor-level-height",
                      ["literal", g],
                    ),
                    this._map.setConfigProperty(
                      this._scope,
                      "mbx-indoor-level-base",
                      ["literal", x],
                    ),
                    this._map.setConfigProperty(
                      this._scope,
                      "mbx-indoor-level-selected",
                      ["literal", w],
                    ),
                    this._map.setConfigProperty(
                      this._scope,
                      "mbx-indoor-level-overlapped",
                      ["literal", S],
                    ),
                    this._map.setConfigProperty(
                      this._scope,
                      "mbx-indoor-underground",
                      t.levelOrder < 0,
                    ));
                }
                selectFloorplan(t) {
                  const s = {
                      target: {
                        featuresetId: this._queryFeatureSetId,
                        importId: this._scope,
                      },
                    },
                    h = [
                      new r.P(0, 0),
                      new r.P(
                        this._map.transform.width,
                        this._map.transform.height,
                      ),
                    ],
                    p = this._map.queryRenderedFeatures(h, s);
                  if (p.length > 0) {
                    for (const g of p)
                      if (JSON.parse(g.properties["indoor-data"]).id === t) {
                        ((this._selectedFloorplan = g),
                          this._floorplanSelected());
                        break;
                      }
                  }
                }
                selectBuilding(t) {
                  const s = this._indoorData.buildings.find((h) => h.id === t);
                  this._buildingSelected(s, !0);
                }
                selectLevel(t) {
                  this._levelSelected(t);
                }
              }
              function m_(c) {
                if (!c.metadata || !c.metadata.content_area) return;
                const t = r.q.devicePixelRatio,
                  {
                    left: s,
                    top: h,
                    width: p,
                    height: g,
                  } = c.metadata.content_area,
                  x = s * t,
                  w = h * t;
                return [x, w, x + p * t, w + g * t];
              }
              function Mp(c) {
                if (c)
                  return c.map(([t, s]) => [
                    t * r.q.devicePixelRatio,
                    s * r.q.devicePixelRatio,
                  ]);
              }
              class Cp {
                constructor(t, s, h) {
                  ((this.id = t),
                    (this.scope = s),
                    (this.sourceCache = h),
                    (this.pendingRequests = new Set()),
                    (this.missingRequests = new Set()));
                }
                addPendingRequest(t) {
                  this.missingRequests.has(t.name) ||
                    this.pendingRequests.has(t.name) ||
                    this.pendingRequests.add(t.name);
                }
                hasPendingRequests() {
                  return this.pendingRequests.size > 0;
                }
                resolvePendingRequests() {
                  const t = new Map();
                  if (!this.sourceCache.loaded()) return t;
                  const s = this.sourceCache.getVisibleCoordinates();
                  if (s.length === 0) return t;
                  const h = this.sourceCache.getSource();
                  if (!(h instanceof Po)) return t;
                  const p = s.map((x) => this.sourceCache.getTile(x)),
                    g = h.getImages(p, Array.from(this.pendingRequests));
                  for (const [x, w] of g)
                    (t.set(r.I.from({ name: x, iconsetId: this.id }), w),
                      this.pendingRequests.delete(x));
                  for (const x of this.pendingRequests)
                    this.missingRequests.add(x);
                  return (this.pendingRequests.clear(), t);
                }
              }
              const Ta = (c, t) =>
                  he(c, t && t.filter((s) => s.identifier !== "source.canvas")),
                fd = r.aF(Ei, [
                  "addLayer",
                  "removeLayer",
                  "setLights",
                  "setPaintProperty",
                  "setLayoutProperty",
                  "setSlot",
                  "setFilter",
                  "addSource",
                  "removeSource",
                  "setLayerZoomRange",
                  "setLight",
                  "setTransition",
                  "setGeoJSONSourceData",
                  "setTerrain",
                  "setFog",
                  "setSnow",
                  "setRain",
                  "setProjection",
                  "setCamera",
                  "addImport",
                  "removeImport",
                  "updateImport",
                  "addIconset",
                  "removeIconset",
                ]),
                Pp = r.aF(Ei, [
                  "setCenter",
                  "setZoom",
                  "setBearing",
                  "setPitch",
                ]),
                Nh = new Set(["background", "sky", "slot", "custom"]),
                pd = { version: 8, layers: [], sources: {} },
                md = { duration: 300, delay: 0 };
              class Er extends r.E {
                constructor(t, s = {}) {
                  (super(),
                    (this.map = t),
                    (this.scope = s.scope || ""),
                    (this.globalId = null),
                    (this.fragments = []),
                    (this.importDepth = s.importDepth || 0),
                    (this.importsCache = s.importsCache || new Map()),
                    (this.resolvedImports = s.resolvedImports || new Set()),
                    (this.transition = r.h({}, md)),
                    (this._buildingIndex = new Tp(this)),
                    (this.crossTileSymbolIndex = new Gr()),
                    (this._mergedOrder = []),
                    (this._drapedFirstOrder = []),
                    (this._mergedLayers = {}),
                    (this._mergedSourceCaches = {}),
                    (this._mergedOtherSourceCaches = {}),
                    (this._mergedSymbolSourceCaches = {}),
                    (this._clipLayerPresent = !1),
                    (this._has3DLayers = !1),
                    (this._hasCircleLayers = !1),
                    (this._hasSymbolLayers = !1),
                    (this._changes = s.styleChanges || new Gn()),
                    (this.dispatcher = s.dispatcher
                      ? s.dispatcher
                      : new r.D(r.c$(), this)),
                    s.imageManager
                      ? (this.imageManager = s.imageManager)
                      : ((this.imageManager = new To(this.map._spriteFormat)),
                        this.imageManager.setEventedParent(this)),
                    this.imageManager.addScope(this.scope),
                    (this.glyphManager = s.glyphManager
                      ? s.glyphManager
                      : new r.d0(
                          t._requestManager,
                          s.localFontFamily
                            ? r.d1.all
                            : s.localIdeographFontFamily
                              ? r.d1.ideographs
                              : r.d1.none,
                          s.localFontFamily || s.localIdeographFontFamily,
                        )),
                    s.modelManager
                      ? (this.modelManager = s.modelManager)
                      : ((this.modelManager = new Ap(t._requestManager)),
                        this.modelManager.setEventedParent(this)),
                    (this._layers = {}),
                    (this._sourceCaches = {}),
                    (this._otherSourceCaches = {}),
                    (this._symbolSourceCaches = {}),
                    (this._loaded = !1),
                    (this._precompileDone = !1),
                    (this._shouldPrecompile = !1),
                    (this._availableImages = []),
                    (this._availableModels = {}),
                    (this._order = []),
                    (this._markersNeedUpdate = !1),
                    (this.options = s.configOptions
                      ? s.configOptions
                      : new Map()),
                    (this._configDependentLayers = s.configDependentLayers
                      ? s.configDependentLayers
                      : new Set()),
                    (this._config = s.config),
                    (this._styleColorTheme = {
                      lut: null,
                      lutLoading: !1,
                      lutLoadingCorrelationID: 0,
                      colorTheme: null,
                      colorThemeOverride: s.colorThemeOverride,
                    }),
                    (this._styleColorThemeForScope = {}),
                    (this._initialConfig = s.initialConfig),
                    this.dispatcher.broadcast("setReferrer", r.d2()));
                  const h = this;
                  ((this._rtlTextPluginCallback =
                    Er.registerForPluginStateChange((p) => {
                      h.dispatcher.broadcast(
                        "syncRTLPluginState",
                        {
                          pluginStatus: p.pluginStatus,
                          pluginURL: p.pluginURL,
                        },
                        (g, x) => {
                          if ((r.d3(g), x && x.every((w) => w)))
                            for (const w in h._sourceCaches) {
                              const S = h._sourceCaches[w],
                                C = S.getSource().type;
                              (C !== "vector" && C !== "geojson") || S.reload();
                            }
                        },
                      );
                    })),
                    this.on("data", (p) => {
                      if (
                        p.dataType !== "source" ||
                        p.sourceDataType !== "metadata"
                      )
                        return;
                      const g = this.getOwnSource(p.sourceId);
                      if (g && g.vectorLayerIds)
                        for (const x in this._layers) {
                          const w = this._layers[x];
                          w.source === g.id && this._validateLayer(w);
                        }
                    }));
                }
                load(t) {
                  return t
                    ? (typeof t == "string"
                        ? this.loadURL(t)
                        : this.loadJSON(t),
                      this)
                    : this;
                }
                _getGlobalId(t) {
                  if (!t) return null;
                  if (typeof t == "string") {
                    if (r.j(t)) return t;
                    const s = r.d4(t);
                    if (!s.startsWith("http"))
                      try {
                        return new URL(s, location.href).toString();
                      } catch {
                        return s;
                      }
                    return s;
                  }
                  return `json://${r.d5(JSON.stringify(t))}`;
                }
                _diffStyle(t, s, h) {
                  this.globalId = this._getGlobalId(t);
                  const p = (g, x) => {
                    try {
                      x(null, this.setState(g, h));
                    } catch (w) {
                      x(w, !1);
                    }
                  };
                  if (typeof t == "string") {
                    const g = this.map._requestManager.normalizeStyleURL(t),
                      x = this.map._requestManager.transformRequest(
                        g,
                        r.R.Style,
                      );
                    r.n(x, (w, S) => {
                      w ? this.fire(new r.z(w)) : S && p(S, s);
                    });
                  } else typeof t == "object" && p(t, s);
                }
                loadURL(t, s = {}) {
                  this.fire(new r.A("dataloading", { dataType: "style" }));
                  const h =
                    typeof s.validate == "boolean" ? s.validate : !r.j(t);
                  ((this.globalId = this._getGlobalId(t)),
                    (t = this.map._requestManager.normalizeStyleURL(
                      t,
                      s.accessToken,
                    )),
                    this.resolvedImports.add(t));
                  const p = this.importsCache.get(t);
                  if (p) return this._load(p, h);
                  const g = this.map._requestManager.transformRequest(
                    t,
                    r.R.Style,
                  );
                  this._request = r.n(g, (x, w) => {
                    if (((this._request = null), x)) this.fire(new r.z(x));
                    else if (w)
                      return (this.importsCache.set(t, w), this._load(w, h));
                  });
                }
                loadJSON(t, s = {}) {
                  (this.fire(new r.A("dataloading", { dataType: "style" })),
                    (this.globalId = this._getGlobalId(t)),
                    (this._request = r.q.frame(() => {
                      ((this._request = null),
                        this._load(t, s.validate !== !1));
                    })));
                }
                loadEmpty() {
                  (this.fire(new r.A("dataloading", { dataType: "style" })),
                    this._load(pd, !1));
                }
                _loadImports(t, s, h) {
                  if (this.importDepth >= 4)
                    return (
                      r.w("Style doesn't support nesting deeper than 5"),
                      Promise.resolve()
                    );
                  const p = [];
                  for (const g of t) {
                    const x = this._createFragmentStyle(g),
                      w = new Promise((D) => {
                        (x.once("style.import.load", D), x.once("error", D));
                      }).then(() => this.mergeAll());
                    if ((p.push(w), this.resolvedImports.has(g.url))) {
                      x.loadEmpty();
                      continue;
                    }
                    const S = g.data || this.importsCache.get(g.url);
                    S
                      ? (x.loadJSON(S, { validate: s }),
                        this._isInternalStyle(S) && (x.globalId = null))
                      : g.url
                        ? x.loadURL(g.url, { validate: s })
                        : x.loadEmpty();
                    const C = { style: x, id: g.id, config: g.config };
                    if (h) {
                      const D = this.fragments.findIndex(
                        ({ id: L }) => L === h,
                      );
                      this.fragments = this.fragments
                        .slice(0, D)
                        .concat(C)
                        .concat(this.fragments.slice(D));
                    } else this.fragments.push(C);
                  }
                  return Promise.allSettled(p);
                }
                getImportGlobalIds(t = this, s = new Set()) {
                  for (const h of t.fragments)
                    (h.style.globalId && s.add(h.style.globalId),
                      this.getImportGlobalIds(h.style, s));
                  return [...s.values()];
                }
                _createFragmentStyle(t) {
                  const s = this.scope ? r.C(t.id, this.scope) : t.id;
                  let h;
                  const p = this._initialConfig && this._initialConfig[s];
                  (t.config || p) && (h = r.h({}, t.config, p));
                  const g = new Er(this.map, {
                    scope: s,
                    styleChanges: this._changes,
                    importDepth: this.importDepth + 1,
                    importsCache: this.importsCache,
                    resolvedImports: new Set(this.resolvedImports),
                    dispatcher: this.dispatcher,
                    imageManager: this.imageManager,
                    glyphManager: this.glyphManager,
                    modelManager: this.modelManager,
                    config: h,
                    configOptions: this.options,
                    colorThemeOverride: t["color-theme"],
                    configDependentLayers: this._configDependentLayers,
                  });
                  return (g.setEventedParent(this.map, { style: g }), g);
                }
                _reloadImports() {
                  (this.mergeAll(),
                    this._updateMapProjection(),
                    this.updateConfigDependencies(),
                    this.map._triggerCameraUpdate(this.camera),
                    this.dispatcher.broadcast("setLayers", {
                      layers: this._serializeLayers(this._order),
                      scope: this.scope,
                      options: this.options,
                    }),
                    (this._shouldPrecompile =
                      this.map._precompilePrograms && this.isRootStyle()));
                }
                _isInternalStyle(t) {
                  return (
                    this.isRootStyle() &&
                    (t.fragment || (!!t.schema && t.fragment !== !1))
                  );
                }
                _load(t, s) {
                  const h = t.indoor ? ao(t.schema) : t.schema;
                  if (this._isInternalStyle(t)) {
                    const x = r.h({}, pd, {
                      imports: [{ id: "basemap", data: t, url: "" }],
                    });
                    return void this._load(x, s);
                  }
                  if (
                    (this.updateConfig(this._config, h), s && Ta(this, Yr(t)))
                  )
                    return;
                  ((this._loaded = !0), (this.stylesheet = r.d6(t)));
                  const p = () => {
                    for (const C in t.sources)
                      this.addSource(C, t.sources[C], {
                        validate: !1,
                        isInitialLoad: !0,
                      });
                    if (t.iconsets)
                      for (const C in t.iconsets)
                        this.addIconset(C, t.iconsets[C]);
                    (t.sprite
                      ? this._loadIconset(t.sprite)
                      : (this.imageManager.setLoaded(!0, this.scope),
                        this.dispatcher.broadcast("spriteLoaded", {
                          scope: this.scope,
                          isLoaded: !0,
                        })),
                      this.setGlyphsUrl(t.glyphs));
                    const x = dc(this.stylesheet.layers);
                    if (
                      ((this._order = x.map((C) => C.id)),
                      this.stylesheet.light &&
                        r.w(
                          "The `light` root property is deprecated, prefer using `lights` with `flat` light type instead.",
                        ),
                      this.stylesheet.lights)
                    )
                      if (
                        this.stylesheet.lights.length === 1 &&
                        this.stylesheet.lights[0].type === "flat"
                      ) {
                        const C = this.stylesheet.lights[0];
                        this.light = new ke(C.properties, C.id);
                      } else this.setLights(this.stylesheet.lights);
                    (this.light || (this.light = new ke(this.stylesheet.light)),
                      (this._layers = {}));
                    for (const C of x) {
                      const D = r.db(
                        C,
                        this.scope,
                        this._styleColorTheme.lut,
                        this.options,
                      );
                      (D.configDependencies.size !== 0 &&
                        this._configDependentLayers.add(D.fqid),
                        D.setEventedParent(this, { layer: { id: D.id } }),
                        (this._layers[D.id] = D));
                      const L = this.getOwnLayerSourceCache(D),
                        z =
                          !!this.directionalLight &&
                          this.directionalLight.shadowsEnabled();
                      L && D.canCastShadows() && z && (L.castsShadows = !0);
                    }
                    (this.stylesheet.featuresets &&
                      this.setFeaturesetSelectors(this.stylesheet.featuresets),
                      this.stylesheet.models &&
                        this.addModelURLs(this.stylesheet.models));
                    const w = this.stylesheet.terrain;
                    (w &&
                      (this.checkCanvasFingerprintNoise(),
                      this.disableElevatedTerrain ||
                        this.terrainSetForDrapingOnly() ||
                        this._createTerrain(w, 1)),
                      this.stylesheet.fog &&
                        this._createFog(this.stylesheet.fog),
                      this.stylesheet.snow &&
                        this._createSnow(this.stylesheet.snow),
                      this.stylesheet.rain &&
                        this._createRain(this.stylesheet.rain),
                      this.stylesheet.transition &&
                        this.setTransition(this.stylesheet.transition),
                      this.fire(new r.A("data", { dataType: "style" })));
                    const S = this.isRootStyle();
                    t.imports
                      ? this._loadImports(t.imports, s)
                          .then(() => {
                            (this._reloadImports(),
                              this.fire(
                                new r.A(S ? "style.load" : "style.import.load"),
                              ));
                          })
                          .catch((C) => {
                            (this.fire(
                              new r.z(new Error("Failed to load imports", C)),
                            ),
                              this.fire(
                                new r.A(S ? "style.load" : "style.import.load"),
                              ));
                          })
                      : (this._reloadImports(),
                        this.fire(
                          new r.A(S ? "style.load" : "style.import.load"),
                        ));
                  };
                  this._styleColorTheme.colorTheme =
                    this.stylesheet["color-theme"];
                  const g = this._styleColorTheme.colorThemeOverride
                    ? this._styleColorTheme.colorThemeOverride
                    : this._styleColorTheme.colorTheme;
                  if (g) {
                    const x = this._evaluateColorThemeData(g);
                    this._loadColorTheme(x)
                      .then(() => {
                        p();
                      })
                      .catch((w) => {
                        (r.w(
                          `Couldn't load color theme from the stylesheet: ${w}`,
                        ),
                          p());
                      });
                  } else ((this._styleColorTheme.lut = null), p());
                }
                isRootStyle() {
                  return this.importDepth === 0;
                }
                mergeAll() {
                  let t, s, h, p, g, x, w, S, C, D;
                  const L = {};
                  (this.terrain &&
                    this.terrain.scope !== this.scope &&
                    delete this.terrain,
                    this.forEachFragmentStyle((z) => {
                      if (z.stylesheet) {
                        if (
                          (z.light != null && (t = z.light),
                          z.stylesheet.lights)
                        )
                          for (const O of z.stylesheet.lights)
                            (O.type === "ambient" &&
                              z.ambientLight != null &&
                              (s = z.ambientLight),
                              O.type === "directional" &&
                                z.directionalLight != null &&
                                (h = z.directionalLight));
                        ((p = this._prioritizeTerrain(
                          p,
                          z.terrain,
                          z.stylesheet.terrain,
                        )),
                          z.stylesheet.fog && z.fog != null && (g = z.fog),
                          z.stylesheet.snow && z.snow != null && (x = z.snow),
                          z.stylesheet.rain && z.rain != null && (w = z.rain),
                          z.stylesheet.camera != null &&
                            (D = z.stylesheet.camera),
                          z.stylesheet.projection != null &&
                            (S = z.stylesheet.projection),
                          z.stylesheet.transition != null &&
                            (C = z.stylesheet.transition),
                          (L[z.scope] = z._styleColorTheme));
                      }
                    }),
                    (this.light = t),
                    (this.ambientLight = s),
                    (this.directionalLight = h),
                    (this.fog = g),
                    (this.snow = x),
                    (this.rain = w),
                    (this._styleColorThemeForScope = L),
                    p === null ? delete this.terrain : (this.terrain = p),
                    (this.camera = D || { "camera-projection": "perspective" }),
                    (this.projection = S || { name: "mercator" }),
                    (this.transition = r.h({}, md, C)),
                    this.mergeSources(),
                    this.mergeLayers());
                }
                forEachFragmentStyle(t) {
                  const s = (h) => {
                    for (const p of h.fragments) s(p.style);
                    t(h);
                  };
                  s(this);
                }
                _prioritizeTerrain(t, s, h) {
                  const p = t && t.drapeRenderMode === 0;
                  return h === null
                    ? s && s.drapeRenderMode === 0
                      ? s
                      : p
                        ? t
                        : null
                    : s != null && (!t || p || (s && s.drapeRenderMode === 1))
                      ? s
                      : t;
                }
                mergeTerrain() {
                  let t;
                  (this.terrain &&
                    this.terrain.scope !== this.scope &&
                    delete this.terrain,
                    this.forEachFragmentStyle((s) => {
                      t = this._prioritizeTerrain(
                        t,
                        s.terrain,
                        s.stylesheet.terrain,
                      );
                    }),
                    t === null ? delete this.terrain : (this.terrain = t));
                }
                mergeProjection() {
                  let t;
                  (this.forEachFragmentStyle((s) => {
                    s.stylesheet.projection != null &&
                      (t = s.stylesheet.projection);
                  }),
                    (this.projection = t || { name: "mercator" }));
                }
                mergeSources() {
                  const t = {},
                    s = {},
                    h = {};
                  (this.forEachFragmentStyle((p) => {
                    for (const g in p._sourceCaches) {
                      const x = r.C(g, p.scope);
                      t[x] = p._sourceCaches[g];
                    }
                    for (const g in p._otherSourceCaches) {
                      const x = r.C(g, p.scope);
                      s[x] = p._otherSourceCaches[g];
                    }
                    for (const g in p._symbolSourceCaches) {
                      const x = r.C(g, p.scope);
                      h[x] = p._symbolSourceCaches[g];
                    }
                  }),
                    (this._mergedSourceCaches = t),
                    (this._mergedOtherSourceCaches = s),
                    (this._mergedSymbolSourceCaches = h));
                }
                mergeLayers() {
                  const t = {},
                    s = [],
                    h = {};
                  ((this._mergedSlots = []),
                    (this._has3DLayers = !1),
                    (this._hasCircleLayers = !1),
                    (this._hasSymbolLayers = !1),
                    this.forEachFragmentStyle((g) => {
                      for (const x of g._order) {
                        const w = g._layers[x];
                        if (w.type === "slot") {
                          const S = r.d7(x);
                          if (t[S]) continue;
                          t[S] = [];
                        }
                        w.slot && t[w.slot] ? t[w.slot].push(w) : s.push(w);
                      }
                    }),
                    (this._mergedOrder = []));
                  const p = (g = []) => {
                    for (const x of g)
                      if (x.type === "slot") {
                        const w = r.d7(x.id);
                        (t[w] && p(t[w]), this._mergedSlots.push(w));
                      } else {
                        const w = r.C(x.id, x.scope);
                        (this._mergedOrder.push(w),
                          (h[w] = x),
                          x.is3D(!!this.terrain) && (this._has3DLayers = !0),
                          x.type === "circle" && (this._hasCircleLayers = !0),
                          x.type === "symbol" && (this._hasSymbolLayers = !0),
                          x.type === "clip" && (this._clipLayerPresent = !0));
                      }
                  };
                  (p(s),
                    this._mergedOrder.sort((g, x) => {
                      const w = h[g],
                        S = h[x];
                      return w.hasInitialOcclusionOpacityProperties
                        ? S.is3D(!!this.terrain)
                          ? 1
                          : 0
                        : w.is3D(!!this.terrain) &&
                            S.hasInitialOcclusionOpacityProperties
                          ? -1
                          : 0;
                    }),
                    (this._mergedLayers = h),
                    this.updateDrapeFirstLayers(),
                    this._buildingIndex.processLayersChanged());
                }
                terrainSetForDrapingOnly() {
                  return !!this.terrain && this.terrain.drapeRenderMode === 0;
                }
                getCamera() {
                  return this.stylesheet.camera;
                }
                setCamera(t) {
                  return (
                    (this.stylesheet.camera = r.h(
                      {},
                      this.stylesheet.camera,
                      t,
                    )),
                    (this.camera = this.stylesheet.camera),
                    this
                  );
                }
                _evaluateColorThemeData(t) {
                  return t.data
                    ? (function (s, h, p, g) {
                        const x = r.h({}, h);
                        for (const S of Object.keys(r.a5.colorTheme))
                          x[S] === void 0 &&
                            (x[S] = r.a5.colorTheme[S].default);
                        const w = new r.a6(Bh, s, new Map(p));
                        return (
                          w.setTransitionOrValue(x, p),
                          w
                            .untransitioned()
                            .possiblyEvaluate(
                              new r.aa(0, { worldview: void 0 }),
                            )
                        );
                      })(this.scope, t, this.options).get("data")
                    : null;
                }
                _loadColorTheme(t) {
                  ((this._styleColorTheme.lutLoading = !0),
                    (this._styleColorTheme.lutLoadingCorrelationID += 1));
                  const s = this._styleColorTheme.lutLoadingCorrelationID;
                  return new Promise((h, p) => {
                    const g = "data:image/png;base64,";
                    if (!t || t.length === 0)
                      return (
                        (this._styleColorTheme.lut = null),
                        (this._styleColorTheme.lutLoading = !1),
                        void h()
                      );
                    let x = t;
                    x.startsWith(g) || (x = g + x);
                    const w = r.I.from("mapbox-reserved-lut"),
                      S = new Image();
                    ((S.src = x),
                      (S.onerror = () => {
                        ((this._styleColorTheme.lutLoading = !1),
                          p(new Error("Failed to load image data")));
                      }),
                      (S.onload = () => {
                        if (this._styleColorTheme.lutLoadingCorrelationID !== s)
                          return void h();
                        this._styleColorTheme.lutLoading = !1;
                        const {
                          width: C,
                          height: D,
                          data: L,
                        } = r.q.getImageData(S);
                        if (D > 32)
                          return void p(
                            new Error(
                              "The height of the image must be less than or equal to 32 pixels.",
                            ),
                          );
                        if (C !== D * D)
                          return void p(
                            new Error(
                              "The width of the image must be equal to the height squared.",
                            ),
                          );
                        (this.getImage(w) && this.removeImage(w),
                          this.addImage(w, {
                            data: new r.r({ width: C, height: D }, L),
                            pixelRatio: 1,
                            sdf: !1,
                            usvg: !1,
                            version: 0,
                          }));
                        const z = this.imageManager.getImage(w, this.scope);
                        z
                          ? ((this._styleColorTheme.lut = {
                              image: z.data,
                              data: t,
                            }),
                            h())
                          : p(new Error("Missing LUT image."));
                      }));
                  });
                }
                getLut(t) {
                  const s = this._styleColorThemeForScope[t];
                  return s ? s.lut : null;
                }
                setProjection(t) {
                  (t
                    ? (this.stylesheet.projection = t)
                    : delete this.stylesheet.projection,
                    this.mergeProjection(),
                    this._updateMapProjection());
                }
                applyProjectionUpdate() {
                  this._loaded &&
                    (this.dispatcher.broadcast(
                      "setProjection",
                      this.map.transform.projectionOptions,
                    ),
                    this.map.transform.projection.requiresDraping
                      ? ((this.getTerrain() || this.stylesheet.terrain) &&
                          !this.disableElevatedTerrain) ||
                        this.setTerrainForDraping()
                      : this.terrainSetForDrapingOnly() &&
                        this.setTerrain(null, 0));
                }
                _updateMapProjection() {
                  this.isRootStyle() &&
                    (this.map._useExplicitProjection
                      ? this.applyProjectionUpdate()
                      : this.map._prioritizeAndUpdateProjection(
                          null,
                          this.projection,
                        ));
                }
                _loadSprite(t) {
                  this._spriteRequest = (function (s, h, p) {
                    let g, x, w;
                    const S = r.q.devicePixelRatio > 1 ? "@2x" : "";
                    let C = r.n(
                        h.transformRequest(
                          h.normalizeSpriteURL(s, S, ".json"),
                          r.R.SpriteJSON,
                        ),
                        (z, O) => {
                          ((C = null), w || ((w = z), (g = O), L()));
                        },
                      ),
                      D = r.o(
                        h.transformRequest(
                          h.normalizeSpriteURL(s, S, ".png"),
                          r.R.SpriteImage,
                        ),
                        (z, O) => {
                          ((D = null), w || ((w = z), (x = O), L()));
                        },
                      );
                    function L() {
                      if (w) p(w);
                      else if (g && x) {
                        const z = r.q.getImageData(x),
                          O = {};
                        for (const G in g) {
                          const {
                              width: U,
                              height: $,
                              x: Z,
                              y: Y,
                              sdf: ie,
                              pixelRatio: ae,
                              stretchX: pe,
                              stretchY: ue,
                              content: ce,
                            } = g[G],
                            le = new r.r({ width: U, height: $ });
                          (r.r.copy(
                            z,
                            le,
                            { x: Z, y: Y },
                            { x: 0, y: 0 },
                            { width: U, height: $ },
                            null,
                          ),
                            (O[G] = {
                              data: le,
                              pixelRatio: ae,
                              sdf: ie,
                              stretchX: pe,
                              stretchY: ue,
                              content: ce,
                              usvg: !1,
                            }));
                        }
                        p(null, O);
                      }
                    }
                    return {
                      cancel() {
                        (C && (C.cancel(), (C = null)),
                          D && (D.cancel(), (D = null)));
                      },
                    };
                  })(t, this.map._requestManager, (s, h) => {
                    if (((this._spriteRequest = null), s))
                      this.fire(new r.z(s));
                    else if (h) {
                      const p = new Map();
                      for (const g in h) p.set(r.I.from(g), h[g]);
                      this.addImages(p);
                    }
                    (this.imageManager.setLoaded(!0, this.scope),
                      this.dispatcher.broadcast("spriteLoaded", {
                        scope: this.scope,
                        isLoaded: !0,
                      }),
                      this.fire(new r.A("data", { dataType: "style" })));
                  });
                }
                addIconset(t, s) {
                  if (s.type === "sprite") return void this._loadSprite(s.url);
                  const h = this.getOwnSourceCache(s.source);
                  if (!h)
                    return void this.fire(
                      new r.z(
                        new Error(
                          `Source "${s.source}" as specified by iconset "${t}" does not exist and cannot be used as an iconset source`,
                        ),
                      ),
                    );
                  const p = h.getSource();
                  if (p.type !== "raster-array")
                    return void this.fire(
                      new r.z(
                        new Error(
                          `Source "${s.source}" as specified by iconset "${t}" is not a "raster-array" source and cannot be used as an iconset source`,
                        ),
                      ),
                    );
                  p.partial = !1;
                  const g = new Cp(t, this.scope, h);
                  this.imageManager.addImageProvider(g, this.scope);
                }
                removeIconset(t) {
                  this.imageManager.removeImageProvider(t, this.scope);
                }
                _loadIconset(t) {
                  if (
                    (!r.j(t) && this.map._spriteFormat !== "icon_set") ||
                    this.map._spriteFormat === "raster"
                  )
                    return void this._loadSprite(t);
                  const s = this.map._spriteFormat === "auto";
                  var h, p;
                  this._spriteRequest =
                    ((p = (g, x) => {
                      if (((this._spriteRequest = null), g))
                        s ? this._loadSprite(t) : this.fire(new r.z(g));
                      else if (x) {
                        const w = new Map();
                        for (const S in x) w.set(r.I.from(S), x[S]);
                        this.addImages(w);
                      }
                      (this.imageManager.setLoaded(!0, this.scope),
                        this.dispatcher.broadcast("spriteLoaded", {
                          scope: this.scope,
                          isLoaded: !0,
                        }),
                        this.fire(new r.A("data", { dataType: "style" })));
                    }),
                    r.br(
                      (h = this.map._requestManager).transformRequest(
                        h.normalizeIconsetURL(t),
                        r.R.Iconset,
                      ),
                      (g, x) => {
                        if (g) return void p(g);
                        const w = {},
                          S = r.c_(new r.bq(x));
                        for (const C of S.icons) {
                          const D = {
                            version: 1,
                            pixelRatio: r.q.devicePixelRatio,
                            content: m_(C),
                            stretchX: C.metadata
                              ? Mp(C.metadata.stretch_x_areas)
                              : void 0,
                            stretchY: C.metadata
                              ? Mp(C.metadata.stretch_y_areas)
                              : void 0,
                            sdf: !1,
                            usvg: !0,
                            icon: C,
                          };
                          w[C.name] = D;
                        }
                        p(null, w);
                      },
                    ));
                }
                _validateLayer(t) {
                  const s = this.getOwnSource(t.source);
                  if (!s) return;
                  const h = t.sourceLayer;
                  h &&
                    (s.type === "geojson" ||
                      (s.vectorLayerIds &&
                        s.vectorLayerIds.indexOf(h) === -1)) &&
                    this.fire(
                      new r.z(
                        new Error(
                          `Source layer "${h}" does not exist on source "${s.id}" as specified by style layer "${t.id}"`,
                        ),
                      ),
                    );
                }
                loaded() {
                  if (
                    !this._loaded ||
                    Object.keys(this._changes.getUpdatedSourceCaches()).length
                  )
                    return !1;
                  for (const t in this._sourceCaches)
                    if (!this._sourceCaches[t].loaded()) return !1;
                  if (
                    !this.imageManager.isLoaded() ||
                    this.imageManager.hasPatternsInFlight() ||
                    !this.modelManager.isLoaded() ||
                    this._styleColorTheme.lutLoading
                  )
                    return !1;
                  for (const { style: t } of this.fragments)
                    if (!t.loaded()) return !1;
                  return !0;
                }
                _serializeImports() {
                  if (this.stylesheet.imports)
                    return this.stylesheet.imports.map((t, s) => {
                      const h = this.fragments[s];
                      return (
                        h && h.style && (t.data = h.style.serialize()),
                        t
                      );
                    });
                }
                _serializeSources() {
                  const t = {};
                  for (const s in this._sourceCaches) {
                    const h = this._sourceCaches[s].getSource();
                    t[h.id] || (t[h.id] = h.serialize());
                  }
                  return t;
                }
                _serializeLayers(t) {
                  const s = [];
                  for (const h of t) {
                    const p = this._layers[h];
                    p && p.type !== "custom" && s.push(p.serialize());
                  }
                  return s;
                }
                hasLightTransitions() {
                  return (
                    !(!this.light || !this.light.hasTransition()) ||
                    !(
                      !this.ambientLight || !this.ambientLight.hasTransition()
                    ) ||
                    !(
                      !this.directionalLight ||
                      !this.directionalLight.hasTransition()
                    )
                  );
                }
                hasFogTransition() {
                  return !!this.fog && this.fog.hasTransition();
                }
                hasSnowTransition() {
                  return !!this.snow && this.snow.hasTransition();
                }
                hasRainTransition() {
                  return !!this.rain && this.rain.hasTransition();
                }
                hasTransitions() {
                  if (
                    this.hasLightTransitions() ||
                    this.hasFogTransition() ||
                    this.hasSnowTransition() ||
                    this.hasRainTransition()
                  )
                    return !0;
                  for (const t in this._sourceCaches)
                    if (this._sourceCaches[t].hasTransition()) return !0;
                  for (const t in this._layers)
                    if (this._layers[t].hasTransition()) return !0;
                  return !1;
                }
                get order() {
                  return this.terrain
                    ? this._drapedFirstOrder
                    : this._mergedOrder;
                }
                _getOrder(t) {
                  return t ? this.order : this._mergedOrder;
                }
                isLayerDraped(t) {
                  return (
                    !!this.terrain && t.isDraped(this.getLayerSourceCache(t))
                  );
                }
                _checkLoaded() {
                  if (!this._loaded)
                    throw new Error("Style is not done loading");
                }
                _checkLayer(t) {
                  const s = this.getOwnLayer(t);
                  if (s) return s;
                  this.fire(
                    new r.z(
                      new Error(
                        `The layer '${t}' does not exist in the map's style.`,
                      ),
                    ),
                  );
                }
                _checkSource(t) {
                  const s = this.getOwnSource(t);
                  if (s) return s;
                  this.fire(
                    new r.z(
                      new Error(
                        `The source '${t}' does not exist in the map's style.`,
                      ),
                    ),
                  );
                }
                precompilePrograms(t, s) {
                  const h = this.map.painter;
                  if (h)
                    for (let p = t.minzoom || 0; p < (t.maxzoom || 25.5); p++) {
                      const g = t.getProgramIds();
                      if (g)
                        for (const x of g) {
                          const w = t.getDefaultProgramParams(
                            x,
                            s.zoom,
                            this._styleColorTheme.lut,
                          );
                          w &&
                            ((h.style = this),
                            this.fog &&
                              ((h._fogVisible = !0),
                              (w.overrideFog = !0),
                              h.getOrCreateProgram(x, w)),
                            (h._fogVisible = !1),
                            (w.overrideFog = !1),
                            h.getOrCreateProgram(x, w),
                            (this.stylesheet.terrain ||
                              (this.stylesheet.projection &&
                                this.stylesheet.projection.name === "globe")) &&
                              ((w.overrideRtt = !0),
                              h.getOrCreateProgram(x, w)));
                        }
                    }
                }
                update(t) {
                  if (!this._loaded) return;
                  (this.ambientLight && this.ambientLight.recalculate(t),
                    this.directionalLight &&
                      this.directionalLight.recalculate(t));
                  const s = this.calculateLightsBrightness();
                  ((t.brightness = s || 0),
                    s !== this._brightness &&
                      ((this._brightness = s),
                      this.dispatcher.broadcast("setBrightness", s)),
                    t.worldview !== this._worldview &&
                      ((this._worldview = t.worldview),
                      this.dispatcher.broadcast(
                        "setWorldview",
                        this._worldview,
                      )));
                  const h = this._changes.isDirty();
                  let p = !1;
                  if (this._changes.isDirty()) {
                    const w = this._changes.getLayerUpdatesByScope();
                    for (const S in w) {
                      const { updatedIds: C, removedIds: D } = w[S];
                      (C || D) && (this._updateWorkerLayers(S, C, D), (p = !0));
                    }
                    (this.updateSourceCaches(),
                      this._updateTilesForChangedImages(),
                      this.updateLayers(t),
                      this.light && this.light.updateTransitions(t),
                      this.ambientLight &&
                        this.ambientLight.updateTransitions(t),
                      this.directionalLight &&
                        this.directionalLight.updateTransitions(t),
                      this.fog && this.fog.updateTransitions(t),
                      this.snow && this.snow.updateTransitions(t),
                      this.rain && this.rain.updateTransitions(t),
                      this._changes.reset());
                  }
                  const g = {};
                  for (const w in this._mergedSourceCaches) {
                    const S = this._mergedSourceCaches[w];
                    ((g[w] = S.used), (S.used = !1), (S.tileCoverLift = 0));
                  }
                  for (const w of this._mergedOrder) {
                    const S = this._mergedLayers[w];
                    if (
                      (S.recalculate(t, this._availableImages),
                      !S.isHidden(t.zoom))
                    ) {
                      const C = this.getLayerSourceCache(S);
                      C &&
                        ((C.used = !0),
                        (C.tileCoverLift = Math.max(
                          C.tileCoverLift,
                          S.tileCoverLift(),
                        )));
                    }
                    !this._precompileDone &&
                      this._shouldPrecompile &&
                      ("requestIdleCallback" in window
                        ? requestIdleCallback(() => {
                            this.precompilePrograms(S, t);
                          })
                        : this.precompilePrograms(S, t));
                  }
                  (this._shouldPrecompile && (this._precompileDone = !0),
                    this.terrain && p && this.mergeLayers());
                  const x = this.imageManager.getPendingImageProviders();
                  for (const w of x) w.sourceCache.used = !0;
                  for (const w in g) {
                    const S = this._mergedSourceCaches[w];
                    g[w] !== S.used &&
                      S.getSource().fire(
                        new r.A("data", {
                          sourceDataType: "visibility",
                          dataType: "source",
                          sourceId: S.getSource().id,
                        }),
                      );
                  }
                  (this.light && this.light.recalculate(t),
                    this.terrain && this.terrain.recalculate(t),
                    this.fog && this.fog.recalculate(t),
                    this.snow && this.snow.recalculate(t),
                    this.rain && this.rain.recalculate(t),
                    (this.z = t.zoom),
                    this._markersNeedUpdate &&
                      (this._updateMarkersOpacity(),
                      (this._markersNeedUpdate = !1)),
                    this.imageManager.clearUpdatedImages(this.scope),
                    h && this.fire(new r.A("data", { dataType: "style" })));
                }
                updateImageProviders() {
                  const t = this.imageManager.getPendingImageProviders();
                  for (const s of t) {
                    const h = s.resolvePendingRequests(),
                      p = this.getFragmentStyle(s.scope);
                    p && p.addImages(h);
                  }
                }
                _updateTilesForChangedImages() {
                  const t = {};
                  for (const s in this._mergedSourceCaches) {
                    const h = this._mergedSourceCaches[s].getSource().scope;
                    ((t[h] = t[h] || this._changes.getUpdatedImages(h)),
                      t[h].length !== 0 &&
                        this._mergedSourceCaches[s].reloadTilesForDependencies(
                          ["icons", "patterns"],
                          t[h],
                        ));
                  }
                  for (const s in t) this._changes.resetUpdatedImages(s);
                }
                _updateWorkerLayers(t, s, h) {
                  const p = this.getFragmentStyle(t);
                  p &&
                    this.dispatcher.broadcast("updateLayers", {
                      layers: s ? p._serializeLayers(s) : [],
                      scope: t,
                      removedIds: h || [],
                      options: p.options,
                    });
                }
                setState(t, s) {
                  if ((this._checkLoaded(), Ta(this, Yr(t)))) return !1;
                  (t = r.d6(t)).layers = dc(t.layers);
                  const h = (function (x, w) {
                    if (!x) return [{ command: Ei.setStyle, args: [w] }];
                    let S = [];
                    try {
                      if (!r.bv(x.version, w.version))
                        return [{ command: Ei.setStyle, args: [w] }];
                      if (
                        (r.bv(x.center, w.center) ||
                          S.push({ command: Ei.setCenter, args: [w.center] }),
                        r.bv(x.zoom, w.zoom) ||
                          S.push({ command: Ei.setZoom, args: [w.zoom] }),
                        r.bv(x.bearing, w.bearing) ||
                          S.push({ command: Ei.setBearing, args: [w.bearing] }),
                        r.bv(x.pitch, w.pitch) ||
                          S.push({ command: Ei.setPitch, args: [w.pitch] }),
                        r.bv(x.sprite, w.sprite) ||
                          S.push({ command: Ei.setSprite, args: [w.sprite] }),
                        r.bv(x.glyphs, w.glyphs) ||
                          S.push({ command: Ei.setGlyphs, args: [w.glyphs] }),
                        r.bv(x.imports, w.imports) ||
                          (function (O = [], G = [], U) {
                            G = G || [];
                            const $ = (O = O || []).map(ma),
                              Z = G.map(ma),
                              Y = O.reduce(Do, {}),
                              ie = G.reduce(Do, {}),
                              ae = $.slice();
                            let pe, ue, ce, le;
                            for (pe = 0, ue = 0; pe < $.length; pe++)
                              ((ce = $[pe]),
                                ie.hasOwnProperty(ce)
                                  ? ue++
                                  : (U.push({
                                      command: Ei.removeImport,
                                      args: [ce],
                                    }),
                                    ae.splice(ae.indexOf(ce, ue), 1)));
                            for (pe = 0, ue = 0; pe < Z.length; pe++)
                              ((ce = Z[Z.length - 1 - pe]),
                                ae[ae.length - 1 - pe] !== ce &&
                                  (Y.hasOwnProperty(ce)
                                    ? (U.push({
                                        command: Ei.removeImport,
                                        args: [ce],
                                      }),
                                      ae.splice(
                                        ae.lastIndexOf(ce, ae.length - ue),
                                        1,
                                      ))
                                    : ue++,
                                  (le = ae[ae.length - pe]),
                                  U.push({
                                    command: Ei.addImport,
                                    args: [ie[ce], le],
                                  }),
                                  ae.splice(ae.length - pe, 0, ce)));
                            for (const me of G) {
                              const _e = Y[me.id];
                              _e &&
                                (delete _e.data,
                                r.bv(_e, me) ||
                                  U.push({
                                    command: Ei.updateImport,
                                    args: [me.id, me],
                                  }));
                            }
                          })(x.imports, w.imports, S),
                        r.bv(x.transition, w.transition) ||
                          S.push({
                            command: Ei.setTransition,
                            args: [w.transition],
                          }),
                        r.bv(x.light, w.light) ||
                          S.push({ command: Ei.setLight, args: [w.light] }),
                        r.bv(x.fog, w.fog) ||
                          S.push({ command: Ei.setFog, args: [w.fog] }),
                        r.bv(x.snow, w.snow) ||
                          S.push({ command: Ei.setSnow, args: [w.snow] }),
                        r.bv(x.rain, w.rain) ||
                          S.push({ command: Ei.setRain, args: [w.rain] }),
                        r.bv(x.projection, w.projection) ||
                          S.push({
                            command: Ei.setProjection,
                            args: [w.projection],
                          }),
                        r.bv(x.lights, w.lights) ||
                          S.push({ command: Ei.setLights, args: [w.lights] }),
                        r.bv(x.camera, w.camera) ||
                          S.push({ command: Ei.setCamera, args: [w.camera] }),
                        r.bv(x.iconsets, w.iconsets) ||
                          (function (O, G, U) {
                            let $;
                            for ($ in ((G = G || {}), (O = O || {})))
                              O.hasOwnProperty($) &&
                                (G.hasOwnProperty($) ||
                                  U.push({
                                    command: Ei.removeIconset,
                                    args: [$],
                                  }));
                            for ($ in G) {
                              if (!G.hasOwnProperty($)) continue;
                              const Z = G[$];
                              O.hasOwnProperty($)
                                ? r.bv(O[$], Z) ||
                                  (U.push({
                                    command: Ei.removeIconset,
                                    args: [$],
                                  }),
                                  U.push({
                                    command: Ei.addIconset,
                                    args: [$, Z],
                                  }))
                                : U.push({
                                    command: Ei.addIconset,
                                    args: [$, Z],
                                  });
                            }
                          })(x.iconsets, w.iconsets, S),
                        !r.bv(x["color-theme"], w["color-theme"]))
                      )
                        return [{ command: Ei.setStyle, args: [w] }];
                      const C = {},
                        D = [];
                      (function (O, G, U, $) {
                        let Z;
                        for (Z in ((G = G || {}), (O = O || {})))
                          O.hasOwnProperty(Z) &&
                            (G.hasOwnProperty(Z) || nl(Z, U, $));
                        for (Z in G) {
                          if (!G.hasOwnProperty(Z)) continue;
                          const Y = G[Z];
                          O.hasOwnProperty(Z)
                            ? r.bv(O[Z], Y) ||
                              (O[Z].type === "geojson" &&
                              Y.type === "geojson" &&
                              c_(O, G, Z)
                                ? U.push({
                                    command: Ei.setGeoJSONSourceData,
                                    args: [Z, Y.data],
                                  })
                                : fc(Z, G, U, $))
                            : Ch(Z, G, U);
                        }
                      })(x.sources, w.sources, D, C);
                      const L = [];
                      x.layers &&
                        x.layers.forEach((O) => {
                          O.source && C[O.source]
                            ? S.push({ command: Ei.removeLayer, args: [O.id] })
                            : L.push(O);
                        });
                      let z = x.terrain;
                      (z &&
                        C[z.source] &&
                        (S.push({ command: Ei.setTerrain, args: [void 0] }),
                        (z = void 0)),
                        (S = S.concat(D)),
                        r.bv(z, w.terrain) ||
                          S.push({ command: Ei.setTerrain, args: [w.terrain] }),
                        (function (O, G, U) {
                          G = G || [];
                          const $ = (O = O || []).map(ma),
                            Z = G.map(ma),
                            Y = O.reduce(Do, {}),
                            ie = G.reduce(Do, {}),
                            ae = $.slice(),
                            pe = Object.create(null);
                          let ue, ce, le, me, _e, De, ze;
                          for (ue = 0, ce = 0; ue < $.length; ue++)
                            ((le = $[ue]),
                              ie.hasOwnProperty(le)
                                ? ce++
                                : (U.push({
                                    command: Ei.removeLayer,
                                    args: [le],
                                  }),
                                  ae.splice(ae.indexOf(le, ce), 1)));
                          for (ue = 0, ce = 0; ue < Z.length; ue++)
                            ((le = Z[Z.length - 1 - ue]),
                              ae[ae.length - 1 - ue] !== le &&
                                (Y.hasOwnProperty(le)
                                  ? (U.push({
                                      command: Ei.removeLayer,
                                      args: [le],
                                    }),
                                    ae.splice(
                                      ae.lastIndexOf(le, ae.length - ce),
                                      1,
                                    ))
                                  : ce++,
                                (De = ae[ae.length - ue]),
                                U.push({
                                  command: Ei.addLayer,
                                  args: [ie[le], De],
                                }),
                                ae.splice(ae.length - ue, 0, le),
                                (pe[le] = !0)));
                          for (ue = 0; ue < Z.length; ue++)
                            if (
                              ((le = Z[ue]),
                              (me = Y[le]),
                              (_e = ie[le]),
                              !pe[le] && !r.bv(me, _e))
                            )
                              if (
                                r.bv(me.source, _e.source) &&
                                r.bv(me["source-layer"], _e["source-layer"]) &&
                                r.bv(me.type, _e.type)
                              ) {
                                for (ze in (pc(
                                  me.layout,
                                  _e.layout,
                                  U,
                                  le,
                                  null,
                                  Ei.setLayoutProperty,
                                ),
                                pc(
                                  me.paint,
                                  _e.paint,
                                  U,
                                  le,
                                  null,
                                  Ei.setPaintProperty,
                                ),
                                r.bv(me.slot, _e.slot) ||
                                  U.push({
                                    command: Ei.setSlot,
                                    args: [le, _e.slot],
                                  }),
                                r.bv(me.filter, _e.filter) ||
                                  U.push({
                                    command: Ei.setFilter,
                                    args: [le, _e.filter],
                                  }),
                                (r.bv(me.minzoom, _e.minzoom) &&
                                  r.bv(me.maxzoom, _e.maxzoom)) ||
                                  U.push({
                                    command: Ei.setLayerZoomRange,
                                    args: [le, _e.minzoom, _e.maxzoom],
                                  }),
                                me))
                                  me.hasOwnProperty(ze) &&
                                    ze !== "layout" &&
                                    ze !== "paint" &&
                                    ze !== "filter" &&
                                    ze !== "metadata" &&
                                    ze !== "minzoom" &&
                                    ze !== "maxzoom" &&
                                    ze !== "slot" &&
                                    (ze.indexOf("paint.") === 0
                                      ? pc(
                                          me[ze],
                                          _e[ze],
                                          U,
                                          le,
                                          ze.slice(6),
                                          Ei.setPaintProperty,
                                        )
                                      : r.bv(me[ze], _e[ze]) ||
                                        U.push({
                                          command: Ei.setLayerProperty,
                                          args: [le, ze, _e[ze]],
                                        }));
                                for (ze in _e)
                                  _e.hasOwnProperty(ze) &&
                                    !me.hasOwnProperty(ze) &&
                                    ze !== "layout" &&
                                    ze !== "paint" &&
                                    ze !== "filter" &&
                                    ze !== "metadata" &&
                                    ze !== "minzoom" &&
                                    ze !== "maxzoom" &&
                                    ze !== "slot" &&
                                    (ze.indexOf("paint.") === 0
                                      ? pc(
                                          me[ze],
                                          _e[ze],
                                          U,
                                          le,
                                          ze.slice(6),
                                          Ei.setPaintProperty,
                                        )
                                      : r.bv(me[ze], _e[ze]) ||
                                        U.push({
                                          command: Ei.setLayerProperty,
                                          args: [le, ze, _e[ze]],
                                        }));
                              } else
                                (U.push({
                                  command: Ei.removeLayer,
                                  args: [le],
                                }),
                                  (De = ae[ae.lastIndexOf(le) + 1]),
                                  U.push({
                                    command: Ei.addLayer,
                                    args: [_e, De],
                                  }));
                        })(L, w.layers, S));
                    } catch (C) {
                      (console.warn("Unable to compute style diff:", C),
                        (S = [{ command: Ei.setStyle, args: [w] }]));
                    }
                    return S;
                  })(this.serialize(), t).filter((x) => !(x.command in Pp));
                  if (h.length === 0) return !1;
                  const p = h.filter((x) => !(x.command in fd));
                  if (p.length > 0)
                    throw new Error(
                      `Unimplemented: ${p.map((x) => x.command).join(", ")}.`,
                    );
                  const g = [];
                  return (
                    h.forEach((x) => {
                      g.push(this[x.command](...x.args));
                    }),
                    s && Promise.all(g).then(s).catch(s),
                    (this.stylesheet = t),
                    this.mergeAll(),
                    this.dispatcher.broadcast("setLayers", {
                      layers: this._serializeLayers(this._order),
                      scope: this.scope,
                      options: this.options,
                    }),
                    !0
                  );
                }
                _updateWorkerImages() {
                  ((this._availableImages = this.imageManager.listImages(
                    this.scope,
                  )),
                    this.dispatcher.broadcast("setImages", {
                      scope: this.scope,
                      images: this._availableImages,
                    }));
                }
                _updateWorkerModels() {
                  ((this._availableModels = this.modelManager.getModelURIs(
                    this.scope,
                  )),
                    this.dispatcher.broadcast("setModels", {
                      scope: this.scope,
                      models: this._availableModels,
                    }));
                }
                addImages(t) {
                  for (const [s, h] of t.entries()) {
                    if (this.getImage(s))
                      return this.fire(
                        new r.z(
                          new Error(
                            `An image with the name "${s.name}" already exists.`,
                          ),
                        ),
                      );
                    (this.imageManager.addImage(s, this.scope, h),
                      this._changes.updateImage(s, this.scope));
                  }
                  return (
                    this._updateWorkerImages(),
                    this.fire(new r.A("data", { dataType: "style" })),
                    this
                  );
                }
                addImage(t, s) {
                  return this.getImage(t)
                    ? this.fire(
                        new r.z(
                          new Error(
                            `An image with the name "${t.name}" already exists.`,
                          ),
                        ),
                      )
                    : (this.imageManager.addImage(t, this.scope, s),
                      this._changes.updateImage(t, this.scope),
                      this._updateWorkerImages(),
                      this.fire(new r.A("data", { dataType: "style" })),
                      this);
                }
                updateImage(t, s, h = !1) {
                  (this.imageManager.updateImage(t, this.scope, s),
                    h &&
                      (this._changes.updateImage(t, this.scope),
                      this._updateWorkerImages(),
                      this.fire(new r.A("data", { dataType: "style" }))));
                }
                getImage(t) {
                  return this.imageManager.getImage(t, this.scope);
                }
                removeImage(t) {
                  return this.getImage(t)
                    ? (this.imageManager.removeImage(t, this.scope),
                      this._changes.updateImage(t, this.scope),
                      this._updateWorkerImages(),
                      this.fire(new r.A("data", { dataType: "style" })),
                      this)
                    : this.fire(
                        new r.z(new Error("No image with this name exists.")),
                      );
                }
                listImages() {
                  return (this._checkLoaded(), this._availableImages.slice());
                }
                addModelURLs(t) {
                  return (
                    this.modelManager.addModelURLs(t, this.scope),
                    this._updateWorkerModels(),
                    this.fire(new r.A("data", { dataType: "style" })),
                    this
                  );
                }
                addModel(t, s, h = {}) {
                  return (
                    this._checkLoaded(),
                    this._validate(oe, `models.${t}`, s, null, h) ||
                      (this.modelManager.addModel(t, s, this.scope),
                      this.fire(new r.A("data", { dataType: "style" }))),
                    this
                  );
                }
                hasModel(t) {
                  return this.modelManager.hasModel(t, this.scope);
                }
                removeModel(t) {
                  return this.hasModel(t)
                    ? (this.modelManager.removeModel(t, this.scope),
                      this.fire(new r.A("data", { dataType: "style" })),
                      this)
                    : this.fire(
                        new r.z(new Error("No model with this ID exists.")),
                      );
                }
                listModels() {
                  return (
                    this._checkLoaded(),
                    this.modelManager.listModels(this.scope)
                  );
                }
                addSource(t, s, h = {}) {
                  if ((this._checkLoaded(), this.getOwnSource(t) !== void 0))
                    throw new Error(
                      `There is already a source with ID "${t}".`,
                    );
                  if (!s.type)
                    throw new Error(
                      `The type property must be defined, but only the following properties were given: ${Object.keys(s).join(", ")}.`,
                    );
                  if (
                    ["vector", "raster", "geojson", "video", "image"].indexOf(
                      s.type,
                    ) >= 0 &&
                    this._validate(td, `sources.${t}`, s, null, h)
                  )
                    return;
                  this.map &&
                    this.map._collectResourceTiming &&
                    (s.collectResourceTiming = !0);
                  const p = oc(t, s, this.dispatcher, this);
                  ((p.scope = this.scope),
                    p.setEventedParent(this, () => ({
                      isSourceLoaded: this._isSourceCacheLoaded(p.id),
                      source: p.serialize(),
                      sourceId: p.id,
                    })));
                  const g = (x) => {
                    const w = (x ? "symbol:" : "other:") + p.id,
                      S = r.C(w, this.scope),
                      C = (this._sourceCaches[w] = new jr(S, p, x));
                    (((x ? this._symbolSourceCaches : this._otherSourceCaches)[
                      p.id
                    ] = C),
                      C.onAdd(this.map));
                  };
                  (g(!1),
                    (s.type !== "vector" && s.type !== "geojson") || g(!0),
                    p.onAdd && p.onAdd(this.map),
                    h.isInitialLoad ||
                      (this.mergeSources(), this._changes.setDirty()));
                }
                removeSource(t) {
                  this._checkLoaded();
                  const s = this.getOwnSource(t);
                  if (!s) throw new Error("There is no source with this ID");
                  for (const p in this._layers)
                    if (this._layers[p].source === t)
                      return this.fire(
                        new r.z(
                          new Error(
                            `Source "${t}" cannot be removed while layer "${p}" is using it.`,
                          ),
                        ),
                      );
                  if (
                    this.terrain &&
                    this.terrain.scope === this.scope &&
                    this.terrain.get().source === t
                  )
                    return this.fire(
                      new r.z(
                        new Error(
                          `Source "${t}" cannot be removed while terrain is using it.`,
                        ),
                      ),
                    );
                  if (this.stylesheet.iconsets) {
                    const p = Object.entries(this.stylesheet.iconsets).find(
                      ([g, x]) => x.type === "source" && x.source === t,
                    );
                    if (p)
                      return this.fire(
                        new r.z(
                          new Error(
                            `Source "${t}" cannot be removed while iconset "${p[0]}" is using it.`,
                          ),
                        ),
                      );
                  }
                  const h = this.getOwnSourceCaches(t);
                  for (const p of h) {
                    const g = r.d7(p.id);
                    (delete this._sourceCaches[g],
                      this._changes.discardSourceCacheUpdate(p.id),
                      p.fire(
                        new r.A("data", {
                          sourceDataType: "metadata",
                          dataType: "source",
                          sourceId: p.getSource().id,
                        }),
                      ),
                      p.setEventedParent(null),
                      p.clearTiles());
                  }
                  return (
                    delete this._otherSourceCaches[t],
                    delete this._symbolSourceCaches[t],
                    this.mergeSources(),
                    s.setEventedParent(null),
                    s.onRemove && s.onRemove(this.map),
                    this._changes.setDirty(),
                    this
                  );
                }
                setGeoJSONSourceData(t, s) {
                  (this._checkLoaded(),
                    this.getOwnSource(t).setData(s),
                    this._changes.setDirty());
                }
                getOwnSource(t) {
                  const s = this.getOwnSourceCache(t);
                  return s && s.getSource();
                }
                getOwnSources() {
                  const t = [];
                  for (const s in this._otherSourceCaches) {
                    const h = this.getOwnSourceCache(s);
                    h && t.push(h.getSource());
                  }
                  return t;
                }
                areTilesLoaded() {
                  const t = this._mergedSourceCaches;
                  for (const s in t) {
                    const h = t[s]._tiles;
                    for (const p in h) {
                      const g = h[p];
                      if (g.state !== "loaded" && g.state !== "errored")
                        return !1;
                    }
                  }
                  return !0;
                }
                setLights(t) {
                  if ((this._checkLoaded(), !t))
                    return (
                      delete this.ambientLight,
                      void delete this.directionalLight
                    );
                  const s = this._getTransitionParameters();
                  for (const g of t) {
                    if (this._validate(ua, "lights", g)) return;
                    switch (g.type) {
                      case "ambient":
                        if (this.ambientLight) {
                          const x = this.ambientLight;
                          (x.set(g), x.updateTransitions(s));
                        } else
                          this.ambientLight = new Ui(
                            g,
                            ri ||
                              (ri = new r.a7({
                                color: new r.a8(
                                  r.a5.properties_light_ambient.color,
                                ),
                                "color-use-theme": new r.a8({
                                  type: "string",
                                  default: "default",
                                  "property-type": "data-constant",
                                }),
                                intensity: new r.a8(
                                  r.a5.properties_light_ambient.intensity,
                                ),
                              })),
                            this.scope,
                            this.options,
                          );
                        break;
                      case "directional":
                        if (this.directionalLight) {
                          const x = this.directionalLight;
                          (x.set(g), x.updateTransitions(s));
                        } else
                          this.directionalLight = new Ui(
                            g,
                            Ki ||
                              (Ki = new r.a7({
                                direction: new r.an(
                                  r.a5.properties_light_directional.direction,
                                ),
                                color: new r.a8(
                                  r.a5.properties_light_directional.color,
                                ),
                                "color-use-theme": new r.a8({
                                  type: "string",
                                  default: "default",
                                  "property-type": "data-constant",
                                }),
                                intensity: new r.a8(
                                  r.a5.properties_light_directional.intensity,
                                ),
                                "cast-shadows": new r.a8(
                                  r.a5.properties_light_directional[
                                    "cast-shadows"
                                  ],
                                ),
                                "shadow-quality": new r.a8(
                                  r.a5.properties_light_directional[
                                    "shadow-quality"
                                  ],
                                ),
                                "shadow-intensity": new r.a8(
                                  r.a5.properties_light_directional[
                                    "shadow-intensity"
                                  ],
                                ),
                              })),
                            this.scope,
                            this.options,
                          );
                    }
                  }
                  const h = Object.assign(s, {
                      worldview: this.map.getWorldview(),
                    }),
                    p = new r.aa(this.z || 0, h);
                  (this.ambientLight && this.ambientLight.recalculate(p),
                    this.directionalLight &&
                      this.directionalLight.recalculate(p),
                    (this._brightness = this.calculateLightsBrightness()),
                    this.dispatcher.broadcast(
                      "setBrightness",
                      this._brightness,
                    ));
                }
                calculateLightsBrightness() {
                  const t = this.directionalLight,
                    s = this.ambientLight;
                  if (!t || !s) return;
                  const h = (z) =>
                      0.2126 *
                        (z[0] <= 0.03928
                          ? z[0] / 12.92
                          : Math.pow((z[0] + 0.055) / 1.055, 2.4)) +
                      0.7152 *
                        (z[1] <= 0.03928
                          ? z[1] / 12.92
                          : Math.pow((z[1] + 0.055) / 1.055, 2.4)) +
                      0.0722 *
                        (z[2] <= 0.03928
                          ? z[2] / 12.92
                          : Math.pow((z[2] + 0.055) / 1.055, 2.4)),
                    p = t.properties
                      .get("color")
                      .toNonPremultipliedRenderColor(null)
                      .toArray01(),
                    g = t.properties.get("intensity"),
                    x = t.properties.get("direction"),
                    w = 1 - r.cR(x.x, x.y, x.z)[2] / 90,
                    S = h(p) * g * w,
                    C = s.properties
                      .get("color")
                      .toNonPremultipliedRenderColor(null)
                      .toArray01(),
                    D = s.properties.get("intensity"),
                    L = h(C) * D;
                  return Number(((S + L) / 2).toFixed(6));
                }
                getBrightness() {
                  return this._brightness;
                }
                getLights() {
                  if (!this.enable3dLights()) return null;
                  const t = [];
                  return (
                    this.directionalLight &&
                      t.push(this.directionalLight.get()),
                    this.ambientLight && t.push(this.ambientLight.get()),
                    t
                  );
                }
                enable3dLights() {
                  return !!this.ambientLight && !!this.directionalLight;
                }
                getFragmentStyle(t) {
                  if (t == null || (t === "" && this.isRootStyle()))
                    return this;
                  if (r.d8(t)) {
                    const s = r.d9(t),
                      h = this.fragments.find(({ id: g }) => g === s);
                    if (!h) return;
                    const p = r.d7(t);
                    return h.style.getFragmentStyle(p);
                  }
                  {
                    const s = this.fragments.find(({ id: h }) => h === t);
                    return s ? s.style : void 0;
                  }
                }
                setFeaturesetSelectors(t) {
                  if (!t) return;
                  const s = {},
                    h = (p, g = "") => `${p}::${g}`;
                  this._featuresetSelectors = {};
                  for (const p in t) {
                    const g = (this._featuresetSelectors[p] = []);
                    for (const x of t[p].selectors) {
                      if (x.featureNamespace) {
                        const S = this.getOwnLayer(x.layer);
                        if (!S) {
                          r.w(`Layer is undefined for selector: ${x.layer}`);
                          continue;
                        }
                        const C = h(S.source, S.sourceLayer);
                        if (C in s && s[C] !== x.featureNamespace) {
                          r.w(
                            `"featureNamespace ${x.featureNamespace} of featureset ${p}'s selector is not associated to the same source, skip this selector`,
                          );
                          continue;
                        }
                        s[C] = x.featureNamespace;
                      }
                      let w;
                      if (x.properties)
                        for (const S in x.properties) {
                          const C = r.X(x.properties[S]);
                          C.result === "success" &&
                            ((w = w || {}), (w[S] = C.value));
                        }
                      g.push({
                        layerId: x.layer,
                        namespace: x.featureNamespace,
                        properties: w,
                        uniqueFeatureID: x._uniqueFeatureID,
                      });
                    }
                  }
                }
                getFeaturesetDescriptors(t) {
                  const s = this.getFragmentStyle(t);
                  if (!s || !s.stylesheet.featuresets) return [];
                  const h = [];
                  for (const p in s.stylesheet.featuresets)
                    h.push({
                      featuresetId: p,
                      importId: s.scope ? s.scope : void 0,
                    });
                  return h;
                }
                getFeaturesetLayers(t, s) {
                  const h = this.getFragmentStyle(s),
                    p = h.stylesheet.featuresets;
                  if (!p || !p[t])
                    return (
                      this.fire(
                        new r.z(
                          new Error(
                            `The featureset '${t}' does not exist in the map's style and cannot be queried.`,
                          ),
                        ),
                      ),
                      []
                    );
                  const g = [];
                  for (const x of p[t].selectors) {
                    const w = h.getOwnLayer(x.layer);
                    w && g.push(w);
                  }
                  return g;
                }
                getConfigProperty(t, s) {
                  const h = this.getFragmentStyle(t);
                  if (!h) return null;
                  const p = r.C(s, h.scope),
                    g = h.options.get(p),
                    x = g ? g.value || g.default : null;
                  return x ? x.serialize() : null;
                }
                setConfigProperty(t, s, h) {
                  const p = this.getFragmentStyle(t);
                  if (!p) return;
                  const g = p.stylesheet.indoor
                    ? ao(p.stylesheet.schema)
                    : p.stylesheet.schema;
                  if (!g || !g[s]) return;
                  const x = r.X(h);
                  if (x.result !== "success") return void Ta(this, x.value);
                  const w = x.value.expression,
                    S = r.C(s, p.scope),
                    C = p.options.get(S);
                  if (!C) return;
                  let D;
                  const {
                      minValue: L,
                      maxValue: z,
                      stepValue: O,
                      type: G,
                      values: U,
                    } = g[s],
                    $ = r.X(g[s].default);
                  ($.result === "success" && (D = $.value.expression),
                    D
                      ? (this.options.set(
                          S,
                          Object.assign({}, C, {
                            value: w,
                            default: D,
                            minValue: L,
                            maxValue: z,
                            stepValue: O,
                            type: G,
                            values: U,
                          }),
                        ),
                        this.updateConfigDependencies(s))
                      : this.fire(
                          new r.z(
                            new Error(
                              `No schema defined for the config option "${s}" in the "${t}" fragment.`,
                            ),
                          ),
                        ));
                }
                getConfig(t) {
                  const s = this.getFragmentStyle(t);
                  if (!s) return null;
                  const h = s.stylesheet.schema;
                  if (!h) return null;
                  const p = {};
                  for (const g in h) {
                    const x = r.C(g, s.scope),
                      w = s.options.get(x),
                      S = w ? w.value || w.default : null;
                    p[g] = S ? S.serialize() : null;
                  }
                  return p;
                }
                setConfig(t, s) {
                  const h = this.getFragmentStyle(t);
                  h &&
                    (h.updateConfig(s, h.stylesheet.schema),
                    this.updateConfigDependencies());
                }
                getSchema(t) {
                  const s = this.getFragmentStyle(t);
                  return s ? s.stylesheet.schema : null;
                }
                setSchema(t, s) {
                  const h = this.getFragmentStyle(t);
                  h &&
                    ((h.stylesheet.schema = s),
                    h.updateConfig(h._config, s),
                    this.updateConfigDependencies());
                }
                updateConfig(t, s) {
                  if (((this._config = t), t || s))
                    if (s)
                      for (const h in s) {
                        let p, g;
                        const x = r.X(s[h].default);
                        if (
                          (x.result === "success" && (p = x.value.expression),
                          t && t[h] !== void 0)
                        ) {
                          const z = r.X(t[h]);
                          z.result === "success" && (g = z.value.expression);
                        }
                        const {
                          minValue: w,
                          maxValue: S,
                          stepValue: C,
                          type: D,
                          values: L,
                        } = s[h];
                        if (p) {
                          const z = r.C(h, this.scope);
                          this.options.set(z, {
                            default: p,
                            value: g,
                            minValue: w,
                            maxValue: S,
                            stepValue: C,
                            type: D,
                            values: L,
                          });
                        } else
                          this.fire(
                            new r.z(
                              new Error(
                                `No schema defined for config option "${h}".`,
                              ),
                            ),
                          );
                      }
                    else
                      this.fire(
                        new r.z(
                          new Error(
                            "Attempting to set config for a style without schema.",
                          ),
                        ),
                      );
                }
                updateConfigDependencies(t) {
                  for (const s of this._configDependentLayers) {
                    const h = this.getLayer(s);
                    if (h) {
                      if (t && !h.configDependencies.has(t)) continue;
                      (h.possiblyEvaluateVisibility(), this._updateLayer(h));
                    }
                  }
                  (this.ambientLight &&
                    this.ambientLight.updateConfig(this.options),
                    this.directionalLight &&
                      this.directionalLight.updateConfig(this.options),
                    this.fog && this.fog.updateConfig(this.options),
                    this.snow && this.snow.updateConfig(this.options),
                    this.rain && this.rain.updateConfig(this.options),
                    this.forEachFragmentStyle((s) => {
                      const h = s._styleColorTheme.colorThemeOverride
                        ? s._styleColorTheme.colorThemeOverride
                        : s._styleColorTheme.colorTheme;
                      if (h) {
                        const p = s._evaluateColorThemeData(h);
                        ((!s._styleColorTheme.lut && p !== "") ||
                          (s._styleColorTheme.lut &&
                            p !== s._styleColorTheme.lut.data)) &&
                          s.setColorTheme(h);
                      }
                    }),
                    this._changes.setDirty());
                }
                addLayer(t, s, h = {}) {
                  this._checkLoaded();
                  const p = t.id;
                  if (this._layers[p])
                    return void this.fire(
                      new r.z(
                        new Error(
                          `Layer with id "${p}" already exists on this map`,
                        ),
                      ),
                    );
                  let g;
                  if (t.type === "custom") {
                    if (Ta(this, r.da(t))) return;
                    g = r.db(
                      t,
                      this.scope,
                      this._styleColorTheme.lut,
                      this.options,
                    );
                  } else {
                    if (
                      (typeof t.source == "object" &&
                        (this.addSource(p, t.source),
                        (t = r.d6(t)),
                        (t = r.h(t, { source: p }))),
                      this._validate(
                        Mi,
                        `layers.${p}`,
                        t,
                        { arrayIndex: -1 },
                        h,
                      ))
                    )
                      return;
                    ((g = r.db(
                      t,
                      this.scope,
                      this._styleColorTheme.lut,
                      this.options,
                    )),
                      this._validateLayer(g),
                      g.setEventedParent(this, { layer: { id: p } }));
                  }
                  g.configDependencies.size !== 0 &&
                    this._configDependentLayers.add(g.fqid);
                  let x = this._order.length;
                  if (s) {
                    const D = this._order.indexOf(s);
                    if (D === -1)
                      return void this.fire(
                        new r.z(
                          new Error(
                            `Layer with id "${s}" does not exist on this map.`,
                          ),
                        ),
                      );
                    g.slot === this._layers[s].slot
                      ? (x = D)
                      : r.w(
                          `Layer with id "${s}" has a different slot. Layers can only be rearranged within the same slot.`,
                        );
                  }
                  (this._order.splice(x, 0, p),
                    (this._layerOrderChanged = !0),
                    (this._layers[p] = g));
                  const w = this.getOwnLayerSourceCache(g),
                    S =
                      !!this.directionalLight &&
                      this.directionalLight.shadowsEnabled();
                  w && g.canCastShadows() && S && (w.castsShadows = !0);
                  const C = this._changes.getRemovedLayer(g);
                  if (C && g.source && w && g.type !== "custom") {
                    this._changes.discardLayerRemoval(g);
                    const D = r.C(g.source, g.scope);
                    C.type !== g.type
                      ? this._changes.updateSourceCache(D, "clear")
                      : (this._changes.updateSourceCache(D, "reload"),
                        w.pause());
                  }
                  (this._updateLayer(g),
                    g.onAdd && g.onAdd(this.map),
                    (g.scope = this.scope),
                    this.mergeLayers());
                }
                moveLayer(t, s) {
                  this._checkLoaded();
                  const h = this._checkLayer(t);
                  if (!h || t === s) return;
                  const p = this._order.indexOf(t);
                  this._order.splice(p, 1);
                  let g = this._order.length;
                  if (s) {
                    const x = this._order.indexOf(s);
                    if (x === -1)
                      return void this.fire(
                        new r.z(
                          new Error(
                            `Layer with id "${s}" does not exist on this map.`,
                          ),
                        ),
                      );
                    h.slot === this._layers[s].slot
                      ? (g = x)
                      : r.w(
                          `Layer with id "${s}" has a different slot. Layers can only be rearranged within the same slot.`,
                        );
                  }
                  (this._order.splice(g, 0, t),
                    this._changes.setDirty(),
                    (this._layerOrderChanged = !0),
                    this.mergeLayers());
                }
                removeLayer(t) {
                  this._checkLoaded();
                  const s = this._checkLayer(t);
                  if (!s) return;
                  s.setEventedParent(null);
                  const h = this._order.indexOf(t);
                  (this._order.splice(h, 1),
                    delete this._layers[t],
                    this._changes.setDirty(),
                    (this._layerOrderChanged = !0),
                    this._configDependentLayers.delete(s.fqid),
                    this._changes.removeLayer(s));
                  const p = this.getOwnLayerSourceCache(s);
                  if (p && p.castsShadows) {
                    let g = !1;
                    for (const x in this._layers)
                      if (
                        this._layers[x].source === s.source &&
                        this._layers[x].canCastShadows()
                      ) {
                        g = !0;
                        break;
                      }
                    p.castsShadows = g;
                  }
                  (s.onRemove && s.onRemove(this.map), this.mergeLayers());
                }
                getOwnLayer(t) {
                  return this._layers[t];
                }
                hasLayer(t) {
                  return t in this._mergedLayers;
                }
                hasLayerType(t) {
                  for (const s in this._layers)
                    if (this._layers[s].type === t) return !0;
                  return !1;
                }
                setLayerZoomRange(t, s, h) {
                  this._checkLoaded();
                  const p = this._checkLayer(t);
                  p &&
                    ((p.minzoom === s && p.maxzoom === h) ||
                      (s != null && (p.minzoom = s),
                      h != null && (p.maxzoom = h),
                      this._updateLayer(p)));
                }
                getSlots() {
                  return (this._checkLoaded(), this._mergedSlots);
                }
                setSlot(t, s) {
                  this._checkLoaded();
                  const h = this._checkLayer(t);
                  h && h.slot !== s && ((h.slot = s), this._updateLayer(h));
                }
                setFilter(t, s, h = {}) {
                  this._checkLoaded();
                  const p = this._checkLayer(t);
                  if (p && !r.bv(p.filter, s))
                    return s == null
                      ? ((p.filter = void 0), void this._updateLayer(p))
                      : void (
                          this._validate(
                            Fe,
                            `layers.${p.id}.filter`,
                            s,
                            { layerType: p.type },
                            h,
                          ) || ((p.filter = r.d6(s)), this._updateLayer(p))
                        );
                }
                getFilter(t) {
                  const s = this._checkLayer(t);
                  if (s) return r.d6(s.filter);
                }
                setLayoutProperty(t, s, h, p = {}) {
                  this._checkLoaded();
                  const g = this._checkLayer(t);
                  if (g && !r.bv(g.getLayoutProperty(s), h)) {
                    if (
                      h != null &&
                      (!p || p.validate !== !1) &&
                      Ta(
                        g,
                        K.call(Yr, {
                          key: `layers.${t}.layout.${s}`,
                          layerType: g.type,
                          objectKey: s,
                          value: h,
                          styleSpec: r.a5,
                          style: { glyphs: !0, sprite: !0 },
                        }),
                      )
                    )
                      return;
                    (g.setLayoutProperty(s, h),
                      g.configDependencies.size !== 0 &&
                        this._configDependentLayers.add(g.fqid),
                      this._updateLayer(g));
                  }
                }
                getLayoutProperty(t, s) {
                  const h = this._checkLayer(t);
                  if (h) return h.getLayoutProperty(s);
                }
                setPaintProperty(t, s, h, p = {}) {
                  this._checkLoaded();
                  const g = this._checkLayer(t);
                  if (
                    !g ||
                    r.bv(g.getPaintProperty(s), h) ||
                    (h != null &&
                      (!p || p.validate !== !1) &&
                      Ta(
                        g,
                        W.call(Yr, {
                          key: `layers.${t}.paint.${s}`,
                          layerType: g.type,
                          objectKey: s,
                          value: h,
                          styleSpec: r.a5,
                        }),
                      ))
                  )
                    return;
                  const x = g.setPaintProperty(s, h);
                  (g.configDependencies.size !== 0 &&
                    this._configDependentLayers.add(g.fqid),
                    x && this._updateLayer(g),
                    this._changes.updatePaintProperties(g));
                }
                getPaintProperty(t, s) {
                  const h = this._checkLayer(t);
                  if (h) return h.getPaintProperty(s);
                }
                setFeatureState(t, s) {
                  if ((this._checkLoaded(), "target" in t)) {
                    if ("featuresetId" in t.target) {
                      const { featuresetId: S, importId: C } = t.target,
                        D = this.getFragmentStyle(C),
                        L = D.getFeaturesetLayers(S);
                      for (const { source: z, sourceLayer: O } of L)
                        D.setFeatureState(
                          { id: t.id, source: z, sourceLayer: O },
                          s,
                        );
                    } else if ("layerId" in t.target) {
                      const { layerId: S } = t.target,
                        C = this.getLayer(S);
                      this.setFeatureState(
                        {
                          id: t.id,
                          source: C.source,
                          sourceLayer: C.sourceLayer,
                        },
                        s,
                      );
                    }
                    return;
                  }
                  const h = t.source,
                    p = t.sourceLayer,
                    g = this._checkSource(h);
                  if (!g) return;
                  const x = g.type;
                  if (x === "geojson" && p)
                    return void this.fire(
                      new r.z(
                        new Error(
                          "GeoJSON sources cannot have a sourceLayer parameter.",
                        ),
                      ),
                    );
                  if (x === "vector" && !p)
                    return void this.fire(
                      new r.z(
                        new Error(
                          "The sourceLayer parameter must be provided for vector source types.",
                        ),
                      ),
                    );
                  t.id === void 0 &&
                    this.fire(
                      new r.z(
                        new Error("The feature id parameter must be provided."),
                      ),
                    );
                  const w = this.getOwnSourceCaches(h);
                  for (const S of w) S.setFeatureState(p, t.id, s);
                }
                removeFeatureState(t, s) {
                  if ((this._checkLoaded(), "target" in t)) {
                    if ("featuresetId" in t.target) {
                      const { featuresetId: S, importId: C } = t.target,
                        D = this.getFragmentStyle(C),
                        L = D.getFeaturesetLayers(S);
                      for (const { source: z, sourceLayer: O } of L)
                        D.removeFeatureState(
                          { id: t.id, source: z, sourceLayer: O },
                          s,
                        );
                    } else if ("layerId" in t.target) {
                      const { layerId: S } = t.target,
                        C = this.getLayer(S);
                      this.removeFeatureState(
                        {
                          id: t.id,
                          source: C.source,
                          sourceLayer: C.sourceLayer,
                        },
                        s,
                      );
                    }
                    return;
                  }
                  const h = t.source,
                    p = this._checkSource(h);
                  if (!p) return;
                  const g = p.type,
                    x = g === "vector" ? t.sourceLayer : void 0;
                  if (g === "vector" && !x)
                    return void this.fire(
                      new r.z(
                        new Error(
                          "The sourceLayer parameter must be provided for vector source types.",
                        ),
                      ),
                    );
                  if (s && typeof t.id != "string" && typeof t.id != "number")
                    return void this.fire(
                      new r.z(
                        new Error(
                          "A feature id is required to remove its specific state property.",
                        ),
                      ),
                    );
                  const w = this.getOwnSourceCaches(h);
                  for (const S of w) S.removeFeatureState(x, t.id, s);
                }
                getFeatureState(t) {
                  if ((this._checkLoaded(), "target" in t)) {
                    let g;
                    if ("featuresetId" in t.target) {
                      const { featuresetId: x, importId: w } = t.target,
                        S = this.getFragmentStyle(w),
                        C = S.getFeaturesetLayers(x);
                      for (const { source: D, sourceLayer: L } of C) {
                        const z = S.getFeatureState({
                          id: t.id,
                          source: D,
                          sourceLayer: L,
                        });
                        if (z && !g) g = z;
                        else if (!r.bv(g, z))
                          return void this.fire(
                            new r.z(
                              new Error(
                                "The same feature id exists in multiple sources in the featureset, but their feature states are not consistent through the sources.",
                              ),
                            ),
                          );
                      }
                    } else if ("layerId" in t.target) {
                      const { layerId: x } = t.target,
                        w = this.getLayer(x);
                      g = this.getFeatureState({
                        id: t.id,
                        source: w.source,
                        sourceLayer: w.sourceLayer,
                      });
                    }
                    return g;
                  }
                  const s = t.source,
                    h = t.sourceLayer,
                    p = this._checkSource(s);
                  if (p) {
                    if (p.type !== "vector" || h)
                      return (
                        t.id === void 0 &&
                          this.fire(
                            new r.z(
                              new Error(
                                "The feature id parameter must be provided.",
                              ),
                            ),
                          ),
                        this.getOwnSourceCaches(s)[0].getFeatureState(h, t.id)
                      );
                    this.fire(
                      new r.z(
                        new Error(
                          "The sourceLayer parameter must be provided for vector source types.",
                        ),
                      ),
                    );
                  }
                }
                setTransition(t) {
                  return (
                    (this.stylesheet.transition = r.h(
                      {},
                      this.stylesheet.transition,
                      t,
                    )),
                    (this.transition = this.stylesheet.transition),
                    this
                  );
                }
                getTransition() {
                  return r.h({}, this.stylesheet.transition);
                }
                serialize() {
                  this._checkLoaded();
                  const t = this.getTerrain(),
                    s =
                      t && this.terrain && this.terrain.scope === this.scope
                        ? t
                        : this.stylesheet.terrain;
                  return r.dc(
                    {
                      version: this.stylesheet.version,
                      name: this.stylesheet.name,
                      metadata: this.stylesheet.metadata,
                      fragment: this.stylesheet.fragment,
                      iconsets: this.stylesheet.iconsets,
                      imports: this._serializeImports(),
                      schema: this.stylesheet.schema,
                      camera: this.stylesheet.camera,
                      light: this.stylesheet.light,
                      lights: this.stylesheet.lights,
                      terrain: s,
                      fog: this.stylesheet.fog,
                      snow: this.stylesheet.snow,
                      rain: this.stylesheet.rain,
                      center: this.stylesheet.center,
                      "color-theme": this.stylesheet["color-theme"],
                      zoom: this.stylesheet.zoom,
                      bearing: this.stylesheet.bearing,
                      pitch: this.stylesheet.pitch,
                      sprite: this.stylesheet.sprite,
                      glyphs: this.stylesheet.glyphs,
                      transition: this.stylesheet.transition,
                      projection: this.stylesheet.projection,
                      sources: this._serializeSources(),
                      layers: this._serializeLayers(this._order),
                    },
                    (h) => h !== void 0,
                  );
                }
                _updateFilteredLayers(t) {
                  for (const s of Object.values(this._mergedLayers))
                    t(s) && this._updateLayer(s);
                }
                _updateLayer(t) {
                  this._changes.updateLayer(t);
                  const s = this.getLayerSourceCache(t),
                    h = r.C(t.source, t.scope),
                    p = this._changes.getUpdatedSourceCaches();
                  (t.source &&
                    !p[h] &&
                    s &&
                    s.getSource().type !== "raster" &&
                    (this._changes.updateSourceCache(h, "reload"), s.pause()),
                    t.invalidateCompiledFilter());
                }
                _flattenAndSortRenderedFeatures(t) {
                  const s = (w) => this._mergedLayers[w].is3D(!!this.terrain),
                    h = this.order,
                    p = {},
                    g = [];
                  for (let w = h.length - 1; w >= 0; w--) {
                    const S = h[w];
                    if (s(S)) {
                      p[S] = w;
                      for (const C of t) {
                        const D = C[S];
                        if (D) for (const L of D) g.push(L);
                      }
                    }
                  }
                  g.sort((w, S) => S.intersectionZ - w.intersectionZ);
                  const x = [];
                  for (let w = h.length - 1; w >= 0; w--) {
                    const S = h[w];
                    if (s(S))
                      for (let C = g.length - 1; C >= 0; C--) {
                        const D = g[C].feature;
                        if (D.layer && p[D.layer.id] < w) break;
                        (x.push(D), g.pop());
                      }
                    else
                      for (const C of t) {
                        const D = C[S];
                        if (D) for (const L of D) x.push(L.feature);
                      }
                  }
                  return x;
                }
                queryRenderedFeatures(t, s, h) {
                  let p;
                  s &&
                    !Array.isArray(s) &&
                    s.filter &&
                    (this._validate(
                      Fe,
                      "queryRenderedFeatures.filter",
                      s.filter,
                      null,
                      s,
                    ),
                    (p = r.b3(s.filter)));
                  const g = {},
                    x = (D) => {
                      if (Nh.has(D.type)) return;
                      const L = this.getOwnLayerSourceCache(D),
                        z = (g[L.id] = g[L.id] || {
                          sourceCache: L,
                          layers: {},
                          has3DLayers: !1,
                        });
                      (D.is3D(!!this.terrain) && (z.has3DLayers = !0),
                        (z.layers[D.fqid] = z.layers[D.fqid] || {
                          styleLayer: D,
                          targets: [],
                        }),
                        z.layers[D.fqid].targets.push({ filter: p }));
                    };
                  if (s && s.layers) {
                    if (!Array.isArray(s.layers))
                      return (
                        this.fire(
                          new r.z(
                            new Error("parameters.layers must be an Array."),
                          ),
                        ),
                        []
                      );
                    for (const D of s.layers) {
                      const L = this._layers[D];
                      if (!L)
                        return (
                          this.fire(
                            new r.z(
                              new Error(
                                `The layer '${D}' does not exist in the map's style and cannot be queried for features.`,
                              ),
                            ),
                          ),
                          []
                        );
                      x(L);
                    }
                  } else for (const D in this._layers) x(this._layers[D]);
                  const w = this._queryRenderedFeatures(t, g, h),
                    S = this._flattenAndSortRenderedFeatures(w),
                    C = [];
                  for (const D of S)
                    r.dd(D.layer.id) === this.scope && C.push(D);
                  return C;
                }
                queryRenderedFeatureset(t, s, h) {
                  let p;
                  s &&
                    !Array.isArray(s) &&
                    s.filter &&
                    (this._validate(
                      Fe,
                      "queryRenderedFeatures.filter",
                      s.filter,
                      null,
                      s,
                    ),
                    (p = r.b3(s.filter)));
                  const g = "mock",
                    x = [];
                  if (s && s.target)
                    x.push(Object.assign({}, s, { targetId: g, filter: p }));
                  else {
                    const D = this.getFeaturesetDescriptors();
                    for (const L of D)
                      x.push({ targetId: g, filter: p, target: L });
                    for (const { style: L } of this.fragments) {
                      const z = L.getFeaturesetDescriptors();
                      for (const O of z)
                        x.push({ targetId: g, filter: p, target: O });
                    }
                  }
                  const w = this.queryRenderedTargets(t, x, h),
                    S = [],
                    C = new Set();
                  for (const D of w)
                    for (const L of D.variants[g])
                      Ih(L, D, C) || S.push(new r.de(D, L));
                  return S;
                }
                queryRenderedTargets(t, s, h) {
                  const p = {},
                    g = (w, S, C, D) => {
                      const L = (p[S.id] = p[S.id] || {
                        sourceCache: S,
                        layers: {},
                        has3DLayers: !1,
                      });
                      if (
                        ((L.layers[w.fqid] = L.layers[w.fqid] || {
                          styleLayer: w,
                          targets: [],
                        }),
                        w.is3D(!!this.terrain) && (L.has3DLayers = !0),
                        !D)
                      )
                        return (
                          (C.uniqueFeatureID = !1),
                          void L.layers[w.fqid].targets.push(C)
                        );
                      L.layers[w.fqid].targets.push(
                        Object.assign({}, C, {
                          namespace: D.namespace,
                          properties: D.properties,
                          uniqueFeatureID: D.uniqueFeatureID,
                        }),
                      );
                    };
                  for (const w of s)
                    if ("featuresetId" in w.target) {
                      const { featuresetId: S, importId: C } = w.target,
                        D = this.getFragmentStyle(C);
                      if (!D || !D._featuresetSelectors) continue;
                      const L = D._featuresetSelectors[S];
                      if (!L) {
                        this.fire(
                          new r.z(
                            new Error(
                              `The featureset '${S}' does not exist in the map's style and cannot be queried for features.`,
                            ),
                          ),
                        );
                        continue;
                      }
                      for (const z of L) {
                        const O = D.getOwnLayer(z.layerId);
                        O &&
                          !Nh.has(O.type) &&
                          g(O, D.getOwnLayerSourceCache(O), w, z);
                      }
                    } else if ("layerId" in w.target) {
                      const { layerId: S } = w.target,
                        C = this.getLayer(S);
                      if (!C || Nh.has(C.type)) continue;
                      g(C, this.getLayerSourceCache(C), w);
                    }
                  const x = this._queryRenderedFeatures(t, p, h);
                  return this._flattenAndSortRenderedFeatures(x);
                }
                _queryRenderedFeatures(t, s, h) {
                  const p = [],
                    g = !!this.map._showQueryGeometry,
                    x = Pi.createFromScreenPoints(t, h);
                  for (const w in s) {
                    const S = Ah(x, s[w], this._availableImages, h, g);
                    Object.keys(S).length && p.push(S);
                  }
                  if (this.placement)
                    for (const w in s) {
                      if (!s[w].sourceCache._onlySymbols) continue;
                      const S = da(
                        x.screenGeometry,
                        s[w],
                        this._availableImages,
                        this.placement.collisionIndex,
                        this.placement.retainedQueryData,
                        this.map.getWorldview(),
                      );
                      Object.keys(S).length && p.push(S);
                    }
                  return p;
                }
                querySourceFeatures(t, s) {
                  const h = s && s.filter;
                  h &&
                    this._validate(
                      Fe,
                      "querySourceFeatures.filter",
                      h,
                      null,
                      s,
                    );
                  let p = [];
                  const g = this.getOwnSourceCaches(t);
                  for (const x of g) p = p.concat(lc(x, s));
                  return p;
                }
                addSourceType(t, s, h) {
                  return Er.getSourceType(t)
                    ? h(
                        new Error(
                          `A source type called "${t}" already exists.`,
                        ),
                      )
                    : (Er.setSourceType(t, s),
                      s.workerSourceURL
                        ? void this.dispatcher.broadcast(
                            "loadWorkerSource",
                            { name: t, url: s.workerSourceURL },
                            h,
                          )
                        : h(null, null));
                }
                getFlatLight() {
                  return this.light.getLight();
                }
                setFlatLight(t, s, h = {}) {
                  this._checkLoaded();
                  const p = this.light.getLight();
                  let g = !1;
                  for (const w in t)
                    if (!r.bv(t[w], p[w])) {
                      g = !0;
                      break;
                    }
                  if (!g) return;
                  const x = this._getTransitionParameters();
                  (this.light.setLight(t, s, h),
                    this.light.updateTransitions(x));
                }
                getTerrain() {
                  return this.terrain && this.terrain.drapeRenderMode === 1
                    ? this.terrain.get()
                    : null;
                }
                setTerrainForDraping() {
                  this.setTerrain({ source: "", exaggeration: 0 }, 0);
                }
                checkCanvasFingerprintNoise() {
                  this.disableElevatedTerrain === void 0 &&
                    ((this.disableElevatedTerrain =
                      r.q.hasCanvasFingerprintNoise()),
                    this.disableElevatedTerrain &&
                      r.w(
                        "Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode).",
                      ));
                }
                setTerrain(t, s = 1) {
                  if ((this._checkLoaded(), !t))
                    return (
                      this.terrainSetForDrapingOnly() ||
                        (delete this.terrain,
                        this.map.transform.projection.requiresDraping &&
                          this.setTerrainForDraping()),
                      s === 0 && delete this.terrain,
                      t === null
                        ? (this.stylesheet.terrain = null)
                        : delete this.stylesheet.terrain,
                      this._force3DLayerUpdate(),
                      void (this._markersNeedUpdate = !0)
                    );
                  this.checkCanvasFingerprintNoise();
                  let h = t;
                  const p = t.source == null;
                  if (s === 1) {
                    if (this.disableElevatedTerrain) return;
                    if (typeof h.source == "object") {
                      const w = "terrain-dem-src";
                      (this.addSource(w, h.source),
                        (h = r.d6(h)),
                        (h = r.h(h, { source: w })));
                    }
                    const g = r.h({}, h),
                      x = {};
                    if (this.terrain && p) {
                      g.source = this.terrain.get().source;
                      const w = this.terrain
                        ? this.getFragmentStyle(this.terrain.scope)
                        : null;
                      w && (x.style = w.serialize());
                    }
                    if (this._validate(ft, "terrain", g, x)) return;
                  }
                  if (
                    !this.terrain ||
                    (this.terrain.scope !== this.scope && !p) ||
                    (this.terrain && s !== this.terrain.drapeRenderMode)
                  ) {
                    if (!h) return;
                    (this._createTerrain(h, s),
                      this.fire(new r.A("data", { dataType: "style" })));
                  } else {
                    const g = this.terrain,
                      x = g.get();
                    for (const w of Object.keys(r.a5.terrain))
                      !h.hasOwnProperty(w) &&
                        r.a5.terrain[w].default &&
                        (h[w] = r.a5.terrain[w].default);
                    for (const w in t)
                      if (!r.bv(t[w], x[w])) {
                        (g.set(t, this.options), (this.stylesheet.terrain = t));
                        const S = this._getTransitionParameters({
                          duration: 0,
                        });
                        (g.updateTransitions(S),
                          this.fire(new r.A("data", { dataType: "style" })));
                        break;
                      }
                  }
                  (this.mergeTerrain(),
                    this.updateDrapeFirstLayers(),
                    (this._markersNeedUpdate = !0));
                }
                _createFog(t) {
                  const s = (this.fog = new Kt(
                    t,
                    this.map.transform,
                    this.scope,
                    this.options,
                  ));
                  this.stylesheet.fog = s.get();
                  const h = this._getTransitionParameters({ duration: 0 });
                  s.updateTransitions(h);
                }
                _createSnow(t) {
                  const s = (this.snow = new gn(
                    t,
                    this.map.transform,
                    this.scope,
                    this.options,
                  ));
                  this.stylesheet.snow = s.get();
                  const h = this._getTransitionParameters({ duration: 0 });
                  s.updateTransitions(h);
                }
                _createRain(t) {
                  const s = (this.rain = new _n(
                    t,
                    this.map.transform,
                    this.scope,
                    this.options,
                  ));
                  this.stylesheet.rain = s.get();
                  const h = this._getTransitionParameters({ duration: 0 });
                  s.updateTransitions(h);
                }
                _updateMarkersOpacity() {
                  this.map._markers.length !== 0 &&
                    this.map._requestDomTask(() => {
                      for (const t of this.map._markers) t._evaluateOpacity();
                    });
                }
                getFog() {
                  return this.fog ? this.fog.get() : null;
                }
                setFog(t) {
                  if ((this._checkLoaded(), !t))
                    return (
                      delete this.fog,
                      delete this.stylesheet.fog,
                      void (this._markersNeedUpdate = !0)
                    );
                  if (this.fog) {
                    const s = this.fog;
                    if (!r.bv(s.get(), t)) {
                      (s.set(t, this.options), (this.stylesheet.fog = s.get()));
                      const h = this._getTransitionParameters({ duration: 0 });
                      s.updateTransitions(h);
                    }
                  } else this._createFog(t);
                  this._markersNeedUpdate = !0;
                }
                getSnow() {
                  return this.snow ? this.snow.get() : null;
                }
                setSnow(t) {
                  if ((this._checkLoaded(), !t))
                    return (delete this.snow, void delete this.stylesheet.snow);
                  if (this.snow) {
                    const s = this.snow;
                    if (!r.bv(s.get(), t)) {
                      (s.set(t, this.options),
                        (this.stylesheet.snow = s.get()));
                      const h = this._getTransitionParameters({ duration: 0 });
                      s.updateTransitions(h);
                    }
                  } else this._createSnow(t);
                  this._markersNeedUpdate = !0;
                }
                getRain() {
                  return this.rain ? this.rain.get() : null;
                }
                setRain(t) {
                  if ((this._checkLoaded(), !t))
                    return (delete this.rain, void delete this.stylesheet.rain);
                  if (this.rain) {
                    const s = this.rain;
                    if (!r.bv(s.get(), t)) {
                      (s.set(t, this.options),
                        (this.stylesheet.rain = s.get()));
                      const h = this._getTransitionParameters({ duration: 0 });
                      s.updateTransitions(h);
                    }
                  } else this._createRain(t);
                  this._markersNeedUpdate = !0;
                }
                _reloadColorTheme() {
                  const t = () => {
                      for (const p in this._layers)
                        this._layers[p].lut = this._styleColorTheme.lut;
                      for (const p in this._sourceCaches)
                        this._sourceCaches[p].clearTiles();
                    },
                    s = this._styleColorTheme.colorThemeOverride
                      ? this._styleColorTheme.colorThemeOverride
                      : this._styleColorTheme.colorTheme;
                  if (!s) return ((this._styleColorTheme.lut = null), void t());
                  const h = this._evaluateColorThemeData(s);
                  this._loadColorTheme(h)
                    .then(() => {
                      (this.fire(new r.A("colorthemeset")), t());
                    })
                    .catch((p) => {
                      r.w(`Couldn't set color theme: ${p}`);
                    });
                }
                setColorTheme(t) {
                  (this._checkLoaded(),
                    this._styleColorTheme.colorThemeOverride &&
                      r.w(
                        "Note: setColorTheme is called on a style with a color-theme override, the passed color-theme won't be visible.",
                      ),
                    (this._styleColorTheme.colorTheme = t),
                    this._reloadColorTheme());
                }
                setImportColorTheme(t, s) {
                  const h = this.getFragmentStyle(t);
                  h &&
                    ((h._styleColorTheme.colorThemeOverride = s),
                    h._reloadColorTheme());
                }
                _getTransitionParameters(t) {
                  return {
                    now: r.q.now(),
                    transition: r.h(this.transition, t),
                  };
                }
                updateDrapeFirstLayers() {
                  if (!this.terrain) return;
                  const t = [],
                    s = [];
                  for (const h of this._mergedOrder)
                    this.isLayerDraped(this._mergedLayers[h])
                      ? t.push(h)
                      : s.push(h);
                  ((this._drapedFirstOrder = []),
                    this._drapedFirstOrder.push(...t),
                    this._drapedFirstOrder.push(...s));
                }
                _createTerrain(t, s) {
                  const h = (this.terrain = new Ee(
                    t,
                    s,
                    this.scope,
                    this.options,
                    this.map.getWorldview(),
                  ));
                  (s === 1 && (this.stylesheet.terrain = t),
                    this.mergeTerrain(),
                    this.updateDrapeFirstLayers(),
                    this._force3DLayerUpdate());
                  const p = this._getTransitionParameters({ duration: 0 });
                  h.updateTransitions(p);
                }
                _force3DLayerUpdate() {
                  for (const t in this._layers) {
                    const s = this._layers[t];
                    s.type === "fill-extrusion" && this._updateLayer(s);
                  }
                }
                _forceSymbolLayerUpdate() {
                  for (const t in this._layers) {
                    const s = this._layers[t];
                    s.type === "symbol" && this._updateLayer(s);
                  }
                }
                _validate(t, s, h, p, g = {}) {
                  if (g && g.validate === !1) return !1;
                  const x = r.h({}, this.serialize());
                  return Ta(
                    this,
                    t.call(
                      Yr,
                      r.h({ key: s, style: x, value: h, styleSpec: r.a5 }, p),
                    ),
                  );
                }
                _remove() {
                  (this._request &&
                    (this._request.cancel(), (this._request = null)),
                    this._spriteRequest &&
                      (this._spriteRequest.cancel(),
                      (this._spriteRequest = null)),
                    r.df.off("pluginStateChange", this._rtlTextPluginCallback));
                  for (const t in this._mergedLayers)
                    this._mergedLayers[t].setEventedParent(null);
                  for (const t in this._mergedSourceCaches)
                    (this._mergedSourceCaches[t].clearTiles(),
                      this._mergedSourceCaches[t].setEventedParent(null));
                  (this.imageManager.removeScope(this.scope),
                    this.setEventedParent(null),
                    delete this.fog,
                    delete this.snow,
                    delete this.rain,
                    delete this.terrain,
                    delete this.ambientLight,
                    delete this.directionalLight,
                    this.isRootStyle() &&
                      (this.imageManager.setEventedParent(null),
                      this.modelManager.setEventedParent(null),
                      this.modelManager.destroy(),
                      this.dispatcher.remove()));
                }
                clearSource(t) {
                  const s = this.getSourceCaches(t);
                  for (const h of s) h.clearTiles();
                }
                clearSources() {
                  for (const t in this._mergedSourceCaches)
                    this._mergedSourceCaches[t].clearTiles();
                }
                reloadSource(t) {
                  const s = this.getSourceCaches(t);
                  for (const h of s) (h.resume(), h.reload());
                }
                reloadSources() {
                  for (const t of this.getSources()) t.reload && t.reload();
                }
                reloadModels() {
                  (this.modelManager.reloadModels(""),
                    this.forEachFragmentStyle((t) => {
                      t.modelManager.reloadModels(t.scope);
                    }));
                }
                updateSources(t) {
                  let s;
                  this.directionalLight && (s = cl(this.directionalLight));
                  const h = new Set();
                  for (const p in this._mergedLayers) {
                    const g = this._mergedLayers[p];
                    g.hasElevation() && !h.has(g.source) && h.add(g.source);
                  }
                  for (const p in this._mergedSourceCaches) {
                    const g = this._mergedSourceCaches[p],
                      x = h.has(g._source.id);
                    g.update(t, void 0, void 0, s, x);
                  }
                }
                _generateCollisionBoxes() {
                  for (const t in this._sourceCaches) {
                    const s = this._sourceCaches[t];
                    (s.resume(), s.reload());
                  }
                }
                _updatePlacement(t, s, h, p, g, x, w = !1) {
                  let S = !1,
                    C = !1;
                  const D = {},
                    L = {};
                  for (const z of this._mergedOrder) {
                    const O = this._mergedLayers[z];
                    if (O.type !== "symbol") continue;
                    const G = r.C(O.source, O.scope);
                    let U = D[G];
                    if (!U) {
                      const Z = this.getLayerSourceCache(O);
                      if (!Z) continue;
                      const Y = Z.getRenderableIds(!0).map((ie) =>
                        Z.getTileByID(ie),
                      );
                      ((L[G] = Y.slice()),
                        (U = D[G] =
                          Y.sort(
                            (ie, ae) =>
                              ae.tileID.overscaledZ - ie.tileID.overscaledZ ||
                              (ie.tileID.isLessThan(ae.tileID) ? -1 : 1),
                          )));
                    }
                    const $ = this.crossTileSymbolIndex.addLayer(
                      O,
                      U,
                      s.center.lng,
                      s.projection,
                    );
                    S = S || $;
                  }
                  if (
                    (this.crossTileSymbolIndex.pruneUnusedLayers(
                      this._mergedOrder,
                    ),
                    (w = w || this._layerOrderChanged || p === 0),
                    this._layerOrderChanged && this.fire(new r.A("neworder")),
                    (w ||
                      !this.pauseablePlacement ||
                      (this.pauseablePlacement.isDone() &&
                        !this.placement.stillRecent(r.q.now(), s.zoom))) &&
                      ((this.pauseablePlacement = new Oh(
                        s,
                        this._mergedOrder,
                        w,
                        h,
                        p,
                        g,
                        this.placement,
                        this.fog && s.projection.supportsFog
                          ? this.fog.state
                          : null,
                        this._buildingIndex,
                      )),
                      (this._layerOrderChanged = !1)),
                    this.pauseablePlacement.isDone()
                      ? this.placement.setStale()
                      : (this.pauseablePlacement.continuePlacement(
                          this._mergedOrder,
                          this._mergedLayers,
                          D,
                          L,
                          this.map.painter.scaleFactor,
                        ),
                        this.pauseablePlacement.isDone() &&
                          ((this.placement = this.pauseablePlacement.commit(
                            r.q.now(),
                          )),
                          (C = !0)),
                        S && this.pauseablePlacement.placement.setStale()),
                    C || S)
                  ) {
                    this._buildingIndex.onNewFrame(s.zoom);
                    for (let z = 0; z < this._mergedOrder.length; z++) {
                      const O = this._mergedLayers[this._mergedOrder[z]];
                      if (O.type !== "symbol") continue;
                      const G = this.isLayerClipped(O);
                      this.placement.updateLayerOpacities(
                        O,
                        D[r.C(O.source, O.scope)],
                        z,
                        G ? x : null,
                      );
                    }
                  }
                  return {
                    needsRerender:
                      !this.pauseablePlacement.isDone() ||
                      this.placement.hasTransitions(r.q.now()),
                  };
                }
                _releaseSymbolFadeTiles() {
                  for (const t in this._sourceCaches)
                    this._sourceCaches[t].releaseSymbolFadeTiles();
                }
                addImport(t, s) {
                  this._checkLoaded();
                  const h = (this.stylesheet.imports =
                    this.stylesheet.imports || []);
                  if (h.findIndex(({ id: g }) => g === t.id) !== -1)
                    return void this.fire(
                      new r.z(
                        new Error(
                          `Import with id '${t.id}' already exists in the map's style.`,
                        ),
                      ),
                    );
                  if (!s) return (h.push(t), this._loadImports([t], !0));
                  const p = h.findIndex(({ id: g }) => g === s);
                  return (
                    p === -1 &&
                      this.fire(
                        new r.z(
                          new Error(
                            `Import with id "${s}" does not exist on this map.`,
                          ),
                        ),
                      ),
                    (this.stylesheet.imports = h
                      .slice(0, p)
                      .concat(t)
                      .concat(h.slice(p))),
                    this._loadImports([t], !0, s)
                  );
                }
                updateImport(t, s) {
                  this._checkLoaded();
                  const h = this.stylesheet.imports || [],
                    p = this.getImportIndex(t);
                  return p === -1
                    ? this
                    : typeof s == "string"
                      ? (this.setImportUrl(t, s), this)
                      : (s.url &&
                          s.url !== h[p].url &&
                          this.setImportUrl(t, s.url),
                        r.bv(s.config, h[p].config) ||
                          this.setImportConfig(t, s.config, s.data.schema),
                        r.bv(s.data, h[p].data) ||
                          this.setImportData(t, s.data),
                        this);
                }
                moveImport(t, s) {
                  this._checkLoaded();
                  let h = this.stylesheet.imports || [];
                  const p = this.getImportIndex(t);
                  if (p === -1) return this;
                  const g = this.getImportIndex(s);
                  if (g === -1) return this;
                  const x = h[p],
                    w = this.fragments[p];
                  return (
                    (h = h.filter(({ id: S }) => S !== t)),
                    (this.fragments = this.fragments.filter(
                      ({ id: S }) => S !== t,
                    )),
                    (this.stylesheet.imports = h
                      .slice(0, g)
                      .concat(x)
                      .concat(h.slice(g))),
                    (this.fragments = this.fragments
                      .slice(0, g)
                      .concat(w)
                      .concat(this.fragments.slice(g))),
                    this.mergeLayers(),
                    this
                  );
                }
                setImportUrl(t, s) {
                  this._checkLoaded();
                  const h = this.stylesheet.imports || [],
                    p = this.getImportIndex(t);
                  if (p === -1) return this;
                  h[p].url = s;
                  const g = this.fragments[p];
                  return (
                    (g.style = this._createFragmentStyle(h[p])),
                    g.style.on("style.import.load", () => this.mergeAll()),
                    g.style.loadURL(s),
                    this
                  );
                }
                setImportData(t, s) {
                  this._checkLoaded();
                  const h = this.getImportIndex(t),
                    p = this.stylesheet.imports || [];
                  return h === -1
                    ? this
                    : s
                      ? (this.fragments[h].style.setState(s),
                        this._reloadImports(),
                        this)
                      : (delete p[h].data, this.setImportUrl(t, p[h].url));
                }
                setImportConfig(t, s, h) {
                  this._checkLoaded();
                  const p = this.getImportIndex(t),
                    g = this.stylesheet.imports || [];
                  if (p === -1) return this;
                  s ? (g[p].config = s) : delete g[p].config;
                  const x = this.fragments[p];
                  h && x.style.stylesheet && (x.style.stylesheet.schema = h);
                  const w = x.style.stylesheet && x.style.stylesheet.schema;
                  return (
                    (x.config = s),
                    x.style.updateConfig(s, w),
                    this.updateConfigDependencies(),
                    this
                  );
                }
                removeImport(t) {
                  this._checkLoaded();
                  const s = this.stylesheet.imports || [],
                    h = this.getImportIndex(t);
                  h !== -1 &&
                    (s.splice(h, 1),
                    this.fragments[h].style._remove(),
                    this.fragments.splice(h, 1),
                    this._reloadImports());
                }
                getImportIndex(t) {
                  const s = (this.stylesheet.imports || []).findIndex(
                    (h) => h.id === t,
                  );
                  return (
                    s === -1 &&
                      this.fire(
                        new r.z(
                          new Error(
                            `Import '${t}' does not exist in the map's style and cannot be updated.`,
                          ),
                        ),
                      ),
                    s
                  );
                }
                getLayer(t) {
                  return this._mergedLayers[t];
                }
                getSources() {
                  const t = [];
                  for (const s in this._mergedOtherSourceCaches) {
                    const h = this._mergedOtherSourceCaches[s];
                    h && t.push(h.getSource());
                  }
                  return t;
                }
                getSource(t, s) {
                  const h = this.getSourceCache(t, s);
                  return h && h.getSource();
                }
                getLayerSource(t) {
                  const s = this.getLayerSourceCache(t);
                  return s && s.getSource();
                }
                getSourceCache(t, s) {
                  const h = r.C(t, s);
                  return this._mergedOtherSourceCaches[h];
                }
                getLayerSourceCache(t) {
                  const s = r.C(t.source, t.scope);
                  return t.type === "symbol"
                    ? this._mergedSymbolSourceCaches[s]
                    : this._mergedOtherSourceCaches[s];
                }
                getSourceCaches(t) {
                  if (t == null) return Object.values(this._mergedSourceCaches);
                  const s = [];
                  return (
                    this._mergedOtherSourceCaches[t] &&
                      s.push(this._mergedOtherSourceCaches[t]),
                    this._mergedSymbolSourceCaches[t] &&
                      s.push(this._mergedSymbolSourceCaches[t]),
                    s
                  );
                }
                updateSourceCaches() {
                  const t = this._changes.getUpdatedSourceCaches();
                  for (const s in t) {
                    const h = t[s];
                    h === "reload"
                      ? this.reloadSource(s)
                      : h === "clear" && this.clearSource(s);
                  }
                }
                updateLayers(t) {
                  const s = this._changes.getUpdatedPaintProperties();
                  for (const h of s) {
                    const p = this.getLayer(h);
                    p && p.updateTransitions(t);
                  }
                }
                getGlyphsUrl() {
                  return this.stylesheet.glyphs;
                }
                setGlyphsUrl(t) {
                  ((this.stylesheet.glyphs = t),
                    this.glyphManager.setURL(t, this.scope));
                }
                getImages(t, s, h) {
                  (this.imageManager.getImages(s.images, s.scope, h),
                    this._updateTilesForChangedImages());
                  const p = (x) => {
                      if (x) {
                        const w = s.images.map((S) => r.I.toString(S));
                        x.setDependencies(s.tileID.key, s.type, w);
                      }
                    },
                    g = r.C(s.source, s.scope);
                  (p(this._mergedOtherSourceCaches[g]),
                    p(this._mergedSymbolSourceCaches[g]));
                }
                rasterizeImages(t, s, h) {
                  this.imageManager.rasterizeImages(s, h);
                }
                getGlyphs(t, s, h) {
                  this.glyphManager.getGlyphs(s.stacks, s.scope, h);
                }
                getResource(t, s, h) {
                  return r.dg(s, h);
                }
                getOwnSourceCache(t) {
                  return this._otherSourceCaches[t];
                }
                getOwnLayerSourceCache(t) {
                  return t.type === "symbol"
                    ? this._symbolSourceCaches[t.source]
                    : this._otherSourceCaches[t.source];
                }
                getOwnSourceCaches(t) {
                  const s = [];
                  return (
                    this._otherSourceCaches[t] &&
                      s.push(this._otherSourceCaches[t]),
                    this._symbolSourceCaches[t] &&
                      s.push(this._symbolSourceCaches[t]),
                    s
                  );
                }
                _isSourceCacheLoaded(t) {
                  const s = this.getOwnSourceCaches(t);
                  return s.length === 0
                    ? (this.fire(
                        new r.z(new Error(`There is no source with ID '${t}'`)),
                      ),
                      !1)
                    : s.every((h) => h.loaded());
                }
                has3DLayers() {
                  return this._has3DLayers;
                }
                hasSymbolLayers() {
                  return this._hasSymbolLayers;
                }
                hasCircleLayers() {
                  return this._hasCircleLayers;
                }
                isLayerClipped(t, s) {
                  if (
                    !this._clipLayerPresent &&
                    t.type !== "fill-extrusion" &&
                    t.type !== "building"
                  )
                    return !1;
                  const h =
                      t.type === "fill-extrusion" &&
                      t.sourceLayer === "building",
                    p = t.type === "building";
                  if (t.is3D(!!this.terrain)) {
                    if (
                      h ||
                      p ||
                      (s && s.type === "batched-model") ||
                      t.type === "model"
                    )
                      return !0;
                  } else if (t.type === "symbol") return !0;
                  return !1;
                }
                _clearWorkerCaches() {
                  this.dispatcher.broadcast("clearCaches");
                }
                destroy() {
                  (this._clearWorkerCaches(),
                    this.fragments.forEach((t) => {
                      t.style._remove();
                    }),
                    this.terrainSetForDrapingOnly() &&
                      (delete this.terrain, delete this.stylesheet.terrain));
                }
              }
              ((Er.getSourceType = function (c) {
                return Eh[c];
              }),
                (Er.setSourceType = function (c, t) {
                  Eh[c] = t;
                }),
                (Er.registerForPluginStateChange = r.dh));
              var Sc = `
#define EPSILON 0.0000001
#define PI 3.141592653589793
#ifdef RENDER_CUTOFF
float cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}
#endif`,
                gd = `
out vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}
#ifdef INDICATOR_CUTOUT
uniform vec3 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;
#endif
vec4 applyCutout(vec4 color,float height) {
#ifdef INDICATOR_CUTOUT
float verticalFadeRange=u_indicator_cutout_centers.z*0.25;float holeMinOpacity=mix(1.0,u_indicator_cutout_params.x,smoothstep(u_indicator_cutout_centers.z,u_indicator_cutout_centers.z+verticalFadeRange,height));float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);
#else
return color;
#endif
}
#ifdef DEBUG_WIREFRAME
#define HANDLE_WIREFRAME_DEBUG \\
glFragColor=vec4(0.7,0.0,0.0,0.7); \\
gl_FragDepth=gl_FragCoord.z-0.0001;
#else
#define HANDLE_WIREFRAME_DEBUG
#endif
#ifdef RENDER_CUTOFF
uniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;
#endif
vec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}`,
                _d = `
#define EXTENT 8192.0
#define RAD_TO_DEG 180.0/PI
#define DEG_TO_RAD PI/180.0
#define GLOBE_RADIUS EXTENT/PI/2.0
float wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}
#ifdef PROJECTION_GLOBE_VIEW
vec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {
#ifndef PROJECTED_POS_ON_VIEWPORT
float tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;
#else
return vec3(0.0);
#endif
}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(
unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}
#ifdef RENDER_CUTOFF
uniform vec4 u_cutoff_params;out float v_cutoff_opacity;
#endif
const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)
{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}`,
                ul =
                  "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}",
                dl = `
#define ELEVATION_SCALE 7.0
#define ELEVATION_OFFSET 450.0
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(
mix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}
#else
vec3 elevationVector(vec2 pos) { return vec3(0,0,1); }
#endif
#ifdef TERRAIN
uniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}float prevElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}
#ifdef TERRAIN_VERTEX_MORPHING
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
float nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}
#else
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
return currentElevation(apos);}
#endif
vec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}
#else
float elevation(vec2 pos) { return 0.0; }
#endif
#ifdef DEPTH_OCCLUSION
uniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;
#ifdef DEPTH_D24
float unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}
#else
highp float unpack_depth_rgba(vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}
#endif
bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;
#ifdef DEPTH_D24
float depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);
#else
float depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));
#endif
return coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;
#ifdef DEPTH_D24
highp vec4 depth=vec4(
texture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r
);depth=unpack_depth4(depth);
#else
highp vec4 depth=vec4(
unpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))
);
#endif
return depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;int NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {
#ifdef DEPTH_D24
highp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);
#else
highp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));
#endif
res+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}
#else
bool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }
#endif//DEPTH_OCCLUSION`,
                yd = `#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}
#endif`,
                Vh = `#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {return color;}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}
#endif`,
                as = `#ifdef RASTER_ARRAY
uniform highp sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)
);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)
);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}
#endif`,
                Uh = `#ifdef RASTER_ARRAY
uniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}
#endif
uniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}`,
                mt = `#ifdef RENDER_SHADOWS
uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}
#endif//RENDER_SHADOWS`,
                xd = `#ifdef RENDER_SHADOWS
precision highp sampler2DShadow;uniform sampler2DShadow u_shadowmap_0;uniform sampler2DShadow u_shadowmap_1;uniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;float shadow_sample(sampler2DShadow shadowmap,highp vec3 pos,highp float bias) {highp vec3 coord=vec3(pos.xy*0.5+0.5,pos.z*0.5+0.5-bias);return texture(shadowmap,coord);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {light_view_pos0.xyz/=light_view_pos0.w;
#ifdef SHADOWS_SINGLE_CASCADE
vec2 abs_bounds=abs(light_view_pos0.xy);if (abs_bounds.x >=1.0 || abs_bounds.y >=1.0) {return 0.0;}return shadow_sample(u_shadowmap_0,light_view_pos0.xyz,bias);
#else
light_view_pos1.xyz/=light_view_pos1.w;vec4 abs_bounds=abs(vec4(light_view_pos0.xy,light_view_pos1.xy));if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {return shadow_sample(u_shadowmap_0,light_view_pos0.xyz,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}float occlusion1=shadow_sample(u_shadowmap_1,light_view_pos1.xyz,bias);return clamp(mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth)),0.0,1.0);
#endif
}highp float calculate_shadow_bias(float NDotL) {
#ifdef NORMAL_OFFSET
return 0.5*u_shadow_bias.x;
#else
return 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));
#endif
}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}highp vec2 compute_receiver_plane_depth_bias(highp vec3 pos_dx,highp vec3 pos_dy)
{highp vec2 biasUV=vec2(
pos_dy.y*pos_dx.z-pos_dx.y*pos_dy.z,pos_dx.x*pos_dy.z-pos_dy.x*pos_dx.z);biasUV*=1.0/((pos_dx.x*pos_dy.y)-(pos_dx.y*pos_dy.x));return biasUV;}float shadowed_light_factor_plane_bias(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {highp vec3 light_view_pos0_xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;highp vec3 light_view_pos0_ddx=dFdx(light_view_pos0_xyz);highp vec3 light_view_pos0_ddy=dFdy(light_view_pos0_xyz);highp vec2 plane_depth_bias=compute_receiver_plane_depth_bias(light_view_pos0_ddx,light_view_pos0_ddy);highp float bias=dot(vec2(u_shadow_texel_size,u_shadow_texel_size),plane_depth_bias)+0.0001;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}
#endif`;
              const fl = [];
              (xs(Sc, fl), xs(_d, fl), xs(gd, fl));
              const pl = {
                  "_prelude_fog.vertex.glsl": yd,
                  "_prelude_terrain.vertex.glsl": dl,
                  "_prelude_shadow.vertex.glsl": mt,
                  "_prelude_fog.fragment.glsl": Vh,
                  "_prelude_shadow.fragment.glsl": xd,
                  "_prelude_lighting.glsl": `
#ifdef LIGHTING_3D_MODE
uniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}
#endif//LIGHTING_3D_MODE`,
                  "_prelude_raster_array.glsl": as,
                  "_prelude_raster_particle.glsl": Uh,
                },
                Ec = {};
              (bi("", dl), bi(Vh, yd), bi(xd, mt), bi(as, ""), bi(Uh, ""));
              const Ic = bi(gd, _d),
                Ns = Sc;
              var jh = {
                background: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec4 u_color;uniform float u_opacity;
#ifdef LIGHTING_3D_MODE
in vec4 v_color;
#endif
void main() {vec4 out_color;
#ifdef LIGHTING_3D_MODE
out_color=v_color;
#else
out_color=u_color;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_fog.vertex.glsl"
#include "_prelude_lighting.glsl"
in vec2 a_pos;uniform mat4 u_matrix;
#ifdef LIGHTING_3D_MODE
uniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;
#endif
void main() {gl_Position=u_matrix*vec4(a_pos,0,1);
#ifdef LIGHTING_3D_MODE
v_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`,
                ),
                backgroundPattern: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`,
                ),
                building: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec4 v_color;in highp vec3 v_normal;in highp float v_height;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;
#endif
uniform lowp float u_opacity;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 apply_lighting_linear(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return color*(ambient_contrib+directional_contrib);}void main() {vec4 color=vec4(v_color.rgb,1.0);vec3 normal=normalize(v_normal);vec3 xy_flipped_normal=vec3(-normal.xy,normal.z);float shadowed_lighting_factor=0.0;
#ifdef RENDER_SHADOWS
shadowed_lighting_factor=shadowed_light_factor_normal(xy_flipped_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
shadowed_lighting_factor=dot(normal,u_lighting_directional_dir);
#endif
color.rgb=apply_lighting_linear(color.rgb,xy_flipped_normal,shadowed_lighting_factor);color.rgb=mix(color.rgb,v_color.rgb,v_color.a);
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos,v_height));
#endif
color.rgb=linearTosRGB(color.rgb);color*=u_opacity;
#ifdef RENDER_CUTOFF
color*=v_cutoff_opacity;
#endif
#ifdef INDICATOR_CUTOUT
color=applyCutout(color,v_height);
#endif
glFragColor=color; 
#ifdef DEBUG_SHOW_NORMALS
color.rgb=xy_flipped_normal*0.5+vec3(0.5,0.5,0.5);color.a=1.0;glFragColor=color;
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec3 a_pos_3f;in vec3 a_normal_3f;out vec4 v_color;out highp vec3 v_normal;out highp float v_height;uniform mat4 u_matrix;uniform mat4 u_normal_matrix;
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;
#endif
vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}
#pragma mapbox: define-attribute-vertex-shader-only highp vec2 part_color_emissive
void main() {
#pragma mapbox: initialize-attribute-custom highp vec2 part_color_emissive
vec4 color_emissive=decode_color(part_color_emissive);v_color=vec4(sRGBToLinear(color_emissive.rgb),color_emissive.a);v_normal=vec3(u_normal_matrix*vec4(a_normal_3f,0.0));vec3 pos=a_pos_3f;v_height=pos.z;gl_Position=u_matrix*vec4(pos,1.0);
#ifdef RENDER_SHADOWS
vec3 shadow_pos=pos;
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset_model(v_normal);shadow_pos+=offset*shadow_normal_offset_multiplier0();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shadow_pos,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(shadow_pos,1.0);v_depth_shadows=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
}`,
                ),
                buildingDepth: bi(
                  `in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`,
                  "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;void main() {gl_Position=u_matrix*vec4(a_pos_3f,1.0);v_depth=gl_Position.z/gl_Position.w;}",
                ),
                circle: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
uniform float u_emissive_strength;void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float antialiase_blur_opacity=smoothstep(0.0,antialiasblur,extrude_length-1.0);float opacity_t=blur_positive==1.0 ? 
smoothstep(0.0,-antialiased_blur,1.0-extrude_length) : 
smoothstep(antialiased_blur,0.0,extrude_length-1.0)-antialiase_blur_opacity;float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(
antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)
);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_apply_premultiplied(out_color,v_fog_pos);
#endif
glFragColor=out_color*(v_visibility*opacity_t);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`,
                  `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define NUM_VISIBILITY_RINGS 2
#define INV_SQRT2 0.70710678
#define ELEVATION_BIAS 0.0001
#define NUM_SAMPLES_PER_RING 16
uniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
#ifdef ELEVATED_ROADS
in float a_circle_z_offset;
#endif
out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
vec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {
#if defined(TERRAIN)
return elevation(pos)+ELEVATION_BIAS;
#else
return 0.0;
#endif
}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);
#ifdef PITCH_WITH_MAP
#ifdef PROJECTION_GLOBE_VIEW
return u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );
#else
return u_matrix*( world_center+vec4(sample_offset,0,0) );
#endif
#else
return projected_center+vec4(sample_offset,0,0);
#endif
}float get_sample_step() {
#ifdef PITCH_WITH_MAP
return 2.0*PI/float(NUM_SAMPLES_PER_RING);
#else
return PI/float(NUM_SAMPLES_PER_RING);
#endif
}void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);
#else 
surface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);
#endif
#ifdef ELEVATED_ROADS
world_center.z+=a_circle_z_offset+ELEVATION_BIAS;
#endif
vec4 projected_center=u_matrix*world_center;float view_scale=0.0;
#ifdef PITCH_WITH_MAP
#ifdef SCALE_WITH_MAP
view_scale=1.0;
#else
view_scale=projected_center.w/u_camera_to_center_distance;
#endif
#else
#ifdef SCALE_WITH_MAP
view_scale=u_camera_to_center_distance;
#else
view_scale=projected_center.w;
#endif
#endif
gl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;
#ifdef TERRAIN
float step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;
#ifdef PITCH_WITH_MAP
float cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;
#else
occlusion_world_center=world_center;occlusion_projected_center=projected_center;
#endif
for(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);
#else
visibility=1.0;
#endif
#ifdef PROJECTION_GLOBE_VIEW
visibility=1.0;
#endif
v_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);
#ifdef FOG
v_fog_pos=fog_position(world_center.xyz);
#endif
}`,
                ),
                clippingMask: bi(
                  "void main() {glFragColor=vec4(1.0);}",
                  "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}",
                ),
                heatmap: bi(
                  `#include "_prelude_fog.fragment.glsl"
uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);
#ifdef FOG
if (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_terrain.vertex.glsl"
#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#else
pos=vec3(tilePos+extrude,elevation(tilePos));
#endif
gl_Position=u_matrix*vec4(pos,1);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`,
                ),
                heatmapTexture: bi(
                  `uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(0.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}",
                ),
                collisionBox: bi(
                  "in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}",
                  `#include "_prelude_terrain.vertex.glsl"
in vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}`,
                ),
                collisionCircle: bi(
                  "in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}",
                  `in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(
mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}`,
                ),
                debug: bi(
                  "uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}",
                  `#include "_prelude_terrain.vertex.glsl"
in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;
#endif
out vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;
#ifdef PROJECTION_GLOBE_VIEW
gl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);
#else
gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);
#endif
}`,
                ),
                elevatedStructuresDepth: bi(
                  `void main() {
#ifndef DEPTH_TEXTURE
glFragColor=vec4(0.);
#endif
}`,
                  "in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform float u_depth_bias;void main() {gl_Position=u_matrix*vec4(a_pos,a_height,1);gl_Position.z=gl_Position.z+u_depth_bias;}",
                ),
                elevatedStructuresDepthReconstruct: bi(
                  `#ifdef DEPTH_RECONSTRUCTION
in float v_height;
#endif
void main() {
#ifdef DEPTH_RECONSTRUCTION
if (v_height >=0.0)
discard;
#endif
glFragColor=vec4(1.0,0.0,0.0,1.0);}`,
                  `in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform vec3 u_camera_pos;uniform highp float u_depth_bias;uniform lowp float u_height_scale;uniform lowp float u_reset_depth;
#ifdef DEPTH_RECONSTRUCTION
out float v_height;
#endif
void main() {vec3 vpos=vec3(a_pos,a_height*u_height_scale);
#ifdef DEPTH_RECONSTRUCTION
if (u_camera_pos.z > vpos.z) {vpos-=(u_camera_pos-vpos)*(vpos.z/(u_camera_pos.z-vpos.z));}v_height=a_height;
#endif
gl_Position=u_matrix*vec4(vpos,1);gl_Position.z=u_reset_depth==1.0 ? gl_Position.w : gl_Position.z+u_depth_bias;}`,
                ),
                elevatedStructures: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
in vec3 v_normal;in float v_height;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth;
#endif
vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}vec3 compute_view_dependent_emissive_color(float ndotl,float emissive_strength,vec3 color)
{color=sRGBToLinear(color);color=color*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);color=linearTosRGB(color.rgb);return color;}uniform float u_emissive_strength;
#pragma mapbox: define highp vec4 structure_color
void main() {
#pragma mapbox: initialize highp vec4 structure_color
vec3 color=structure_color.xyz;
#ifdef LIGHTING_3D_MODE
vec3 normal=normalize(v_normal);vec3 transformed_normal=vec3(-normal.xy,normal.z);float ndotl=calculate_NdotL(transformed_normal);float emissive_strength=u_emissive_strength;emissive_strength=0.0;vec3 emissive_color=compute_view_dependent_emissive_color(ndotl,emissive_strength,color.xyz);
#ifdef RENDER_SHADOWS
float shadowed_lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color.rgb=apply_lighting(color.rgb,transformed_normal,shadowed_lighting_factor);
#else
color=apply_lighting(color,transformed_normal);
#endif
color=mix(color,emissive_color,emissive_strength);if (v_height < 0.0) {float penetration=max(v_height+7.5,0.0);float occlusion=1.0-1.0/PI*acos(1.0-penetration/4.0);color=color*(1.0-pow(occlusion,2.0)*0.3);}
#endif
#ifdef FOG
color=fog_apply(color,v_fog_pos);
#endif
vec4 out_color=vec4(color,1.0);
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_height);
#endif
glFragColor=out_color;HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec2 a_pos;in float a_height;in vec3 a_pos_normal_3;uniform mat4 u_matrix;out vec3 v_normal;out float v_height;
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth;
#endif
#pragma mapbox: define highp vec4 structure_color
void main() {
#pragma mapbox: initialize highp vec4 structure_color
v_normal=a_pos_normal_3/16384.0;v_height=a_height;vec3 pos=vec3(a_pos,a_height);gl_Position=u_matrix*vec4(pos,1);
#ifdef RENDER_SHADOWS
vec3 shd_pos0=pos;vec3 shd_pos1=pos;
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(-v_normal.xy,v_normal.z));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`,
                ),
                fill: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#ifdef ELEVATED_ROADS
in highp float v_road_z_offset;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
vec4 out_color=color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);
#ifdef ELEVATED_ROADS
out_color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#else
out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
out_color*=opacity;
#ifdef INDICATOR_CUTOUT
if (v_z_offset >=0.0) {out_color=applyCutout(out_color,v_z_offset);}
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;out highp float v_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp float z_offset
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;v_road_z_offset=z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=z_offset;
#endif
}`,
                ),
                fillOutline: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
in highp vec2 v_pos;uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
uniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp float z_offset
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`,
                ),
                fillOutlinePattern: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;
#ifdef FILL_PATTERN_TRANSITION
uniform float u_pattern_transition;
#endif
uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
in highp vec2 v_pos;in highp vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef FILL_PATTERN_TRANSITION
vec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
out highp vec2 v_pos;out highp vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
#pragma mapbox: define lowp float pixel_ratio
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
#pragma mapbox: initialize lowp float pixel_ratio
#pragma mapbox: initialize highp float z_offset
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`,
                ),
                fillPattern: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;
#ifdef FILL_PATTERN_TRANSITION
uniform float u_pattern_transition;
#endif
in highp vec2 v_pos;uniform float u_emissive_strength;
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#ifdef ELEVATED_ROADS
in highp float v_road_z_offset;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef FILL_PATTERN_TRANSITION
vec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);
#ifdef ELEVATED_ROADS
out_color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#else
out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;
#ifdef ELEVATED_ROADS
in float a_road_z_offset;out highp float v_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
out highp vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
#pragma mapbox: define lowp float pixel_ratio
#pragma mapbox: define highp float z_offset
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
#pragma mapbox: initialize highp float z_offset
#ifdef FILL_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;
#ifdef ELEVATED_ROADS
z_offset+=a_road_z_offset;v_road_z_offset=z_offset;
#endif
float hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);
#ifdef RENDER_SHADOWS
vec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`,
                ),
                fillExtrusion: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec4 v_color;in vec4 v_flat;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;
#endif
uniform lowp float u_opacity;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;in vec2 v_ao;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
in vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
in highp vec3 v_normal;
#endif
uniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;
#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)
in float v_flood_radius;in float v_has_floodlight;
#endif
in float v_height;
#pragma mapbox: define highp float emissive_strength
void main() {
#pragma mapbox: initialize highp float emissive_strength
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
vec3 normal=normalize(v_normal);
#endif
float z;vec4 color=v_color;
#ifdef ZERO_ROOF_RADIUS
z=float(normal.z > 0.00001);
#ifdef LIGHTING_3D_MODE
normal=mix(normal,vec3(0.0,0.0,1.0),z);
#else
color=mix(v_color,v_roof_color,z);
#endif
#endif
float h=max(0.0,v_height);float ao_shade=1.0;
#ifdef FAUX_AO
float intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;
#ifdef ZERO_ROOF_RADIUS
concave*=(1.0-z);
#endif
float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);
#ifdef LIGHTING_3D_MODE
#ifdef FLOOD_LIGHT
color.rgb*=mix(ao_shade,1.0,v_has_floodlight);
#else
color.rgb*=ao_shade;
#endif
#else
color.rgb*=ao_shade;
#endif
#endif
#ifdef LIGHTING_3D_MODE
float flood_radiance=0.0;
#ifdef FLOOD_LIGHT
flood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;
#endif
#ifdef RENDER_SHADOWS
#ifdef FLOOD_LIGHT
float ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);
#else
float shadowed_lighting_factor;
#ifdef RENDER_CUTOFF
shadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}
#else
shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);
#endif
color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);
#endif
#else
color.rgb=apply_lighting(color.rgb,normal);
#ifdef FLOOD_LIGHT
color.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);
#endif
#endif
color.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));
#endif
#ifdef INDICATOR_CUTOUT
color=applyCutout(color,h);
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_lighting.glsl"
uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
uniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
out vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
out highp vec3 v_normal;
#endif
#ifdef FAUX_AO
uniform lowp vec2 u_ao;out vec2 v_ao;
#endif
#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)
out float v_flood_radius;out float v_has_floodlight;
#endif
out float v_height;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
#pragma mapbox: define highp float flood_light_wall_radius
#pragma mapbox: define highp float line_width
#pragma mapbox: define highp float emissive_strength
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize highp float flood_light_wall_radius
#pragma mapbox: initialize highp float line_width
#pragma mapbox: initialize highp float emissive_strength
base*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
v_normal=normal;
#endif
base=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);
#else
h=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
float cutoff=1.0;vec3 scaled_pos=pos;
#ifdef RENDER_CUTOFF
vec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=cutoff_opacity(u_cutoff_params,ground.z);if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
gl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=pos;vec3 shd_pos1=pos;
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);
#endif
float NdotL=0.0;float colorvalue=0.0;
#ifndef LIGHTING_3D_MODE
colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}
#endif
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
#ifdef FLOOD_LIGHT
float is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;
#endif
v_color=vec4(color.rgb,1.0);float ndotl=calculate_NdotL(normal);v_flat.rgb=sRGBToLinear(color.rgb);v_flat.rgb=v_flat.rgb*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);v_flat=vec4(linearTosRGB(v_flat.rgb),1.0);
#else
v_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
float roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`,
                ),
                fillExtrusionDepth: bi(
                  `in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`,
                  `#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp float line_width
#pragma mapbox: define highp vec4 color
out highp float v_depth;void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp float line_width
#pragma mapbox: initialize highp vec4 color
base*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
vec3 pos;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;float ele=elevation(pos_nx.xy);float c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);float h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);
#else
pos=vec3(pos_nx.xy,t > 0.0 ? height : base);
#endif
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}`,
                ),
                fillExtrusionPattern: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;
#ifdef FILL_EXTRUSION_PATTERN_TRANSITION
uniform float u_pattern_transition;
#endif
#ifdef FAUX_AO
uniform lowp vec2 u_ao;in vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
in vec3 v_normal;
#endif
in highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define mediump vec4 pattern
#ifdef FILL_EXTRUSION_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
#pragma mapbox: define highp float pixel_ratio
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize mediump vec4 pattern
#ifdef FILL_EXTRUSION_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
#pragma mapbox: initialize highp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);
#ifdef FILL_EXTRUSION_PATTERN_TRANSITION
vec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;
#else
out_color=out_color*v_lighting;
#endif
#ifdef FAUX_AO
float intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,height);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#include "_prelude_lighting.glsl"
uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef RENDER_WALL_MODE
in vec3 a_join_normal_inside;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
#ifdef TERRAIN
uniform int u_height_type;uniform int u_base_type;
#endif
out highp vec2 v_pos;out vec4 v_lighting;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;out vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
out vec3 v_normal;
#endif
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump vec4 pattern
#ifdef FILL_EXTRUSION_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
#pragma mapbox: define highp float pixel_ratio
#pragma mapbox: define highp float line_width
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump vec4 pattern
#ifdef FILL_EXTRUSION_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
#pragma mapbox: initialize highp float pixel_ratio
#pragma mapbox: initialize highp float line_width
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=z;vec3 p;float c_ele;
#ifdef TERRAIN
bool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;p=vec3(pos_nx.xy,h);
#else
p=vec3(pos_nx.xy,z);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
#ifdef RENDER_WALL_MODE
vec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;
#endif
float hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0
? pos_nx.xy
: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;
#ifdef LIGHTING_3D_MODE
NdotL=calculate_NdotL(normal);
#else
NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);
#endif
if (normal.y !=0.0) {float r=0.84;
#ifndef LIGHTING_3D_MODE
r=mix(0.7,0.98,1.0-u_lightintensity);
#endif
NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
v_normal=normal;
#else
v_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;
#endif
#ifdef FOG
v_fog_pos=fog_position(p);
#endif
}`,
                ),
                groundShadow: bi(
                  `#include "_prelude_shadow.fragment.glsl"
precision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;
#ifdef FOG
in float v_fog_opacity;
#endif
void main() {float light=shadowed_light_factor_plane_bias(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);
#ifdef RENDER_CUTOFF
shadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));
#endif
#ifdef FOG
shadow=mix(shadow,vec3(1.0),v_fog_opacity);
#endif
#ifdef INDICATOR_CUTOUT
shadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0),0.0).r);
#endif
glFragColor=vec4(shadow,1.0);}`,
                  `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;
#ifdef FOG
out float v_fog_opacity;
#endif
void main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);
#ifdef FOG
v_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);
#endif
}`,
                ),
                fillExtrusionGroundEffect: bi(
                  `uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;
#ifdef SDF_SUBPASS
in highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}
#ifdef FOG
in highp float v_fog;
#endif
#endif
void main() {
#ifdef CLEAR_SUBPASS
vec4 color=vec4(1.0);
#ifdef CLEAR_FROM_TEXTURE
color=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));
#endif
glFragColor=color;
#else
#ifdef SDF_SUBPASS
highp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;
#ifdef FOG
fog=v_fog;
#endif
#ifdef RENDER_CUTOFF
fog*=v_cutoff_opacity;
#endif
glFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));
#else
vec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);
#ifdef OVERDRAW_INSPECTOR
color=vec4(1.0);
#endif
glFragColor=color;
#endif
HANDLE_WIREFRAME_DEBUG;
#endif
}`,
                  `#include "_prelude_fog.vertex.glsl"
in highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;
#ifdef SDF_SUBPASS
out highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;
#ifdef FOG
out highp float v_fog;
#endif
#endif
uniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;
#pragma mapbox: define highp float flood_light_ground_radius
const float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {
#pragma mapbox: initialize highp float flood_light_ground_radius
vec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;
#ifdef SDF_SUBPASS
v_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);
#ifdef FOG
v_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);
#endif
#endif
float hidden_by_landmark=0.0;
#ifdef HAS_CENTROID
hidden_by_landmark=a_hidden_by_landmark;
#endif
float isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
}`,
                ),
                hillshadePrepare: bi(
                  `precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(
(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)
)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(
deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}`,
                  "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}",
                ),
                hillshade: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef LIGHTING_3D_MODE
glFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);
#endif
#ifdef FOG
glFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`,
                ),
                line: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform lowp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_floor_width_scale;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec3 v_uv;
#ifdef ELEVATED_ROADS
in highp float v_road_z_offset;
#endif
#ifdef RENDER_LINE_DASH
uniform sampler2D u_dash_image;in vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform sampler2D u_gradient_image;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float border_width
#pragma mapbox: define lowp vec4 border_color
float linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float border_width
#pragma mapbox: initialize lowp vec4 border_color
float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);
#ifdef RENDER_LINE_DASH
float sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;float scaled_floorwidth=(floorwidth*u_floor_width_scale);alpha*=linearstep(0.5-sdfgamma/scaled_floorwidth,0.5+sdfgamma/scaled_floorwidth,sdfdist);
#endif
highp vec4 out_color;
#ifdef RENDER_LINE_GRADIENT
out_color=texture(u_gradient_image,v_uv.xy);
#else
out_color=color;
#endif
float trim_alpha=1.0;
#ifdef RENDER_LINE_TRIM_OFFSET
highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);out_color=mix(out_color,u_trim_color,transition_factor);trim_alpha=1.0-transition_factor;}
#endif
if (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}
#ifdef RENDER_LINE_BORDER
float edgeBlur=((border_width*u_width_scale)+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color=mix(border_color*trim_alpha,out_color,smoothAlpha);}}
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);
#ifdef ELEVATED_ROADS
out_color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#else
out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
out_color*=(alpha*opacity);
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_z_offset);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define EXTRUDE_SCALE 0.015873016
in vec2 a_pos_normal;in vec4 a_data;
#if defined(ELEVATED) || defined(ELEVATED_ROADS) || defined(VARIABLE_LINE_WIDTH)
in vec3 a_z_offset_width;
#endif
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
in highp vec3 a_packed;
#endif
#ifdef RENDER_LINE_DASH
in float a_linesofar;
#endif
uniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;uniform float u_width_scale;uniform highp float u_floor_width_scale;
#ifdef ELEVATED
uniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {
#ifdef ELEVATION_REFERENCE_SEA
return 0.0;
#else
return elevation(apos);
#endif
}
#endif
out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec3 v_uv;
#ifdef ELEVATED_ROADS
out highp float v_road_z_offset;
#endif
#ifdef RENDER_LINE_DASH
uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform float u_image_height;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float border_width
#pragma mapbox: define lowp vec4 border_color
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float border_width
#pragma mapbox: initialize lowp vec4 border_color
float a_z_offset;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
a_z_offset=a_z_offset_width.x;
#endif
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth;
#ifdef VARIABLE_LINE_WIDTH
float left=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);halfwidth=(u_width_scale*(left==1.0 ? a_z_offset_width.y : a_z_offset_width.z))/2.0;
#else
halfwidth=(u_width_scale*width)/2.0;
#endif
offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;
#ifdef ELEVATED_ROADS
v_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;
#else
#ifdef ELEVATED
vec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;
#ifdef CROSS_SLOPE_VERTICAL
float top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);
#else
#ifdef CROSS_SLOPE_HORIZONTAL
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;
#else
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;
#endif
#endif
gl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);
#else
gl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);
#endif
#endif
#ifdef ELEVATED_ROADS
#ifdef RENDER_SHADOWS
vec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;
#ifdef NORMAL_OFFSET
vec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#endif
#ifndef RENDER_TO_TEXTURE
float epsilon=0.0001;float extrude_length_without_perspective=max(length(dist),epsilon);float extrude_length_with_perspective=max(length(projected_extrude_xy/gl_Position.w*u_units_to_pixels),epsilon);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));
#else
v_gamma_scale=1.0;
#endif
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
highp float a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float line_progress=a_packed[2];
#ifdef RENDER_LINE_GRADIENT
highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec3(a_uv_x,a_split_index*texel_height-half_texel_height,line_progress);
#else
v_uv=vec3(a_uv_x,0.0,line_progress);
#endif
#endif
#ifdef RENDER_LINE_DASH
float scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/(floorwidth*u_floor_width_scale),(-normal.y*height+dash.x+0.5)/u_texsize.y);
#endif
v_width2=vec2(outset,inset);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=a_z_offset;
#endif
}`,
                ),
                linePattern: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
uniform highp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;uniform sampler2D u_image;
#ifdef LINE_PATTERN_TRANSITION
uniform float u_pattern_transition;
#endif
in vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef RENDER_LINE_TRIM_OFFSET
in highp vec3 v_uv;
#endif
#ifdef ELEVATED_ROADS
in highp float v_road_z_offset;
#endif
#ifdef LINE_JOIN_NONE
in vec2 v_pattern_data;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
uniform float u_emissive_strength;
#pragma mapbox: define mediump vec4 pattern
#ifdef LINE_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
#pragma mapbox: define mediump float pixel_ratio
#pragma mapbox: define mediump float blur
#pragma mapbox: define mediump float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern
#ifdef LINE_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
#pragma mapbox: initialize mediump float pixel_ratio
#pragma mapbox: initialize mediump float blur
#pragma mapbox: initialize mediump float opacity
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;highp float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);
#ifdef LINE_PATTERN_TRANSITION
vec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl*texel_size-texel_size,pattern_b_br*texel_size+texel_size,vec2(x,y));vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);color=color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;
#endif
#ifdef RENDER_LINE_TRIM_OFFSET
highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);color=mix(color,color.a*u_trim_color,transition_factor);}
#endif
#ifdef LINE_JOIN_NONE
highp float pattern_len=pattern_size/aspect;highp float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);highp float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;highp float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}
#endif
#ifdef LIGHTING_3D_MODE
color=apply_lighting_with_emission_ground(color,u_emissive_strength);
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);
#ifdef ELEVATED_ROADS
color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#else
color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);
#endif
#endif
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
color*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}
#ifdef INDICATOR_CUTOUT
color=applyCutout(color,v_z_offset);
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
in vec3 a_z_offset_width;
#endif
#ifdef RENDER_LINE_TRIM_OFFSET
in highp vec3 a_packed;
#endif
in highp float a_linesofar;
#ifdef LINE_JOIN_NONE
in highp vec3 a_pattern_data;out vec2 v_pattern_data;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#endif
uniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;uniform float u_width_scale;uniform float u_floor_width_scale;
#ifdef ELEVATED
uniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {
#ifdef ELEVATION_REFERENCE_SEA
return 0.0;
#else
return elevation(apos);
#endif
}
#endif
out vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef RENDER_LINE_TRIM_OFFSET
out highp vec3 v_uv;
#endif
#ifdef ELEVATED_ROADS
out highp float v_road_z_offset;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#pragma mapbox: define mediump float blur
#pragma mapbox: define mediump float opacity
#pragma mapbox: define mediump float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define mediump float floorwidth
#pragma mapbox: define mediump vec4 pattern
#ifdef LINE_PATTERN_TRANSITION
#pragma mapbox: define mediump vec4 pattern_b
#endif
#pragma mapbox: define mediump float pixel_ratio
void main() {
#pragma mapbox: initialize mediump float blur
#pragma mapbox: initialize mediump float opacity
#pragma mapbox: initialize mediump float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize mediump float floorwidth
#pragma mapbox: initialize mediump vec4 pattern
#ifdef LINE_PATTERN_TRANSITION
#pragma mapbox: initialize mediump vec4 pattern_b
#endif
#pragma mapbox: initialize mediump float pixel_ratio
float a_z_offset;
#if defined(ELEVATED) || defined(ELEVATED_ROADS)
a_z_offset=a_z_offset_width.x;
#endif
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=(u_width_scale*width)/2.0;offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;
#ifdef ELEVATED_ROADS
v_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;
#else
#ifdef ELEVATED
vec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;
#ifdef CROSS_SLOPE_VERTICAL
float top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);
#else
#ifdef CROSS_SLOPE_HORIZONTAL
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;
#else
float ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;
#endif
#endif
gl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);
#else
gl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);
#endif
#endif
#ifdef ELEVATED_ROADS
#ifdef RENDER_SHADOWS
vec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;
#ifdef NORMAL_OFFSET
vec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#endif
#ifndef RENDER_TO_TEXTURE
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));
#else
v_gamma_scale=1.0;
#endif
#ifdef RENDER_LINE_TRIM_OFFSET
highp float a_uv_x=a_packed[0];highp float line_progress=a_packed[2];v_uv=vec3(a_uv_x,0.0,line_progress);
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=(floorwidth*u_floor_width_scale);
#ifdef LINE_JOIN_NONE
v_width=(floorwidth*u_floor_width_scale)+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=a_z_offset;
#endif
}`,
                ),
                raster: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_raster_array.glsl"
uniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;
#ifdef PROJECTION_GLOBE_VIEW
in float v_split_fade;
#endif
uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;
#ifndef RASTER_ARRAY
uniform highp sampler2D u_image0;uniform sampler2D u_image1;
#endif
#ifdef RASTER_COLOR
uniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;
#endif
void main() {vec4 color0,color1,color;vec2 value;
#ifdef RASTER_COLOR
#ifdef RASTER_ARRAY
#ifdef RASTER_ARRAY_LINEAR
value=mix(
raTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t
);
#else
value=mix(
raTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t
);
#endif
if (value.y > 0.0) value.x/=value.y;
#else
color=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);
#endif
color=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;
#else
color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);
#endif
color.a*=u_opacity;
#ifdef GLOBE_POLES
color.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);
#endif
vec3 rgb=color.rgb;rgb=vec3(
dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;
#endif
#ifdef FOG
highp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));
#endif
glFragColor=vec4(out_color*color.a,color.a);
#ifdef PROJECTION_GLOBE_VIEW
glFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));
#endif
#ifdef RENDER_CUTOFF
glFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;
#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8
#ifdef GLOBE_POLES
in vec3 a_globe_pos;in vec2 a_uv;
#else
in vec2 a_pos;in vec2 a_texture_pos;
#endif
out vec2 v_pos0;out vec2 v_pos1;out float v_depth;
#ifdef PROJECTION_GLOBE_VIEW
out float v_split_fade;
#endif
void main() {vec2 uv;
#ifdef GLOBE_POLES
vec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);
#endif
#else
float w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;
#ifdef PROJECTION_GLOBE_VIEW
vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    
v_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
#else
gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#endif
#endif
v_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;
#ifdef RENDER_CUTOFF
v_depth=gl_Position.z;
#endif
}`,
                ),
                rasterParticle: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;
#endif
#ifdef FOG
highp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));
#endif
glFragColor=vec4(out_color*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;
#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8
in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;
#ifdef PROJECTION_GLOBE_VIEW
vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
#else
uv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
#endif
v_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`,
                ),
                rasterParticleDraw: bi(
                  "uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}",
                  `#include "_prelude_raster_particle.glsl"
in float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(
mod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}`,
                ),
                rasterParticleTexture: bi(
                  "uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}",
                  "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}",
                ),
                rasterParticleUpdate: bi(
                  `#include "_prelude_raster_particle.glsl"
uniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(
linearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)
);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}`,
                  "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}",
                ),
                symbol: bi(
                  `#include "_prelude_lighting.glsl"
#include "_prelude_shadow.fragment.glsl"
#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;uniform lowp float u_scale_factor;
#ifdef ICON_TRANSITION
uniform float u_icon_transition;
#endif
#ifdef COLOR_ADJUSTMENT
uniform mat4 u_color_adj_mat;
#endif
#ifdef INDICATOR_CUTOUT
in highp float v_z_offset;
#else
#ifdef Z_OFFSET
#ifdef RENDER_SHADOWS
in highp float v_z_offset;
#endif
#endif
#endif
in vec2 v_tex_a;
#ifdef ICON_TRANSITION
in vec2 v_tex_b;
#endif
in float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;
#ifdef RENDER_TEXT_AND_SYMBOL
in float is_sdf;in vec2 v_tex_a_icon;
#endif
#ifdef Z_OFFSET
#ifdef RENDER_SHADOWS
uniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;
#endif
#endif
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
#pragma mapbox: define lowp float emissive_strength
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
#pragma mapbox: initialize lowp float emissive_strength
vec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];
#ifdef RENDER_TEXT_AND_SYMBOL
if (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
return;}
#endif
#ifdef RENDER_SDF
float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*u_scale_factor*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width*u_scale_factor/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;
#else
#ifdef ICON_TRANSITION
vec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);
#else
out_color=texture(u_texture,v_tex_a);
#endif
#ifdef COLOR_ADJUSTMENT
out_color=u_color_adj_mat*out_color;
#endif
#endif
out_color*=opacity*fade_opacity;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,emissive_strength);
#ifdef Z_OFFSET
#ifdef RENDER_SHADOWS
float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(v_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);
#endif
#endif
#endif
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color,v_z_offset);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_terrain.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;
#ifdef Z_OFFSET
in float a_auto_z_offset;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_globe_anchor;in vec3 a_globe_normal;
#endif
#ifdef ICON_TRANSITION
in vec2 a_texb;
#endif
#ifdef OCCLUSION_QUERIES
in float a_occlusion_query_opacity;
#endif
#ifdef ELEVATED_ROADS
in vec3 a_x_axis;in vec3 a_y_axis;uniform float u_normal_scale;
#endif
#ifdef INDICATOR_CUTOUT
out highp float v_z_offset;
#else
#ifdef Z_OFFSET
#ifdef RENDER_SHADOWS
out highp float v_z_offset;
#endif
#endif
#endif
uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;
#endif
out vec2 v_tex_a;
#ifdef ICON_TRANSITION
out vec2 v_tex_b;
#endif
out float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;
#ifdef RENDER_TEXT_AND_SYMBOL
out float is_sdf;out vec2 v_tex_a_icon;
#endif
#ifdef Z_OFFSET
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;
#endif
#endif
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
#pragma mapbox: define lowp float emissive_strength
#pragma mapbox: define lowp float occlusion_opacity
#pragma mapbox: define lowp float z_offset
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
#pragma mapbox: initialize lowp float emissive_strength
#pragma mapbox: initialize lowp float occlusion_opacity
#pragma mapbox: initialize lowp float z_offset
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);
#ifdef Z_OFFSET
e+=a_auto_z_offset;
#endif
vec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;
#ifdef PROJECTION_GLOBE_VIEW
mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;
#else
world_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(
0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;
#ifdef PROJECTION_GLOBE_VIEW
vec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;
#else
offsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;
#endif
vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;
#ifdef PROJECTION_GLOBE_VIEW
#ifdef PROJECTED_POS_ON_VIEWPORT
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xyz+h,1.0);
#else
vec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz,mercator_pos,u_zoom_transition)+h;projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);    
#endif
#else
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);
#endif
highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);
#ifdef TERRAIN
#ifdef PITCH_WITH_MAP_TERRAIN
vec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);
#endif
#endif
#ifdef Z_OFFSET
z+=u_pitch_with_map ? a_auto_z_offset+z_offset : 0.0;
#else
z+=u_pitch_with_map ? z_offset : 0.0;
#endif
float occlusion_fade=globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));
#ifdef DEPTH_OCCLUSION
float depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;
#endif
#ifdef OCCLUSION_QUERIES
float occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;
#endif
float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);vec3 pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;
#else
#ifdef ELEVATED_ROADS
vec3 xAxis=vec3(a_x_axis.xy,a_x_axis.z*u_normal_scale);vec3 yAxis=vec3(a_y_axis.xy,a_y_axis.z*u_normal_scale);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;
#else
pos=vec3(projected_pos.xy/projected_pos.w+offset,z);
#endif
#endif
gl_Position=mix(u_coord_matrix*vec4(pos,1.0),AWAY,hidden);float gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;
#ifdef RENDER_TEXT_AND_SYMBOL
is_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;
#endif
#ifdef ICON_TRANSITION
v_tex_b=a_texb/u_texsize;
#endif
#ifdef Z_OFFSET
#ifdef RENDER_SHADOWS
vec4 shd_pos=u_inv_matrix*vec4(pos,1.0);vec3 shd_pos0=shd_pos.xyz;vec3 shd_pos1=shd_pos.xyz;
#ifdef NORMAL_OFFSET
vec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
#endif
#ifdef INDICATOR_CUTOUT
v_z_offset=e;
#else
#ifdef Z_OFFSET
#ifdef RENDER_SHADOWS
v_z_offset=e;
#endif
#endif
#endif
}`,
                ),
                terrainRaster: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image0;in vec2 v_pos0;
#ifdef FOG
in float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;
#endif
uniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;
#ifdef LIGHTING_3D_MODE
const vec3 normal=vec3(0.0,0.0,1.0);
#ifdef RENDER_SHADOWS
float cutoffOpacity=1.0;
#ifdef RENDER_CUTOFF
cutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);
#endif
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
vec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;
#else
float lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));
#endif
#else
float lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
color.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;
#endif
#endif
#else
color=image_color;
#endif
#ifdef FOG
#ifdef ZERO_EXAGGERATION
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#else
color=fog_dither(fog_apply_from_vert(color,v_fog_opacity));
#endif
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;
#ifdef FOG
out float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;
#endif
void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);
#ifdef FOG
#ifdef ZERO_EXAGGERATION
v_fog_pos=fog_position(decodedPos);
#else
v_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));
#endif
#endif
#ifdef RENDER_SHADOWS
vec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);
#endif
}`,
                ),
                terrainDepth: bi(
                  "precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}",
                  `#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}`,
                ),
                skybox: bi(
                  `#include "_prelude_fog.fragment.glsl"
in lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(
cos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;
#ifdef FOG
sky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);
#endif
sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`,
                  ul,
                ),
                skyboxGradient: bi(
                  `#include "_prelude_fog.fragment.glsl"
in highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));
#ifdef FOG
color.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;
#endif
color*=u_opacity;glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`,
                  ul,
                ),
                skyboxCapture: bi(
                  `
in highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;
#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)
#define BETA_M                  vec3(21e-6,21e-6,21e-6)
#define MIE_G                   0.76
#define DENSITY_HEIGHT_SCALE_R  8000.0
#define DENSITY_HEIGHT_SCALE_M  1200.0
#define PLANET_RADIUS           6360e3
#define ATMOSPHERE_RADIUS       6420e3
#define SAMPLE_STEPS            10
#define DENSITY_STEPS           4
float ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}`,
                  "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}",
                ),
                globeRaster: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;
#ifndef FOG
uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;
#endif
void main() {vec4 color;
#ifdef CUSTOM_ANTIALIASING
highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;highp float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);highp float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);
#ifdef LIGHTING_3D_MODE
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
raster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(clamp(raster.rgb,vec3(0),vec3(1))*antialias,antialias);
#else
raster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);
#endif
#else
color=vec4(raster.rgb*antialias,raster.a*antialias);
#endif
#else
color=texture(u_image0,v_pos0);
#ifdef LIGHTING_3D_MODE
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
color=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;
#else
color=apply_lighting_ground(color);
#endif
#endif
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
color*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;
#ifdef GLOBE_POLES
in vec3 a_globe_pos;in vec2 a_uv;
#else
in vec2 a_pos;
#endif
out vec2 v_pos0;void main() {
#ifdef GLOBE_POLES
vec3 globe_pos=a_globe_pos;vec2 uv=a_uv;
#else
float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);
#endif
v_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;
#ifdef GLOBE_POLES
vec3 up_vector=globe_derived_up_vector;
#else
vec3 up_vector=elevationVector(tile_pos);
#endif
float height=elevation(tile_pos);globe_pos+=up_vector*height;
#ifndef GLOBE_POLES
globe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;
#endif
#ifdef GLOBE_POLES
vec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);
#else
vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);
#endif
gl_Position=u_proj_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
}`,
                ),
                globeAtmosphere: bi(
                  `#include "_prelude_fog.fragment.glsl"
uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;
#ifdef PROJECTION_GLOBE_VIEW
globe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {
#ifdef ALPHA_PASS
glFragColor=vec4(0,0,0,0);return;
#else
#ifdef NATIVE
glFragColor=vec4(1,1,1,1);
#else
glFragColor=vec4(0,0,0,1);
#endif
return;
#endif
}
#endif
highp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?
0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;
#ifdef PROJECTION_GLOBE_VIEW
highp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?
PI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);
#else
horizon_angle=horizon_angle_mercator;
#endif
horizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;
#ifdef ALPHA_PASS
float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);
#else
vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;glFragColor=vec4(c*t,t);
#endif
}`,
                  `in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(
mix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}`,
                ),
                model: bi(
                  `#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;
#endif
#ifdef OCCLUSION_TEXTURE_TRANSFORM
uniform vec4 u_occlusionTextureTransform;
#endif
#pragma mapbox: define-attribute highp vec3 normal_3f
#pragma mapbox: define-attribute highp vec3 color_3f
#pragma mapbox: define-attribute highp vec4 color_4f
#pragma mapbox: define-attribute highp vec2 uv_2f
#pragma mapbox: initialize-attribute highp vec3 normal_3f
#pragma mapbox: initialize-attribute highp vec3 color_3f
#pragma mapbox: initialize-attribute highp vec4 color_4f
#pragma mapbox: initialize-attribute highp vec2 uv_2f
#ifdef HAS_ATTRIBUTE_a_pbr
in lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;
#endif
#ifdef HAS_TEXTURE_u_baseColorTexture
uniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;
#endif
#ifdef HAS_TEXTURE_u_metallicRoughnessTexture
uniform sampler2D u_metallicRoughnessTexture;
#endif
#ifdef HAS_TEXTURE_u_occlusionTexture
uniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;
#endif
#ifdef HAS_TEXTURE_u_normalTexture
uniform sampler2D u_normalTexture;
#endif
#ifdef HAS_TEXTURE_u_emissionTexture
uniform sampler2D u_emissionTexture;
#endif
#ifdef APPLY_LUT_ON_GPU
uniform highp sampler3D u_lutTexture;
#endif
#ifdef TERRAIN_FRAGMENT_OCCLUSION
in highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;
#ifdef DEPTH_D24
highp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}
#else
highp float unpack_depth_rgba(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}
#endif
bool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;
#ifdef DEPTH_D24
highp float depth=unpack_depth(texture(u_depthTexture,coord).r);
#else
highp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));
#endif
return v_depth > depth+0.0005;}
#endif
#define saturate(_x) clamp(_x,0.,1.)
vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)
{
#ifdef LIGHTING_3D_MODE
vec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;
#ifdef RENDER_SHADOWS
lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
lighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));
#endif
return apply_lighting(albedo,transformed_normal,lighting_factor);
#else
vec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;
#endif
}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;
#ifdef HAS_ATTRIBUTE_a_color_3f
albedo*=vec4(color_3f,1.0);
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
#else
#ifdef HAS_ATTRIBUTE_a_color_4f
albedo*=color_4f;
#endif
#endif
#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)
vec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}
#ifdef UNPREMULT_TEXTURE_IN_SHADER
if(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;
#endif
if(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}
#endif
vec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);
#ifdef APPLY_LUT_ON_GPU
color=applyLUT(u_lutTexture,color);
#endif
return color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {
#ifdef HAS_TEXTURE_u_normalTexture
highp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;
#else
return mat3(1.0);
#endif
}highp vec3 getNormal(){highp vec3 n;
#ifdef HAS_ATTRIBUTE_a_normal_3f
n=normalize(normal_3f);
#else
highp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;
#endif
#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
vec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);
#endif
return n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;
#ifdef HAS_ATTRIBUTE_a_pbr
mat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;
#endif
#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) 
vec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;
#endif
const float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)
{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)
{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)
{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)
{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)
{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)
{
#ifdef LIGHTING_3D_MODE
return mat.diffuseColor;
#else
return mat.diffuseColor/PI;
#endif
}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)
{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)
{vec3 env_light=vec3(0.65,0.65,0.65);
#ifdef LIGHTING_3D_MODE
float ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;
#endif
vec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)
{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;
#ifdef RENDER_SHADOWS
lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
lighting_factor=NdotL;
#endif
vec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;
#if !defined(LIGHTING_3D_MODE)
const vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);
#endif
color*=intensityFactor;return color;}void main() {
#ifdef TERRAIN_FRAGMENT_OCCLUSION
if (isOccluded()) {discard;}
#endif
vec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;
#ifdef LIGHTING_3D_MODE
lightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;
#endif
vec4 finalColor;
#ifdef DIFFUSE_SHADED
vec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);
#ifdef HAS_TEXTURE_u_occlusionTexture
float ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;
#endif
finalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;
#else
Material mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;
#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
#ifdef OCCLUSION_TEXTURE_TRANSFORM
vec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;
#else
vec2 uv=uv_2f;
#endif
ao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;
#endif
vec4 emissive=u_emissiveFactor;
#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
emissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);
#endif
#ifdef APPLY_LUT_ON_GPU
float emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;
#endif
color+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;
#ifdef HAS_ATTRIBUTE_a_pbr
float resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;
#ifdef APPLY_LUT_ON_GPU
color_mix=applyLUT(u_lutTexture,color_mix);
#endif
color=mix(color,color_mix,min(1.0,resEmission));
#ifdef HAS_ATTRIBUTE_a_color_4f
float distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);
#endif
#endif
vec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);
#endif
#ifdef FOG
finalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));
#endif
#ifdef RENDER_CUTOFF
finalColor*=v_cutoff_opacity;
#endif
#ifdef INDICATOR_CUTOUT
finalColor=applyCutout(finalColor,v_position_height.w);
#endif
glFragColor=finalColor;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
                  `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec3 a_pos_3f;
#pragma mapbox: define-attribute highp vec3 normal_3f
#pragma mapbox: define-attribute highp vec2 uv_2f
#pragma mapbox: define-attribute highp vec3 color_3f
#pragma mapbox: define-attribute highp vec4 color_4f
#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr
#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength
uniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;
#ifdef INSTANCED_ARRAYS
in vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;
#else
uniform highp mat4 u_normal_matrix;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;
#endif
out vec4 v_position_height;out lowp vec4 v_color_mix;
#ifdef TERRAIN_FRAGMENT_OCCLUSION
out highp float v_depth;
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
out lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;
#endif
vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {
#pragma mapbox: initialize-attribute highp vec3 normal_3f
#pragma mapbox: initialize-attribute highp vec2 uv_2f
#pragma mapbox: initialize-attribute highp vec3 color_3f
#pragma mapbox: initialize-attribute highp vec4 color_4f
#pragma mapbox: initialize-attribute-custom highp vec4 pbr
#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength
highp mat4 normal_matrix;
#ifdef INSTANCED_ARRAYS
normal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);
#else
normal_matrix=u_normal_matrix;
#endif
vec3 local_pos;mat3 rs;
#ifdef MODEL_POSITION_ON_GPU
vec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;
#else
local_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);
#endif
v_position_height.w=a_pos_3f.z;
#ifdef HAS_ATTRIBUTE_a_pbr
vec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;
#endif
#ifdef FOG
v_fog_pos=fog_position(local_pos);
#endif
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
#ifdef TERRAIN_FRAGMENT_OCCLUSION
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef HAS_ATTRIBUTE_a_normal_3f
#ifdef MODEL_POSITION_ON_GPU
float x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);
#else
normal_3f=vec3(normal_matrix*vec4(normal_3f,0));
#endif
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
#ifdef HAS_ATTRIBUTE_a_color_4f
v_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);
#endif
#endif
#ifdef RENDER_SHADOWS
vec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);
#ifdef NORMAL_OFFSET
#ifdef HAS_ATTRIBUTE_a_normal_3f
#ifdef MODEL_POSITION_ON_GPU
vec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();
#else
vec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();
#endif
#endif
#endif
v_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;
#endif
}`,
                ),
                modelDepth: bi(
                  `in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`,
                  `in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;
#ifdef MODEL_POSITION_ON_GPU
#ifdef INSTANCED_ARRAYS
in vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;
#else
uniform highp mat4 u_instance;
#endif
uniform highp mat4 u_node_matrix;
#endif
void main() {
#ifdef MODEL_POSITION_ON_GPU
highp mat4 instance;
#ifdef INSTANCED_ARRAYS
instance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);
#else
instance=u_instance;
#endif
vec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);
#else
gl_Position=u_matrix*vec4(a_pos_3f,1);
#endif
v_depth=gl_Position.z/gl_Position.w;}`,
                ),
                stars: bi(
                  `in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)
{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}`,
                  `
in vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}`,
                ),
                snowParticle: bi(
                  "in highp vec2 uv;in highp float alphaMultiplier;uniform vec4 u_particleColor;uniform vec2 u_simpleShapeParameters;void main() {float t=clamp((length(uv)-u_simpleShapeParameters.x)/(1.0-u_simpleShapeParameters.x),0.0,1.0);float alpha=1.0-pow(t,pow(10.0,u_simpleShapeParameters.y));alpha*=alphaMultiplier;alpha*=u_particleColor.a;vec3 color=u_particleColor.rgb*alpha;glFragColor=vec4(color,alpha) ;HANDLE_WIREFRAME_DEBUG;}",
                  `
in highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_snowParticleData;in highp vec4 a_snowParticleDataHorizontalOscillation;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform vec2 u_screenSize;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; 
uniform float u_velocity;uniform vec3 u_direction;uniform float u_horizontalOscillationRadius; 
uniform float u_horizontalOscillationRate; 
uniform float u_billboardSize;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;out highp vec2 uv;out highp float alphaMultiplier;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos.xyz*=halfBoxSize;pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_snowParticleData.z;float coneAngleHeadingRad=a_snowParticleData.w*radians(360.0);vec3 localZ=normalize(u_direction);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 direction;direction.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.z=cos(coneAnglePichRad);direction=normalize(direction);vec3 simPosLocal=vec3(0,0,0);float velocityScale=(1.0+3.0*a_snowParticleData.y)*u_velocity;simPosLocal+=direction*velocityScale*u_time;float horizontalOscillationRadius=u_horizontalOscillationRadius*a_snowParticleDataHorizontalOscillation.x;float horizontalOscillationAngle=u_horizontalOscillationRate*u_time*(-1.0+2.0*a_snowParticleDataHorizontalOscillation.y);simPosLocal.xy+=horizontalOscillationRadius*vec2(cos(horizontalOscillationAngle),sin(horizontalOscillationAngle));vec3 simPos=localX*simPosLocal.x+
localY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);float clipZ=-u_cam_pos.z+pos.z;vec4 posView=u_modelview*vec4(pos,1.0);float size=u_billboardSize;alphaMultiplier=1.0;vec4 posScreen=u_projection*posView;posScreen/=posScreen.w;posScreen.xy=vec2(0.5)+posScreen.xy*0.5;posScreen.xy*=u_screenSize;vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=u_screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-posScreen.xy)/(0.5*u_screenSize));screenDist+=a_snowParticleData.x*u_thinningParticleOffset;float scaleFactorMode=0.0;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);if (a_snowParticleData.x < u_thinningAffectedRatio) {scaleFactorMode=1.0-thinningFadeRatio;alphaMultiplier=thinningFadeRatio;}}vec4 posScreen1=u_projection*vec4(posView.x-size,posView.yzw);posScreen1/=posScreen1.w;vec4 posScreen2=u_projection*vec4(posView.x+size,posView.yzw);posScreen2/=posScreen2.w;posScreen1.xy=vec2(0.5)+posScreen1.xy*0.5;posScreen1.xy*=u_screenSize;posScreen2.xy=vec2(0.5)+posScreen2.xy*0.5;posScreen2.xy*=u_screenSize;float screenLength=length(posScreen1.xy-posScreen2.xy);float screenEpsilon=3.0;float scaleFactor=1.0;if (screenLength < screenEpsilon) {scaleFactor=screenEpsilon/max(screenLength,0.01);scaleFactor=mix(scaleFactor,1.0,scaleFactorMode);}float screenEpsilon2=15.0;if (screenLength > screenEpsilon2) {scaleFactor=screenEpsilon2/max(screenLength,0.01);}size*=scaleFactor;vec2 right=size*vec2(1,0);vec2 up=size*vec2(0,1);posView.xy+=right*a_uv.x;posView.xy+=up*a_uv.y;uv=a_uv;gl_Position=u_projection*posView;}`,
                ),
                rainParticle: bi(
                  "in highp vec2 uv;in highp float particleRandomValue;uniform sampler2D u_texScreen;uniform float u_distortionStrength;uniform vec4 u_color;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;uniform float u_shapeDirectionalPower;uniform float u_mode;void main() {vec2 st=uv*0.5+vec2(0.5);vec2 uvm=uv;uvm.y=-1.0+2.0*pow(st.y,u_shapeDirectionalPower);float shape=clamp(1.0-length(uvm),0.0,1.0);float alpha=abs(shape)*u_color.a;vec2 screenSize=vec2(textureSize(u_texScreen,0));vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-gl_FragCoord.xy)/(0.5*screenSize));screenDist+=(0.5+0.5*particleRandomValue)*u_thinningParticleOffset;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;float thinningAlpha=1.0;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);thinningAlpha*=thinningFadeRatio;}vec2 offsetXY=normalize(uvm)*abs(shape);vec2 stScreen=(gl_FragCoord.xy+offsetXY*u_distortionStrength*thinningAlpha)/screenSize;vec3 colorScreen=texture(u_texScreen,stScreen).rgb;alpha*=thinningAlpha;glFragColor=mix(vec4(colorScreen,1.0),vec4(u_color.rgb*alpha,alpha),u_mode);HANDLE_WIREFRAME_DEBUG;}",
                  `
in highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_rainParticleData;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; 
uniform float u_velocity; 
uniform vec2 u_rainDropletSize;uniform vec3 u_rainDirection;out highp vec2 uv;out highp float particleRandomValue;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos*=halfBoxSize; 
pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_rainParticleData.z;float coneAngleHeadingRad=a_rainParticleData.w*radians(360.0);vec3 localZ=normalize(u_rainDirection);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 directionLocal;directionLocal.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.z=cos(coneAnglePichRad);directionLocal=normalize(directionLocal);vec3 directionWorld=localX*directionLocal.x+localY*directionLocal.y+localZ*directionLocal.z;float velocityScale=(1.0+3.0*a_rainParticleData.y)*u_velocity;vec3 simPosLocal=vec3(0,0,0);simPosLocal+=directionLocal*velocityScale*u_time;vec3 simPos=localX*simPosLocal.x+
localY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);vec4 posView=u_modelview*vec4(pos,1.0);vec3 directionView=normalize((u_modelview*vec4(directionWorld,0.0)).xyz);vec3 side=cross(directionView,normalize(posView.xyz));posView.xyz+=side*a_uv.x*u_rainDropletSize.x;posView.xyz+=directionView*a_uv.y*u_rainDropletSize.y;uv=a_uv;particleRandomValue=a_rainParticleData.x;gl_Position=u_projection*posView;}`,
                ),
                vignette: bi(
                  "uniform vec3 u_vignetteShape;uniform vec4 u_vignetteColor;in vec2 st;void main() {float screenDist=length(st);float alpha=clamp((screenDist-u_vignetteShape.x)/u_vignetteShape.y,0.0,1.0);alpha=pow(alpha,u_vignetteShape.z)*u_vignetteColor.a;vec3 color=u_vignetteColor.rgb;glFragColor=vec4(color*alpha,alpha) ;}",
                  "in vec2 a_pos_2f;out vec2 st;void main() {st=a_pos_2f;gl_Position=vec4(a_pos_2f,0,1);}",
                ),
                occlusion: bi(
                  "uniform vec4 u_color;void main() {glFragColor=u_color;}",
                  `#include "_prelude_terrain.vertex.glsl"
in highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;
#ifdef TERRAIN
float e=elevation(world_pos.xy);world_pos.z+=e;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}`,
                ),
              };
              function xs(c, t) {
                const s = c.replace(
                  /\s*\/\/[^\n]*\n/g,
                  `
`,
                ).split(`
`);
                for (let h of s)
                  if (
                    ((h = h.trim()),
                    h[0] === "#" && h.includes("if") && !h.includes("endif"))
                  ) {
                    h = h
                      .replace("#", "")
                      .replace(/ifdef|ifndef|elif|if/g, "")
                      .replace(/!|defined|\(|\)|\|\||&&/g, "")
                      .replace(/\s+/g, " ")
                      .trim();
                    const p = h.split(" ");
                    for (const g of p) t.includes(g) || t.push(g);
                  }
              }
              function bi(c, t) {
                const s = /#include\s+"([^"]+)"/g,
                  h = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
                let p = t.match(
                  /(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm,
                );
                p &&
                  ((p = p.map((C) => {
                    const D = C.split(" ");
                    return D[D.length - 1];
                  })),
                  (p = [...new Set(p)]));
                const g = {},
                  x = [],
                  w = [];
                if (
                  ((c = c.replace(s, (C, D) => (w.push(D), ""))),
                  (t = t.replace(s, (C, D) => (x.push(D), ""))).includes(
                    "flat out",
                  ))
                )
                  return void console.error(
                    'The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071',
                  );
                let S = [...fl];
                (xs(c, S), xs(t, S));
                for (const C of [...x, ...w])
                  (pl[C] || console.error(`Undefined include: ${C}`),
                    Ec[C] || ((Ec[C] = []), xs(pl[C], Ec[C])),
                    (S = [...S, ...Ec[C]]));
                return {
                  fragmentSource: (c = c.replace(
                    h,
                    (C, D, L, z, O) => (
                      (g[O] = !0),
                      D === "define"
                        ? `
#ifndef HAS_UNIFORM_u_${O}
in ${L} ${z} ${O};
#else
uniform ${L} ${z} u_${O};
#endif
`
                        : D === "initialize"
                          ? `
#ifdef HAS_UNIFORM_u_${O}
    ${L} ${z} ${O} = u_${O};
#endif
`
                          : D === "define-attribute"
                            ? `
#ifdef HAS_ATTRIBUTE_a_${O}
    in ${L} ${z} ${O};
#endif
`
                            : D === "initialize-attribute"
                              ? ""
                              : void 0
                    ),
                  )),
                  vertexSource: (t = t.replace(h, (C, D, L, z, O) => {
                    const G = z === "float" ? "vec2" : z,
                      U = O.match(/color/) ? "color" : G;
                    return D === "define-attribute-vertex-shader-only"
                      ? `
#ifdef HAS_ATTRIBUTE_a_${O}
in ${L} ${z} a_${O};
#endif
`
                      : g[O]
                        ? D === "define"
                          ? `
#ifndef HAS_UNIFORM_u_${O}
uniform lowp float u_${O}_t;
in ${L} ${G} a_${O};
out ${L} ${z} ${O};
#else
uniform ${L} ${z} u_${O};
#endif
`
                          : D === "initialize"
                            ? U === "vec4"
                              ? `
#ifndef HAS_UNIFORM_u_${O}
    ${O} = a_${O};
#else
    ${L} ${z} ${O} = u_${O};
#endif
`
                              : `
#ifndef HAS_UNIFORM_u_${O}
    ${O} = unpack_mix_${U}(a_${O}, u_${O}_t);
#else
    ${L} ${z} ${O} = u_${O};
#endif
`
                            : D === "define-attribute"
                              ? `
#ifdef HAS_ATTRIBUTE_a_${O}
    in ${L} ${z} a_${O};
    out ${L} ${z} ${O};
#endif
`
                              : D === "initialize-attribute"
                                ? `
#ifdef HAS_ATTRIBUTE_a_${O}
    ${O} = a_${O};
#endif
`
                                : void 0
                        : D === "define"
                          ? `
#ifndef HAS_UNIFORM_u_${O}
uniform lowp float u_${O}_t;
in ${L} ${G} a_${O};
#else
uniform ${L} ${z} u_${O};
#endif
`
                          : D === "define-instanced"
                            ? U === "mat4"
                              ? `
#ifdef INSTANCED_ARRAYS
in vec4 a_${O}0;
in vec4 a_${O}1;
in vec4 a_${O}2;
in vec4 a_${O}3;
#else
uniform ${L} ${z} u_${O};
#endif
`
                              : `
#ifdef INSTANCED_ARRAYS
in ${L} ${G} a_${O};
#else
uniform ${L} ${z} u_${O};
#endif
`
                            : D === "initialize-attribute-custom"
                              ? `
#ifdef HAS_ATTRIBUTE_a_${O}
    ${L} ${z} ${O} = a_${O};
#endif
`
                              : U === "vec4"
                                ? `
#ifndef HAS_UNIFORM_u_${O}
    ${L} ${z} ${O} = a_${O};
#else
    ${L} ${z} ${O} = u_${O};
#endif
`
                                : `
#ifndef HAS_UNIFORM_u_${O}
    ${L} ${z} ${O} = unpack_mix_${U}(a_${O}, u_${O}_t);
#else
    ${L} ${z} ${O} = u_${O};
#endif
`;
                  })),
                  staticAttributes: p,
                  usedDefines: S,
                  vertexIncludes: x,
                  fragmentIncludes: w,
                };
              }
              class ml {
                constructor() {
                  ((this.boundProgram = null),
                    (this.boundLayoutVertexBuffer = null),
                    (this.boundPaintVertexBuffers = []),
                    (this.boundIndexBuffer = null),
                    (this.boundVertexOffset = null),
                    (this.boundDynamicVertexBuffers = []),
                    (this.vao = null));
                }
                bind(t, s, h, p, g, x, w, S) {
                  this.context = t;
                  let C = this.boundPaintVertexBuffers.length !== p.length;
                  for (let L = 0; !C && L < p.length; L++)
                    this.boundPaintVertexBuffers[L] !== p[L] && (C = !0);
                  let D = this.boundDynamicVertexBuffers.length !== w.length;
                  for (let L = 0; !D && L < w.length; L++)
                    this.boundDynamicVertexBuffers[L] !== w[L] && (D = !0);
                  if (
                    !this.vao ||
                    this.boundProgram !== s ||
                    this.boundLayoutVertexBuffer !== h ||
                    C ||
                    D ||
                    this.boundIndexBuffer !== g ||
                    this.boundVertexOffset !== x
                  )
                    this.freshBind(s, h, p, g, x, w, S);
                  else {
                    t.bindVertexArrayOES.set(this.vao);
                    for (const L of w)
                      L &&
                        (L.bind(),
                        S &&
                          L.instanceCount &&
                          L.setVertexAttribDivisor(t.gl, s, S));
                    g && g.dynamicDraw && g.bind();
                  }
                }
                freshBind(t, s, h, p, g, x, w) {
                  const S = t.numAttributes,
                    C = this.context,
                    D = C.gl;
                  (this.vao && this.destroy(),
                    (this.vao = C.gl.createVertexArray()),
                    C.bindVertexArrayOES.set(this.vao),
                    (this.boundProgram = t),
                    (this.boundLayoutVertexBuffer = s),
                    (this.boundPaintVertexBuffers = h),
                    (this.boundIndexBuffer = p),
                    (this.boundVertexOffset = g),
                    (this.boundDynamicVertexBuffers = x),
                    s.enableAttributes(D, t),
                    s.bind(),
                    s.setVertexAttribPointers(D, t, g));
                  for (const L of h)
                    (L.enableAttributes(D, t),
                      L.bind(),
                      L.setVertexAttribPointers(D, t, g));
                  for (const L of x)
                    L &&
                      (L.enableAttributes(D, t),
                      L.bind(),
                      L.setVertexAttribPointers(D, t, g),
                      w &&
                        L.instanceCount &&
                        L.setVertexAttribDivisor(D, t, w));
                  (p && p.bind(), (C.currentNumAttributes = S));
                }
                destroy() {
                  this.vao &&
                    (this.context.gl.deleteVertexArray(this.vao),
                    (this.vao = null));
                }
              }
              function g_(c, t) {
                const s = Math.pow(2, t.canonical.z),
                  h = t.canonical.y;
                return [
                  new r.ac(0, h / s).toLngLat().lat,
                  new r.ac(0, (h + 1) / s).toLngLat().lat,
                ];
              }
              function __(c, t, s, h, p, g, x) {
                const w = c.context,
                  S = w.gl,
                  C = s.hillshadeFBO;
                if (!C) return;
                c.prepareDrawTile();
                const D = c.isTileAffectedByFog(t),
                  L = c.getOrCreateProgram("hillshade", { overrideFog: D });
                (w.activeTexture.set(S.TEXTURE0),
                  S.bindTexture(S.TEXTURE_2D, C.colorAttachment.get()));
                const z = (($, Z, Y, ie) => {
                  const ae = Y.paint.get("hillshade-shadow-color"),
                    pe =
                      Y.paint
                        .get("hillshade-shadow-color-use-theme")
                        .constantOr("default") === "none",
                    ue = Y.paint.get("hillshade-highlight-color"),
                    ce =
                      Y.paint
                        .get("hillshade-highlight-color-use-theme")
                        .constantOr("default") === "none",
                    le = Y.paint.get("hillshade-accent-color"),
                    me =
                      Y.paint
                        .get("hillshade-accent-color-use-theme")
                        .constantOr("default") === "none",
                    _e = Y.paint.get("hillshade-emissive-strength");
                  let De = r.al(
                    Y.paint.get("hillshade-illumination-direction"),
                  );
                  if (
                    Y.paint.get("hillshade-illumination-anchor") === "viewport"
                  )
                    De -= $.transform.angle;
                  else if (
                    $.style &&
                    $.style.enable3dLights() &&
                    $.style.directionalLight
                  ) {
                    const He =
                        $.style.directionalLight.properties.get("direction"),
                      We = r.cR(He.x, He.y, He.z);
                    De = r.al(We[1]);
                  }
                  const ze = !$.options.moving;
                  return {
                    u_matrix:
                      ie ||
                      $.transform.calculateProjMatrix(
                        Z.tileID.toUnwrapped(),
                        ze,
                      ),
                    u_image: 0,
                    u_latrange: g_(0, Z.tileID),
                    u_light: [Y.paint.get("hillshade-exaggeration"), De],
                    u_shadow: ae.toPremultipliedRenderColor(pe ? null : Y.lut),
                    u_highlight: ue.toPremultipliedRenderColor(
                      ce ? null : Y.lut,
                    ),
                    u_emissive_strength: _e,
                    u_accent: le.toPremultipliedRenderColor(me ? null : Y.lut),
                  };
                })(c, s, h, c.terrain ? t.projMatrix : null);
                c.uploadCommonUniforms(w, L, t.toUnwrapped());
                const {
                  tileBoundsBuffer: O,
                  tileBoundsIndexBuffer: G,
                  tileBoundsSegments: U,
                } = c.getTileBoundsBuffers(s);
                L.draw(c, S.TRIANGLES, p, g, x, Gt.disabled, z, h.id, O, G, U);
              }
              function Gh(c, t, s) {
                if (!t.needsDEMTextureUpload) return;
                const h = c.context,
                  p = h.gl;
                (h.pixelStoreUnpackPremultiplyAlpha.set(!1),
                  (t.demTexture = t.demTexture || c.getTileTexture(s.stride)));
                const g = s.getPixels();
                (t.demTexture
                  ? t.demTexture.update(g, { premultiply: !1 })
                  : (t.demTexture = new r.T(h, g, p.R32F, { premultiply: !1 })),
                  (t.needsDEMTextureUpload = !1));
              }
              function y_(c, t, s) {
                const h = c.context,
                  p = h.gl;
                if (!t.dem) return;
                const g = t.dem;
                if (
                  (h.activeTexture.set(p.TEXTURE1), Gh(c, t, g), !t.demTexture)
                )
                  return;
                t.demTexture.bind(p.NEAREST, p.CLAMP_TO_EDGE);
                const x = g.dim;
                h.activeTexture.set(p.TEXTURE0);
                let w = t.hillshadeFBO;
                if (!w) {
                  const z = new r.T(
                    h,
                    { width: x, height: x, data: null },
                    p.RGBA8,
                  );
                  (z.bind(p.LINEAR, p.CLAMP_TO_EDGE),
                    (w = t.hillshadeFBO =
                      h.createFramebuffer(x, x, !0, "renderbuffer")),
                    w.colorAttachment.set(z.texture));
                }
                (h.bindFramebuffer.set(w.framebuffer),
                  h.viewport.set([0, 0, x, x]));
                const {
                    tileBoundsBuffer: S,
                    tileBoundsIndexBuffer: C,
                    tileBoundsSegments: D,
                  } = c.getMercatorTileBoundsBuffers(),
                  L = [];
                (c.linearFloatFilteringSupported() &&
                  L.push("TERRAIN_DEM_FLOAT_FORMAT"),
                  c.getOrCreateProgram("hillshadePrepare", { defines: L }).draw(
                    c,
                    p.TRIANGLES,
                    wt.disabled,
                    Yt.disabled,
                    ui.unblended,
                    Gt.disabled,
                    ((z, O) => {
                      const G = O.stride,
                        U = r.bz();
                      return (
                        r.c5(U, 0, r.aj, -8192, 0, 0, 1),
                        r.bo(U, U, [0, -8192, 0]),
                        {
                          u_matrix: U,
                          u_image: 1,
                          u_dimension: [G, G],
                          u_zoom: z.overscaledZ,
                        }
                      );
                    })(t.tileID, g),
                    s.id,
                    S,
                    C,
                    D,
                  ),
                  (t.needsHillshadePrepare = !1));
              }
              class Sn {
                constructor(t) {
                  ((this.gl = t.gl),
                    (this.default = this.getDefault()),
                    (this.current = this.default),
                    (this.dirty = !1));
                }
                get() {
                  return this.current;
                }
                set(t) {}
                getDefault() {
                  return this.default;
                }
                setDefault() {
                  this.set(this.default);
                }
              }
              class Dp extends Sn {
                getDefault() {
                  return r.am.transparent.toNonPremultipliedRenderColor(null);
                }
                set(t) {
                  const s = this.current;
                  (t.r !== s.r ||
                    t.g !== s.g ||
                    t.b !== s.b ||
                    t.a !== s.a ||
                    this.dirty) &&
                    (this.gl.clearColor(t.r, t.g, t.b, t.a),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class vd extends Sn {
                getDefault() {
                  return 1;
                }
                set(t) {
                  (t !== this.current || this.dirty) &&
                    (this.gl.clearDepth(t),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class x_ extends Sn {
                getDefault() {
                  return 0;
                }
                set(t) {
                  (t !== this.current || this.dirty) &&
                    (this.gl.clearStencil(t),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class v_ extends Sn {
                getDefault() {
                  return [!0, !0, !0, !0];
                }
                set(t) {
                  const s = this.current;
                  (t[0] !== s[0] ||
                    t[1] !== s[1] ||
                    t[2] !== s[2] ||
                    t[3] !== s[3] ||
                    this.dirty) &&
                    (this.gl.colorMask(t[0], t[1], t[2], t[3]),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class b_ extends Sn {
                getDefault() {
                  return !0;
                }
                set(t) {
                  (t !== this.current || this.dirty) &&
                    (this.gl.depthMask(t),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class w_ extends Sn {
                getDefault() {
                  return 255;
                }
                set(t) {
                  (t !== this.current || this.dirty) &&
                    (this.gl.stencilMask(t),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class Rp extends Sn {
                getDefault() {
                  return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
                }
                set(t) {
                  const s = this.current;
                  (t.func !== s.func ||
                    t.ref !== s.ref ||
                    t.mask !== s.mask ||
                    this.dirty) &&
                    (this.gl.stencilFunc(t.func, t.ref, t.mask),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class T_ extends Sn {
                getDefault() {
                  const t = this.gl;
                  return [t.KEEP, t.KEEP, t.KEEP];
                }
                set(t) {
                  const s = this.current;
                  (t[0] !== s[0] ||
                    t[1] !== s[1] ||
                    t[2] !== s[2] ||
                    this.dirty) &&
                    (this.gl.stencilOp(t[0], t[1], t[2]),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class $h extends Sn {
                getDefault() {
                  return !1;
                }
                set(t) {
                  if (t === this.current && !this.dirty) return;
                  const s = this.gl;
                  (t ? s.enable(s.STENCIL_TEST) : s.disable(s.STENCIL_TEST),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class S_ extends Sn {
                getDefault() {
                  return [0, 1];
                }
                set(t) {
                  const s = this.current;
                  (t[0] !== s[0] || t[1] !== s[1] || this.dirty) &&
                    (this.gl.depthRange(t[0], t[1]),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class zp extends Sn {
                getDefault() {
                  return !1;
                }
                set(t) {
                  if (t === this.current && !this.dirty) return;
                  const s = this.gl;
                  (t ? s.enable(s.DEPTH_TEST) : s.disable(s.DEPTH_TEST),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class bd extends Sn {
                getDefault() {
                  return this.gl.LESS;
                }
                set(t) {
                  (t !== this.current || this.dirty) &&
                    (this.gl.depthFunc(t),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class Hh extends Sn {
                getDefault() {
                  return !1;
                }
                set(t) {
                  if (t === this.current && !this.dirty) return;
                  const s = this.gl;
                  (t ? s.enable(s.BLEND) : s.disable(s.BLEND),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class wd extends Sn {
                getDefault() {
                  const t = this.gl;
                  return [t.ONE, t.ZERO, t.ONE, t.ZERO];
                }
                set(t) {
                  const s = this.current;
                  (t[0] !== s[0] ||
                    t[1] !== s[1] ||
                    t[2] !== s[2] ||
                    t[3] !== s[3] ||
                    this.dirty) &&
                    (this.gl.blendFuncSeparate(t[0], t[1], t[2], t[3]),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class Sa extends Sn {
                getDefault() {
                  return r.am.transparent.toNonPremultipliedRenderColor(null);
                }
                set(t) {
                  const s = this.current;
                  (t.r !== s.r ||
                    t.g !== s.g ||
                    t.b !== s.b ||
                    t.a !== s.a ||
                    this.dirty) &&
                    (this.gl.blendColor(t.r, t.g, t.b, t.a),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class gl extends Sn {
                getDefault() {
                  return this.gl.FUNC_ADD;
                }
                set(t) {
                  (t !== this.current || this.dirty) &&
                    (this.gl.blendEquationSeparate(t, t),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class Wh extends Sn {
                getDefault() {
                  return !1;
                }
                set(t) {
                  if (t === this.current && !this.dirty) return;
                  const s = this.gl;
                  (t ? s.enable(s.CULL_FACE) : s.disable(s.CULL_FACE),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class qh extends Sn {
                getDefault() {
                  return this.gl.BACK;
                }
                set(t) {
                  (t !== this.current || this.dirty) &&
                    (this.gl.cullFace(t),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class _l extends Sn {
                getDefault() {
                  return this.gl.CCW;
                }
                set(t) {
                  (t !== this.current || this.dirty) &&
                    (this.gl.frontFace(t),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              let kp = class extends Sn {
                getDefault() {
                  return null;
                }
                set(c) {
                  (c !== this.current || this.dirty) &&
                    (this.gl.useProgram(c),
                    (this.current = c),
                    (this.dirty = !1));
                }
              };
              class Td extends Sn {
                getDefault() {
                  return this.gl.TEXTURE0;
                }
                set(t) {
                  (t !== this.current || this.dirty) &&
                    (this.gl.activeTexture(t),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class Lp extends Sn {
                getDefault() {
                  const t = this.gl;
                  return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];
                }
                set(t) {
                  const s = this.current;
                  (t[0] !== s[0] ||
                    t[1] !== s[1] ||
                    t[2] !== s[2] ||
                    t[3] !== s[3] ||
                    this.dirty) &&
                    (this.gl.viewport(t[0], t[1], t[2], t[3]),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class yl extends Sn {
                getDefault() {
                  return null;
                }
                set(t) {
                  if (t === this.current && !this.dirty) return;
                  const s = this.gl;
                  (s.bindFramebuffer(s.FRAMEBUFFER, t),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class Zh extends Sn {
                getDefault() {
                  return null;
                }
                set(t) {
                  if (t === this.current && !this.dirty) return;
                  const s = this.gl;
                  (s.bindRenderbuffer(s.RENDERBUFFER, t),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class Xh extends Sn {
                getDefault() {
                  return null;
                }
                set(t) {
                  if (t === this.current && !this.dirty) return;
                  const s = this.gl;
                  (s.bindTexture(s.TEXTURE_2D, t),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class Sd extends Sn {
                getDefault() {
                  return null;
                }
                set(t) {
                  if (t === this.current && !this.dirty) return;
                  const s = this.gl;
                  (s.bindBuffer(s.ARRAY_BUFFER, t),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class Yh extends Sn {
                getDefault() {
                  return null;
                }
                set(t) {
                  const s = this.gl;
                  (s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, t),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class Ac extends Sn {
                getDefault() {
                  return null;
                }
                set(t) {
                  this.gl &&
                    (t !== this.current || this.dirty) &&
                    (this.gl.bindVertexArray(t),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class Op extends Sn {
                getDefault() {
                  return 4;
                }
                set(t) {
                  if (t === this.current && !this.dirty) return;
                  const s = this.gl;
                  (s.pixelStorei(s.UNPACK_ALIGNMENT, t),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class Fp extends Sn {
                getDefault() {
                  return !1;
                }
                set(t) {
                  if (t === this.current && !this.dirty) return;
                  const s = this.gl;
                  (s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class Bp extends Sn {
                getDefault() {
                  return !1;
                }
                set(t) {
                  if (t === this.current && !this.dirty) return;
                  const s = this.gl;
                  (s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, t),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class Lo extends Sn {
                constructor(t, s) {
                  (super(t), (this.context = t), (this.parent = s));
                }
                getDefault() {
                  return null;
                }
              }
              class Np extends Lo {
                setDirty() {
                  this.dirty = !0;
                }
                set(t) {
                  if (t === this.current && !this.dirty) return;
                  this.context.bindFramebuffer.set(this.parent);
                  const s = this.gl;
                  (s.framebufferTexture2D(
                    s.FRAMEBUFFER,
                    s.COLOR_ATTACHMENT0,
                    s.TEXTURE_2D,
                    t,
                    0,
                  ),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class Vp extends Lo {
                attachment() {
                  return this.gl.DEPTH_ATTACHMENT;
                }
                set(t) {
                  if (t === this.current && !this.dirty) return;
                  this.context.bindFramebuffer.set(this.parent);
                  const s = this.gl;
                  (s.framebufferRenderbuffer(
                    s.FRAMEBUFFER,
                    this.attachment(),
                    s.RENDERBUFFER,
                    t,
                  ),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class E_ extends Lo {
                attachment() {
                  return this.gl.DEPTH_ATTACHMENT;
                }
                set(t) {
                  if (t === this.current && !this.dirty) return;
                  this.context.bindFramebuffer.set(this.parent);
                  const s = this.gl;
                  (s.framebufferTexture2D(
                    s.FRAMEBUFFER,
                    this.attachment(),
                    s.TEXTURE_2D,
                    t,
                    0,
                  ),
                    (this.current = t),
                    (this.dirty = !1));
                }
              }
              class I_ extends Vp {
                attachment() {
                  return this.gl.DEPTH_STENCIL_ATTACHMENT;
                }
              }
              const Ed = (c, t, s) => ({
                  u_matrix: c,
                  u_image0: 0,
                  u_skirt_height: t,
                  u_ground_shadow_factor: s,
                }),
                Kh = (c, t, s, h, p, g, x, w, S, C, D, L, z, O, G, U) => ({
                  u_proj_matrix: Float32Array.from(c),
                  u_globe_matrix: t,
                  u_normalize_matrix: Float32Array.from(h),
                  u_merc_matrix: s,
                  u_zoom_transition: p,
                  u_merc_center: g,
                  u_image0: 0,
                  u_frustum_tl: x,
                  u_frustum_tr: w,
                  u_frustum_br: S,
                  u_frustum_bl: C,
                  u_globe_pos: D,
                  u_globe_radius: L,
                  u_viewport: z,
                  u_grid_matrix: U ? Float32Array.from(U) : new Float32Array(9),
                  u_skirt_height: O,
                  u_far_z_cutoff: G,
                });
              function Jh(c, t) {
                return (
                  c != null &&
                  t != null &&
                  !(!c.hasData() || !t.hasData()) &&
                  c.demTexture != null &&
                  t.demTexture != null &&
                  c.tileID.key !== t.tileID.key
                );
              }
              const Oo = new (class {
                  constructor() {
                    this.operations = {};
                  }
                  newMorphing(c, t, s, h, p) {
                    if (c in this.operations) {
                      const g = this.operations[c];
                      g.to.tileID.key !== s.tileID.key && (g.queued = s);
                    } else
                      this.operations[c] = {
                        startTime: h,
                        phase: 0,
                        duration: p,
                        from: t,
                        to: s,
                        queued: null,
                      };
                  }
                  getMorphValuesForProxy(c) {
                    if (!(c in this.operations)) return null;
                    const t = this.operations[c];
                    return { from: t.from, to: t.to, phase: t.phase };
                  }
                  update(c) {
                    for (const t in this.operations) {
                      const s = this.operations[t];
                      for (
                        s.phase = (c - s.startTime) / s.duration;
                        s.phase >= 1 || !this._validOp(s);

                      )
                        if (!this._nextOp(s, c)) {
                          delete this.operations[t];
                          break;
                        }
                    }
                  }
                  _nextOp(c, t) {
                    return (
                      !!c.queued &&
                      ((c.from = c.to),
                      (c.to = c.queued),
                      (c.queued = null),
                      (c.phase = 0),
                      (c.startTime = t),
                      !0)
                    );
                  }
                  _validOp(c) {
                    return c.from.hasData() && c.to.hasData();
                  }
                })(),
                Id = { 0: null, 1: "TERRAIN_VERTEX_MORPHING" };
              function Ad(c, t, s) {
                if (t === 0) return 0;
                const h = t < 1 && s === 514 ? 0.25 / t : 1;
                return 6 * Math.pow(1.5, 22 - c) * Math.max(t, 1) * h;
              }
              function A_(c, t) {
                const s = 1 << c.z;
                return (
                  (!t && (c.x === 0 || c.x === s - 1)) ||
                  c.y === 0 ||
                  c.y === s - 1
                );
              }
              const Ea = (c) => ({ u_matrix: c });
              function Ia(c, t, s, h, p) {
                if (p > 0) {
                  const g = r.q.now(),
                    x = (g - c.timeAdded) / p,
                    w = t ? (g - t.timeAdded) / p : -1,
                    S = s.getSource(),
                    C = h.coveringZoomLevel({
                      tileSize: S.tileSize,
                      roundZoom: S.roundZoom,
                    }),
                    D =
                      !t ||
                      Math.abs(t.tileID.overscaledZ - C) >
                        Math.abs(c.tileID.overscaledZ - C),
                    L =
                      D && c.refreshedUponExpiration
                        ? 1
                        : r.ay(D ? x : 1 - w, 0, 1);
                  return (
                    c.refreshedUponExpiration &&
                      x >= 1 &&
                      (c.refreshedUponExpiration = !1),
                    t ? { opacity: 1, mix: 1 - L } : { opacity: L, mix: 0 }
                  );
                }
                return { opacity: 1, mix: 0 };
              }
              class Up extends jr {
                constructor(t) {
                  const s = {
                      type: "raster-dem",
                      maxzoom: t.transform.maxZoom,
                    },
                    h = new r.D(r.c$(), null),
                    p = oc("mock-dem", s, h, t.style);
                  (super("mock-dem", p, !1),
                    p.setEventedParent(this),
                    (this._sourceLoaded = !0));
                }
                _loadTile(t, s) {
                  ((t.state = "loaded"), s(null));
                }
              }
              class ls extends jr {
                constructor(t) {
                  const s = oc(
                    "proxy",
                    { type: "geojson", maxzoom: t.transform.maxZoom },
                    new r.D(r.c$(), null),
                    t.style,
                  );
                  (super("proxy", s, !1),
                    s.setEventedParent(this),
                    (this.map = this.getSource().map = t),
                    (this.used = this._sourceLoaded = !0),
                    (this.renderCache = []),
                    (this.renderCachePool = []),
                    (this.proxyCachedFBO = {}));
                }
                update(t, s, h) {
                  if (t.freezeTileCoverage) return;
                  this.transform = t;
                  const p = t
                    .coveringTiles({
                      tileSize: this._source.tileSize,
                      minzoom: this._source.minzoom,
                      maxzoom: this._source.maxzoom,
                      roundZoom: this._source.roundZoom,
                      reparseOverscaled: this._source.reparseOverscaled,
                    })
                    .reduce((g, x) => {
                      if (((g[x.key] = ""), !this._tiles[x.key])) {
                        const w = new fa(
                          x,
                          this._source.tileSize * x.overscaleFactor(),
                          t.tileZoom,
                          void 0,
                          void 0,
                          this._source.worldview,
                        );
                        ((w.state = "loaded"), (this._tiles[x.key] = w));
                      }
                      return g;
                    }, {});
                  for (const g in this._tiles)
                    g in p ||
                      (this.freeFBO(g),
                      this._tiles[g].unloadVectorData(),
                      delete this._tiles[g]);
                }
                freeFBO(t) {
                  const s = this.proxyCachedFBO[t];
                  if (s !== void 0) {
                    const h = Object.values(s);
                    (this.renderCachePool.push(...h),
                      delete this.proxyCachedFBO[t]);
                  }
                }
                deallocRenderCache() {
                  (this.renderCache.forEach((t) => t.fb.destroy()),
                    (this.renderCache = []),
                    (this.renderCachePool = []),
                    (this.proxyCachedFBO = {}));
                }
              }
              class Qh extends r.aM {
                constructor(t, s, h) {
                  (super(
                    t.overscaledZ,
                    t.wrap,
                    t.canonical.z,
                    t.canonical.x,
                    t.canonical.y,
                  ),
                    (this.proxyTileKey = s),
                    (this.projMatrix = h));
                }
              }
              class Mc extends r.dt {
                constructor(t, s) {
                  (super(),
                    (this._debugParams = {
                      sortTilesHiZFirst: !0,
                      disableRenderCache: !1,
                    }),
                    t.tp.registerParameter(
                      this._debugParams,
                      ["Terrain"],
                      "sortTilesHiZFirst",
                      {},
                      () => {
                        this._style.map.triggerRepaint();
                      },
                    ),
                    t.tp.registerParameter(
                      this._debugParams,
                      ["Terrain"],
                      "disableRenderCache",
                      {},
                      () => {
                        this._style.map.triggerRepaint();
                      },
                    ),
                    t.tp.registerButton(
                      ["Terrain"],
                      "Invalidate Render Cache",
                      () => {
                        ((this.invalidateRenderCache = !0),
                          this._style.map.triggerRepaint());
                      },
                    ),
                    (this.painter = t),
                    (this.terrainTileForTile = {}),
                    (this.prevTerrainTileForTile = {}));
                  const [h, p, g] = (function (S) {
                      const C = new r.ba(),
                        D = new r.a_(),
                        L = 131;
                      (C.reserve(17161), D.reserve(33800));
                      const z = r.aj / 128,
                        O = r.aj + z / 2,
                        G = O + z;
                      for (let $ = -64; $ < G; $ += z)
                        for (let Z = -64; Z < G; Z += z) {
                          const Y =
                              Z < 0 || Z > O || $ < 0 || $ > O ? 24575 : 0,
                            ie = r.ay(Math.round(Z), 0, r.aj),
                            ae = r.ay(Math.round($), 0, r.aj);
                          C.emplaceBack(ie + Y, ae);
                        }
                      const U = ($, Z) => {
                        const Y = Z * L + $;
                        (D.emplaceBack(Y + 1, Y, Y + L),
                          D.emplaceBack(Y + L, Y + L + 1, Y + 1));
                      };
                      for (let $ = 1; $ < 129; $++)
                        for (let Z = 1; Z < 129; Z++) U(Z, $);
                      return (
                        [0, 129].forEach(($) => {
                          for (let Z = 0; Z < 130; Z++) (U(Z, $), U($, Z));
                        }),
                        [C, D, 32768]
                      );
                    })(),
                    x = t.context;
                  ((this.gridBuffer = x.createVertexBuffer(h, r.bc.members)),
                    (this.gridIndexBuffer = x.createIndexBuffer(p)),
                    (this.gridSegments = r.bd.simpleSegment(
                      0,
                      0,
                      h.length,
                      p.length,
                    )),
                    (this.gridNoSkirtSegments = r.bd.simpleSegment(
                      0,
                      0,
                      h.length,
                      g,
                    )),
                    (this.proxyCoords = []),
                    (this.proxiedCoords = {}),
                    (this._visibleDemTiles = []),
                    (this._drapedRenderBatches = []),
                    (this._sourceTilesOverlap = {}),
                    (this.proxySourceCache = new ls(s.map)),
                    (this.orthoMatrix = r.bz()),
                    r.c5(
                      this.orthoMatrix,
                      this.painter.transform.projection.name === "globe"
                        ? 0.015
                        : 0,
                      r.aj,
                      0,
                      r.aj,
                      0,
                      1,
                    ));
                  const w = x.gl;
                  ((this._overlapStencilMode = new Yt(
                    { func: w.GEQUAL, mask: 255 },
                    0,
                    255,
                    w.KEEP,
                    w.KEEP,
                    w.REPLACE,
                  )),
                    (this._previousZoom = t.transform.zoom),
                    (this.pool = []),
                    (this._findCoveringTileCache = {}),
                    (this._tilesDirty = {}),
                    (this.style = s),
                    (this._useVertexMorphing = !0),
                    (this._exaggeration = 1),
                    (this._mockSourceCache = new Up(s.map)),
                    (this._pendingGroundEffectLayers = []));
                }
                set style(t) {
                  (t.on("data", this._onStyleDataEvent.bind(this)),
                    (this._style = t),
                    this._style.map.on("moveend", () => {
                      this._clearLineLayersFromRenderCache();
                    }));
                }
                update(t, s, h) {
                  if (t && t.terrain) {
                    this._style !== t &&
                      ((this.style = t), (this._evaluationZoom = void 0));
                    const p = t.terrain.properties,
                      g = t.terrain.drapeRenderMode === 0,
                      x = t.terrain.isZoomDependent();
                    ((this._previousUpdateTimestamp = this.enabled
                      ? this._updateTimestamp
                      : void 0),
                      (this._updateTimestamp = r.q.now()));
                    const w = t.terrain && t.terrain.scope,
                      S = p.get("source"),
                      C = g ? this._mockSourceCache : t.getSourceCache(S, w);
                    if (!C)
                      return void r.w(`Couldn't find terrain source "${S}".`);
                    if (
                      ((this.sourceCache = C),
                      (this._attenuationRange =
                        t.terrain.getAttenuationRange()),
                      (this._exaggeration = x
                        ? this.calculateExaggeration(s)
                        : p.get("exaggeration")),
                      !s.projection.requiresDraping &&
                        x &&
                        this._exaggeration === 0)
                    )
                      return void this._disable();
                    this.enabled = !0;
                    const D = () => {
                      this.sourceCache.used &&
                        r.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                      const L = this.getScaledDemTileSize();
                      (this.sourceCache.update(s, L, !0),
                        this.resetTileLookupCache(this.sourceCache.id));
                    };
                    (this.sourceCache.usedForTerrain ||
                      (this.resetTileLookupCache(this.sourceCache.id),
                      (this.sourceCache.usedForTerrain = !0),
                      D(),
                      (this._initializing = !0)),
                      D(),
                      s.updateElevation(!0, h),
                      this.resetTileLookupCache(this.proxySourceCache.id),
                      this.proxySourceCache.update(s),
                      (this._emptyDEMTextureDirty = !0),
                      (this._previousZoom = s.zoom));
                  } else this._disable();
                }
                calculateExaggeration(t) {
                  if (
                    this._attenuationRange &&
                    t.zoom >= Math.ceil(this._attenuationRange[1])
                  )
                    return this._style.terrain.getExaggeration(t.zoom);
                  const s = this._previousCameraAltitude,
                    h =
                      (t.getFreeCameraOptions().position.z / t.pixelsPerMeter) *
                      t.worldSize;
                  this._previousCameraAltitude = h;
                  const p = s != null ? h - s : Number.MAX_VALUE;
                  if (Math.abs(p) < 2) return this._exaggeration;
                  const g = t.zoom,
                    x = this._style.terrain;
                  if (!this._previousUpdateTimestamp)
                    return x.getExaggeration(g);
                  let w = g - this._previousZoom;
                  const S = this._previousUpdateTimestamp;
                  let C = g;
                  (this._evaluationZoom != null &&
                    ((C = this._evaluationZoom),
                    Math.abs(g - C) > 0.5 && (w = 0.5 * (g - C + w)),
                    w * p < 0 && (C += w)),
                    (this._evaluationZoom = C));
                  const D = x.getExaggeration(C),
                    L = D === x.getExaggeration(Math.max(0, C - 0.1));
                  if (L && Math.abs(D - this._exaggeration) < 0.01) return D;
                  let z = Math.min(0.1, 0.00375 * (this._updateTimestamp - S));
                  return (
                    (L || D < 0.1 || Math.abs(w) < 1e-4) &&
                      (z = Math.min(0.2, 4 * z)),
                    r.ai(this._exaggeration, D, z)
                  );
                }
                resetTileLookupCache(t) {
                  this._findCoveringTileCache[t] = {};
                }
                attenuationRange() {
                  return this._attenuationRange;
                }
                getDemUpscale() {
                  return this.proxySourceCache.getSource().tileSize / 128;
                }
                getScaledDemTileSize() {
                  return (
                    (this.sourceCache.getSource().tileSize / 128) *
                    this.proxySourceCache.getSource().tileSize
                  );
                }
                _onStyleDataEvent(t) {
                  t.coord && t.dataType === "source"
                    ? this._clearRenderCacheForTile(t.sourceCacheId, t.coord)
                    : t.dataType === "style" &&
                      ((this.invalidateRenderCache = !0),
                      (this._evaluationZoom = void 0),
                      (this._previousUpdateTimestamp = void 0),
                      (this._previousCameraAltitude = void 0));
                }
                _disable() {
                  if (
                    this.enabled &&
                    ((this.enabled = !1),
                    (this._emptyDEMTextureDirty = !0),
                    (this._sharedDepthStencil = void 0),
                    (this._evaluationZoom = void 0),
                    (this._previousUpdateTimestamp = void 0),
                    this.proxySourceCache.deallocRenderCache(),
                    this._style)
                  )
                    for (const t in this._style._mergedSourceCaches)
                      this._style._mergedSourceCaches[t].usedForTerrain = !1;
                }
                destroy() {
                  (this._disable(),
                    this._emptyDEMTexture && this._emptyDEMTexture.destroy(),
                    this.pool.forEach((t) => t.fb.destroy()),
                    (this.pool = []),
                    this.framebufferCopyTexture &&
                      this.framebufferCopyTexture.destroy());
                }
                _source() {
                  return this.enabled ? this.sourceCache : null;
                }
                isUsingMockSource() {
                  return this.sourceCache === this._mockSourceCache;
                }
                exaggeration() {
                  return this.enabled ? this._exaggeration : 0;
                }
                get visibleDemTiles() {
                  return this._visibleDemTiles;
                }
                get drapeBufferSize() {
                  const t = 2 * this.proxySourceCache.getSource().tileSize;
                  return [t, t];
                }
                set useVertexMorphing(t) {
                  this._useVertexMorphing = t;
                }
                updateTileBinding(t) {
                  if (!this.enabled) return;
                  this.prevTerrainTileForTile = this.terrainTileForTile;
                  const s = this.proxySourceCache,
                    h = this.painter.transform;
                  this._initializing &&
                    ((this._initializing =
                      h._centerAltitude === 0 &&
                      this.getAtPointOrZero(r.ac.fromLngLat(h.center), -1) ===
                        -1),
                    (this._emptyDEMTextureDirty = !this._initializing));
                  const p = (this.proxyCoords = s.getIds().map((S) => {
                    const C = s.getTileByID(S).tileID;
                    return (
                      (C.projMatrix = h.calculateProjMatrix(C.toUnwrapped())),
                      C
                    );
                  }));
                  (function (S, C) {
                    const D = C.transform.pointCoordinate(
                        C.transform.getCameraPoint(),
                      ),
                      L = new r.P(D.x, D.y);
                    S.sort((z, O) => {
                      if (O.overscaledZ - z.overscaledZ)
                        return O.overscaledZ - z.overscaledZ;
                      const G = new r.P(
                          z.canonical.x + (1 << z.canonical.z) * z.wrap,
                          z.canonical.y,
                        ),
                        U = new r.P(
                          O.canonical.x + (1 << O.canonical.z) * O.wrap,
                          O.canonical.y,
                        ),
                        $ = L.mult(1 << z.canonical.z);
                      return (
                        ($.x -= 0.5),
                        ($.y -= 0.5),
                        $.distSqr(G) - $.distSqr(U)
                      );
                    });
                  })(p, this.painter);
                  const g = this.proxyToSource || {};
                  ((this.proxyToSource = {}),
                    p.forEach((S) => {
                      this.proxyToSource[S.key] = {};
                    }),
                    (this.terrainTileForTile = {}));
                  const x = this._style._mergedSourceCaches;
                  for (const S in x) {
                    const C = x[S];
                    if (
                      !C.used ||
                      (C !== this.sourceCache &&
                        this.resetTileLookupCache(C.id),
                      this._setupProxiedCoordsForOrtho(C, t[S], g),
                      C.usedForTerrain)
                    )
                      continue;
                    const D = t[S];
                    C.getSource().reparseOverscaled &&
                      this._assignTerrainTiles(D);
                  }
                  ((this.proxiedCoords[s.id] = p.map(
                    (S) => new Qh(S, S.key, this.orthoMatrix),
                  )),
                    this._assignTerrainTiles(p),
                    this._prepareDEMTextures(),
                    this._setupDrapedRenderBatches(),
                    this._initFBOPool(),
                    this._setupRenderCache(g),
                    (this.renderingToTexture = !1));
                  const w = {};
                  this._visibleDemTiles = [];
                  for (const S of this.proxyCoords) {
                    const C = this.terrainTileForTile[S.key];
                    if (!C) continue;
                    const D = C.tileID.key;
                    D in w || (this._visibleDemTiles.push(C), (w[D] = D));
                  }
                }
                _assignTerrainTiles(t) {
                  this._initializing ||
                    t.forEach((s) => {
                      if (this.terrainTileForTile[s.key]) return;
                      const h = this._findTileCoveringTileID(
                        s,
                        this.sourceCache,
                      );
                      h && (this.terrainTileForTile[s.key] = h);
                    });
                }
                _prepareDEMTextures() {
                  const t = this.painter.context,
                    s = t.gl;
                  for (const h in this.terrainTileForTile) {
                    const p = this.terrainTileForTile[h],
                      g = p.dem;
                    !g ||
                      (p.demTexture && !p.needsDEMTextureUpload) ||
                      (t.activeTexture.set(s.TEXTURE1), Gh(this.painter, p, g));
                  }
                }
                _prepareDemTileUniforms(t, s, h, p) {
                  if (!s || s.demTexture == null) return !1;
                  const g = t.tileID.canonical,
                    x = Math.pow(2, s.tileID.canonical.z - g.z),
                    w = p || "";
                  return (
                    (h[`u_dem_tl${w}`] = [(g.x * x) % 1, (g.y * x) % 1]),
                    (h[`u_dem_scale${w}`] = x),
                    !0
                  );
                }
                get emptyDEMTexture() {
                  return !this._emptyDEMTextureDirty && this._emptyDEMTexture
                    ? this._emptyDEMTexture
                    : this._updateEmptyDEMTexture();
                }
                _getLoadedAreaMinimum() {
                  if (!this.enabled) return 0;
                  let t = 0;
                  const s = this._visibleDemTiles.reduce((h, p) => {
                    if (!p.dem) return h;
                    const g = p.dem.tree.minimums[0];
                    return (g > 0 && t++, h + g);
                  }, 0);
                  return t ? s / t : 0;
                }
                _updateEmptyDEMTexture() {
                  const t = this.painter.context,
                    s = t.gl;
                  t.activeTexture.set(s.TEXTURE2);
                  const h = this._getLoadedAreaMinimum(),
                    p = new r.du(
                      { width: 1, height: 1 },
                      new Float32Array([h]),
                    );
                  this._emptyDEMTextureDirty = !1;
                  let g = this._emptyDEMTexture;
                  return (
                    g
                      ? g.update(p, { premultiply: !1 })
                      : (g = this._emptyDEMTexture =
                          new r.T(t, p, s.R32F, { premultiply: !1 })),
                    g
                  );
                }
                setupElevationDraw(t, s, h) {
                  const p = this.painter.context,
                    g = p.gl,
                    x = {
                      u_dem: 2,
                      u_dem_prev: 4,
                      u_dem_tl: [0, 0],
                      u_dem_tl_prev: [0, 0],
                      u_dem_scale: 0,
                      u_dem_scale_prev: 0,
                      u_dem_size: 0,
                      u_dem_lerp: 1,
                      u_depth: 3,
                      u_depth_size_inv: [0, 0],
                      u_depth_range_unpack: [0, 1],
                      u_occluder_half_size: 16,
                      u_occlusion_depth_offset: -1e-4,
                      u_exaggeration: 0,
                    };
                  x.u_exaggeration = this.exaggeration();
                  let w = null,
                    S = null,
                    C = 1;
                  if (h && h.morphing && this._useVertexMorphing) {
                    const O = h.morphing.srcDemTile,
                      G = h.morphing.dstDemTile;
                    ((C = h.morphing.phase),
                      O &&
                        G &&
                        (this._prepareDemTileUniforms(t, O, x, "_prev") &&
                          (S = O),
                        this._prepareDemTileUniforms(t, G, x) && (w = G)));
                  }
                  const D = (O) =>
                    O &&
                    O.demTexture &&
                    this.painter.linearFloatFilteringSupported()
                      ? g.LINEAR
                      : g.NEAREST;
                  let L = null;
                  var z;
                  if (
                    (this.enabled
                      ? S && w
                        ? ((L = w.demTexture),
                          p.activeTexture.set(g.TEXTURE4),
                          S.demTexture.bind(D(S), g.CLAMP_TO_EDGE),
                          (x.u_dem_lerp = C))
                        : ((w = this.terrainTileForTile[t.tileID.key]),
                          (L = this._prepareDemTileUniforms(t, w, x)
                            ? w.demTexture
                            : this.emptyDEMTexture))
                      : (L = this.emptyDEMTexture),
                    p.activeTexture.set(g.TEXTURE2),
                    L &&
                      ((x.u_dem_size =
                        (z = L).size[0] === 1 ? 1 : z.size[0] - 2),
                      L.bind(D(w), g.CLAMP_TO_EDGE)),
                    this.painter.setupDepthForOcclusion(
                      h && h.useDepthForOcclusion,
                      s,
                      x,
                    ),
                    h && h.useMeterToDem && w)
                  ) {
                    const O =
                      (1 << w.tileID.canonical.z) *
                      r.c6(1, this.painter.transform.center.lat) *
                      this.sourceCache.getSource().tileSize;
                    x.u_meter_to_dem = O;
                  }
                  if (
                    (h &&
                      h.labelPlaneMatrixInv &&
                      (x.u_label_plane_matrix_inv = h.labelPlaneMatrixInv),
                    s.setTerrainUniformValues(p, x),
                    this.painter.transform.projection.name === "globe")
                  ) {
                    const O = this.globeUniformValues(
                      this.painter.transform,
                      t.tileID.canonical,
                      h && h.useDenormalizedUpVectorScale,
                    );
                    s.setGlobeUniformValues(p, O);
                  }
                }
                globeUniformValues(t, s, h) {
                  const p = t.projection;
                  return {
                    u_tile_tl_up: p.upVector(s, 0, 0),
                    u_tile_tr_up: p.upVector(s, r.aj, 0),
                    u_tile_br_up: p.upVector(s, r.aj, r.aj),
                    u_tile_bl_up: p.upVector(s, 0, r.aj),
                    u_tile_up_scale: h
                      ? r.dv(1)
                      : p.upVectorScale(s, t.center.lat, t.worldSize)
                          .metersToTile,
                  };
                }
                renderToBackBuffer(t) {
                  const s = this.painter,
                    h = this.painter.context;
                  t.length !== 0 &&
                    (h.bindFramebuffer.set(null),
                    h.viewport.set([0, 0, s.width, s.height]),
                    s.gpuTimingDeferredRenderStart(),
                    (this.renderingToTexture = !1),
                    (function (p, g, x, w, S) {
                      if (p.transform.projection.name === "globe")
                        (function (C, D, L, z, O) {
                          const G = C.context,
                            U = G.gl;
                          let $, Z;
                          const Y = C.transform,
                            ie = r.dl(C, G, Y),
                            ae = (He, We) => {
                              if (Z === We) return;
                              const et = [Id[We], "PROJECTION_GLOBE_VIEW"];
                              ie && et.push("CUSTOM_ANTIALIASING");
                              const Ce = C.isTileAffectedByFog(He);
                              (($ = C.getOrCreateProgram("globeRaster", {
                                defines: et,
                                overrideFog: Ce,
                              })),
                                (Z = We));
                            },
                            pe = C.colorModeForRenderPass(),
                            ue = new wt(
                              U.LEQUAL,
                              wt.ReadWrite,
                              C.depthRangeFor3D,
                            );
                          Oo.update(O);
                          const ce = r.dm(Y),
                            le = [r.aD(Y.center.lng), r.aH(Y.center.lat)],
                            me = C.globeSharedBuffers,
                            _e = [
                              Y.width * r.q.devicePixelRatio,
                              Y.height * r.q.devicePixelRatio,
                            ],
                            De = Float32Array.from(Y.globeMatrix),
                            ze = { useDenormalizedUpVectorScale: !0 };
                          {
                            const He = C.transform,
                              We = Ad(
                                He.zoom,
                                D.exaggeration(),
                                D.sourceCache._source.tileSize,
                              );
                            Z = -1;
                            const et = U.TRIANGLES;
                            for (const Ce of z) {
                              const Ve = L.getTile(Ce),
                                Te = Yt.disabled,
                                Ze = D.prevTerrainTileForTile[Ce.key],
                                Oe = D.terrainTileForTile[Ce.key];
                              (Jh(Ze, Oe) &&
                                Oo.newMorphing(Ce.key, Ze, Oe, O, 250),
                                G.activeTexture.set(U.TEXTURE0),
                                Ve.texture &&
                                  Ve.texture.bind(U.LINEAR, U.CLAMP_TO_EDGE));
                              const Ke = Oo.getMorphValuesForProxy(Ce.key),
                                ht = Ke ? 1 : 0;
                              Ke &&
                                r.L(ze, {
                                  morphing: {
                                    srcDemTile: Ke.from,
                                    dstDemTile: Ke.to,
                                    phase: r.dk(Ke.phase),
                                  },
                                });
                              const qe = r.dn(Ce.canonical),
                                lt = r.dp(qe.getCenter().lat),
                                St = r.dq(
                                  Ce.canonical,
                                  qe,
                                  lt,
                                  He.worldSize / He._pixelsPerMercatorPixel,
                                ),
                                Et = r.bh(r.dr(Ce.canonical)),
                                bt = Kh(
                                  He.expandedFarZProjMatrix,
                                  De,
                                  ce,
                                  Et,
                                  r.ah(He.zoom),
                                  le,
                                  He.frustumCorners.TL,
                                  He.frustumCorners.TR,
                                  He.frustumCorners.BR,
                                  He.frustumCorners.BL,
                                  He.globeCenterInViewSpace,
                                  He.globeRadius,
                                  _e,
                                  We,
                                  He._farZ,
                                  St,
                                );
                              if (
                                (ae(Ce, ht),
                                $ &&
                                  (D.setupElevationDraw(Ve, $, ze),
                                  C.uploadCommonUniforms(
                                    G,
                                    $,
                                    Ce.toUnwrapped(),
                                  ),
                                  me))
                              ) {
                                const [kt, Bt, Vt] = me.getGridBuffers(
                                  lt,
                                  We !== 0,
                                );
                                $.draw(
                                  C,
                                  et,
                                  ue,
                                  Te,
                                  pe,
                                  Gt.backCCW,
                                  bt,
                                  "globe_raster",
                                  kt,
                                  Bt,
                                  Vt,
                                );
                              }
                            }
                          }
                          if (
                            me &&
                            (C.renderDefaultNorthPole ||
                              C.renderDefaultSouthPole)
                          ) {
                            const He = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                            (ie && He.push("CUSTOM_ANTIALIASING"),
                              ($ = C.getOrCreateProgram("globeRaster", {
                                defines: He,
                              })));
                            for (const We of z) {
                              const { x: et, y: Ce, z: Ve } = We.canonical,
                                Te = Ce === 0,
                                Ze = Ce === (1 << Ve) - 1,
                                [Oe, Ke, ht, qe] = me.getPoleBuffers(Ve, !1);
                              if (qe && (Te || Ze)) {
                                const lt = L.getTile(We);
                                (G.activeTexture.set(U.TEXTURE0),
                                  lt.texture &&
                                    lt.texture.bind(U.LINEAR, U.CLAMP_TO_EDGE));
                                let St = r.ds(Ve, et, Y);
                                const Et = r.bh(r.dr(We.canonical)),
                                  bt = (kt, Bt) =>
                                    kt.draw(
                                      C,
                                      U.TRIANGLES,
                                      ue,
                                      Yt.disabled,
                                      pe,
                                      Gt.disabled,
                                      Kh(
                                        Y.expandedFarZProjMatrix,
                                        St,
                                        St,
                                        Et,
                                        0,
                                        le,
                                        Y.frustumCorners.TL,
                                        Y.frustumCorners.TR,
                                        Y.frustumCorners.BR,
                                        Y.frustumCorners.BL,
                                        Y.globeCenterInViewSpace,
                                        Y.globeRadius,
                                        _e,
                                        0,
                                        Y._farZ,
                                      ),
                                      "globe_pole_raster",
                                      Bt,
                                      ht,
                                      qe,
                                    );
                                (D.setupElevationDraw(lt, $, ze),
                                  C.uploadCommonUniforms(
                                    G,
                                    $,
                                    We.toUnwrapped(),
                                  ),
                                  Te && C.renderDefaultNorthPole && bt($, Oe),
                                  Ze &&
                                    C.renderDefaultSouthPole &&
                                    ((St = r.cE(r.bz(), St, [1, -1, 1])),
                                    bt($, Ke)));
                              }
                            }
                          }
                        })(p, g, x, w, S);
                      else {
                        const C = p.context,
                          D = C.gl;
                        let L, z;
                        const O = p.shadowRenderer,
                          G = Bs(p, p.longestCutoffRange),
                          U = (pe) => {
                            if (z === pe) return;
                            const ue = [];
                            (ue.push(Id[pe]),
                              G.shouldRenderCutoff && ue.push("RENDER_CUTOFF"),
                              O &&
                                (ue.push("RENDER_SHADOWS", "DEPTH_TEXTURE"),
                                O.useNormalOffset && ue.push("NORMAL_OFFSET")),
                              (L = p.getOrCreateProgram("terrainRaster", {
                                defines: ue,
                              })),
                              (z = pe));
                          },
                          $ = p.colorModeForRenderPass(),
                          Z = new wt(D.LEQUAL, wt.ReadWrite, p.depthRangeFor3D);
                        Oo.update(S);
                        const Y = p.transform,
                          ie = Ad(
                            Y.zoom,
                            g.exaggeration(),
                            g.sourceCache._source.tileSize,
                          );
                        let ae = [0, 0, 0];
                        if (O) {
                          const pe = p.style.directionalLight,
                            ue = p.style.ambientLight;
                          pe && ue && (ae = wa(p.style, pe, ue));
                        }
                        {
                          z = -1;
                          const pe = D.TRIANGLES,
                            [ue, ce] = [g.gridIndexBuffer, g.gridSegments];
                          for (const le of w) {
                            const me = x.getTile(le),
                              _e = Yt.disabled,
                              De = g.prevTerrainTileForTile[le.key],
                              ze = g.terrainTileForTile[le.key];
                            (Jh(De, ze) &&
                              Oo.newMorphing(le.key, De, ze, S, 250),
                              C.activeTexture.set(D.TEXTURE0),
                              me.texture &&
                                me.texture.bind(D.LINEAR, D.CLAMP_TO_EDGE));
                            const He = Oo.getMorphValuesForProxy(le.key),
                              We = He ? 1 : 0;
                            let et;
                            He &&
                              (et = {
                                morphing: {
                                  srcDemTile: He.from,
                                  dstDemTile: He.to,
                                  phase: r.dk(He.phase),
                                },
                              });
                            const Ce = Ed(
                              le.projMatrix,
                              A_(le.canonical, Y.renderWorldCopies)
                                ? ie / 10
                                : ie,
                              ae,
                            );
                            if ((U(We), !L)) continue;
                            g.setupElevationDraw(me, L, et);
                            const Ve = le.toUnwrapped();
                            (O && O.setupShadows(Ve, L),
                              p.uploadCommonUniforms(C, L, Ve, null, G),
                              L.draw(
                                p,
                                pe,
                                Z,
                                _e,
                                $,
                                Gt.backCCW,
                                Ce,
                                "terrain_raster",
                                g.gridBuffer,
                                ue,
                                ce,
                              ));
                          }
                        }
                      }
                    })(
                      s,
                      this,
                      this.proxySourceCache,
                      t,
                      this._updateTimestamp,
                    ),
                    (this.renderingToTexture = !0),
                    s.gpuTimingDeferredRenderEnd(),
                    t.splice(0, t.length));
                }
                renderBatch(t) {
                  if (this._drapedRenderBatches.length === 0) return t + 1;
                  this.renderingToTexture = !0;
                  const s = this.painter,
                    h = this.painter.context,
                    p = this.proxySourceCache,
                    g = this.proxiedCoords[p.id],
                    x = this._drapedRenderBatches.shift(),
                    w = s.style.order,
                    S = [];
                  let C = 0;
                  for (const D of g) {
                    const L = p.getTileByID(D.proxyTileKey),
                      z = p.proxyCachedFBO[D.key]
                        ? p.proxyCachedFBO[D.key][t]
                        : void 0,
                      O = z !== void 0 ? p.renderCache[z] : this.pool[C++],
                      G = z !== void 0;
                    if (((L.texture = O.tex), G && !O.dirty)) {
                      S.push(L.tileID);
                      continue;
                    }
                    let U;
                    (h.bindFramebuffer.set(O.fb.framebuffer),
                      (this.renderedToTile = !1),
                      O.dirty &&
                        (h.clear({ color: r.am.transparent, stencil: 0 }),
                        (O.dirty = !1)));
                    for (let $ = x.start; $ <= x.end; ++$) {
                      const Z = s.style._mergedLayers[w[$]];
                      if (Z.isHidden(s.transform.zoom)) continue;
                      const Y = s.style.getLayerSourceCache(Z),
                        ie = Y ? this.proxyToSource[D.key][Y.id] : [D];
                      if (!ie) continue;
                      const ae = ie;
                      (h.viewport.set([0, 0, O.fb.width, O.fb.height]),
                        U !== (Y ? Y.id : null) &&
                          (this._setupStencil(O, ie, Z, Y),
                          (U = Y ? Y.id : null)),
                        s.renderLayer(s, Y, Z, ae));
                    }
                    if (this._drapedRenderBatches.length === 0)
                      for (const $ of this._pendingGroundEffectLayers) {
                        const Z = s.style._mergedLayers[w[$]];
                        if (Z.isHidden(s.transform.zoom)) continue;
                        const Y = s.style.getLayerSourceCache(Z),
                          ie = Y ? this.proxyToSource[D.key][Y.id] : [D];
                        if (!ie) continue;
                        const ae = ie;
                        (h.viewport.set([0, 0, O.fb.width, O.fb.height]),
                          U !== (Y ? Y.id : null) &&
                            (this._setupStencil(O, ie, Z, Y),
                            (U = Y ? Y.id : null)),
                          s.renderLayer(s, Y, Z, ae));
                      }
                    (this.renderedToTile
                      ? ((O.dirty = !0), S.push(L.tileID))
                      : G || --C,
                      C === 5 && ((C = 0), this.renderToBackBuffer(S)));
                  }
                  return (
                    this.renderToBackBuffer(S),
                    (this.renderingToTexture = !1),
                    h.bindFramebuffer.set(null),
                    h.viewport.set([0, 0, s.width, s.height]),
                    x.end + 1
                  );
                }
                postRender() {}
                isLayerOrderingCorrect(t) {
                  const s = t.order.length;
                  let h = -1,
                    p = s;
                  for (let g = 0; g < s; ++g)
                    this._style.isLayerDraped(t._mergedLayers[t.order[g]])
                      ? (h = Math.max(h, g))
                      : (p = Math.min(p, g));
                  return p > h;
                }
                getMinElevationBelowMSL() {
                  let t = 0;
                  return (
                    this._visibleDemTiles
                      .filter((s) => s.dem)
                      .forEach((s) => {
                        t = Math.min(t, s.dem.tree.minimums[0]);
                      }),
                    t === 0 ? t : (t - 30) * this._exaggeration
                  );
                }
                raycast(t, s, h) {
                  if (!this._visibleDemTiles) return null;
                  const p = this._visibleDemTiles
                    .filter((g) => g.dem)
                    .map((g) => {
                      const x = g.tileID,
                        w = 1 << x.overscaledZ,
                        { x: S, y: C } = x.canonical,
                        D = S / w,
                        L = (S + 1) / w,
                        z = C / w,
                        O = (C + 1) / w;
                      return {
                        minx: D,
                        miny: z,
                        maxx: L,
                        maxy: O,
                        t: g.dem.tree.raycastRoot(D, z, L, O, t, s, h),
                        tile: g,
                      };
                    });
                  p.sort(
                    (g, x) =>
                      (g.t !== null ? g.t : Number.MAX_VALUE) -
                      (x.t !== null ? x.t : Number.MAX_VALUE),
                  );
                  for (const g of p) {
                    if (g.t == null) return null;
                    const x = g.tile.dem.tree.raycast(
                      g.minx,
                      g.miny,
                      g.maxx,
                      g.maxy,
                      t,
                      s,
                      h,
                    );
                    if (x != null) return x;
                  }
                  return null;
                }
                _createFBO() {
                  const t = this.painter.context,
                    s = t.gl,
                    h = this.drapeBufferSize;
                  t.activeTexture.set(s.TEXTURE0);
                  const p = new r.T(
                    t,
                    { width: h[0], height: h[1], data: null },
                    s.RGBA8,
                  );
                  p.bind(s.LINEAR, s.CLAMP_TO_EDGE);
                  const g = t.createFramebuffer(h[0], h[1], !0, null);
                  return (
                    g.colorAttachment.set(p.texture),
                    (g.depthAttachment = new I_(t, g.framebuffer)),
                    this._sharedDepthStencil === void 0
                      ? ((this._sharedDepthStencil = t.createRenderbuffer(
                          t.gl.DEPTH_STENCIL,
                          h[0],
                          h[1],
                        )),
                        (this._stencilRef = 0),
                        g.depthAttachment.set(this._sharedDepthStencil),
                        t.clear({ stencil: 0 }))
                      : g.depthAttachment.set(this._sharedDepthStencil),
                    t.extTextureFilterAnisotropic &&
                      s.texParameterf(
                        s.TEXTURE_2D,
                        t.extTextureFilterAnisotropic
                          .TEXTURE_MAX_ANISOTROPY_EXT,
                        t.extTextureFilterAnisotropicMax,
                      ),
                    { fb: g, tex: p, dirty: !1 }
                  );
                }
                _initFBOPool() {
                  for (
                    ;
                    this.pool.length < Math.min(5, this.proxyCoords.length);

                  )
                    this.pool.push(this._createFBO());
                }
                _shouldDisableRenderCache() {
                  if (
                    this._debugParams.disableRenderCache ||
                    this._style.hasLightTransitions()
                  )
                    return !0;
                  for (const t in this._style._mergedSourceCaches)
                    if (this._style._mergedSourceCaches[t].hasTransition())
                      return !0;
                  return this._style.order.some((t) => {
                    const s = this._style._mergedLayers[t],
                      h = s.isHidden(this.painter.transform.zoom);
                    return s.type === "hillshade" || s.type === "custom"
                      ? !h && s.shouldRedrape()
                      : !h && s.hasTransition();
                  });
                }
                _clearLineLayersFromRenderCache() {
                  let t = !1;
                  for (const h of this._style.getSources())
                    if (h instanceof sc) {
                      t = !0;
                      break;
                    }
                  if (!t) return;
                  const s = {};
                  for (let h = 0; h < this._style.order.length; ++h) {
                    const p = this._style._mergedLayers[this._style.order[h]],
                      g = this._style.getLayerSourceCache(p);
                    if (
                      g &&
                      !s[g.id] &&
                      !p.isHidden(this.painter.transform.zoom) &&
                      p.type === "line" &&
                      p.widthExpression() instanceof r.ab
                    ) {
                      s[g.id] = !0;
                      for (const x of this.proxyCoords) {
                        const w = this.proxyToSource[x.key][g.id];
                        if (w)
                          for (const S of w)
                            this._clearRenderCacheForTile(g.id, S);
                      }
                    }
                  }
                }
                _clearRasterLayersFromRenderCache() {
                  let t = !1;
                  for (const h in this._style._mergedSourceCaches)
                    if (
                      this._style._mergedSourceCaches[h]._source instanceof hr
                    ) {
                      t = !0;
                      break;
                    }
                  if (!t) return;
                  const s = {};
                  for (let h = 0; h < this._style.order.length; ++h) {
                    const p = this._style._mergedLayers[this._style.order[h]],
                      g = this._style.getLayerSourceCache(p);
                    if (
                      !g ||
                      s[g.id] ||
                      p.isHidden(this.painter.transform.zoom) ||
                      p.type !== "raster"
                    )
                      continue;
                    const x = p.paint.get("raster-fade-duration");
                    for (const w of this.proxyCoords) {
                      const S = this.proxyToSource[w.key][g.id];
                      if (S)
                        for (const C of S) {
                          const D = Ia(
                            g.getTile(C),
                            g.findLoadedParent(C, 0),
                            g,
                            this.painter.transform,
                            x,
                          );
                          (D.opacity !== 1 || D.mix !== 0) &&
                            this._clearRenderCacheForTile(g.id, C);
                        }
                    }
                  }
                }
                _setupDrapedRenderBatches() {
                  this._style.updateDrapeFirstLayers();
                  const t = this._style.order,
                    s = t.length;
                  if (s === 0) return;
                  const h = [];
                  this._pendingGroundEffectLayers = [];
                  let p,
                    g = 0,
                    x = this._style._mergedLayers[t[g]];
                  for (
                    ;
                    !this._style.isLayerDraped(x) &&
                    x.isHidden(this.painter.transform.zoom) &&
                    ++g < s;

                  )
                    x = this._style._mergedLayers[t[g]];
                  for (; g < s; ++g) {
                    const w = this._style._mergedLayers[t[g]];
                    w.isHidden(this.painter.transform.zoom) ||
                      (this._style.isLayerDraped(w)
                        ? p === void 0 && (p = g)
                        : (w.type === "fill-extrusion" &&
                            this._pendingGroundEffectLayers.push(g),
                          p !== void 0 &&
                            (h.push({ start: p, end: g - 1 }), (p = void 0))));
                  }
                  if (
                    (p !== void 0 && h.push({ start: p, end: g - 1 }),
                    h.length !== 0)
                  ) {
                    const w = h[h.length - 1];
                    this._pendingGroundEffectLayers.every((S) => S > w.end) ||
                      r.w(
                        "fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.",
                      );
                  }
                  this._drapedRenderBatches = h;
                }
                _setupRenderCache(t) {
                  const s = this.proxySourceCache;
                  if (
                    this._shouldDisableRenderCache() ||
                    this.invalidateRenderCache
                  ) {
                    if (
                      ((this.invalidateRenderCache = !1),
                      s.renderCache.length > s.renderCachePool.length)
                    ) {
                      const x = Object.values(s.proxyCachedFBO);
                      s.proxyCachedFBO = {};
                      for (let w = 0; w < x.length; ++w) {
                        const S = Object.values(x[w]);
                        s.renderCachePool.push(...S);
                      }
                    }
                    return;
                  }
                  this._clearRasterLayersFromRenderCache();
                  const h = this.proxyCoords,
                    p = this._tilesDirty;
                  for (let x = h.length - 1; x >= 0; x--) {
                    const w = h[x];
                    if (
                      (s.getTileByID(w.key), s.proxyCachedFBO[w.key] !== void 0)
                    ) {
                      const S = t[w.key],
                        C = this.proxyToSource[w.key];
                      let D = 0;
                      for (const L in C) {
                        const z = C[L],
                          O = S[L];
                        if (
                          !O ||
                          O.length !== z.length ||
                          z.some(
                            (G, U) =>
                              G !== O[U] ||
                              (p[L] && p[L].hasOwnProperty(G.key)),
                          )
                        ) {
                          D = -1;
                          break;
                        }
                        ++D;
                      }
                      for (const L in s.proxyCachedFBO[w.key])
                        s.renderCache[s.proxyCachedFBO[w.key][L]].dirty =
                          D < 0 || D !== Object.values(S).length;
                    }
                  }
                  const g = [...this._drapedRenderBatches];
                  g.sort((x, w) => w.end - w.start - (x.end - x.start));
                  for (const x of g)
                    for (const w of h) {
                      if (s.proxyCachedFBO[w.key]) continue;
                      let S = s.renderCachePool.pop();
                      (S === void 0 &&
                        s.renderCache.length < 50 &&
                        ((S = s.renderCache.length),
                        s.renderCache.push(this._createFBO())),
                        S !== void 0 &&
                          ((s.proxyCachedFBO[w.key] = {}),
                          (s.proxyCachedFBO[w.key][x.start] = S),
                          (s.renderCache[S].dirty = !0)));
                    }
                  this._tilesDirty = {};
                }
                _setupStencil(t, s, h, p) {
                  if (!p || !this._sourceTilesOverlap[p.id])
                    return void (
                      this._overlapStencilType &&
                      (this._overlapStencilType = !1)
                    );
                  const g = this.painter.context,
                    x = g.gl;
                  if (s.length <= 1)
                    return void (this._overlapStencilType = !1);
                  let w;
                  if (h.isTileClipped())
                    ((w = s.length),
                      (this._overlapStencilMode.test = {
                        func: x.EQUAL,
                        mask: 255,
                      }),
                      (this._overlapStencilType = "Clip"));
                  else {
                    if (!(s[0].overscaledZ > s[s.length - 1].overscaledZ))
                      return void (this._overlapStencilType = !1);
                    ((w = 1),
                      (this._overlapStencilMode.test = {
                        func: x.GREATER,
                        mask: 255,
                      }),
                      (this._overlapStencilType = "Mask"));
                  }
                  (this._stencilRef + w > 255 &&
                    (g.clear({ stencil: 0 }), (this._stencilRef = 0)),
                    (this._stencilRef += w),
                    (this._overlapStencilMode.ref = this._stencilRef),
                    h.isTileClipped() &&
                      this._renderTileClippingMasks(
                        s,
                        this._overlapStencilMode.ref,
                      ));
                }
                clipOrMaskOverlapStencilType() {
                  return (
                    this._overlapStencilType === "Clip" ||
                    this._overlapStencilType === "Mask"
                  );
                }
                stencilModeForRTTOverlap(t) {
                  return this.renderingToTexture && this._overlapStencilType
                    ? (this._overlapStencilType === "Clip" &&
                        (this._overlapStencilMode.ref =
                          this.painter._tileClippingMaskIDs[t.key]),
                      this._overlapStencilMode)
                    : Yt.disabled;
                }
                _renderTileClippingMasks(t, s) {
                  const h = this.painter,
                    p = this.painter.context,
                    g = p.gl;
                  ((h._tileClippingMaskIDs = {}),
                    p.setColorMode(ui.disabled),
                    p.setDepthMode(wt.disabled));
                  const x = h.getOrCreateProgram("clippingMask");
                  for (const w of t) {
                    const S = (h._tileClippingMaskIDs[w.key] = --s);
                    x.draw(
                      h,
                      g.TRIANGLES,
                      wt.disabled,
                      new Yt(
                        { func: g.ALWAYS, mask: 0 },
                        S,
                        255,
                        g.KEEP,
                        g.KEEP,
                        g.REPLACE,
                      ),
                      ui.disabled,
                      Gt.disabled,
                      Ea(w.projMatrix),
                      "$clipping",
                      h.tileExtentBuffer,
                      h.quadTriangleIndexBuffer,
                      h.tileExtentSegments,
                    );
                  }
                }
                pointCoordinate(t) {
                  const s = this.painter.transform;
                  if (t.x < 0 || t.x > s.width || t.y < 0 || t.y > s.height)
                    return null;
                  const h = [t.x, t.y, 1, 1];
                  (r.aA(h, h, s.pixelMatrixInverse),
                    r.cw(h, h, 1 / h[3]),
                    (h[0] /= s.worldSize),
                    (h[1] /= s.worldSize));
                  const p = s._camera.position,
                    g = r.c6(1, s.center.lat),
                    x = [p[0], p[1], p[2] / g, 0],
                    w = r.cX([], h.slice(0, 3), x);
                  r.au(w, w);
                  const S = this.raycast(x, w, this._exaggeration);
                  return S !== null && S
                    ? (r.bE(x, x, w, S), (x[3] = x[2]), (x[2] *= g), x)
                    : null;
                }
                _setupProxiedCoordsForOrtho(t, s, h) {
                  if (t.getSource() instanceof r.aP)
                    return this._setupProxiedCoordsForImageSource(t, s, h);
                  this._findCoveringTileCache[t.id] =
                    this._findCoveringTileCache[t.id] || {};
                  const p = (this.proxiedCoords[t.id] = []),
                    g = this.proxyCoords;
                  for (let S = 0; S < g.length; S++) {
                    const C = g[S],
                      D = this._findTileCoveringTileID(C, t);
                    if (D) {
                      const L = this._createProxiedId(
                        C,
                        D,
                        h[C.key] && h[C.key][t.id],
                      );
                      (p.push(L), (this.proxyToSource[C.key][t.id] = [L]));
                    }
                  }
                  let x = !1;
                  const w = new Set();
                  for (let S = 0; S < s.length; S++) {
                    const C = t.getTile(s[S]);
                    if (!C || !C.hasData()) continue;
                    const D = this._findTileCoveringTileID(
                      C.tileID,
                      this.proxySourceCache,
                    );
                    if (D && D.tileID.canonical.z !== C.tileID.canonical.z) {
                      const L = this.proxyToSource[D.tileID.key][t.id],
                        z = this._createProxiedId(
                          D.tileID,
                          C,
                          h[D.tileID.key] && h[D.tileID.key][t.id],
                        );
                      L
                        ? L.splice(L.length - 1, 0, z)
                        : (this.proxyToSource[D.tileID.key][t.id] = [z]);
                      const O = this.proxyToSource[D.tileID.key][t.id];
                      (w.has(O) || w.add(O), p.push(z), (x = !0));
                    }
                  }
                  if (
                    ((this._sourceTilesOverlap[t.id] = x),
                    x && this._debugParams.sortTilesHiZFirst)
                  )
                    for (const S of w)
                      S.sort((C, D) => D.overscaledZ - C.overscaledZ);
                }
                _setupProxiedCoordsForImageSource(t, s, h) {
                  if (!t.getSource().loaded()) return;
                  const p = (this.proxiedCoords[t.id] = []),
                    g = this.proxyCoords,
                    x = t.getSource(),
                    w = x.tileID;
                  if (!w) return;
                  const S = new r.P(w.x, w.y)._div(1 << w.z),
                    C = x.coordinates
                      .map(r.ac.fromLngLat)
                      .reduce(
                        (L, z) => (
                          (L.min.x = Math.min(L.min.x, z.x - S.x)),
                          (L.min.y = Math.min(L.min.y, z.y - S.y)),
                          (L.max.x = Math.max(L.max.x, z.x - S.x)),
                          (L.max.y = Math.max(L.max.y, z.y - S.y)),
                          L
                        ),
                        {
                          min: new r.P(Number.MAX_VALUE, Number.MAX_VALUE),
                          max: new r.P(-Number.MAX_VALUE, -Number.MAX_VALUE),
                        },
                      ),
                    D = (L, z) => {
                      const O = L.wrap + L.canonical.x / (1 << L.canonical.z),
                        G = L.canonical.y / (1 << L.canonical.z),
                        U = r.aj / (1 << L.canonical.z),
                        $ = z.wrap + z.canonical.x / (1 << z.canonical.z),
                        Z = z.canonical.y / (1 << z.canonical.z);
                      return (
                        O + U < $ + C.min.x ||
                        O > $ + C.max.x ||
                        G + U < Z + C.min.y ||
                        G > Z + C.max.y
                      );
                    };
                  for (let L = 0; L < g.length; L++) {
                    const z = g[L];
                    for (let O = 0; O < s.length; O++) {
                      const G = t.getTile(s[O]);
                      if (!G || !G.hasData() || D(z, G.tileID)) continue;
                      const U = this._createProxiedId(
                          z,
                          G,
                          h[z.key] && h[z.key][t.id],
                        ),
                        $ = this.proxyToSource[z.key][t.id];
                      ($ ? $.push(U) : (this.proxyToSource[z.key][t.id] = [U]),
                        p.push(U));
                    }
                  }
                }
                _createProxiedId(t, s, h) {
                  let p = this.orthoMatrix;
                  if (h) {
                    const g = h.find((x) => x.key === s.tileID.key);
                    if (g) return g;
                  }
                  if (s.tileID.key !== t.key) {
                    const g = t.canonical.z - s.tileID.canonical.z;
                    let x, w, S;
                    p = r.bz();
                    const C = (s.tileID.wrap - t.wrap) << t.overscaledZ;
                    (g > 0
                      ? ((x = r.aj >> g),
                        (w =
                          x *
                          ((s.tileID.canonical.x << g) - t.canonical.x + C)),
                        (S = x * ((s.tileID.canonical.y << g) - t.canonical.y)))
                      : ((x = r.aj << -g),
                        (w =
                          r.aj *
                          (s.tileID.canonical.x - ((t.canonical.x + C) << -g))),
                        (S =
                          r.aj *
                          (s.tileID.canonical.y - (t.canonical.y << -g)))),
                      r.c5(p, 0, x, 0, x, 0, 1),
                      r.bo(p, p, [w, S, 0]));
                  }
                  return new Qh(s.tileID, t.key, p);
                }
                _findTileCoveringTileID(t, s) {
                  let h = s.getTile(t);
                  if (h && h.hasData()) return h;
                  const p = this._findCoveringTileCache[s.id],
                    g = p[t.key];
                  if (
                    ((h = g ? s.getTileByID(g) : null),
                    (h && h.hasData()) || g === null)
                  )
                    return h;
                  let x = h ? h.tileID : t,
                    w = x.overscaledZ;
                  const S = s.getSource().minzoom,
                    C = [];
                  if (!g) {
                    const L = s.getSource().maxzoom;
                    if (t.canonical.z >= L) {
                      const z = t.canonical.z - L;
                      s.getSource().reparseOverscaled
                        ? ((w = Math.max(
                            t.canonical.z + 2,
                            s.transform.tileZoom,
                          )),
                          (x = new r.aM(
                            w,
                            t.wrap,
                            L,
                            t.canonical.x >> z,
                            t.canonical.y >> z,
                          )))
                        : z !== 0 &&
                          ((w = L),
                          (x = new r.aM(
                            w,
                            t.wrap,
                            L,
                            t.canonical.x >> z,
                            t.canonical.y >> z,
                          )));
                    }
                    x.key !== t.key && (C.push(x.key), (h = s.getTile(x)));
                  }
                  const D = (L) => {
                    (C.forEach((z) => {
                      p[z] = L;
                    }),
                      (C.length = 0));
                  };
                  for (w -= 1; w >= S && (!h || !h.hasData()); w--) {
                    h && D(h.tileID.key);
                    const L = x.calculateScaledKey(w);
                    if (((h = s.getTileByID(L)), h && h.hasData())) break;
                    const z = p[L];
                    if (z === null) break;
                    z === void 0 ? C.push(L) : (h = s.getTileByID(z));
                  }
                  return (
                    D(h ? h.tileID.key : null),
                    h && h.hasData() ? h : null
                  );
                }
                findDEMTileFor(t) {
                  return this.enabled
                    ? this._findTileCoveringTileID(t, this.sourceCache)
                    : null;
                }
                prepareDrawTile() {
                  this.renderedToTile = !0;
                }
                _clearRenderCacheForTile(t, s) {
                  let h = this._tilesDirty[t];
                  (h || (h = this._tilesDirty[t] = {}), (h[s.key] = !0));
                }
              }
              function eu(c, t, s) {
                const h = (function (w, S, C) {
                    const D = r.bG(S, w),
                      L = r.bG(C, [0.2126, 0.7152, 0.0722]),
                      z = (G, U, $) => (1 - $) * G + $ * U,
                      O = z(1 - 0.3 * Math.min(L, 1), 1, Math.min(D + 1, 1));
                    return (
                      z(0.92, 1, Math.asin(r.ay(S[2], -1, 1)) / Math.PI + 0.5) *
                      O
                    );
                  })(c, [0, 0, 1], t),
                  p = [0, 0, 0];
                r.bY(p, s.slice(0, 3), h);
                const g = [0, 0, 0];
                r.bY(g, t.slice(0, 3), c[2]);
                const x = [0, 0, 0];
                return (r.cV(x, p, g), r.cY(x));
              }
              const Md = [
                  "fill",
                  "fillOutline",
                  "fillPattern",
                  "line",
                  "linePattern",
                  "background",
                  "backgroundPattern",
                  "hillshade",
                  "raster",
                ],
                Cd = [
                  "stars",
                  "rainParticle",
                  "snowParticle",
                  "fillExtrusion",
                  "fillExtrusionGroundEffect",
                  "elevatedStructures",
                  "model",
                  "symbol",
                ];
              class tu {
                static cacheKey(t, s, h, p) {
                  let g = `${s}${p ? p.cacheKey : ""}`;
                  for (const x of h)
                    t.usedDefines.includes(x) && (g += `/${x}`);
                  return g;
                }
                constructor(t, s, h, p, g, x) {
                  const w = t.gl;
                  ((this.program = w.createProgram()),
                    (this.configuration = p),
                    (this.name = s),
                    (this.fixedDefines = [...x]));
                  const S = p ? p.getBinderAttributes() : [],
                    C = (h.staticAttributes || []).concat(S);
                  let D = p ? p.defines() : [];
                  D = D.concat(x.map(($) => `#define ${$}`));
                  const L = `#version 300 es
`;
                  let z =
                    L +
                    D.concat("precision mediump float;", Ns, Ic.fragmentSource)
                      .join(`
`);
                  for (const $ of h.fragmentIncludes)
                    z += `
${pl[$]}`;
                  z += `
${h.fragmentSource}`;
                  let O =
                    L +
                    D.concat("precision highp float;", Ns, Ic.vertexSource)
                      .join(`
`);
                  for (const $ of h.vertexIncludes)
                    O += `
${pl[$]}`;
                  ((this.forceManualRenderingForInstanceIDShaders =
                    t.forceManualRenderingForInstanceIDShaders &&
                    h.vertexSource.indexOf("gl_InstanceID") !== -1),
                    this.forceManualRenderingForInstanceIDShaders &&
                      (O += `
uniform int u_instanceID;
`),
                    (O += `
${h.vertexSource}`),
                    this.forceManualRenderingForInstanceIDShaders &&
                      (O = O.replaceAll("gl_InstanceID", "u_instanceID")));
                  const G = w.createShader(w.FRAGMENT_SHADER);
                  if (w.isContextLost()) return void (this.failedToCreate = !0);
                  (w.shaderSource(G, z),
                    w.compileShader(G),
                    w.attachShader(this.program, G));
                  const U = w.createShader(w.VERTEX_SHADER);
                  if (w.isContextLost()) this.failedToCreate = !0;
                  else {
                    (w.shaderSource(U, O),
                      w.compileShader(U),
                      w.attachShader(this.program, U),
                      (this.attributes = {}),
                      (this.numAttributes = C.length));
                    for (let $ = 0; $ < this.numAttributes; $++)
                      if (C[$]) {
                        const Z = C[$].startsWith("a_") ? C[$] : `a_${C[$]}`;
                        (w.bindAttribLocation(this.program, $, Z),
                          (this.attributes[Z] = $));
                      }
                    (w.linkProgram(this.program),
                      w.deleteShader(U),
                      w.deleteShader(G),
                      (this.fixedUniforms = g(t)),
                      (this.binderUniforms = p ? p.getUniforms(t) : []),
                      this.forceManualRenderingForInstanceIDShaders &&
                        (this.instancingUniforms = (($) => ({
                          u_instanceID: new r.c8($),
                        }))(t)),
                      (x.includes("TERRAIN") ||
                        s.indexOf("symbol") !== -1 ||
                        s.indexOf("circle") !== -1) &&
                        (this.terrainUniforms = (($) => ({
                          u_dem: new r.c8($),
                          u_dem_prev: new r.c8($),
                          u_dem_tl: new r.cb($),
                          u_dem_scale: new r.ca($),
                          u_dem_tl_prev: new r.cb($),
                          u_dem_scale_prev: new r.ca($),
                          u_dem_size: new r.ca($),
                          u_dem_lerp: new r.ca($),
                          u_exaggeration: new r.ca($),
                          u_depth: new r.c8($),
                          u_depth_size_inv: new r.cb($),
                          u_depth_range_unpack: new r.cb($),
                          u_occluder_half_size: new r.ca($),
                          u_occlusion_depth_offset: new r.ca($),
                          u_meter_to_dem: new r.ca($),
                          u_label_plane_matrix_inv: new r.cc($),
                        }))(t)),
                      x.includes("GLOBE") &&
                        (this.globeUniforms = (($) => ({
                          u_tile_tl_up: new r.c9($),
                          u_tile_tr_up: new r.c9($),
                          u_tile_br_up: new r.c9($),
                          u_tile_bl_up: new r.c9($),
                          u_tile_up_scale: new r.ca($),
                        }))(t)),
                      x.includes("FOG") &&
                        (this.fogUniforms = (($) => ({
                          u_fog_matrix: new r.cc($),
                          u_fog_range: new r.cb($),
                          u_fog_color: new r.cQ($),
                          u_fog_horizon_blend: new r.ca($),
                          u_fog_vertical_limit: new r.cb($),
                          u_fog_temporal_offset: new r.ca($),
                          u_frustum_tl: new r.c9($),
                          u_frustum_tr: new r.c9($),
                          u_frustum_br: new r.c9($),
                          u_frustum_bl: new r.c9($),
                          u_globe_pos: new r.c9($),
                          u_globe_radius: new r.ca($),
                          u_globe_transition: new r.ca($),
                          u_is_globe: new r.c8($),
                          u_viewport: new r.cb($),
                        }))(t)),
                      x.includes("RENDER_CUTOFF") &&
                        (this.cutoffUniforms = (($) => ({
                          u_cutoff_params: new r.cQ($),
                        }))(t)),
                      x.includes("LIGHTING_3D_MODE") &&
                        (this.lightsUniforms = (($) => ({
                          u_lighting_ambient_color: new r.c9($),
                          u_lighting_directional_dir: new r.c9($),
                          u_lighting_directional_color: new r.c9($),
                          u_ground_radiance: new r.c9($),
                        }))(t)),
                      x.includes("RENDER_SHADOWS") &&
                        (this.shadowUniforms = (($) => ({
                          u_light_matrix_0: new r.cc($),
                          u_light_matrix_1: new r.cc($),
                          u_fade_range: new r.cb($),
                          u_shadow_normal_offset: new r.c9($),
                          u_shadow_intensity: new r.ca($),
                          u_shadow_texel_size: new r.ca($),
                          u_shadow_map_resolution: new r.ca($),
                          u_shadow_direction: new r.c9($),
                          u_shadow_bias: new r.c9($),
                          u_shadowmap_0: new r.c8($),
                          u_shadowmap_1: new r.c8($),
                        }))(t)));
                  }
                }
                setTerrainUniformValues(t, s) {
                  if (!this.terrainUniforms) return;
                  const h = this.terrainUniforms;
                  if (!this.failedToCreate) {
                    t.program.set(this.program);
                    for (const p in s) h[p] && h[p].set(this.program, p, s[p]);
                  }
                }
                setGlobeUniformValues(t, s) {
                  if (!this.globeUniforms) return;
                  const h = this.globeUniforms;
                  if (!this.failedToCreate) {
                    t.program.set(this.program);
                    for (const p in s) h[p] && h[p].set(this.program, p, s[p]);
                  }
                }
                setFogUniformValues(t, s) {
                  if (!this.fogUniforms) return;
                  const h = this.fogUniforms;
                  if (!this.failedToCreate) {
                    t.program.set(this.program);
                    for (const p in s) h[p].set(this.program, p, s[p]);
                  }
                }
                setCutoffUniformValues(t, s) {
                  if (!this.cutoffUniforms) return;
                  const h = this.cutoffUniforms;
                  if (!this.failedToCreate) {
                    t.program.set(this.program);
                    for (const p in s) h[p].set(this.program, p, s[p]);
                  }
                }
                setLightsUniformValues(t, s) {
                  if (!this.lightsUniforms) return;
                  const h = this.lightsUniforms;
                  if (!this.failedToCreate) {
                    t.program.set(this.program);
                    for (const p in s) h[p].set(this.program, p, s[p]);
                  }
                }
                setShadowUniformValues(t, s) {
                  if (this.failedToCreate || !this.shadowUniforms) return;
                  const h = this.shadowUniforms;
                  t.program.set(this.program);
                  for (const p in s) h[p].set(this.program, p, s[p]);
                }
                _drawDebugWireframe(t, s, h, p, g, x, w, S, C, D) {
                  const L = t.options.wireframe;
                  if (
                    L.terrain === !1 &&
                    L.layers2D === !1 &&
                    L.layers3D === !1
                  )
                    return;
                  const z = t.context;
                  if (
                    !(
                      !(
                        !L.terrain ||
                        (this.name !== "terrainRaster" &&
                          this.name !== "globeRaster")
                      ) ||
                      !(
                        !L.layers2D ||
                        (t._terrain && t._terrain.renderingToTexture) ||
                        !Md.includes(this.name)
                      ) ||
                      !(!L.layers3D || !Cd.includes(this.name))
                    )
                  )
                    return;
                  const O = z.gl,
                    G = t.wireframeDebugCache.getLinesFromTrianglesBuffer(
                      t.frameCounter,
                      g,
                      z,
                    );
                  if (!G) return;
                  const U = [...this.fixedDefines];
                  U.push("DEBUG_WIREFRAME");
                  const $ = t.getOrCreateProgram(this.name, {
                    config: this.configuration,
                    defines: U,
                  });
                  z.program.set($.program);
                  const Z = (ae, pe, ue) => {
                    if (pe[ae] && ue[ae])
                      for (const ce in pe[ae])
                        ue[ae][ce] &&
                          ue[ae][ce].set(ue.program, ce, pe[ae][ce].current);
                  };
                  (C &&
                    C.setUniforms($.program, z, $.binderUniforms, w, {
                      zoom: S,
                    }),
                    Z("fixedUniforms", this, $),
                    Z("terrainUniforms", this, $),
                    Z("globeUniforms", this, $),
                    Z("fogUniforms", this, $),
                    Z("lightsUniforms", this, $),
                    Z("shadowUniforms", this, $),
                    G.bind(),
                    z.setColorMode(
                      new ui(
                        [O.ONE, O.ONE_MINUS_SRC_ALPHA, O.ZERO, O.ONE],
                        r.am.transparent,
                        [!0, !0, !0, !1],
                      ),
                    ),
                    z.setDepthMode(
                      new wt(
                        s.func === O.LESS ? O.LEQUAL : s.func,
                        wt.ReadOnly,
                        s.range,
                      ),
                    ),
                    z.setStencilMode(Yt.disabled));
                  const Y = 3 * x.primitiveLength * 2,
                    ie = 3 * x.primitiveOffset * 2 * 2;
                  if (this.forceManualRenderingForInstanceIDShaders) {
                    const ae = D || 1;
                    for (let pe = 0; pe < ae; ++pe)
                      ($.instancingUniforms.u_instanceID.set(
                        this.program,
                        "u_instanceID",
                        pe,
                      ),
                        O.drawElements(O.LINES, Y, O.UNSIGNED_SHORT, ie));
                  } else
                    D && D > 1
                      ? O.drawElementsInstanced(
                          O.LINES,
                          Y,
                          O.UNSIGNED_SHORT,
                          ie,
                          D,
                        )
                      : O.drawElements(O.LINES, Y, O.UNSIGNED_SHORT, ie);
                  (g.bind(),
                    z.program.set(this.program),
                    z.setDepthMode(s),
                    z.setStencilMode(h),
                    z.setColorMode(p));
                }
                checkUniforms(t, s, h) {
                  if (this.fixedDefines.includes(s)) {
                    for (const p of Object.keys(h))
                      if (!h[p].initialized)
                        throw new Error(
                          `Program '${this.name}', from draw '${t}': uniform ${p} not set but required by ${s} being defined`,
                        );
                  }
                }
                draw(t, s, h, p, g, x, w, S, C, D, L, z, O, G, U, $) {
                  const Z = t.context,
                    Y = Z.gl;
                  if (this.failedToCreate) return;
                  (Z.program.set(this.program),
                    Z.setDepthMode(h),
                    Z.setStencilMode(p),
                    Z.setColorMode(g),
                    Z.setCullFace(x));
                  for (const pe of Object.keys(this.fixedUniforms))
                    this.fixedUniforms[pe].set(this.program, pe, w[pe]);
                  G &&
                    G.setUniforms(this.program, Z, this.binderUniforms, z, {
                      zoom: O,
                    });
                  const ie = {
                    [Y.POINTS]: 1,
                    [Y.LINES]: 2,
                    [Y.TRIANGLES]: 3,
                    [Y.LINE_STRIP]: 1,
                  }[s];
                  this.checkUniforms(S, "RENDER_SHADOWS", this.shadowUniforms);
                  const ae = $ && $ > 0 ? 1 : void 0;
                  for (const pe of L.get()) {
                    const ue = pe.vaos || (pe.vaos = {});
                    if (
                      ((ue[S] || (ue[S] = new ml())).bind(
                        Z,
                        this,
                        C,
                        G ? G.getPaintVertexBuffers() : [],
                        D,
                        pe.vertexOffset,
                        U || [],
                        ae,
                      ),
                      this.forceManualRenderingForInstanceIDShaders)
                    ) {
                      const ce = $ || 1;
                      for (let le = 0; le < ce; ++le)
                        (this.instancingUniforms.u_instanceID.set(
                          this.program,
                          "u_instanceID",
                          le,
                        ),
                          D
                            ? Y.drawElements(
                                s,
                                pe.primitiveLength * ie,
                                Y.UNSIGNED_SHORT,
                                pe.primitiveOffset * ie * 2,
                              )
                            : Y.drawArrays(
                                s,
                                pe.vertexOffset,
                                pe.vertexLength,
                              ));
                    } else
                      $ && $ > 1
                        ? Y.drawElementsInstanced(
                            s,
                            pe.primitiveLength * ie,
                            Y.UNSIGNED_SHORT,
                            pe.primitiveOffset * ie * 2,
                            $,
                          )
                        : D
                          ? Y.drawElements(
                              s,
                              pe.primitiveLength * ie,
                              Y.UNSIGNED_SHORT,
                              pe.primitiveOffset * ie * 2,
                            )
                          : Y.drawArrays(s, pe.vertexOffset, pe.vertexLength);
                    s === Y.TRIANGLES &&
                      D &&
                      this._drawDebugWireframe(t, h, p, g, D, pe, z, O, G, $);
                  }
                }
              }
              function Cc(c, t, s = 0) {
                const h = Math.pow(2, t.tileID.overscaledZ),
                  p = (t.tileSize * Math.pow(2, c.transform.tileZoom)) / h,
                  g = p * (t.tileID.canonical.x + t.tileID.wrap * h),
                  x = p * t.tileID.canonical.y;
                return {
                  u_image: 0,
                  u_texsize: t.imageAtlasTexture
                    ? t.imageAtlasTexture.size
                    : [0, 0],
                  u_tile_units_to_pixels: 1 / r.aw(t, 1, c.transform.tileZoom),
                  u_pixel_coord_upper: [g >> 16, x >> 16],
                  u_pixel_coord_lower: [65535 & g, 65535 & x],
                  u_pattern_transition: s,
                };
              }
              const xl = { terrain: 0, flat: 1 },
                Pd = r.bz(),
                Pc = (c, t, s, h, p, g, x, w, S, C, D, L, z, O, G, U, $, Z) => {
                  const Y = t.style.light,
                    ie = Y.properties.get("position"),
                    ae = [ie.x, ie.y, ie.z],
                    pe = r.dx();
                  Y.properties.get("anchor") === "viewport" &&
                    (r.dy(pe, -t.transform.angle), r.dz(ae, ae, pe));
                  const ue = Y.properties
                      .get("color")
                      .toPremultipliedRenderColor(null),
                    ce = t.transform,
                    le = {
                      u_matrix: c,
                      u_lightpos: ae,
                      u_lightintensity: Y.properties.get("intensity"),
                      u_lightcolor: [ue.r, ue.g, ue.b],
                      u_vertical_gradient: +s,
                      u_opacity: h,
                      u_tile_id: [0, 0, 0],
                      u_zoom_transition: 0,
                      u_inv_rot_matrix: Pd,
                      u_merc_center: [0, 0],
                      u_up_dir: [0, 0, 0],
                      u_height_lift: 0,
                      u_height_type: xl[C],
                      u_base_type: xl[D],
                      u_ao: p,
                      u_edge_radius: g,
                      u_width_scale: x,
                      u_flood_light_color: G,
                      u_vertical_scale: U,
                      u_flood_light_intensity: $,
                      u_ground_shadow_factor: Z,
                    };
                  return (
                    ce.projection.name === "globe" &&
                      ((le.u_tile_id = [
                        w.canonical.x,
                        w.canonical.y,
                        1 << w.canonical.z,
                      ]),
                      (le.u_zoom_transition = L),
                      (le.u_inv_rot_matrix = O),
                      (le.u_merc_center = z),
                      (le.u_up_dir = ce.projection.upVector(
                        new r.cp(0, 0, 0),
                        z[0] * r.aj,
                        z[1] * r.aj,
                      )),
                      (le.u_height_lift = S)),
                    le
                  );
                },
                jp = (c, t, s, h, p, g) => ({
                  u_matrix: c,
                  u_edge_radius: t,
                  u_width_scale: s,
                  u_vertical_scale: h,
                  u_height_type: xl[p],
                  u_base_type: xl[g],
                }),
                Gp = (c, t, s, h, p, g, x, w, S, C, D, L, z, O, G, U, $, Z) => {
                  const Y = Pc(
                      c,
                      t,
                      s,
                      h,
                      p,
                      g,
                      x,
                      w,
                      C,
                      D,
                      L,
                      z,
                      O,
                      G,
                      U,
                      $,
                      1,
                      [0, 0, 0],
                    ),
                    ie = {
                      u_height_factor:
                        -Math.pow(2, w.overscaledZ) / S.tileSize / 8,
                    };
                  return r.h(Y, Cc(t, S, Z), ie);
                },
                Aa = (c, t, s) => ({
                  u_matrix: c,
                  u_emissive_strength: t,
                  u_ground_shadow_factor: s,
                }),
                $p = (c, t, s, h, p, g = 0) => r.h(Aa(c, t, p), Cc(s, h, g)),
                M_ = (c, t, s, h) => ({
                  u_matrix: c,
                  u_world: s,
                  u_emissive_strength: t,
                  u_ground_shadow_factor: h,
                }),
                C_ = (c, t, s, h, p, g, x = 0) =>
                  r.h($p(c, t, s, h, g, x), { u_world: p }),
                P_ = (c, t) => ({ u_matrix: c, u_ground_shadow_factor: t }),
                iu = (c, t, s, h, p) => ({
                  u_matrix: c,
                  u_camera_pos: [t[0], t[1], t[2]],
                  u_depth_bias: s,
                  u_height_scale: h,
                  u_reset_depth: p,
                }),
                D_ = (c, t, s, h) => {
                  const p = r.aj / s.tileSize;
                  return {
                    u_matrix: c,
                    u_camera_to_center_distance: t.getCameraToCenterDistance(h),
                    u_extrude_scale: [
                      t.pixelsToGLUnits[0] / p,
                      t.pixelsToGLUnits[1] / p,
                    ],
                  };
                },
                nu = (c, t, s = 1) => ({
                  u_matrix: c,
                  u_color: t,
                  u_overlay: 0,
                  u_overlay_scale: s,
                }),
                Dd = r.bz(),
                Hp = (c, t, s, h, p, g, x) => {
                  const w = c.transform,
                    S = w.projection.name === "globe",
                    C = S
                      ? r.dA(w.zoom, t.canonical) * w._pixelsPerMercatorPixel
                      : r.aw(s, 1, g),
                    D = {
                      u_matrix: t.projMatrix,
                      u_extrude_scale: C,
                      u_intensity: x,
                      u_inv_rot_matrix: Dd,
                      u_merc_center: [0, 0],
                      u_tile_id: [0, 0, 0],
                      u_zoom_transition: 0,
                      u_up_dir: [0, 0, 0],
                    };
                  if (S) {
                    ((D.u_inv_rot_matrix = h),
                      (D.u_merc_center = p),
                      (D.u_tile_id = [
                        t.canonical.x,
                        t.canonical.y,
                        1 << t.canonical.z,
                      ]),
                      (D.u_zoom_transition = r.ah(w.zoom)));
                    const L = p[0] * r.aj,
                      z = p[1] * r.aj;
                    D.u_up_dir = w.projection.upVector(new r.cp(0, 0, 0), L, z);
                  }
                  return D;
                };
              function Ma(c, [t, s, h, p], [g, x]) {
                if (g === x) return [0, 0, 0, 0];
                const w = (255 * (c - 1)) / (c * (x - g));
                return [t * w, s * w, h * w, p * w];
              }
              function Rd(c, t, [s, h]) {
                return s === h
                  ? 0
                  : 0.5 / c + ((t - s) * (c - 1)) / (c * (h - s));
              }
              const zd = (
                c,
                t,
                s,
                h,
                p,
                g,
                x,
                w,
                S,
                C,
                D,
                L,
                z,
                O,
                G,
                U,
                $,
                Z,
                Y,
                ie,
                ae,
              ) => ({
                u_matrix: c,
                u_normalize_matrix: t,
                u_globe_matrix: s,
                u_merc_matrix: h,
                u_grid_matrix: p,
                u_tl_parent: g,
                u_scale_parent: C,
                u_fade_t: D.mix,
                u_opacity: D.opacity * L.paint.get("raster-opacity"),
                u_image0: 0,
                u_image1: 1,
                u_brightness_low: L.paint.get("raster-brightness-min"),
                u_brightness_high: L.paint.get("raster-brightness-max"),
                u_saturation_factor: r.dC(L.paint.get("raster-saturation")),
                u_contrast_factor: r.dB(L.paint.get("raster-contrast")),
                u_spin_weights: Wp(L.paint.get("raster-hue-rotate")),
                u_perspective_transform: z,
                u_raster_elevation: O,
                u_zoom_transition: x,
                u_merc_center: w,
                u_cutoff_params: S,
                u_colorization_mix: Ma(r.dD, U, Z),
                u_colorization_offset: Rd(r.dD, $, Z),
                u_color_ramp: G,
                u_texture_offset: [ie / (Y + 2 * ie), Y / (Y + 2 * ie)],
                u_texture_res: [Y + 2 * ie, Y + 2 * ie],
                u_emissive_strength: ae,
              });
              function Wp(c) {
                c *= Math.PI / 180;
                const t = Math.sin(c),
                  s = Math.cos(c);
                return [
                  (2 * s + 1) / 3,
                  (-Math.sqrt(3) * t - s + 1) / 3,
                  (Math.sqrt(3) * t - s + 1) / 3,
                ];
              }
              const Fo = 0.05,
                Ca = (c, t, s, h, p, g, x, w, S, C, D, L) => ({
                  u_matrix: c,
                  u_normalize_matrix: t,
                  u_globe_matrix: s,
                  u_merc_matrix: h,
                  u_grid_matrix: p,
                  u_tl_parent: g,
                  u_scale_parent: C,
                  u_fade_t: D.mix,
                  u_opacity: D.opacity,
                  u_image0: 0,
                  u_image1: 1,
                  u_raster_elevation: L,
                  u_zoom_transition: x,
                  u_merc_center: w,
                  u_cutoff_params: S,
                }),
                qp = (c, t, s, h, p, g, x, w, S, C) => ({
                  u_particle_texture: c,
                  u_particle_texture_side_len: t,
                  u_tile_offset: s,
                  u_velocity: h,
                  u_color_ramp: g,
                  u_velocity_res: p,
                  u_max_speed: x,
                  u_uv_offset: w,
                  u_data_scale: [255 * S[0], 255 * S[1]],
                  u_data_offset: C,
                  u_particle_pos_scale: 1.1,
                  u_particle_pos_offset: [Fo, Fo],
                }),
                Bo = (c, t, s, h, p, g, x, w, S, C) => ({
                  u_particle_texture: c,
                  u_particle_texture_side_len: t,
                  u_velocity: s,
                  u_velocity_res: h,
                  u_max_speed: p,
                  u_speed_factor: g,
                  u_reset_rate: x,
                  u_rand_seed: Math.random(),
                  u_uv_offset: w,
                  u_data_scale: [255 * S[0], 255 * S[1]],
                  u_data_offset: C,
                  u_particle_pos_scale: 1.1,
                  u_particle_pos_offset: [Fo, Fo],
                }),
                ru = r.bz(),
                Dc = (
                  c,
                  t,
                  s,
                  h,
                  p,
                  g,
                  x,
                  w,
                  S,
                  C,
                  D,
                  L,
                  z,
                  O,
                  G,
                  U,
                  $,
                  Z,
                  Y,
                  ie,
                  ae,
                  pe,
                  ue,
                  ce,
                ) => {
                  const le = p.transform,
                    me = {
                      u_is_size_zoom_constant: +(
                        c === "constant" || c === "source"
                      ),
                      u_is_size_feature_constant: +(
                        c === "constant" || c === "camera"
                      ),
                      u_size_t: t ? t.uSizeT : 0,
                      u_size: t ? t.uSize : 0,
                      u_camera_to_center_distance:
                        le.getCameraToCenterDistance(Y),
                      u_rotate_symbol: +s,
                      u_aspect_ratio: le.width / le.height,
                      u_fade_change: p.options.fadeDuration
                        ? p.symbolFadeChange
                        : 1,
                      u_matrix: g,
                      u_label_plane_matrix: x,
                      u_coord_matrix: w,
                      u_is_text: +C,
                      u_elevation_from_sea: S ? 1 : 0,
                      u_pitch_with_map: +h,
                      u_texsize: D,
                      u_texsize_icon: L,
                      u_texture: 0,
                      u_texture_icon: 1,
                      u_tile_id: [0, 0, 0],
                      u_zoom_transition: 0,
                      u_inv_rot_matrix: ru,
                      u_merc_center: [0, 0],
                      u_camera_forward: [0, 0, 0],
                      u_ecef_origin: [0, 0, 0],
                      u_tile_matrix: ru,
                      u_up_vector: [0, -1, 0],
                      u_color_adj_mat: pe,
                      u_icon_transition: ue || 0,
                      u_gamma_scale: h
                        ? p.transform.getCameraToCenterDistance(Y) *
                          Math.cos(p.terrain ? 0 : p.transform._pitch)
                        : 1,
                      u_device_pixel_ratio: r.q.devicePixelRatio,
                      u_is_halo: 1,
                      u_scale_factor: ce || 1,
                      u_ground_shadow_factor: ie,
                      u_inv_matrix: r.bi(r.bz(), x),
                      u_normal_scale: ae,
                    };
                  return (
                    Y.name === "globe" &&
                      ((me.u_tile_id = [
                        O.canonical.x,
                        O.canonical.y,
                        1 << O.canonical.z,
                      ]),
                      (me.u_zoom_transition = G),
                      (me.u_inv_rot_matrix = $),
                      (me.u_merc_center = U),
                      (me.u_camera_forward = le._camera.forward()),
                      (me.u_ecef_origin = r.dE(
                        le.globeMatrix,
                        O.toUnwrapped(),
                      )),
                      (me.u_tile_matrix = Float32Array.from(le.globeMatrix)),
                      (me.u_up_vector = Z)),
                    me
                  );
                },
                kd = (c, t, s, h) => ({
                  u_matrix: c,
                  u_emissive_strength: t,
                  u_opacity: s,
                  u_color: h,
                }),
                Ld = (c, t, s, h, p, g, x, w, S) =>
                  r.h(
                    (function (C, D, L, z, O, G) {
                      const { width: U, height: $ } =
                          z.imageManager.getPixelSize(D),
                        Z = Math.pow(2, G.tileID.overscaledZ),
                        Y =
                          (G.tileSize * Math.pow(2, z.transform.tileZoom)) / Z,
                        ie = Y * (G.tileID.canonical.x + G.tileID.wrap * Z),
                        ae = Y * G.tileID.canonical.y;
                      return {
                        u_image: 0,
                        u_pattern_tl: L.tl,
                        u_pattern_br: L.br,
                        u_texsize: [U, $],
                        u_pattern_size: L.displaySize,
                        u_pattern_units_to_pixels: O
                          ? [z.transform.width, -1 * z.transform.height]
                          : [
                              1 / r.aw(G, 1, z.transform.tileZoom),
                              1 / r.aw(G, 1, z.transform.tileZoom),
                            ],
                        u_pixel_coord_upper: [ie >> 16, ae >> 16],
                        u_pixel_coord_lower: [65535 & ie, 65535 & ae],
                      };
                    })(0, g, x, h, w, S),
                    { u_matrix: c, u_emissive_strength: t, u_opacity: s },
                  ),
                Rc = new Float32Array(r.bx([])),
                zc = (
                  c,
                  t,
                  s,
                  h,
                  p,
                  g,
                  x,
                  w,
                  S,
                  C,
                  D,
                  L,
                  z,
                  O = [0, 0, 0],
                  G,
                ) => {
                  const U = p.style.light,
                    $ = U.properties.get("position"),
                    Z = [-$.x, -$.y, $.z],
                    Y = r.dx();
                  U.properties.get("anchor") === "viewport" &&
                    (r.dy(Y, -p.transform.angle), r.dz(Z, Z, Y));
                  const ie = D.alphaMode === "MASK",
                    ae = U.properties
                      .get("color")
                      .toNonPremultipliedRenderColor(null),
                    pe = z.paint.get("model-ambient-occlusion-intensity"),
                    ue = z.paint
                      .get("model-color")
                      .constantOr(r.am.white)
                      .toNonPremultipliedRenderColor(null);
                  return (
                    (ue.a = z.paint
                      .get("model-color-mix-intensity")
                      .constantOr(0)),
                    {
                      u_matrix: c,
                      u_lighting_matrix: t,
                      u_normal_matrix: s,
                      u_node_matrix: h || Rc,
                      u_lightpos: Z,
                      u_lightintensity: U.properties.get("intensity"),
                      u_lightcolor: [ae.r, ae.g, ae.b],
                      u_camera_pos: O,
                      u_opacity: g,
                      u_baseTextureIsAlpha: 0,
                      u_alphaMask: +ie,
                      u_alphaCutoff: D.alphaCutoff,
                      u_baseColorFactor: x
                        .toNonPremultipliedRenderColor(null)
                        .toArray01(),
                      u_emissiveFactor: w
                        .toNonPremultipliedRenderColor(null)
                        .toArray01(),
                      u_metallicFactor: S,
                      u_roughnessFactor: C,
                      u_baseColorTexture: zr.BaseColor,
                      u_metallicRoughnessTexture: zr.MetallicRoughness,
                      u_normalTexture: zr.Normal,
                      u_occlusionTexture: zr.Occlusion,
                      u_emissionTexture: zr.Emission,
                      u_lutTexture: zr.LUT,
                      u_color_mix: ue.toArray01(),
                      u_aoIntensity: pe,
                      u_emissive_strength: L,
                      u_occlusionTextureTransform: G || [0, 0, 0, 0],
                    }
                  );
                },
                Zp = (c, t = Rc, s = Rc) => ({
                  u_matrix: c,
                  u_instance: t,
                  u_node_matrix: s,
                }),
                Xp = {
                  fillExtrusion: (c) => ({
                    u_matrix: new r.cc(c),
                    u_lightpos: new r.c9(c),
                    u_lightintensity: new r.ca(c),
                    u_lightcolor: new r.c9(c),
                    u_vertical_gradient: new r.ca(c),
                    u_opacity: new r.ca(c),
                    u_edge_radius: new r.ca(c),
                    u_width_scale: new r.ca(c),
                    u_ao: new r.cb(c),
                    u_height_type: new r.c8(c),
                    u_base_type: new r.c8(c),
                    u_tile_id: new r.c9(c),
                    u_zoom_transition: new r.ca(c),
                    u_inv_rot_matrix: new r.cc(c),
                    u_merc_center: new r.cb(c),
                    u_up_dir: new r.c9(c),
                    u_height_lift: new r.ca(c),
                    u_flood_light_color: new r.c9(c),
                    u_vertical_scale: new r.ca(c),
                    u_flood_light_intensity: new r.ca(c),
                    u_ground_shadow_factor: new r.c9(c),
                  }),
                  fillExtrusionDepth: (c) => ({
                    u_matrix: new r.cc(c),
                    u_edge_radius: new r.ca(c),
                    u_width_scale: new r.ca(c),
                    u_vertical_scale: new r.ca(c),
                    u_height_type: new r.c8(c),
                    u_base_type: new r.c8(c),
                  }),
                  fillExtrusionPattern: (c) => ({
                    u_matrix: new r.cc(c),
                    u_lightpos: new r.c9(c),
                    u_lightintensity: new r.ca(c),
                    u_lightcolor: new r.c9(c),
                    u_vertical_gradient: new r.ca(c),
                    u_height_factor: new r.ca(c),
                    u_edge_radius: new r.ca(c),
                    u_width_scale: new r.ca(c),
                    u_ao: new r.cb(c),
                    u_height_type: new r.c8(c),
                    u_base_type: new r.c8(c),
                    u_tile_id: new r.c9(c),
                    u_zoom_transition: new r.ca(c),
                    u_inv_rot_matrix: new r.cc(c),
                    u_merc_center: new r.cb(c),
                    u_up_dir: new r.c9(c),
                    u_height_lift: new r.ca(c),
                    u_image: new r.c8(c),
                    u_texsize: new r.cb(c),
                    u_pixel_coord_upper: new r.cb(c),
                    u_pixel_coord_lower: new r.cb(c),
                    u_tile_units_to_pixels: new r.ca(c),
                    u_opacity: new r.ca(c),
                    u_pattern_transition: new r.ca(c),
                  }),
                  fillExtrusionGroundEffect: (c) => ({
                    u_matrix: new r.cc(c),
                    u_opacity: new r.ca(c),
                    u_ao_pass: new r.ca(c),
                    u_meter_to_tile: new r.ca(c),
                    u_ao: new r.cb(c),
                    u_flood_light_intensity: new r.ca(c),
                    u_flood_light_color: new r.c9(c),
                    u_attenuation: new r.ca(c),
                    u_edge_radius: new r.ca(c),
                    u_fb: new r.c8(c),
                    u_fb_size: new r.ca(c),
                    u_dynamic_offset: new r.ca(c),
                  }),
                  fill: (c) => ({
                    u_matrix: new r.cc(c),
                    u_emissive_strength: new r.ca(c),
                    u_ground_shadow_factor: new r.c9(c),
                  }),
                  fillPattern: (c) => ({
                    u_matrix: new r.cc(c),
                    u_emissive_strength: new r.ca(c),
                    u_image: new r.c8(c),
                    u_texsize: new r.cb(c),
                    u_pixel_coord_upper: new r.cb(c),
                    u_pixel_coord_lower: new r.cb(c),
                    u_tile_units_to_pixels: new r.ca(c),
                    u_ground_shadow_factor: new r.c9(c),
                    u_pattern_transition: new r.ca(c),
                  }),
                  fillOutline: (c) => ({
                    u_matrix: new r.cc(c),
                    u_emissive_strength: new r.ca(c),
                    u_world: new r.cb(c),
                    u_ground_shadow_factor: new r.c9(c),
                  }),
                  fillOutlinePattern: (c) => ({
                    u_matrix: new r.cc(c),
                    u_emissive_strength: new r.ca(c),
                    u_world: new r.cb(c),
                    u_image: new r.c8(c),
                    u_texsize: new r.cb(c),
                    u_pixel_coord_upper: new r.cb(c),
                    u_pixel_coord_lower: new r.cb(c),
                    u_tile_units_to_pixels: new r.ca(c),
                    u_ground_shadow_factor: new r.c9(c),
                    u_pattern_transition: new r.ca(c),
                  }),
                  building: (c) => ({
                    u_matrix: new r.cc(c),
                    u_normal_matrix: new r.cc(c),
                    u_opacity: new r.ca(c),
                  }),
                  buildingDepth: (c) => ({ u_matrix: new r.cc(c) }),
                  elevatedStructuresDepth: (c) => ({
                    u_matrix: new r.cc(c),
                    u_depth_bias: new r.ca(c),
                  }),
                  elevatedStructures: (c) => ({
                    u_matrix: new r.cc(c),
                    u_ground_shadow_factor: new r.c9(c),
                  }),
                  elevatedStructuresDepthReconstruct: (c) => ({
                    u_matrix: new r.cc(c),
                    u_camera_pos: new r.c9(c),
                    u_depth_bias: new r.ca(c),
                    u_height_scale: new r.ca(c),
                    u_reset_depth: new r.ca(c),
                  }),
                  circle: r.dH,
                  collisionBox: (c) => ({
                    u_matrix: new r.cc(c),
                    u_camera_to_center_distance: new r.ca(c),
                    u_extrude_scale: new r.cb(c),
                  }),
                  collisionCircle: (c) => ({
                    u_matrix: new r.cc(c),
                    u_inv_matrix: new r.cc(c),
                    u_camera_to_center_distance: new r.ca(c),
                    u_viewport_size: new r.cb(c),
                  }),
                  debug: (c) => ({
                    u_color: new r.di(c),
                    u_matrix: new r.cc(c),
                    u_overlay: new r.c8(c),
                    u_overlay_scale: new r.ca(c),
                  }),
                  clippingMask: (c) => ({ u_matrix: new r.cc(c) }),
                  heatmap: (c) => ({
                    u_extrude_scale: new r.ca(c),
                    u_intensity: new r.ca(c),
                    u_matrix: new r.cc(c),
                    u_inv_rot_matrix: new r.cc(c),
                    u_merc_center: new r.cb(c),
                    u_tile_id: new r.c9(c),
                    u_zoom_transition: new r.ca(c),
                    u_up_dir: new r.c9(c),
                  }),
                  heatmapTexture: (c) => ({
                    u_image: new r.c8(c),
                    u_color_ramp: new r.c8(c),
                    u_opacity: new r.ca(c),
                  }),
                  hillshade: (c) => ({
                    u_matrix: new r.cc(c),
                    u_image: new r.c8(c),
                    u_latrange: new r.cb(c),
                    u_light: new r.cb(c),
                    u_shadow: new r.di(c),
                    u_highlight: new r.di(c),
                    u_emissive_strength: new r.ca(c),
                    u_accent: new r.di(c),
                  }),
                  hillshadePrepare: (c) => ({
                    u_matrix: new r.cc(c),
                    u_image: new r.c8(c),
                    u_dimension: new r.cb(c),
                    u_zoom: new r.ca(c),
                  }),
                  line: r.dG,
                  linePattern: r.dF,
                  raster: (c) => ({
                    u_matrix: new r.cc(c),
                    u_normalize_matrix: new r.cc(c),
                    u_globe_matrix: new r.cc(c),
                    u_merc_matrix: new r.cc(c),
                    u_grid_matrix: new r.dj(c),
                    u_tl_parent: new r.cb(c),
                    u_scale_parent: new r.ca(c),
                    u_fade_t: new r.ca(c),
                    u_opacity: new r.ca(c),
                    u_image0: new r.c8(c),
                    u_image1: new r.c8(c),
                    u_brightness_low: new r.ca(c),
                    u_brightness_high: new r.ca(c),
                    u_saturation_factor: new r.ca(c),
                    u_contrast_factor: new r.ca(c),
                    u_spin_weights: new r.c9(c),
                    u_perspective_transform: new r.cb(c),
                    u_raster_elevation: new r.ca(c),
                    u_zoom_transition: new r.ca(c),
                    u_merc_center: new r.cb(c),
                    u_cutoff_params: new r.cQ(c),
                    u_colorization_mix: new r.cQ(c),
                    u_colorization_offset: new r.ca(c),
                    u_color_ramp: new r.c8(c),
                    u_texture_offset: new r.cb(c),
                    u_texture_res: new r.cb(c),
                    u_emissive_strength: new r.ca(c),
                  }),
                  rasterParticle: (c) => ({
                    u_matrix: new r.cc(c),
                    u_normalize_matrix: new r.cc(c),
                    u_globe_matrix: new r.cc(c),
                    u_merc_matrix: new r.cc(c),
                    u_grid_matrix: new r.dj(c),
                    u_tl_parent: new r.cb(c),
                    u_scale_parent: new r.ca(c),
                    u_fade_t: new r.ca(c),
                    u_opacity: new r.ca(c),
                    u_image0: new r.c8(c),
                    u_image1: new r.c8(c),
                    u_raster_elevation: new r.ca(c),
                    u_zoom_transition: new r.ca(c),
                    u_merc_center: new r.cb(c),
                    u_cutoff_params: new r.cQ(c),
                  }),
                  rasterParticleTexture: (c) => ({
                    u_texture: new r.c8(c),
                    u_opacity: new r.ca(c),
                  }),
                  rasterParticleDraw: (c) => ({
                    u_particle_texture: new r.c8(c),
                    u_particle_texture_side_len: new r.ca(c),
                    u_tile_offset: new r.cb(c),
                    u_velocity: new r.c8(c),
                    u_color_ramp: new r.c8(c),
                    u_velocity_res: new r.cb(c),
                    u_max_speed: new r.ca(c),
                    u_uv_offset: new r.cb(c),
                    u_data_scale: new r.cb(c),
                    u_data_offset: new r.ca(c),
                    u_particle_pos_scale: new r.ca(c),
                    u_particle_pos_offset: new r.cb(c),
                  }),
                  rasterParticleUpdate: (c) => ({
                    u_particle_texture: new r.c8(c),
                    u_particle_texture_side_len: new r.ca(c),
                    u_velocity: new r.c8(c),
                    u_velocity_res: new r.cb(c),
                    u_max_speed: new r.ca(c),
                    u_speed_factor: new r.ca(c),
                    u_reset_rate: new r.ca(c),
                    u_rand_seed: new r.ca(c),
                    u_uv_offset: new r.cb(c),
                    u_data_scale: new r.cb(c),
                    u_data_offset: new r.ca(c),
                    u_particle_pos_scale: new r.ca(c),
                    u_particle_pos_offset: new r.cb(c),
                  }),
                  symbol: (c) => ({
                    u_is_size_zoom_constant: new r.c8(c),
                    u_is_size_feature_constant: new r.c8(c),
                    u_size_t: new r.ca(c),
                    u_size: new r.ca(c),
                    u_camera_to_center_distance: new r.ca(c),
                    u_rotate_symbol: new r.c8(c),
                    u_aspect_ratio: new r.ca(c),
                    u_fade_change: new r.ca(c),
                    u_matrix: new r.cc(c),
                    u_label_plane_matrix: new r.cc(c),
                    u_coord_matrix: new r.cc(c),
                    u_is_text: new r.c8(c),
                    u_elevation_from_sea: new r.c8(c),
                    u_pitch_with_map: new r.c8(c),
                    u_texsize: new r.cb(c),
                    u_texsize_icon: new r.cb(c),
                    u_texture: new r.c8(c),
                    u_texture_icon: new r.c8(c),
                    u_gamma_scale: new r.ca(c),
                    u_device_pixel_ratio: new r.ca(c),
                    u_tile_id: new r.c9(c),
                    u_zoom_transition: new r.ca(c),
                    u_inv_rot_matrix: new r.cc(c),
                    u_merc_center: new r.cb(c),
                    u_camera_forward: new r.c9(c),
                    u_tile_matrix: new r.cc(c),
                    u_up_vector: new r.c9(c),
                    u_ecef_origin: new r.c9(c),
                    u_is_halo: new r.c8(c),
                    u_icon_transition: new r.ca(c),
                    u_color_adj_mat: new r.cc(c),
                    u_scale_factor: new r.ca(c),
                    u_ground_shadow_factor: new r.c9(c),
                    u_inv_matrix: new r.cc(c),
                    u_normal_scale: new r.ca(c),
                  }),
                  background: (c) => ({
                    u_matrix: new r.cc(c),
                    u_emissive_strength: new r.ca(c),
                    u_opacity: new r.ca(c),
                    u_color: new r.di(c),
                  }),
                  backgroundPattern: (c) => ({
                    u_matrix: new r.cc(c),
                    u_emissive_strength: new r.ca(c),
                    u_opacity: new r.ca(c),
                    u_image: new r.c8(c),
                    u_pattern_tl: new r.cb(c),
                    u_pattern_br: new r.cb(c),
                    u_texsize: new r.cb(c),
                    u_pattern_size: new r.cb(c),
                    u_pixel_coord_upper: new r.cb(c),
                    u_pixel_coord_lower: new r.cb(c),
                    u_pattern_units_to_pixels: new r.cb(c),
                  }),
                  terrainRaster: (c) => ({
                    u_matrix: new r.cc(c),
                    u_image0: new r.c8(c),
                    u_skirt_height: new r.ca(c),
                    u_ground_shadow_factor: new r.c9(c),
                  }),
                  skybox: (c) => ({
                    u_matrix: new r.cc(c),
                    u_sun_direction: new r.c9(c),
                    u_cubemap: new r.c8(c),
                    u_opacity: new r.ca(c),
                    u_temporal_offset: new r.ca(c),
                  }),
                  skyboxGradient: (c) => ({
                    u_matrix: new r.cc(c),
                    u_color_ramp: new r.c8(c),
                    u_center_direction: new r.c9(c),
                    u_radius: new r.ca(c),
                    u_opacity: new r.ca(c),
                    u_temporal_offset: new r.ca(c),
                  }),
                  skyboxCapture: (c) => ({
                    u_matrix_3f: new r.dj(c),
                    u_sun_direction: new r.c9(c),
                    u_sun_intensity: new r.ca(c),
                    u_color_tint_r: new r.cQ(c),
                    u_color_tint_m: new r.cQ(c),
                    u_luminance: new r.ca(c),
                  }),
                  globeRaster: (c) => ({
                    u_proj_matrix: new r.cc(c),
                    u_globe_matrix: new r.cc(c),
                    u_normalize_matrix: new r.cc(c),
                    u_merc_matrix: new r.cc(c),
                    u_zoom_transition: new r.ca(c),
                    u_merc_center: new r.cb(c),
                    u_image0: new r.c8(c),
                    u_grid_matrix: new r.dj(c),
                    u_skirt_height: new r.ca(c),
                    u_far_z_cutoff: new r.ca(c),
                    u_frustum_tl: new r.c9(c),
                    u_frustum_tr: new r.c9(c),
                    u_frustum_br: new r.c9(c),
                    u_frustum_bl: new r.c9(c),
                    u_globe_pos: new r.c9(c),
                    u_globe_radius: new r.ca(c),
                    u_viewport: new r.cb(c),
                  }),
                  globeAtmosphere: (c) => ({
                    u_frustum_tl: new r.c9(c),
                    u_frustum_tr: new r.c9(c),
                    u_frustum_br: new r.c9(c),
                    u_frustum_bl: new r.c9(c),
                    u_horizon: new r.ca(c),
                    u_transition: new r.ca(c),
                    u_fadeout_range: new r.ca(c),
                    u_color: new r.cQ(c),
                    u_high_color: new r.cQ(c),
                    u_space_color: new r.cQ(c),
                    u_temporal_offset: new r.ca(c),
                    u_horizon_angle: new r.ca(c),
                  }),
                  model: (c) => ({
                    u_matrix: new r.cc(c),
                    u_lighting_matrix: new r.cc(c),
                    u_normal_matrix: new r.cc(c),
                    u_node_matrix: new r.cc(c),
                    u_lightpos: new r.c9(c),
                    u_lightintensity: new r.ca(c),
                    u_lightcolor: new r.c9(c),
                    u_camera_pos: new r.c9(c),
                    u_opacity: new r.ca(c),
                    u_baseColorFactor: new r.cQ(c),
                    u_emissiveFactor: new r.cQ(c),
                    u_metallicFactor: new r.ca(c),
                    u_roughnessFactor: new r.ca(c),
                    u_baseTextureIsAlpha: new r.c8(c),
                    u_alphaMask: new r.c8(c),
                    u_alphaCutoff: new r.ca(c),
                    u_baseColorTexture: new r.c8(c),
                    u_metallicRoughnessTexture: new r.c8(c),
                    u_normalTexture: new r.c8(c),
                    u_occlusionTexture: new r.c8(c),
                    u_emissionTexture: new r.c8(c),
                    u_lutTexture: new r.c8(c),
                    u_color_mix: new r.cQ(c),
                    u_aoIntensity: new r.ca(c),
                    u_emissive_strength: new r.ca(c),
                    u_occlusionTextureTransform: new r.cQ(c),
                  }),
                  modelDepth: (c) => ({
                    u_matrix: new r.cc(c),
                    u_instance: new r.cc(c),
                    u_node_matrix: new r.cc(c),
                  }),
                  groundShadow: (c) => ({
                    u_matrix: new r.cc(c),
                    u_ground_shadow_factor: new r.c9(c),
                  }),
                  stars: (c) => ({
                    u_matrix: new r.cc(c),
                    u_up: new r.c9(c),
                    u_right: new r.c9(c),
                    u_intensity_multiplier: new r.ca(c),
                  }),
                  snowParticle: (c) => ({
                    u_modelview: new r.cc(c),
                    u_projection: new r.cc(c),
                    u_time: new r.ca(c),
                    u_cam_pos: new r.c9(c),
                    u_velocityConeAperture: new r.ca(c),
                    u_velocity: new r.ca(c),
                    u_horizontalOscillationRadius: new r.ca(c),
                    u_horizontalOscillationRate: new r.ca(c),
                    u_boxSize: new r.ca(c),
                    u_billboardSize: new r.ca(c),
                    u_simpleShapeParameters: new r.cb(c),
                    u_screenSize: new r.cb(c),
                    u_thinningCenterPos: new r.cb(c),
                    u_thinningShape: new r.c9(c),
                    u_thinningAffectedRatio: new r.ca(c),
                    u_thinningParticleOffset: new r.ca(c),
                    u_particleColor: new r.cQ(c),
                    u_direction: new r.c9(c),
                  }),
                  rainParticle: (c) => ({
                    u_modelview: new r.cc(c),
                    u_projection: new r.cc(c),
                    u_time: new r.ca(c),
                    u_cam_pos: new r.c9(c),
                    u_texScreen: new r.c8(c),
                    u_velocityConeAperture: new r.ca(c),
                    u_velocity: new r.ca(c),
                    u_boxSize: new r.ca(c),
                    u_rainDropletSize: new r.cb(c),
                    u_distortionStrength: new r.ca(c),
                    u_rainDirection: new r.c9(c),
                    u_color: new r.cQ(c),
                    u_screenSize: new r.cb(c),
                    u_thinningCenterPos: new r.cb(c),
                    u_thinningShape: new r.c9(c),
                    u_thinningAffectedRatio: new r.ca(c),
                    u_thinningParticleOffset: new r.ca(c),
                    u_shapeDirectionalPower: new r.ca(c),
                    u_shapeNormalPower: new r.ca(c),
                    u_mode: new r.ca(c),
                  }),
                  vignette: (c) => ({
                    u_vignetteShape: new r.c9(c),
                    u_vignetteColor: new r.cQ(c),
                  }),
                  occlusion: (c) => ({
                    u_matrix: new r.cc(c),
                    u_anchorPos: new r.c9(c),
                    u_screenSizePx: new r.cb(c),
                    u_occluderSizePx: new r.cb(c),
                    u_color: new r.cQ(c),
                  }),
                };
              class vs {
                constructor(t, s, h, p) {
                  ((this.id = vs.uniqueIdxCounter),
                    vs.uniqueIdxCounter++,
                    (this.context = t));
                  const g = t.gl;
                  ((this.buffer = g.createBuffer()),
                    (this.dynamicDraw = !!h),
                    this.context.unbindVAO(),
                    t.bindElementBuffer.set(this.buffer),
                    g.bufferData(
                      g.ELEMENT_ARRAY_BUFFER,
                      s.arrayBuffer,
                      this.dynamicDraw ? g.DYNAMIC_DRAW : g.STATIC_DRAW,
                    ),
                    this.dynamicDraw || p || s.destroy());
                }
                bind() {
                  this.context.bindElementBuffer.set(this.buffer);
                }
                updateData(t) {
                  ((this.id = vs.uniqueIdxCounter), vs.uniqueIdxCounter++);
                  const s = this.context.gl;
                  (this.context.unbindVAO(),
                    this.bind(),
                    s.bufferSubData(s.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer));
                }
                destroy() {
                  this.buffer &&
                    (this.context.gl.deleteBuffer(this.buffer),
                    delete this.buffer);
                }
              }
              vs.uniqueIdxCounter = 0;
              const R_ = {
                Int8: "BYTE",
                Uint8: "UNSIGNED_BYTE",
                Int16: "SHORT",
                Uint16: "UNSIGNED_SHORT",
                Int32: "INT",
                Uint32: "UNSIGNED_INT",
                Float32: "FLOAT",
              };
              class z_ {
                constructor(t, s, h, p, g, x) {
                  ((this.length = s.length),
                    (this.attributes = h),
                    (this.itemSize = s.bytesPerElement),
                    (this.dynamicDraw = p),
                    (this.instanceCount = x),
                    (this.context = t));
                  const w = t.gl;
                  ((this.buffer = w.createBuffer()),
                    t.bindVertexBuffer.set(this.buffer),
                    w.bufferData(
                      w.ARRAY_BUFFER,
                      s.arrayBuffer,
                      this.dynamicDraw ? w.DYNAMIC_DRAW : w.STATIC_DRAW,
                    ),
                    this.dynamicDraw || g || s.destroy());
                }
                bind() {
                  this.context.bindVertexBuffer.set(this.buffer);
                }
                updateData(t) {
                  const s = this.context.gl;
                  (this.bind(),
                    s.bufferSubData(s.ARRAY_BUFFER, 0, t.arrayBuffer));
                }
                enableAttributes(t, s) {
                  for (let h = 0; h < this.attributes.length; h++) {
                    const p = s.attributes[this.attributes[h].name];
                    p !== void 0 && t.enableVertexAttribArray(p);
                  }
                }
                setVertexAttribPointers(t, s, h) {
                  for (let p = 0; p < this.attributes.length; p++) {
                    const g = this.attributes[p],
                      x = s.attributes[g.name];
                    x !== void 0 &&
                      t.vertexAttribPointer(
                        x,
                        g.components,
                        t[R_[g.type]],
                        !1,
                        this.itemSize,
                        g.offset + this.itemSize * (h || 0),
                      );
                  }
                }
                setVertexAttribDivisor(t, s, h) {
                  for (let p = 0; p < this.attributes.length; p++) {
                    const g = s.attributes[this.attributes[p].name];
                    g !== void 0 &&
                      this.instanceCount &&
                      this.instanceCount > 0 &&
                      t.vertexAttribDivisor(g, h);
                  }
                }
                destroy() {
                  this.buffer &&
                    (this.context.gl.deleteBuffer(this.buffer),
                    delete this.buffer);
                }
              }
              class Od {
                constructor(t, s, h, p, g) {
                  ((this.context = t), (this.width = s), (this.height = h));
                  const x = (this.framebuffer = t.gl.createFramebuffer());
                  (p && (this.colorAttachment = new Np(t, x)),
                    g &&
                      ((this.depthAttachmentType = g),
                      (this.depthAttachment =
                        g === "renderbuffer" ? new Vp(t, x) : new E_(t, x))));
                }
                destroy() {
                  const t = this.context.gl;
                  if (this.colorAttachment) {
                    const s = this.colorAttachment.get();
                    s && t.deleteTexture(s);
                  }
                  if (this.depthAttachment && this.depthAttachmentType)
                    if (this.depthAttachmentType === "renderbuffer") {
                      const s = this.depthAttachment.get();
                      s && t.deleteRenderbuffer(s);
                    } else {
                      const s = this.depthAttachment.get();
                      s && t.deleteTexture(s);
                    }
                  t.deleteFramebuffer(this.framebuffer);
                }
              }
              class k_ {
                constructor(t, s) {
                  ((this.gl = t),
                    (this.clearColor = new Dp(this)),
                    (this.clearDepth = new vd(this)),
                    (this.clearStencil = new x_(this)),
                    (this.colorMask = new v_(this)),
                    (this.depthMask = new b_(this)),
                    (this.stencilMask = new w_(this)),
                    (this.stencilFunc = new Rp(this)),
                    (this.stencilOp = new T_(this)),
                    (this.stencilTest = new $h(this)),
                    (this.depthRange = new S_(this)),
                    (this.depthTest = new zp(this)),
                    (this.depthFunc = new bd(this)),
                    (this.blend = new Hh(this)),
                    (this.blendFunc = new wd(this)),
                    (this.blendColor = new Sa(this)),
                    (this.blendEquation = new gl(this)),
                    (this.cullFace = new Wh(this)),
                    (this.cullFaceSide = new qh(this)),
                    (this.frontFace = new _l(this)),
                    (this.program = new kp(this)),
                    (this.activeTexture = new Td(this)),
                    (this.viewport = new Lp(this)),
                    (this.bindFramebuffer = new yl(this)),
                    (this.bindRenderbuffer = new Zh(this)),
                    (this.bindTexture = new Xh(this)),
                    (this.bindVertexBuffer = new Sd(this)),
                    (this.bindElementBuffer = new Yh(this)),
                    (this.bindVertexArrayOES = new Ac(this)),
                    (this.pixelStoreUnpack = new Op(this)),
                    (this.pixelStoreUnpackPremultiplyAlpha = new Fp(this)),
                    (this.pixelStoreUnpackFlipY = new Bp(this)),
                    (this.options = s ? Object.assign({}, s) : {}),
                    this.options.extTextureFilterAnisotropicForceOff ||
                      ((this.extTextureFilterAnisotropic =
                        t.getExtension("EXT_texture_filter_anisotropic") ||
                        t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                        t.getExtension(
                          "WEBKIT_EXT_texture_filter_anisotropic",
                        )),
                      this.extTextureFilterAnisotropic &&
                        (this.extTextureFilterAnisotropicMax = t.getParameter(
                          this.extTextureFilterAnisotropic
                            .MAX_TEXTURE_MAX_ANISOTROPY_EXT,
                        ))),
                    (this.extDebugRendererInfo = t.getExtension(
                      "WEBGL_debug_renderer_info",
                    )),
                    this.extDebugRendererInfo &&
                      ((this.renderer = t.getParameter(
                        this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL,
                      )),
                      (this.vendor = t.getParameter(
                        this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL,
                      ))),
                    (this.forceManualRenderingForInstanceIDShaders =
                      (s && !!s.forceManualRenderingForInstanceIDShaders) ||
                      (this.renderer &&
                        this.renderer.indexOf("PowerVR") !== -1)),
                    this.options.extTextureFloatLinearForceOff ||
                      (this.extTextureFloatLinear = t.getExtension(
                        "OES_texture_float_linear",
                      )),
                    (this.extRenderToTextureHalfFloat = t.getExtension(
                      "EXT_color_buffer_half_float",
                    )),
                    (this.extTimerQuery = t.getExtension(
                      "EXT_disjoint_timer_query_webgl2",
                    )),
                    (this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE)),
                    (this.maxPointSize = t.getParameter(
                      t.ALIASED_POINT_SIZE_RANGE,
                    )[1]));
                }
                setDefault() {
                  (this.unbindVAO(),
                    this.clearColor.setDefault(),
                    this.clearDepth.setDefault(),
                    this.clearStencil.setDefault(),
                    this.colorMask.setDefault(),
                    this.depthMask.setDefault(),
                    this.stencilMask.setDefault(),
                    this.stencilFunc.setDefault(),
                    this.stencilOp.setDefault(),
                    this.stencilTest.setDefault(),
                    this.depthRange.setDefault(),
                    this.depthTest.setDefault(),
                    this.depthFunc.setDefault(),
                    this.blend.setDefault(),
                    this.blendFunc.setDefault(),
                    this.blendColor.setDefault(),
                    this.blendEquation.setDefault(),
                    this.cullFace.setDefault(),
                    this.cullFaceSide.setDefault(),
                    this.frontFace.setDefault(),
                    this.program.setDefault(),
                    this.activeTexture.setDefault(),
                    this.bindFramebuffer.setDefault(),
                    this.pixelStoreUnpack.setDefault(),
                    this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                    this.pixelStoreUnpackFlipY.setDefault());
                }
                setDirty() {
                  ((this.clearColor.dirty = !0),
                    (this.clearDepth.dirty = !0),
                    (this.clearStencil.dirty = !0),
                    (this.colorMask.dirty = !0),
                    (this.depthMask.dirty = !0),
                    (this.stencilMask.dirty = !0),
                    (this.stencilFunc.dirty = !0),
                    (this.stencilOp.dirty = !0),
                    (this.stencilTest.dirty = !0),
                    (this.depthRange.dirty = !0),
                    (this.depthTest.dirty = !0),
                    (this.depthFunc.dirty = !0),
                    (this.blend.dirty = !0),
                    (this.blendFunc.dirty = !0),
                    (this.blendColor.dirty = !0),
                    (this.blendEquation.dirty = !0),
                    (this.cullFace.dirty = !0),
                    (this.cullFaceSide.dirty = !0),
                    (this.frontFace.dirty = !0),
                    (this.program.dirty = !0),
                    (this.activeTexture.dirty = !0),
                    (this.viewport.dirty = !0),
                    (this.bindFramebuffer.dirty = !0),
                    (this.bindRenderbuffer.dirty = !0),
                    (this.bindTexture.dirty = !0),
                    (this.bindVertexBuffer.dirty = !0),
                    (this.bindElementBuffer.dirty = !0),
                    (this.bindVertexArrayOES.dirty = !0),
                    (this.pixelStoreUnpack.dirty = !0),
                    (this.pixelStoreUnpackPremultiplyAlpha.dirty = !0),
                    (this.pixelStoreUnpackFlipY.dirty = !0));
                }
                createIndexBuffer(t, s, h) {
                  return new vs(this, t, s, h);
                }
                createVertexBuffer(t, s, h, p, g) {
                  return new z_(this, t, s, h, p, g);
                }
                createRenderbuffer(t, s, h) {
                  const p = this.gl,
                    g = p.createRenderbuffer();
                  return (
                    this.bindRenderbuffer.set(g),
                    p.renderbufferStorage(p.RENDERBUFFER, t, s, h),
                    this.bindRenderbuffer.set(null),
                    g
                  );
                }
                createFramebuffer(t, s, h, p) {
                  return new Od(this, t, s, h, p);
                }
                clear({ color: t, depth: s, stencil: h, colorMask: p }) {
                  const g = this.gl;
                  let x = 0;
                  (t &&
                    ((x |= g.COLOR_BUFFER_BIT),
                    this.clearColor.set(t.toNonPremultipliedRenderColor(null)),
                    this.colorMask.set(p || [!0, !0, !0, !0])),
                    s !== void 0 &&
                      ((x |= g.DEPTH_BUFFER_BIT),
                      this.depthRange.set([0, 1]),
                      this.clearDepth.set(s),
                      this.depthMask.set(!0)),
                    h !== void 0 &&
                      ((x |= g.STENCIL_BUFFER_BIT),
                      this.clearStencil.set(h),
                      this.stencilMask.set(255)),
                    g.clear(x));
                }
                setCullFace(t) {
                  t.enable === !1
                    ? this.cullFace.set(!1)
                    : (this.cullFace.set(!0),
                      this.cullFaceSide.set(t.mode),
                      this.frontFace.set(t.frontFace));
                }
                setDepthMode(t) {
                  t.func !== this.gl.ALWAYS || t.mask
                    ? (this.depthTest.set(!0),
                      this.depthFunc.set(t.func),
                      this.depthMask.set(t.mask),
                      this.depthRange.set(t.range))
                    : this.depthTest.set(!1);
                }
                setStencilMode(t) {
                  t.test.func !== this.gl.ALWAYS || t.mask
                    ? (this.stencilTest.set(!0),
                      this.stencilMask.set(t.mask),
                      this.stencilOp.set([t.fail, t.depthFail, t.pass]),
                      this.stencilFunc.set({
                        func: t.test.func,
                        ref: t.ref,
                        mask: t.test.mask,
                      }))
                    : this.stencilTest.set(!1);
                }
                setColorMode(t) {
                  (r.bv(t.blendFunction, ui.Replace)
                    ? this.blend.set(!1)
                    : (this.blend.set(!0),
                      this.blendFunc.set(t.blendFunction),
                      this.blendColor.set(t.blendColor),
                      t.blendEquation
                        ? this.blendEquation.set(t.blendEquation)
                        : this.blendEquation.setDefault()),
                    this.colorMask.set(t.mask));
                }
                unbindVAO() {
                  this.bindVertexArrayOES.set(null);
                }
              }
              let vl;
              function su(c, t, s, h, p, g, x) {
                const w = c.context,
                  S = w.gl,
                  C = c.transform,
                  D = c.getOrCreateProgram("collisionBox"),
                  L = [];
                let z = 0,
                  O = 0;
                for (let ae = 0; ae < h.length; ae++) {
                  const pe = h[ae],
                    ue = t.getTile(pe),
                    ce = ue.getBucket(s);
                  if (!ce) continue;
                  const le = Ht(pe, ce, C);
                  let me = le;
                  (p[0] === 0 && p[1] === 0) ||
                    (me = c.translatePosMatrix(le, ue, p, g));
                  const _e = x ? ce.textCollisionBox : ce.iconCollisionBox,
                    De = ce.collisionCircleArray;
                  if (De.length > 0) {
                    const ze = r.bz(),
                      He = me;
                    (r.cB(ze, ce.placementInvProjMatrix, C.glCoordMatrix),
                      r.cB(ze, ze, ce.placementViewportMatrix),
                      L.push({
                        circleArray: De,
                        circleOffset: O,
                        transform: He,
                        invTransform: ze,
                        projection: ce.getProjection(),
                      }),
                      (z += De.length / 4),
                      (O = z));
                  }
                  _e &&
                    (c.terrain && c.terrain.setupElevationDraw(ue, D),
                    D.draw(
                      c,
                      S.LINES,
                      wt.disabled,
                      Yt.disabled,
                      c.colorModeForRenderPass(),
                      Gt.disabled,
                      D_(me, C, ue, ce.getProjection()),
                      s.id,
                      _e.layoutVertexBuffer,
                      _e.indexBuffer,
                      _e.segments,
                      null,
                      C.zoom,
                      null,
                      [_e.collisionVertexBuffer, _e.collisionVertexBufferExt],
                    ));
                }
                if (!x || !L.length) return;
                const G = c.getOrCreateProgram("collisionCircle"),
                  U = new r.dI();
                (U.resize(4 * z), U._trim());
                let $ = 0;
                for (const ae of L)
                  for (let pe = 0; pe < ae.circleArray.length / 4; pe++) {
                    const ue = 4 * pe,
                      ce = ae.circleArray[ue + 0],
                      le = ae.circleArray[ue + 1],
                      me = ae.circleArray[ue + 2],
                      _e = ae.circleArray[ue + 3];
                    (U.emplace($++, ce, le, me, _e, 0),
                      U.emplace($++, ce, le, me, _e, 1),
                      U.emplace($++, ce, le, me, _e, 2),
                      U.emplace($++, ce, le, me, _e, 3));
                  }
                (!vl || vl.length < 2 * z) &&
                  (vl = (function (ae) {
                    const pe = 2 * ae,
                      ue = new r.a_();
                    (ue.resize(pe), ue._trim());
                    for (let ce = 0; ce < pe; ce++) {
                      const le = 6 * ce;
                      ((ue.uint16[le + 0] = 4 * ce + 0),
                        (ue.uint16[le + 1] = 4 * ce + 1),
                        (ue.uint16[le + 2] = 4 * ce + 2),
                        (ue.uint16[le + 3] = 4 * ce + 2),
                        (ue.uint16[le + 4] = 4 * ce + 3),
                        (ue.uint16[le + 5] = 4 * ce + 0));
                    }
                    return ue;
                  })(z));
                const Z = w.createIndexBuffer(vl, !0),
                  Y = w.createVertexBuffer(U, r.dJ.members, !0);
                for (const ae of L) {
                  const pe = {
                    u_matrix: ae.transform,
                    u_inv_matrix: ae.invTransform,
                    u_camera_to_center_distance: (ie =
                      C).getCameraToCenterDistance(ae.projection),
                    u_viewport_size: [ie.width, ie.height],
                  };
                  G.draw(
                    c,
                    S.TRIANGLES,
                    wt.disabled,
                    Yt.disabled,
                    c.colorModeForRenderPass(),
                    Gt.disabled,
                    pe,
                    s.id,
                    Y,
                    Z,
                    r.bd.simpleSegment(
                      0,
                      2 * ae.circleOffset,
                      ae.circleArray.length,
                      ae.circleArray.length / 2,
                    ),
                    null,
                    C.zoom,
                  );
                }
                var ie;
                (Y.destroy(), Z.destroy());
              }
              const lo = r.bz();
              function kc(c) {
                const t = c._camera.getWorldToCamera(c.worldSize, 1),
                  s = r.az([], t, c.globeMatrix);
                r.bi(s, s);
                const h = [0, 0, 0],
                  p = [0, 1, 0, 0];
                return (
                  r.aA(p, p, s),
                  (h[0] = p[0]),
                  (h[1] = p[1]),
                  (h[2] = p[2]),
                  r.au(h, h),
                  h
                );
              }
              function Lc(
                { width: c, height: t, anchor: s, textOffset: h, textScale: p },
                g,
              ) {
                const { horizontalAlign: x, verticalAlign: w } = r.bT(s),
                  S = -(x - 0.5) * c,
                  C = -(w - 0.5) * t,
                  D = r.bU(s, h);
                return new r.P((S / p + D[0]) * g, (C / p + D[1]) * g);
              }
              function Yp(c, t, s, h, p, g, x, w, S, C) {
                const D = c.text.placedSymbolArray,
                  L = c.text.dynamicLayoutVertexArray,
                  z = c.icon.dynamicLayoutVertexArray,
                  O = {},
                  G = c.getProjection(),
                  U = kh(x, G, p),
                  $ = p.elevation,
                  Z = G.upVectorScale(
                    x.canonical,
                    p.center.lat,
                    p.worldSize,
                  ).metersToTile;
                L.clear();
                for (let Y = 0; Y < D.length; Y++) {
                  const ie = D.get(Y),
                    { tileAnchorX: ae, tileAnchorY: pe, numGlyphs: ue } = ie,
                    ce =
                      ie.hidden ||
                      !ie.crossTileID ||
                      (c.allowVerticalPlacement && !ie.placedOrientation)
                        ? null
                        : h[ie.crossTileID];
                  if (ce) {
                    let le = 0,
                      me = 0,
                      _e = 0;
                    if ($) {
                      const Ze = $ ? $.getAtTileOffset(x, ae, pe) : 0,
                        [Oe, Ke, ht] = G.upVector(x.canonical, ae, pe);
                      ((le = Ze * Oe * Z),
                        (me = Ze * Ke * Z),
                        (_e = Ze * ht * Z));
                    }
                    let [De, ze, He, We] = Cs(
                      ie.projectedAnchorX + le,
                      ie.projectedAnchorY + me,
                      ie.projectedAnchorZ + _e,
                      s ? U : g,
                    );
                    const et = mc(p.getCameraToCenterDistance(G), We);
                    let Ce = (r.bJ(c.textSizeData, S, ie) * et) / r.bO;
                    s && (Ce *= c.tilePixelRatio / w);
                    const Ve = Lc(ce, Ce);
                    s
                      ? (({
                          x: De,
                          y: ze,
                          z: He,
                        } = G.projectTilePoint(
                          ae + Ve.x,
                          pe + Ve.y,
                          x.canonical,
                        )),
                        ([De, ze, He] = Cs(De + le, ze + me, He + _e, g)))
                      : (t && Ve._rotate(-p.angle),
                        (De += Ve.x),
                        (ze += Ve.y),
                        (He = 0));
                    const Te =
                      c.allowVerticalPlacement &&
                      ie.placedOrientation === r.bI.vertical
                        ? Math.PI / 2
                        : 0;
                    for (let Ze = 0; Ze < ue; Ze++) r.bL(L, De, ze, He, Te);
                    C &&
                      ie.associatedIconIndex >= 0 &&
                      (O[ie.associatedIconIndex] = {
                        x: De,
                        y: ze,
                        z: He,
                        angle: Te,
                      });
                  } else xa(ue, L);
                }
                if (C) {
                  z.clear();
                  const Y = c.icon.placedSymbolArray;
                  for (let ie = 0; ie < Y.length; ie++) {
                    const ae = Y.get(ie),
                      { numGlyphs: pe } = ae,
                      ue = O[ie];
                    if (ae.hidden || !ue) xa(pe, z);
                    else {
                      const { x: ce, y: le, z: me, angle: _e } = ue;
                      for (let De = 0; De < pe; De++) r.bL(z, ce, le, me, _e);
                    }
                  }
                  c.icon.dynamicLayoutVertexBuffer.updateData(z);
                }
                c.text.dynamicLayoutVertexBuffer.updateData(L);
              }
              function bl(c, t, s, h, p, g, x = {}) {
                const w = s.paint.get("icon-translate"),
                  S = s.paint.get("text-translate"),
                  C = s.paint.get("icon-translate-anchor"),
                  D = s.paint.get("text-translate-anchor"),
                  L = s.layout.get("icon-rotation-alignment"),
                  z = s.layout.get("text-rotation-alignment"),
                  O = s.layout.get("icon-pitch-alignment"),
                  G = s.layout.get("text-pitch-alignment"),
                  U = s.layout.get("icon-keep-upright"),
                  $ = s.layout.get("text-keep-upright"),
                  Z = s.paint.get("icon-color-saturation"),
                  Y = s.paint.get("icon-color-contrast"),
                  ie = s.paint.get("icon-color-brightness-min"),
                  ae = s.paint.get("icon-color-brightness-max"),
                  pe = s.layout.get("symbol-elevation-reference") === "sea",
                  ue = c.context,
                  ce = ue.gl,
                  le = c.transform,
                  me = L === "map",
                  _e = z === "map",
                  De = O === "map",
                  ze = G === "map",
                  He = s.layout.get("symbol-sort-key").constantOr(1) !== void 0;
                let We = !1;
                const et = c.depthModeForSublayer(0, wt.ReadOnly),
                  Ce = new wt(
                    c.context.gl.LEQUAL,
                    wt.ReadOnly,
                    c.depthRangeFor3D,
                  ),
                  Ve = [r.aD(le.center.lng), r.aH(le.center.lat)],
                  Te = s.layout.get("text-variable-anchor"),
                  Ze = le.projection.name === "globe",
                  Oe = [],
                  Ke = [0, -1, 0];
                for (const ht of h) {
                  const qe = t.getTile(ht),
                    lt = qe.getBucket(s);
                  if (
                    !lt ||
                    (lt.projection.name === "mercator" && Ze) ||
                    lt.fullyClipped
                  )
                    continue;
                  const St = lt.projection.name === "globe",
                    Et = St ? r.ah(le.zoom) : 0,
                    bt = kh(ht, lt.getProjection(), le),
                    kt = le.calculatePixelsToTileUnitsMatrix(qe),
                    Bt = Te && lt.hasTextData(),
                    Vt = lt.hasIconTextFit() && Bt && lt.hasIconData(),
                    Zt = lt
                      .getProjection()
                      .createInversionMatrix(le, ht.canonical),
                    si =
                      ((1 << qe.tileID.canonical.z) * r.aj) /
                      c.transform.worldSize,
                    Fi = (rn) => {
                      let Di = [0, 0, 0];
                      if (rn) {
                        const Pn = c.style.directionalLight,
                          Ti = c.style.ambientLight;
                        Pn && Ti && (Di = wa(c.style, Pn, Ti));
                      }
                      return Di;
                    },
                    nn = (rn) => {
                      le.depthOcclusionForSymbolsAndCircles &&
                        (s.hasInitialOcclusionOpacityProperties || c.terrain) &&
                        (rn.push("DEPTH_D24"), rn.push("DEPTH_OCCLUSION"));
                    },
                    ji = () => {
                      const rn =
                          me && s.layout.get("symbol-placement") !== "point",
                        Di = [];
                      nn(Di);
                      const Pn = rn || Vt,
                        Ti = lt.elevationType === "road" && De,
                        Un = c.shadowRenderer,
                        hn = Ti && !!Un && Un.enabled,
                        Ji = Fi(hn),
                        un = Ti ? Ce : et,
                        ki = s.paint.get("icon-image-cross-fade");
                      (c.terrainRenderModeElevated() &&
                        De &&
                        Di.push("PITCH_WITH_MAP_TERRAIN"),
                        St &&
                          (Di.push("PROJECTION_GLOBE_VIEW"),
                          Pn && Di.push("PROJECTED_POS_ON_VIEWPORT")),
                        ki > 0 && Di.push("ICON_TRANSITION"),
                        lt.icon.zOffsetVertexBuffer && Di.push("Z_OFFSET"),
                        (Z === 0 && Y === 0 && ie === 0 && ae === 1) ||
                          Di.push("COLOR_ADJUSTMENT"),
                        lt.sdfIcons && Di.push("RENDER_SDF"),
                        hn &&
                          Di.push(
                            "RENDER_SHADOWS",
                            "DEPTH_TEXTURE",
                            "NORMAL_OFFSET",
                          ),
                        Ti &&
                          lt.icon.orientationVertexBuffer &&
                          Di.push("ELEVATED_ROADS"));
                      const zn = lt.icon.programConfigurations.get(s.id),
                        fr = c.getOrCreateProgram("symbol", {
                          config: zn,
                          defines: Di,
                        }),
                        xn = qe.imageAtlasTexture
                          ? qe.imageAtlasTexture.size
                          : [0, 0],
                        Ci = lt.iconSizeData,
                        es = r.bH(Ci, le.zoom),
                        $r = De || !le.isOrthographic,
                        cs = ro(
                          bt,
                          qe.tileID.canonical,
                          De,
                          me,
                          le,
                          lt.getProjection(),
                          kt,
                        ),
                        zs = Dh(
                          bt,
                          qe.tileID.canonical,
                          De,
                          me,
                          le,
                          lt.getProjection(),
                          kt,
                        ),
                        ws = c.translatePosMatrix(zs, qe, w, C, !0),
                        Hr = c.translatePosMatrix(bt, qe, w, C),
                        qo = Pn ? lo : cs,
                        ks = me && !De && !rn;
                      let Zo = Ke;
                      (!Ze && !le.mercatorFromTransition) ||
                        me ||
                        (Zo = kc(le));
                      const Jc = St ? Zo : Ke,
                        af = s.getColorAdjustmentMatrix(Z, Y, ie, ae),
                        Ll = Dc(
                          Ci.kind,
                          es,
                          ks,
                          De,
                          c,
                          Hr,
                          qo,
                          ws,
                          pe,
                          !1,
                          xn,
                          [0, 0],
                          0,
                          ht,
                          Et,
                          Ve,
                          Zt,
                          Jc,
                          lt.getProjection(),
                          Ji,
                          si,
                          af,
                          ki,
                          null,
                        ),
                        lf = qe.imageAtlasTexture ? qe.imageAtlasTexture : null,
                        Qc =
                          s.layout.get("icon-size").constantOr(0) !== 1 ||
                          lt.iconsNeedLinear,
                        Su =
                          lt.sdfIcons ||
                          c.options.rotating ||
                          c.options.zooming ||
                          Qc ||
                          $r
                            ? ce.LINEAR
                            : ce.NEAREST,
                        Eu =
                          lt.sdfIcons &&
                          s.paint.get("icon-halo-width").constantOr(1) !== 0,
                        Gs = c.terrain && De && rn ? r.bi(r.bz(), cs) : lo;
                      if (rn && lt.icon) {
                        const Ol = le.elevation,
                          La = Ol
                            ? Ol.getAtTileOffsetFunc(
                                ht,
                                le.center.lat,
                                le.worldSize,
                                lt.getProjection(),
                              )
                            : null,
                          Xo = Ph(
                            bt,
                            qe.tileID.canonical,
                            De,
                            me,
                            le,
                            lt.getProjection(),
                            kt,
                          );
                        Rh(lt, bt, c, !1, Xo, zs, De, U, La, ht);
                      }
                      return {
                        program: fr,
                        buffers: lt.icon,
                        uniformValues: Ll,
                        atlasTexture: lf,
                        atlasTextureIcon: null,
                        atlasInterpolation: Su,
                        atlasInterpolationIcon: null,
                        isSDF: lt.sdfIcons,
                        hasHalo: Eu,
                        depthMode: un,
                        tile: qe,
                        renderWithShadows: hn,
                        labelPlaneMatrixInv: Gs,
                      };
                    },
                    Hi = () => {
                      const rn =
                          _e && s.layout.get("symbol-placement") !== "point",
                        Di = [],
                        Pn = rn || Te || Vt,
                        Ti = lt.elevationType === "road" && ze,
                        Un = c.shadowRenderer,
                        hn = Ti && !!Un && Un.enabled,
                        Ji = Fi(hn),
                        un = Ti ? Ce : et;
                      (c.terrainRenderModeElevated() &&
                        ze &&
                        Di.push("PITCH_WITH_MAP_TERRAIN"),
                        St &&
                          (Di.push("PROJECTION_GLOBE_VIEW"),
                          Pn && Di.push("PROJECTED_POS_ON_VIEWPORT")),
                        lt.text.zOffsetVertexBuffer && Di.push("Z_OFFSET"),
                        lt.iconsInText && Di.push("RENDER_TEXT_AND_SYMBOL"),
                        Di.push("RENDER_SDF"),
                        hn &&
                          Di.push(
                            "RENDER_SHADOWS",
                            "DEPTH_TEXTURE",
                            "NORMAL_OFFSET",
                          ),
                        Ti &&
                          lt.text.orientationVertexBuffer &&
                          Di.push("ELEVATED_ROADS"),
                        nn(Di));
                      const ki = lt.text.programConfigurations.get(s.id),
                        zn = c.getOrCreateProgram("symbol", {
                          config: ki,
                          defines: Di,
                        });
                      let fr,
                        xn = [0, 0],
                        Ci = null;
                      const es = lt.textSizeData;
                      lt.iconsInText &&
                        ((xn = qe.imageAtlasTexture
                          ? qe.imageAtlasTexture.size
                          : [0, 0]),
                        (Ci = qe.imageAtlasTexture
                          ? qe.imageAtlasTexture
                          : null),
                        (fr =
                          ze ||
                          !le.isOrthographic ||
                          c.options.rotating ||
                          c.options.zooming ||
                          es.kind === "composite" ||
                          es.kind === "camera"
                            ? ce.LINEAR
                            : ce.NEAREST));
                      const $r = qe.glyphAtlasTexture
                          ? qe.glyphAtlasTexture.size
                          : [0, 0],
                        cs = s.layout.get("text-size-scale-range"),
                        zs = r.ay(c.scaleFactor, cs[0], cs[1]),
                        ws = r.bH(es, le.zoom, zs),
                        Hr = ro(
                          bt,
                          qe.tileID.canonical,
                          ze,
                          _e,
                          le,
                          lt.getProjection(),
                          kt,
                        ),
                        qo = Dh(
                          bt,
                          qe.tileID.canonical,
                          ze,
                          _e,
                          le,
                          lt.getProjection(),
                          kt,
                        ),
                        ks = c.translatePosMatrix(qo, qe, S, D, !0),
                        Zo = c.translatePosMatrix(bt, qe, S, D),
                        Jc = Pn ? lo : Hr,
                        af = _e && !ze && !rn;
                      let Ll = Ke;
                      (!Ze && !le.mercatorFromTransition) ||
                        _e ||
                        (Ll = kc(le));
                      const lf = Dc(
                          es.kind,
                          ws,
                          af,
                          ze,
                          c,
                          Zo,
                          Jc,
                          ks,
                          pe,
                          !0,
                          $r,
                          xn,
                          0,
                          ht,
                          Et,
                          Ve,
                          Zt,
                          St ? Ll : Ke,
                          lt.getProjection(),
                          Ji,
                          si,
                          null,
                          null,
                          zs,
                        ),
                        Qc = qe.glyphAtlasTexture ? qe.glyphAtlasTexture : null,
                        Su = ce.LINEAR,
                        Eu = s.paint.get("text-halo-width").constantOr(1) !== 0,
                        Gs = c.terrain && ze && rn ? r.bi(r.bz(), Hr) : lo;
                      if (rn && lt.text) {
                        const Ol = le.elevation,
                          La = Ol
                            ? Ol.getAtTileOffsetFunc(
                                ht,
                                le.center.lat,
                                le.worldSize,
                                lt.getProjection(),
                              )
                            : null,
                          Xo = Ph(
                            bt,
                            qe.tileID.canonical,
                            ze,
                            _e,
                            le,
                            lt.getProjection(),
                            kt,
                          );
                        Rh(lt, bt, c, !0, Xo, qo, ze, $, La, ht);
                      }
                      return {
                        program: zn,
                        buffers: lt.text,
                        uniformValues: lf,
                        atlasTexture: Qc,
                        atlasTextureIcon: Ci,
                        atlasInterpolation: Su,
                        atlasInterpolationIcon: fr,
                        isSDF: !0,
                        hasHalo: Eu,
                        depthMode: un,
                        tile: qe,
                        renderWithShadows: hn,
                        labelPlaneMatrixInv: Gs,
                      };
                    },
                    Fn = lt.icon.segments.get().length,
                    ti = lt.text.segments.get().length,
                    li = Fn && !x.onlyText ? ji() : null,
                    gi = ti && !x.onlyIcons ? Hi() : null,
                    cn = s.paint.get("icon-opacity").constantOr(1),
                    qn = s.paint.get("text-opacity").constantOr(1);
                  if (He && lt.canOverlap) {
                    We = !0;
                    const rn = cn && !x.onlyText ? lt.icon.segments.get() : [],
                      Di = qn && !x.onlyIcons ? lt.text.segments.get() : [];
                    for (const Pn of rn)
                      Oe.push({
                        segments: new r.bd([Pn]),
                        sortKey: Pn.sortKey,
                        state: li,
                      });
                    for (const Pn of Di)
                      Oe.push({
                        segments: new r.bd([Pn]),
                        sortKey: Pn.sortKey,
                        state: gi,
                      });
                  } else
                    (x.onlyText ||
                      Oe.push({
                        segments: cn ? lt.icon.segments : new r.bd([]),
                        sortKey: 0,
                        state: li,
                      }),
                      x.onlyIcons ||
                        Oe.push({
                          segments: qn ? lt.text.segments : new r.bd([]),
                          sortKey: 0,
                          state: gi,
                        }));
                }
                We && Oe.sort((ht, qe) => ht.sortKey - qe.sortKey);
                for (const ht of Oe) {
                  const qe = ht.state;
                  if (qe)
                    if (
                      (c.terrain
                        ? c.terrain.setupElevationDraw(qe.tile, qe.program, {
                            useDepthForOcclusion:
                              le.depthOcclusionForSymbolsAndCircles,
                            labelPlaneMatrixInv: qe.labelPlaneMatrixInv,
                          })
                        : c.setupDepthForOcclusion(
                            le.depthOcclusionForSymbolsAndCircles,
                            qe.program,
                          ),
                      ue.activeTexture.set(ce.TEXTURE0),
                      qe.atlasTexture &&
                        qe.atlasTexture.bind(
                          qe.atlasInterpolation,
                          ce.CLAMP_TO_EDGE,
                          !0,
                        ),
                      qe.atlasTextureIcon &&
                        (ue.activeTexture.set(ce.TEXTURE1),
                        qe.atlasTextureIcon &&
                          qe.atlasTextureIcon.bind(
                            qe.atlasInterpolationIcon,
                            ce.CLAMP_TO_EDGE,
                            !0,
                          )),
                      qe.renderWithShadows &&
                        c.shadowRenderer.setupShadows(
                          qe.tile.tileID.toUnwrapped(),
                          qe.program,
                          "vector-tile",
                          qe.tile.tileID.overscaledZ,
                        ),
                      c.uploadCommonLightUniforms(c.context, qe.program),
                      qe.hasHalo)
                    ) {
                      const lt = qe.uniformValues;
                      ((lt.u_is_halo = 1),
                        wl(
                          qe.buffers,
                          ht.segments,
                          s,
                          c,
                          qe.program,
                          qe.depthMode,
                          p,
                          g,
                          lt,
                          2,
                        ),
                        (lt.u_is_halo = 0));
                    } else {
                      if (qe.isSDF) {
                        const lt = qe.uniformValues;
                        (qe.hasHalo &&
                          ((lt.u_is_halo = 1),
                          wl(
                            qe.buffers,
                            ht.segments,
                            s,
                            c,
                            qe.program,
                            qe.depthMode,
                            p,
                            g,
                            lt,
                            1,
                          )),
                          (lt.u_is_halo = 0));
                      }
                      wl(
                        qe.buffers,
                        ht.segments,
                        s,
                        c,
                        qe.program,
                        qe.depthMode,
                        p,
                        g,
                        qe.uniformValues,
                        1,
                      );
                    }
                }
              }
              function wl(c, t, s, h, p, g, x, w, S, C) {
                const D = [
                  c.dynamicLayoutVertexBuffer,
                  c.opacityVertexBuffer,
                  c.iconTransitioningVertexBuffer,
                  c.globeExtVertexBuffer,
                  c.zOffsetVertexBuffer,
                  c.orientationVertexBuffer,
                ];
                p.draw(
                  h,
                  h.context.gl.TRIANGLES,
                  g,
                  x,
                  w,
                  Gt.disabled,
                  S,
                  s.id,
                  c.layoutVertexBuffer,
                  c.indexBuffer,
                  t,
                  s.paint,
                  h.transform.zoom,
                  c.programConfigurations.get(s.id),
                  D,
                  C,
                );
              }
              function ou(c, t) {
                const s = 1 << c.canonical.z,
                  h = (t.x * s - c.canonical.x - c.wrap * s) * r.aj,
                  p = (t.y * s - c.canonical.y) * r.aj,
                  g = r.dS(t.z, t.y);
                return r.cS(h, p, g);
              }
              function Fd(c, t, s, h, p) {
                if (
                  !s.layout ||
                  s.layout.get("fill-elevation-reference") === "none"
                )
                  return;
                const g = c.context.gl,
                  x = new wt(
                    c.context.gl.LEQUAL,
                    wt.ReadWrite,
                    c.depthRangeFor3D,
                  ),
                  w = new wt(
                    c.context.gl.GREATER,
                    wt.ReadWrite,
                    c.depthRangeFor3D,
                  ),
                  S = (function (O) {
                    const G = r.cJ(O.pitch);
                    let U = 0.01;
                    return (
                      O.isOrthographic &&
                        (U = r.ai(1e-4, U, r.cN(G >= lr ? 1 : G / lr))),
                      2 * U
                    );
                  })(c.transform),
                  C = c.transform.getFreeCameraOptions().position,
                  D = "elevatedStructuresDepthReconstruct",
                  L = c.getOrCreateProgram(D, {
                    defines: ["DEPTH_RECONSTRUCTION"],
                  }),
                  z = c.getOrCreateProgram(D);
                for (const O of h) {
                  const G = t.getTile(O),
                    U = G.getBucket(s);
                  if (!U) continue;
                  const $ = U.elevatedStructures;
                  if (!$) continue;
                  const Z = U.elevationBufferData.heightRange,
                    Y = ou(O.toUnwrapped(), C),
                    ie = c.translatePosMatrix(
                      O.projMatrix,
                      G,
                      s.paint.get("fill-translate"),
                      s.paint.get("fill-translate-anchor"),
                    );
                  let ae, pe, ue, ce;
                  if (p === "initialize") {
                    if (
                      !Z ||
                      Z.min >= 1 ||
                      $.depthSegments.segments[0].primitiveLength === 0
                    )
                      continue;
                    ((ae = iu(ie, Y, S, 1, 0)),
                      (pe = x),
                      (ue = $.depthSegments),
                      (ce = L));
                  } else if (p === "reset") {
                    if (
                      !Z ||
                      Z.min >= 0 ||
                      $.maskSegments.segments[0].primitiveLength === 0
                    )
                      continue;
                    ((ae = iu(ie, Y, 0, 0, 1)),
                      (pe = w),
                      (ue = $.maskSegments),
                      (ce = L));
                  } else if (p === "geometry") {
                    if ($.depthSegments.segments[0].primitiveLength === 0)
                      continue;
                    ((ae = iu(ie, Y, S, 1, 0)),
                      (pe = x),
                      (ue = $.depthSegments),
                      (ce = z));
                  }
                  ce.draw(
                    c,
                    g.TRIANGLES,
                    pe,
                    Yt.disabled,
                    ui.disabled,
                    Gt.disabled,
                    ae,
                    s.id,
                    $.vertexBuffer,
                    $.indexBuffer,
                    ue,
                    s.paint,
                    c.transform.zoom,
                  );
                }
              }
              function Bd(c, t, s) {
                const {
                    painter: h,
                    sourceCache: p,
                    layer: g,
                    coords: x,
                    colorMode: w,
                    elevationType: S,
                    terrainEnabled: C,
                    pass: D,
                  } = c,
                  L = h.context.gl,
                  z = g.paint.get("fill-pattern"),
                  O = g.paint.get("fill-pattern-cross-fade"),
                  G = z.constantOr(null);
                let U = S;
                S !== "road" || (t && !C) || (U = "none");
                const $ = U === "road",
                  Z = c.painter.shadowRenderer,
                  Y = $ && !!Z && Z.enabled,
                  ie = new wt(
                    h.context.gl.LEQUAL,
                    wt.ReadOnly,
                    h.depthRangeFor3D,
                  );
                let ae = [0, 0, 0];
                if (Y) {
                  const ce = h.style.directionalLight,
                    le = h.style.ambientLight;
                  ce && le && (ae = wa(h.style, ce, le));
                }
                const pe = z && z.constantOr(1),
                  ue = (ce, le) => {
                    let me, _e, De, ze, He;
                    le
                      ? ((me =
                          pe && !g.getPaintProperty("fill-outline-color")
                            ? "fillOutlinePattern"
                            : "fillOutline"),
                        (De = L.LINES))
                      : ((me = pe ? "fillPattern" : "fill"),
                        (De = L.TRIANGLES));
                    for (const We of x) {
                      const et = p.getTile(We);
                      if (pe && !et.patternsLoaded()) continue;
                      const Ce = et.getBucket(g);
                      if (!Ce) continue;
                      const Ve = t ? Ce.elevationBufferData : Ce.bufferData;
                      if (Ve.isEmpty()) continue;
                      h.prepareDrawTile();
                      const Te = Ve.programConfigurations.get(g.id),
                        Ze = h.isTileAffectedByFog(We),
                        Oe = [],
                        Ke = [];
                      ($ &&
                        (Oe.push("ELEVATED_ROADS"),
                        Ke.push(Ve.elevatedLayoutVertexBuffer)),
                        Y &&
                          Oe.push(
                            "RENDER_SHADOWS",
                            "DEPTH_TEXTURE",
                            "NORMAL_OFFSET",
                          ),
                        pe &&
                          (h.context.activeTexture.set(L.TEXTURE0),
                          et.imageAtlasTexture &&
                            et.imageAtlasTexture.bind(
                              L.LINEAR,
                              L.CLAMP_TO_EDGE,
                            ),
                          Te.updatePaintBuffers()));
                      let ht = !1;
                      if (G && et.imageAtlas) {
                        const bt = et.imageAtlas,
                          kt = r.dN.from(G),
                          Bt = kt
                            .getPrimary()
                            .scaleSelf(r.q.devicePixelRatio)
                            .toString(),
                          Vt = kt.getSecondary(),
                          Zt = bt.patternPositions.get(Bt),
                          si = Vt
                            ? bt.patternPositions.get(
                                Vt.scaleSelf(r.q.devicePixelRatio).toString(),
                              )
                            : null;
                        ((ht = !!Zt && !!si),
                          Zt && Te.setConstantPatternPositions(Zt, si));
                      }
                      O > 0 &&
                        (ht ||
                          Te.getPatternTransitionVertexBuffer(
                            "fill-pattern",
                          )) &&
                        Oe.push("FILL_PATTERN_TRANSITION");
                      const qe = h.getOrCreateProgram(me, {
                          config: Te,
                          overrideFog: Ze,
                          defines: Oe,
                        }),
                        lt = h.translatePosMatrix(
                          We.projMatrix,
                          et,
                          g.paint.get("fill-translate"),
                          g.paint.get("fill-translate-anchor"),
                        );
                      Y &&
                        Z.setupShadows(
                          et.tileID.toUnwrapped(),
                          qe,
                          "vector-tile",
                          et.tileID.overscaledZ,
                        );
                      const St = g.paint.get("fill-emissive-strength");
                      if (le) {
                        ((ze = Ve.lineIndexBuffer), (He = Ve.lineSegments));
                        const bt =
                          h.terrain && h.terrain.renderingToTexture
                            ? h.terrain.drapeBufferSize
                            : [L.drawingBufferWidth, L.drawingBufferHeight];
                        _e =
                          me === "fillOutlinePattern" && pe
                            ? C_(lt, St, h, et, bt, ae, O)
                            : M_(lt, St, bt, ae);
                      } else
                        ((ze = Ve.indexBuffer),
                          (He = Ve.triangleSegments),
                          (_e = pe
                            ? $p(lt, St, h, et, ae, O)
                            : Aa(lt, St, ae)));
                      h.uploadCommonUniforms(h.context, qe, We.toUnwrapped());
                      let Et = ce;
                      (((S === "road" && !C) || S === "offset") && (Et = ie),
                        qe.draw(
                          h,
                          De,
                          Et,
                          s || h.stencilModeForClipping(We),
                          w,
                          Gt.disabled,
                          _e,
                          g.id,
                          Ve.layoutVertexBuffer,
                          ze,
                          He,
                          g.paint,
                          h.transform.zoom,
                          Te,
                          Ke,
                        ));
                    }
                  };
                (h.renderPass === D &&
                  ue(
                    h.depthModeForSublayer(
                      1,
                      h.renderPass === "opaque" ? wt.ReadWrite : wt.ReadOnly,
                    ),
                    !1,
                  ),
                  U === "none" &&
                    h.renderPass === "translucent" &&
                    g.paint.get("fill-antialias") &&
                    ue(
                      h.depthModeForSublayer(
                        g.getPaintProperty("fill-outline-color") ? 2 : 0,
                        wt.ReadOnly,
                      ),
                      !0,
                    ));
              }
              function co(c, t, s, h, p, g, x, w) {
                s.resetLayerRenderingStats(c);
                const S = c.context,
                  C = S.gl,
                  D = c.transform,
                  L = s.paint.get("fill-extrusion-pattern"),
                  z = s.paint.get("fill-extrusion-pattern-cross-fade"),
                  O = L.constantOr(null),
                  G = L.constantOr(1),
                  U = s.paint.get("fill-extrusion-opacity"),
                  $ = c.style.enable3dLights(),
                  Z = s.paint.get(
                    $ && !G
                      ? "fill-extrusion-ambient-occlusion-wall-radius"
                      : "fill-extrusion-ambient-occlusion-radius",
                  ),
                  Y = [
                    s.paint.get("fill-extrusion-ambient-occlusion-intensity"),
                    Z,
                  ],
                  ie = s.layout.get("fill-extrusion-edge-radius"),
                  ae = ie > 0 && !s.paint.get("fill-extrusion-rounded-roof"),
                  pe = ae ? 0 : ie,
                  ue = D.projection.name === "globe" ? r.dV() : 0,
                  ce = D.projection.name === "globe",
                  le = ce ? r.ah(D.zoom) : 0,
                  me = [r.aD(D.center.lng), r.aH(D.center.lat)],
                  _e =
                    s.paint
                      .get("fill-extrusion-flood-light-color-use-theme")
                      .constantOr("default") === "none",
                  De = s.paint
                    .get("fill-extrusion-flood-light-color")
                    .toNonPremultipliedRenderColor(_e ? null : s.lut)
                    .toArray01()
                    .slice(0, 3),
                  ze = s.paint.get("fill-extrusion-flood-light-intensity"),
                  He = s.paint.get("fill-extrusion-vertical-scale"),
                  We =
                    s.paint.get("fill-extrusion-line-width").constantOr(1) !==
                    0,
                  et = s.paint.get("fill-extrusion-height-alignment"),
                  Ce = s.paint.get("fill-extrusion-base-alignment"),
                  Ve = Bs(c, s.paint.get("fill-extrusion-cutoff-fade-range")),
                  Te = [];
                let Ze;
                (ce && Te.push("PROJECTION_GLOBE_VIEW"),
                  Y[0] > 0 && Te.push("FAUX_AO"),
                  ae && Te.push("ZERO_ROOF_RADIUS"),
                  w && Te.push("HAS_CENTROID"),
                  ze > 0 && Te.push("FLOOD_LIGHT"),
                  Ve.shouldRenderCutoff && Te.push("RENDER_CUTOFF"),
                  We && Te.push("RENDER_WALL_MODE"));
                const Oe = c.renderPass === "shadow",
                  Ke = c.shadowRenderer,
                  ht = Oe && !!Ke,
                  qe = Oe ? Gt.disabled : Gt.backCCW;
                c.shadowRenderer && (c.shadowRenderer.useNormalOffset = !0);
                let lt = [0, 0, 0];
                if (Ke) {
                  const bt = c.style.directionalLight,
                    kt = c.style.ambientLight;
                  (bt && kt && (lt = wa(c.style, bt, kt)),
                    Oe ||
                      (Te.push("RENDER_SHADOWS", "DEPTH_TEXTURE"),
                      Ke.useNormalOffset && Te.push("NORMAL_OFFSET")),
                    (Ze = Te.concat(["SHADOWS_SINGLE_CASCADE"])));
                }
                const St = ht
                    ? "fillExtrusionDepth"
                    : G
                      ? "fillExtrusionPattern"
                      : "fillExtrusion",
                  Et = s.getLayerRenderingStats();
                for (const bt of h) {
                  const kt = t.getTile(bt),
                    Bt = kt.getBucket(s);
                  if (!Bt || Bt.projection.name !== D.projection.name) continue;
                  let Vt = !1;
                  Ke && (Vt = Ke.getMaxCascadeForTile(bt.toUnwrapped()) === 0);
                  const Zt = c.isTileAffectedByFog(bt),
                    si = Bt.programConfigurations.get(s.id);
                  let Fi = !1;
                  if (O && kt.imageAtlas) {
                    const gi = kt.imageAtlas,
                      cn = r.dN.from(O),
                      qn = cn
                        .getPrimary()
                        .scaleSelf(r.q.devicePixelRatio)
                        .toString(),
                      rn = cn.getSecondary(),
                      Di = gi.patternPositions.get(qn),
                      Pn = rn
                        ? gi.patternPositions.get(
                            rn.scaleSelf(r.q.devicePixelRatio).toString(),
                          )
                        : null;
                    ((Fi = !!Di && !!Pn),
                      Di && si.setConstantPatternPositions(Di, Pn));
                  }
                  z > 0 &&
                    (Fi ||
                      si.getPatternTransitionVertexBuffer(
                        "fill-extrusion-pattern",
                      )) &&
                    Te.push("FILL_EXTRUSION_PATTERN_TRANSITION");
                  const nn = c.getOrCreateProgram(St, {
                    config: si,
                    defines: Vt ? Ze : Te,
                    overrideFog: Zt,
                  });
                  if (
                    (c.terrain &&
                      c.terrain.setupElevationDraw(kt, nn, {
                        useMeterToDem: !0,
                      }),
                    !Bt.centroidVertexBuffer)
                  ) {
                    const gi = nn.attributes.a_centroid_pos;
                    gi !== void 0 && C.vertexAttrib2f(gi, 0, 0);
                  }
                  (!Oe &&
                    Ke &&
                    Ke.setupShadows(
                      kt.tileID.toUnwrapped(),
                      nn,
                      "vector-tile",
                      kt.tileID.overscaledZ,
                    ),
                    G &&
                      (c.context.activeTexture.set(C.TEXTURE0),
                      kt.imageAtlasTexture &&
                        kt.imageAtlasTexture.bind(C.LINEAR, C.CLAMP_TO_EDGE),
                      si.updatePaintBuffers()));
                  const ji = s.paint.get("fill-extrusion-vertical-gradient"),
                    Hi = 1 / Bt.tileToMeter;
                  let Fn;
                  if (Oe && Ke) {
                    if (Vo(kt.tileID, Bt, c)) continue;
                    const gi = Ke.calculateShadowPassMatrixFromTile(
                      kt.tileID.toUnwrapped(),
                    );
                    Fn = jp(gi, pe, Hi, He, et, Ce);
                  } else {
                    const gi = c.translatePosMatrix(
                        bt.expandedProjMatrix,
                        kt,
                        s.paint.get("fill-extrusion-translate"),
                        s.paint.get("fill-extrusion-translate-anchor"),
                      ),
                      cn = D.projection.createInversionMatrix(D, bt.canonical);
                    Fn = G
                      ? Gp(
                          gi,
                          c,
                          ji,
                          U,
                          Y,
                          pe,
                          Hi,
                          bt,
                          kt,
                          ue,
                          et,
                          Ce,
                          le,
                          me,
                          cn,
                          De,
                          He,
                          z,
                        )
                      : Pc(
                          gi,
                          c,
                          ji,
                          U,
                          Y,
                          pe,
                          Hi,
                          bt,
                          ue,
                          et,
                          Ce,
                          le,
                          me,
                          cn,
                          De,
                          He,
                          ze,
                          lt,
                        );
                  }
                  c.uploadCommonUniforms(S, nn, bt.toUnwrapped(), null, Ve);
                  let ti = Bt.segments;
                  if (
                    D.projection.name === "mercator" &&
                    !Oe &&
                    ((ti = Bt.getVisibleSegments(
                      kt.tileID,
                      c.terrain,
                      c.transform.getFrustum(0),
                    )),
                    !ti.get().length)
                  )
                    continue;
                  if (Et)
                    if (Oe)
                      for (const gi of ti.get())
                        Et.numRenderedVerticesInShadowPass +=
                          gi.primitiveLength;
                    else
                      for (const gi of ti.get())
                        Et.numRenderedVerticesInTransparentPass +=
                          gi.primitiveLength;
                  const li = [];
                  ((c.terrain || w) && li.push(Bt.centroidVertexBuffer),
                    ce && li.push(Bt.layoutVertexExtBuffer),
                    We && li.push(Bt.wallVertexBuffer),
                    nn.draw(
                      c,
                      S.gl.TRIANGLES,
                      p,
                      g,
                      x,
                      qe,
                      Fn,
                      s.id,
                      Bt.layoutVertexBuffer,
                      Bt.indexBuffer,
                      ti,
                      s.paint,
                      c.transform.zoom,
                      si,
                      li,
                    ));
                }
                c.shadowRenderer && (c.shadowRenderer.useNormalOffset = !1);
              }
              function ho(
                c,
                t,
                s,
                h,
                p,
                g,
                x,
                w,
                S,
                C,
                D,
                L,
                z,
                O,
                G,
                U,
                $,
                Z,
                Y,
              ) {
                const ie = c.context,
                  ae = ie.gl,
                  pe = c.transform,
                  ue = c.transform.zoom,
                  ce = [],
                  le = Bs(c, s.paint.get("fill-extrusion-cutoff-fade-range"));
                (C === "clear"
                  ? (ce.push("CLEAR_SUBPASS"),
                    Y &&
                      (ce.push("CLEAR_FROM_TEXTURE"),
                      ie.activeTexture.set(ae.TEXTURE0),
                      Y.bind(ae.LINEAR, ae.CLAMP_TO_EDGE)))
                  : C === "sdf" && ce.push("SDF_SUBPASS"),
                  $ && ce.push("HAS_CENTROID"),
                  le.shouldRenderCutoff && ce.push("RENDER_CUTOFF"));
                const me = s.layout.get("fill-extrusion-edge-radius"),
                  _e = (De, ze, He, We, et) => {
                    const Ce = ze.programConfigurations.get(s.id),
                      Ve = c.isTileAffectedByFog(De),
                      Te = c.getOrCreateProgram("fillExtrusionGroundEffect", {
                        config: Ce,
                        defines: ce,
                        overrideFog: Ve,
                      }),
                      Ze = ((Ke, ht, qe, lt, St, Et, bt, kt, Bt, Vt, Zt) => ({
                        u_matrix: ht,
                        u_opacity: qe,
                        u_ao_pass: lt ? 1 : 0,
                        u_meter_to_tile: St,
                        u_ao: Et,
                        u_flood_light_intensity: bt,
                        u_flood_light_color: kt,
                        u_attenuation: Bt,
                        u_edge_radius: Vt,
                        u_fb: 0,
                        u_fb_size: Zt,
                        u_dynamic_offset: 1,
                      }))(
                        0,
                        We,
                        D,
                        S,
                        et,
                        [L, z * et],
                        O,
                        G,
                        U,
                        ue >= 17 ? 0 : me * et,
                        Y ? Y.size[0] : 0,
                      ),
                      Oe = [];
                    ($ && Oe.push(ze.hiddenByLandmarkVertexBuffer),
                      c.uploadCommonUniforms(
                        ie,
                        Te,
                        De.toUnwrapped(),
                        null,
                        le,
                      ),
                      Te.draw(
                        c,
                        ie.gl.TRIANGLES,
                        p,
                        g,
                        x,
                        w,
                        Ze,
                        s.id,
                        ze.vertexBuffer,
                        ze.indexBuffer,
                        He,
                        s.paint,
                        ue,
                        Ce,
                        Oe,
                      ));
                  };
                for (const De of h) {
                  const ze = t.getTile(De),
                    He = ze.getBucket(s);
                  if (
                    !He ||
                    He.projection.name !== pe.projection.name ||
                    !He.groundEffect ||
                    (He.groundEffect && !He.groundEffect.hasData())
                  )
                    continue;
                  const We = He.groundEffect,
                    et = 1 / He.tileToMeter;
                  {
                    const Ce = c.translatePosMatrix(
                        De.projMatrix,
                        ze,
                        s.paint.get("fill-extrusion-translate"),
                        s.paint.get("fill-extrusion-translate-anchor"),
                      ),
                      Ve = We.getDefaultSegment();
                    _e(De, We, Ve, Ce, et);
                  }
                  if (Z)
                    for (let Ce = 0; Ce < 4; Ce++) {
                      const Ve = r.dT[Ce](De),
                        Te = t.getTile(Ve);
                      if (!Te) continue;
                      const Ze = Te.getBucket(s);
                      if (
                        !Ze ||
                        Ze.projection.name !== pe.projection.name ||
                        !Ze.groundEffect ||
                        (Ze.groundEffect && !Ze.groundEffect.hasData())
                      )
                        continue;
                      const Oe = Ze.groundEffect;
                      let Ke, ht;
                      Ce === 0
                        ? ((Ke = [-8192, 0, 0]), (ht = 1))
                        : Ce === 1
                          ? ((Ke = [r.aj, 0, 0]), (ht = 0))
                          : Ce === 2
                            ? ((Ke = [0, -8192, 0]), (ht = 3))
                            : ((Ke = [0, r.aj, 0]), (ht = 2));
                      const qe = Oe.regionSegments[ht];
                      if (!qe) continue;
                      const lt = new Float32Array(16);
                      (r.bo(lt, De.projMatrix, Ke),
                        _e(
                          De,
                          Oe,
                          qe,
                          c.translatePosMatrix(
                            lt,
                            ze,
                            s.paint.get("fill-extrusion-translate"),
                            s.paint.get("fill-extrusion-translate-anchor"),
                          ),
                          et,
                        ));
                    }
                }
              }
              function Tt(c, t, s, h, p, g, x) {
                h.centroidVertexArray.length === 0 && h.createCentroidsBuffer();
                const w = g ? g.findDEMTileFor(s) : null;
                if (!((w && w.dem) || x)) return;
                g &&
                  w &&
                  w.dem &&
                  h.selfDEMTileTimestamp !== w.dem._timestamp &&
                  ((h.borderDoneWithNeighborZ = [-1, -1, -1, -1]),
                  (h.selfDEMTileTimestamp = w.dem._timestamp));
                const S = (Z) => new r.P(Math.ceil((Z + r.dX) * r.dY), 0),
                  C = (Z) => {
                    const Y = t.getSource().minzoom,
                      ie = (pe) => {
                        const ue = t.getTileByID(pe);
                        if (ue && ue.hasData()) return ue.getBucket(p);
                      },
                      ae = [0, -1, 1];
                    for (const pe of ae) {
                      if (Z.overscaledZ + pe < Y) continue;
                      const ue = ie(Z.calculateScaledKey(Z.overscaledZ + pe));
                      if (ue) return ue;
                    }
                  },
                  D = [0, 0, 0],
                  L = (Z, Y) => (
                    (D[0] = Math.min(Z.min.y, Y.min.y)),
                    (D[1] = Math.max(Z.max.y, Y.max.y)),
                    (D[2] =
                      r.aj - Y.min.x > Z.max.x ? Y.min.x - r.aj : Z.max.x),
                    D
                  ),
                  z = (Z, Y) => (
                    (D[0] = Math.min(Z.min.x, Y.min.x)),
                    (D[1] = Math.max(Z.max.x, Y.max.x)),
                    (D[2] =
                      r.aj - Y.min.y > Z.max.y ? Y.min.y - r.aj : Z.max.y),
                    D
                  ),
                  O = [
                    (Z, Y) => L(Z, Y),
                    (Z, Y) => L(Y, Z),
                    (Z, Y) => z(Z, Y),
                    (Z, Y) => z(Y, Z),
                  ],
                  G = (Z, Y, ie, ae, pe, ue, ce) => {
                    if (!g) return 0;
                    const le = [
                        [ue ? ie : Z, ue ? Z : ie, 0],
                        [ue ? ie : Y, ue ? Y : ie, 0],
                      ],
                      me = ce < 0 ? r.aj + ce : ce,
                      _e = [ue ? me : (Z + Y) / 2, ue ? (Z + Y) / 2 : me, 0];
                    return (
                      (ie === 0 && ce < 0) || (ie !== 0 && ce > 0)
                        ? g.getForTilePoints(pe, [_e], !0, ae)
                        : le.push(_e),
                      g.getForTilePoints(s, le, !0, w),
                      Math.max(le[0][2], le[1][2], _e[2]) / g.exaggeration()
                    );
                  };
                for (let Z = 0; Z < 4; Z++) {
                  const Y = h.borderFeatureIndices[Z];
                  if (Y.length === 0) continue;
                  const ie = r.dT[Z](s),
                    ae = C(ie);
                  if (!(ae && ae instanceof r.dU)) continue;
                  const pe = g ? g.findDEMTileFor(ie) : null;
                  if (
                    !((pe && pe.dem) || x) ||
                    (g &&
                      pe &&
                      pe.dem &&
                      h.borderDEMTileTimestamp[Z] !== pe.dem._timestamp &&
                      ((h.borderDoneWithNeighborZ[Z] = -1),
                      (h.borderDEMTileTimestamp[Z] = pe.dem._timestamp)),
                    h.borderDoneWithNeighborZ[Z] === ae.canonical.z)
                  )
                    continue;
                  ae.centroidVertexArray.length === 0 &&
                    ae.createCentroidsBuffer();
                  const ue = (Z < 2 ? 1 : 5) - Z,
                    ce = ae.borderDoneWithNeighborZ[ue] !== h.canonical.z,
                    le = ae.borderFeatureIndices[ue];
                  let me = 0;
                  if (h.canonical.z !== ae.canonical.z) {
                    for (const _e of Y) h.showCentroid(h.featuresOnBorder[_e]);
                    if (ce)
                      for (const _e of le)
                        ae.showCentroid(ae.featuresOnBorder[_e]);
                    ((h.borderDoneWithNeighborZ[Z] = ae.canonical.z),
                      (ae.borderDoneWithNeighborZ[ue] = h.canonical.z));
                  }
                  for (const _e of Y) {
                    const De = h.featuresOnBorder[_e],
                      ze = h.centroidData[De.centroidDataIndex],
                      He = De.borders[Z];
                    let We;
                    for (; me < le.length; ) {
                      We = ae.featuresOnBorder[le[me]];
                      const et = We.borders[ue];
                      if (et[1] > He[0] + 3 || et[0] > He[0] - 3) break;
                      (ae.showCentroid(We), me++);
                    }
                    if (We && me < le.length) {
                      const et = me;
                      let Ce = 0;
                      for (
                        ;
                        !(We.borders[ue][0] > He[1] - 3) &&
                        (Ce++, ++me !== le.length);

                      )
                        We = ae.featuresOnBorder[le[me]];
                      We = ae.featuresOnBorder[le[et]];
                      let Ve = !1;
                      if (Ce >= 1) {
                        const Oe = We.borders[ue];
                        Math.abs(He[0] - Oe[0]) < 3 &&
                          Math.abs(He[1] - Oe[1]) < 3 &&
                          ((Ce = 1), (Ve = !0), (me = et + 1));
                      } else if (Ce === 0) {
                        h.showCentroid(De);
                        continue;
                      }
                      const Te = ae.centroidData[We.centroidDataIndex];
                      x &&
                        Ve &&
                        (((U = ze).flags | ($ = Te).flags) & r.dW
                          ? ((U.flags |= r.dW), ($.flags |= r.dW))
                          : ((U.flags &= 2147483647), ($.flags &= 2147483647)));
                      const Ze =
                        De.intersectsCount() > 1 || We.intersectsCount() > 1;
                      if (Ce > 1)
                        ((me = et),
                          (ze.centroidXY = Te.centroidXY = new r.P(0, 0)));
                      else if (pe && pe.dem && !Ze) {
                        const Oe = O[Z](ze, Te),
                          Ke = Z % 2 ? r.aj - 1 : 0,
                          ht = G(
                            Oe[0],
                            Math.min(r.aj - 1, Oe[1]),
                            Ke,
                            pe,
                            ie,
                            Z < 2,
                            Oe[2],
                          );
                        ze.centroidXY = Te.centroidXY = S(ht);
                      } else
                        Ze
                          ? (ze.centroidXY = Te.centroidXY = new r.P(0, 0))
                          : ((ze.centroidXY = h.encodeBorderCentroid(De)),
                            (Te.centroidXY = ae.encodeBorderCentroid(We)));
                      (h.writeCentroidToBuffer(ze),
                        ae.writeCentroidToBuffer(Te));
                    } else h.showCentroid(De);
                  }
                  ((h.borderDoneWithNeighborZ[Z] = ae.canonical.z),
                    (ae.borderDoneWithNeighborZ[ue] = h.canonical.z));
                }
                var U, $;
                (h.needsCentroidUpdate ||
                  (!h.centroidVertexBuffer &&
                    h.centroidVertexArray.length !== 0)) &&
                  h.uploadCentroid(c);
              }
              const Kp = [1, 0, 0],
                Jp = [0, 1, 0],
                No = [0, 0, 1];
              function Vo(c, t, s) {
                const h = s.transform,
                  p = s.shadowRenderer;
                if (!p) return !0;
                const g = c.toUnwrapped(),
                  x = h.tileSize * p._cascades[s.currentShadowCascade].scale;
                let w = t.maxHeight;
                if (h.elevation) {
                  const U = h.elevation.getMinMaxForTile(c);
                  U && (w += U.max);
                }
                const S = [...p.shadowDirection];
                S[2] = -S[2];
                const C = p.computeSimplifiedTileShadowVolume(g, w, x, S);
                if (!C) return !1;
                const D = [Kp, Jp, No, S, [S[0], 0, S[2]], [0, S[1], S[2]]],
                  L = h.projection.name === "globe",
                  z = h.scaleZoom(x),
                  O = r.cn.fromInvProjectionMatrix(
                    h.invProjMatrix,
                    h.worldSize,
                    z,
                    !L,
                  ),
                  G = p.getCurrentCascadeFrustum();
                return (
                  O.intersectsPrecise(C.vertices, C.planes, D) === 0 ||
                  G.intersectsPrecise(C.vertices, C.planes, D) === 0
                );
              }
              function Ut(c) {
                return [c[0] * r.dZ, c[1] * r.dZ, c[2] * r.dZ, 0];
              }
              function Oc(c, t, s, h, p, g, x, w, S) {
                const C = h.getSource(),
                  D = s.globeSharedBuffers;
                if (!D) return;
                let L, z, O;
                if (
                  (t && (L = h.getTile(t)),
                  C instanceof r.aP
                    ? ((z = C.texture), (O = r.ds(0, 0, s.transform)))
                    : L &&
                      t &&
                      ((z = L.texture),
                      (O = r.ds(t.canonical.z, t.canonical.x, s.transform))),
                  !z || !O)
                )
                  return;
                c || (O = r.cE(r.bz(), O, [1, -1, 1]));
                const G = s.context,
                  U = G.gl,
                  $ =
                    p.paint.get("raster-resampling") === "nearest"
                      ? U.NEAREST
                      : U.LINEAR,
                  Z = s.colorModeForDrapableLayerRenderPass(g),
                  Y = x.defines;
                Y.push("GLOBE_POLES");
                const ie = new wt(U.LEQUAL, wt.ReadWrite, s.depthRangeFor3D),
                  ae = Float32Array.from(s.transform.expandedFarZProjMatrix),
                  pe = Float32Array.from(r.bh(r.dr(new r.cp(0, 0, 0))));
                (s.terrain && s.terrain.prepareDrawTile(),
                  G.activeTexture.set(U.TEXTURE0),
                  z.bind($, U.CLAMP_TO_EDGE),
                  G.activeTexture.set(U.TEXTURE1),
                  z.bind($, U.CLAMP_TO_EDGE),
                  "useMipmap" in z &&
                    G.extTextureFilterAnisotropic &&
                    s.transform.pitch > 20 &&
                    U.texParameterf(
                      U.TEXTURE_2D,
                      G.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT,
                      G.extTextureFilterAnisotropicMax,
                    ));
                const [ue, ce, le, me] = t
                    ? D.getPoleBuffers(t.canonical.z, !1)
                    : D.getPoleBuffers(0, !0),
                  _e = p.paint.get("raster-elevation");
                let De;
                c
                  ? ((De = ue), (s.renderDefaultNorthPole = _e !== 0))
                  : ((De = ce), (s.renderDefaultSouthPole = _e !== 0));
                const ze = Ut(x.mix),
                  He = ((et, Ce, Ve, Te, Ze, Oe, Ke, ht, qe, lt, St, Et, bt) =>
                    zd(
                      et,
                      Ce,
                      Ve,
                      new Float32Array(16),
                      new Float32Array(9),
                      [0, 0],
                      Te,
                      [0, 0],
                      [0, 0, 0, 0],
                      1,
                      { opacity: 1, mix: 0 },
                      Oe,
                      [0, 0],
                      ht,
                      2,
                      lt,
                      St,
                      Et,
                      1,
                      0,
                      bt,
                    ))(
                    ae,
                    pe,
                    O,
                    r.ah(s.transform.zoom),
                    0,
                    p,
                    0,
                    _e,
                    0,
                    ze,
                    x.offset,
                    x.range,
                    g,
                  ),
                  We = s.getOrCreateProgram("raster", { defines: Y });
                (s.uploadCommonUniforms(G, We, null),
                  We.draw(s, U.TRIANGLES, ie, S, Z, w, He, p.id, De, le, me));
              }
              function L_(c) {
                const t = c._nearZ,
                  s = c.projection.farthestPixelDistance(c),
                  h = s - t,
                  p = 0.2 * c.height,
                  g = t + p;
                return [t, s, (g - p - t) / h, (g - t) / h];
              }
              function O_(c, t, s, h) {
                if (c)
                  return t instanceof Po && c instanceof tl
                    ? t.getTextureDescriptor(c, s, !0)
                    : {
                        texture: c.texture,
                        mix: Ut(h.mix),
                        offset: h.offset,
                        buffer: 0,
                        tileSize: 1,
                      };
              }
              var Nd = r.d_([
                { name: "a_index", type: "Int16", components: 1 },
              ]);
              class Qp {
                constructor(t, s, h, p) {
                  const g = { width: h[0], height: h[1], data: null },
                    x = t.gl;
                  ((this.targetColorTexture = new r.T(t, g, x.RGBA8, {
                    useMipmap: !1,
                  })),
                    (this.backgroundColorTexture = new r.T(t, g, x.RGBA8, {
                      useMipmap: !1,
                    })),
                    (this.context = t),
                    this.updateParticleTexture(s, p),
                    (this.lastInvalidatedAt = 0));
                }
                updateParticleTexture(t, s) {
                  if (this.particleTextureDimension === s.width) return;
                  (this.particleTexture0 ||
                    this.particleTexture1 ||
                    this.particleIndexBuffer ||
                    this.particleSegment) &&
                    (this.particleTexture0.destroy(),
                    this.particleTexture1.destroy(),
                    this.particleIndexBuffer.destroy(),
                    this.particleSegment.destroy());
                  const h = this.context.gl,
                    p = s.width * s.height;
                  ((this.particleTexture0 = new r.T(this.context, s, h.RGBA8, {
                    premultiply: !1,
                    useMipmap: !1,
                  })),
                    (this.particleTexture1 = new r.T(this.context, s, h.RGBA8, {
                      premultiply: !1,
                      useMipmap: !1,
                    })));
                  const g = new r.d$();
                  g.reserve(p);
                  for (let x = 0; x < p; x++) g.emplaceBack(x);
                  ((this.particleIndexBuffer = this.context.createVertexBuffer(
                    g,
                    Nd.members,
                    !0,
                  )),
                    (this.particleSegment = r.bd.simpleSegment(
                      0,
                      0,
                      this.particleIndexBuffer.length,
                      0,
                    )),
                    (this.particleTextureDimension = s.width));
                }
                update(t) {
                  return !(
                    this.lastInvalidatedAt < t &&
                    ((this.lastInvalidatedAt = r.q.now()), 1)
                  );
                }
                destroy() {
                  (this.targetColorTexture.destroy(),
                    this.backgroundColorTexture.destroy(),
                    this.particleIndexBuffer.destroy(),
                    this.particleTexture0.destroy(),
                    this.particleTexture1.destroy(),
                    this.particleSegment.destroy());
                }
              }
              function F_(c, t, s) {
                if (!c) return null;
                const h = t.getTextureDescriptor(c, s, !0);
                if (!h) return null;
                let {
                  texture: p,
                  mix: g,
                  offset: x,
                  tileSize: w,
                  buffer: S,
                  format: C,
                } = h;
                if (!p || !C) return null;
                let D = !1;
                return (
                  C === "uint32" &&
                    ((D = !0),
                    (g[3] = 0),
                    (g = Ma(r.e0, g, [
                      0,
                      s.paint.get("raster-particle-max-speed"),
                    ])),
                    (x = Rd(r.e0, x, [
                      0,
                      s.paint.get("raster-particle-max-speed"),
                    ]))),
                  {
                    texture: p,
                    textureOffset: [S / (w + 2 * S), w / (w + 2 * S)],
                    tileSize: w,
                    scalarData: D,
                    scale: g,
                    offset: x,
                    defines: [
                      "RASTER_ARRAY",
                      {
                        uint8: "DATA_FORMAT_UINT8",
                        uint16: "DATA_FORMAT_UINT16",
                        uint32: "DATA_FORMAT_UINT32",
                      }[C],
                    ],
                  }
                );
              }
              function em(c) {
                const t = c._nearZ,
                  s = c.projection.farthestPixelDistance(c),
                  h = s - t,
                  p = 0.2 * c.height,
                  g = t + p;
                return [t, s, (g - p - t) / h, (g - t) / h];
              }
              const B_ = new r.am(1, 0, 0, 1),
                N_ = new r.am(0, 1, 0, 1),
                Qr = new r.am(0, 0, 1, 1),
                Vd = new r.am(1, 0, 1, 1),
                kr = new r.am(0, 1, 1, 1);
              function uo(c, t, s, h, p, g) {
                for (let x = 0; x < s.length; x++)
                  if (p) {
                    const C = new r.am(h.r * 0.8, h.g * 0.8, h.b * 0.8, 1);
                    (Pa(c, t, s[x], h, -1, -1, g),
                      Pa(c, t, s[x], h, -1, 1, g),
                      Pa(c, t, s[x], h, 1, 1, g),
                      Pa(c, t, s[x], h, 1, -1, g),
                      Pa(c, t, s[x], C, 0, 0, g));
                  } else Pa(c, t, s[x], h, 0, 0, g);
              }
              function Pa(c, t, s, h, p, g, x) {
                const w = c.context,
                  S = c.transform,
                  C = w.gl,
                  D = S.projection.name === "globe",
                  L = D ? ["PROJECTION_GLOBE_VIEW"] : [];
                let z = r.bw(s.projMatrix);
                if (D && r.ah(S.zoom) > 0) {
                  const ze = r.bg(s.canonical, S),
                    He = r.e1(ze);
                  ((z = r.az(new Float32Array(16), S.globeMatrix, He)),
                    r.az(z, S.projMatrix, z));
                }
                const O = r.bz();
                ((O[12] += (2 * p) / (r.q.devicePixelRatio * S.width)),
                  (O[13] += (2 * g) / (r.q.devicePixelRatio * S.height)),
                  r.az(z, O, z));
                const G = c.getOrCreateProgram("debug", { defines: L }),
                  U = t.getTileByID(s.key);
                c.terrain && c.terrain.setupElevationDraw(U, G);
                const $ = wt.disabled,
                  Z = Yt.disabled,
                  Y = c.colorModeForRenderPass(),
                  ie = "$debug";
                (w.activeTexture.set(C.TEXTURE0),
                  c.emptyTexture.bind(C.LINEAR, C.CLAMP_TO_EDGE),
                  D
                    ? U._makeGlobeTileDebugBuffers(c.context, S)
                    : U._makeDebugTileBoundsBuffers(c.context, S.projection));
                const ae = U._tileDebugBuffer || c.debugBuffer,
                  pe = U._tileDebugIndexBuffer || c.debugIndexBuffer,
                  ue = U._tileDebugSegments || c.debugSegments;
                if (
                  (G.draw(
                    c,
                    C.LINE_STRIP,
                    $,
                    Z,
                    Y,
                    Gt.disabled,
                    nu(z, h.toPremultipliedRenderColor(null)),
                    ie,
                    ae,
                    pe,
                    ue,
                    null,
                    null,
                    null,
                    [U._globeTileDebugBorderBuffer],
                  ),
                  x)
                ) {
                  const ze = U.latestRawTileData,
                    He = Math.floor(((ze && ze.byteLength) || 0) / 1024);
                  let We = s.canonical.toString();
                  (s.overscaledZ !== s.canonical.z &&
                    (We += ` => ${s.overscaledZ}`),
                    (We += ` ${U.state}`),
                    (We += ` ${He}kb`),
                    (function (et, Ce) {
                      et.initDebugOverlayCanvas();
                      const Ve = et.debugOverlayCanvas,
                        Te = et.context.gl,
                        Ze = et.debugOverlayCanvas.getContext("2d");
                      (Ze.clearRect(0, 0, Ve.width, Ve.height),
                        (Ze.shadowColor = "white"),
                        (Ze.shadowBlur = 2),
                        (Ze.lineWidth = 1.5),
                        (Ze.strokeStyle = "white"),
                        (Ze.textBaseline = "top"),
                        (Ze.font = "bold 36px Open Sans, sans-serif"),
                        Ze.fillText(Ce, 5, 5),
                        Ze.strokeText(Ce, 5, 5),
                        et.debugOverlayTexture.update(Ve),
                        et.debugOverlayTexture.bind(
                          Te.LINEAR,
                          Te.CLAMP_TO_EDGE,
                        ));
                    })(c, We));
                }
                const ce = t.getTile(s).tileSize,
                  le =
                    (512 / Math.min(ce, 512)) * (s.overscaledZ / S.zoom) * 0.5,
                  me = U._tileDebugTextBuffer || c.debugBuffer,
                  _e = U._tileDebugTextIndexBuffer || c.quadTriangleIndexBuffer,
                  De = U._tileDebugTextSegments || c.debugSegments;
                G.draw(
                  c,
                  C.TRIANGLES,
                  $,
                  Z,
                  ui.alphaBlended,
                  Gt.disabled,
                  nu(z, r.am.transparent.toPremultipliedRenderColor(null), le),
                  ie,
                  me,
                  _e,
                  De,
                  null,
                  null,
                  null,
                  [U._globeTileDebugTextBuffer],
                );
              }
              function au(c, t, s, h) {
                Tl(c, 0, t + s / 2, c.transform.width, s, h);
              }
              function lu(c, t, s, h) {
                Tl(c, t - s / 2, 0, s, c.transform.height, h);
              }
              function Tl(c, t, s, h, p, g) {
                const x = c.context,
                  w = x.gl;
                (w.enable(w.SCISSOR_TEST),
                  w.scissor(
                    t * r.q.devicePixelRatio,
                    s * r.q.devicePixelRatio,
                    h * r.q.devicePixelRatio,
                    p * r.q.devicePixelRatio,
                  ),
                  x.clear({ color: g }),
                  w.disable(w.SCISSOR_TEST));
              }
              const tm = r.d_([
                  { name: "a_pos_3f", components: 3, type: "Float32" },
                ]),
                { members: fo } = tm;
              function qi(c, t, s, h) {
                c.emplaceBack(t, s, h);
              }
              class Fc {
                constructor(t) {
                  ((this.vertexArray = new r.e2()),
                    (this.indices = new r.a_()),
                    qi(this.vertexArray, -1, -1, 1),
                    qi(this.vertexArray, 1, -1, 1),
                    qi(this.vertexArray, -1, 1, 1),
                    qi(this.vertexArray, 1, 1, 1),
                    qi(this.vertexArray, -1, -1, -1),
                    qi(this.vertexArray, 1, -1, -1),
                    qi(this.vertexArray, -1, 1, -1),
                    qi(this.vertexArray, 1, 1, -1),
                    this.indices.emplaceBack(5, 1, 3),
                    this.indices.emplaceBack(3, 7, 5),
                    this.indices.emplaceBack(6, 2, 0),
                    this.indices.emplaceBack(0, 4, 6),
                    this.indices.emplaceBack(2, 6, 7),
                    this.indices.emplaceBack(7, 3, 2),
                    this.indices.emplaceBack(5, 4, 0),
                    this.indices.emplaceBack(0, 1, 5),
                    this.indices.emplaceBack(0, 2, 3),
                    this.indices.emplaceBack(3, 1, 0),
                    this.indices.emplaceBack(7, 6, 4),
                    this.indices.emplaceBack(4, 5, 7),
                    (this.vertexBuffer = t.createVertexBuffer(
                      this.vertexArray,
                      fo,
                    )),
                    (this.indexBuffer = t.createIndexBuffer(this.indices)),
                    (this.segment = r.bd.simpleSegment(0, 0, 36, 12)));
                }
              }
              function Uo(c, t, s, h, p, g) {
                const x = c.context.gl,
                  w = t.paint.get("sky-atmosphere-color"),
                  S = t.paint.get("sky-atmosphere-halo-color"),
                  C = t.paint.get("sky-atmosphere-sun-intensity"),
                  D = ((L, z, O, G, U) => ({
                    u_matrix_3f: L,
                    u_sun_direction: z,
                    u_sun_intensity: O,
                    u_color_tint_r: [G.r, G.g, G.b, G.a],
                    u_color_tint_m: [U.r, U.g, U.b, U.a],
                    u_luminance: 5e-5,
                  }))(
                    r.e4(r.dx(), h),
                    p,
                    C,
                    w.toPremultipliedRenderColor(null),
                    S.toPremultipliedRenderColor(null),
                  );
                (x.framebufferTexture2D(
                  x.FRAMEBUFFER,
                  x.COLOR_ATTACHMENT0,
                  x.TEXTURE_CUBE_MAP_POSITIVE_X + g,
                  t.skyboxTexture,
                  0,
                ),
                  s.draw(
                    c,
                    x.TRIANGLES,
                    wt.disabled,
                    Yt.disabled,
                    ui.unblended,
                    Gt.frontCW,
                    D,
                    "skyboxCapture",
                    t.skyboxGeometry.vertexBuffer,
                    t.skyboxGeometry.indexBuffer,
                    t.skyboxGeometry.segment,
                  ));
              }
              const im = r.d_([
                { type: "Float32", name: "a_pos", components: 3 },
                { type: "Float32", name: "a_uv", components: 2 },
              ]);
              class nm {
                constructor(t) {
                  const s = new r.e5();
                  (s.emplaceBack(-1, 1, 1, 0, 0),
                    s.emplaceBack(1, 1, 1, 1, 0),
                    s.emplaceBack(1, -1, 1, 1, 1),
                    s.emplaceBack(-1, -1, 1, 0, 1));
                  const h = new r.a_();
                  (h.emplaceBack(0, 1, 2),
                    h.emplaceBack(2, 3, 0),
                    (this.vertexBuffer = t.createVertexBuffer(s, im.members)),
                    (this.indexBuffer = t.createIndexBuffer(h)),
                    (this.segments = r.bd.simpleSegment(0, 0, 4, 2)));
                }
                destroy() {
                  (this.vertexBuffer.destroy(),
                    this.indexBuffer.destroy(),
                    this.segments.destroy());
                }
              }
              const rm = r.d_([
                { type: "Float32", name: "a_pos_3f", components: 3 },
                { type: "Float32", name: "a_uv", components: 2 },
                { type: "Float32", name: "a_size_scale", components: 1 },
                { type: "Float32", name: "a_fade_opacity", components: 1 },
              ]);
              class V_ {
                constructor() {
                  ((this.starsCount = 16e3),
                    (this.sizeMultiplier = 0.15),
                    (this.sizeRange = 100),
                    (this.intensityRange = 200));
                }
              }
              class Sl {
                constructor(t) {
                  ((this.colorModeAlphaBlendedWriteRGB = new ui(
                    [1, ba, 1, ba],
                    r.am.transparent,
                    [!0, !0, !0, !1],
                  )),
                    (this.colorModeWriteAlpha = new ui(
                      [1, 0, 1, 0],
                      r.am.transparent,
                      [!1, !1, !1, !0],
                    )),
                    (this.params = new V_()),
                    (this.updateNeeded = !0),
                    t.tp.registerParameter(
                      this.params,
                      ["Stars"],
                      "starsCount",
                      { min: 100, max: 16e3, step: 1 },
                      () => {
                        this.updateNeeded = !0;
                      },
                    ),
                    t.tp.registerParameter(
                      this.params,
                      ["Stars"],
                      "sizeMultiplier",
                      { min: 0.01, max: 2, step: 0.01 },
                    ),
                    t.tp.registerParameter(
                      this.params,
                      ["Stars"],
                      "sizeRange",
                      { min: 0, max: 200, step: 1 },
                      () => {
                        this.updateNeeded = !0;
                      },
                    ),
                    t.tp.registerParameter(
                      this.params,
                      ["Stars"],
                      "intensityRange",
                      { min: 0, max: 200, step: 1 },
                      () => {
                        this.updateNeeded = !0;
                      },
                    ));
                }
                update(t) {
                  const s = t.context;
                  if (!this.atmosphereBuffer || this.updateNeeded) {
                    ((this.updateNeeded = !1),
                      (this.atmosphereBuffer = new nm(s)));
                    const h = this.params.sizeRange,
                      p = this.params.intensityRange,
                      g = (function (D) {
                        const L = r.e7(30),
                          z = [];
                        for (let O = 0; O < D; ++O) {
                          const G = 2 * Math.PI * L(),
                            U = Math.acos(1 - 2 * L()) - 0.5 * Math.PI;
                          z.push(
                            r.cS(
                              Math.cos(U) * Math.cos(G),
                              Math.cos(U) * Math.sin(G),
                              Math.sin(U),
                            ),
                          );
                        }
                        return z;
                      })(this.params.starsCount),
                      x = r.e7(300),
                      w = new r.e6(),
                      S = new r.a_();
                    let C = 0;
                    for (let D = 0; D < g.length; ++D) {
                      const L = r.bY([], g[D], 200),
                        z = Math.max(0, 1 + 0.01 * h * (1 * x() - 0.5)),
                        O = Math.max(0, 1 + 0.01 * p * (1 * x() - 0.5));
                      (w.emplaceBack(L[0], L[1], L[2], -1, -1, z, O),
                        w.emplaceBack(L[0], L[1], L[2], 1, -1, z, O),
                        w.emplaceBack(L[0], L[1], L[2], 1, 1, z, O),
                        w.emplaceBack(L[0], L[1], L[2], -1, 1, z, O),
                        S.emplaceBack(C + 0, C + 1, C + 2),
                        S.emplaceBack(C + 0, C + 2, C + 3),
                        (C += 4));
                    }
                    ((this.starsVx = s.createVertexBuffer(w, rm.members)),
                      (this.starsIdx = s.createIndexBuffer(S)),
                      (this.starsSegments = r.bd.simpleSegment(
                        0,
                        0,
                        w.length,
                        S.length,
                      )));
                  }
                }
                destroy() {
                  (this.atmosphereBuffer && this.atmosphereBuffer.destroy(),
                    this.starsVx && this.starsVx.destroy(),
                    this.starsIdx && this.starsIdx.destroy());
                }
                drawAtmosphereGlow(t, s) {
                  const h = t.context,
                    p = h.gl,
                    g = t.transform,
                    x = new wt(p.LEQUAL, wt.ReadOnly, [0, 1]),
                    w = r.ah(g.zoom),
                    S = t.style.getLut(s.scope),
                    C = s.properties.get("color-use-theme") === "none",
                    D = s.properties
                      .get("color")
                      .toNonPremultipliedRenderColor(C ? null : S)
                      .toArray01(),
                    L = s.properties.get("high-color-use-theme") === "none",
                    z = s.properties
                      .get("high-color")
                      .toNonPremultipliedRenderColor(L ? null : S)
                      .toArray01(),
                    O = s.properties.get("space-color-use-theme") === "none",
                    G = s.properties
                      .get("space-color")
                      .toNonPremultipliedRenderColor(O ? null : S)
                      .toArray01(),
                    U = 5e-4,
                    $ = r.e8(s.properties.get("horizon-blend"), 0, 1, U, 0.25),
                    Z =
                      r.dl(t, h, g) && $ === U
                        ? g.worldSize / (2 * Math.PI * 1.025) - 1
                        : g.globeRadius,
                    Y = (t.frameCounter / 1e3) % 1,
                    ie = r.ae(g.globeCenterInViewSpace),
                    ae = Math.sqrt(Math.pow(ie, 2) - Math.pow(Z, 2)),
                    pe = Math.acos(ae / ie),
                    ue = (ce) => {
                      const le =
                        g.projection.name === "globe"
                          ? ["PROJECTION_GLOBE_VIEW", "FOG"]
                          : ["FOG"];
                      ce && le.push("ALPHA_PASS");
                      const me = t.getOrCreateProgram("globeAtmosphere", {
                          defines: le,
                        }),
                        _e = ((
                          ze,
                          He,
                          We,
                          et,
                          Ce,
                          Ve,
                          Te,
                          Ze,
                          Oe,
                          Ke,
                          ht,
                          qe,
                        ) => ({
                          u_frustum_tl: ze,
                          u_frustum_tr: He,
                          u_frustum_br: We,
                          u_frustum_bl: et,
                          u_horizon: Ce,
                          u_transition: Ve,
                          u_fadeout_range: Te,
                          u_color: Ze,
                          u_high_color: Oe,
                          u_space_color: Ke,
                          u_temporal_offset: ht,
                          u_horizon_angle: qe,
                        }))(
                          g.frustumCorners.TL,
                          g.frustumCorners.TR,
                          g.frustumCorners.BR,
                          g.frustumCorners.BL,
                          g.frustumCorners.horizon,
                          w,
                          $,
                          D,
                          z,
                          G,
                          Y,
                          pe,
                        );
                      t.uploadCommonUniforms(h, me);
                      const De = this.atmosphereBuffer;
                      De &&
                        me.draw(
                          t,
                          p.TRIANGLES,
                          x,
                          Yt.disabled,
                          ce
                            ? this.colorModeWriteAlpha
                            : this.colorModeAlphaBlendedWriteRGB,
                          Gt.backCW,
                          _e,
                          ce ? "atmosphere_glow_alpha" : "atmosphere_glow",
                          De.vertexBuffer,
                          De.indexBuffer,
                          De.segments,
                        );
                    };
                  (ue(!1), ue(!0));
                }
                drawStars(t, s) {
                  const h = r.ay(s.properties.get("star-intensity"), 0, 1);
                  if (h === 0) return;
                  const p = t.context,
                    g = p.gl,
                    x = t.transform,
                    w = t.getOrCreateProgram("stars"),
                    S = r.b_([]);
                  (r.c0(S, S, -x._pitch),
                    r.b$(S, S, -x.angle),
                    r.c0(S, S, r.al(x._center.lat)),
                    r.e9(S, S, -r.al(x._center.lng)));
                  const C = r.c3(new Float32Array(16), S),
                    D = r.az([], x.starsProjMatrix, C),
                    L = r.e4([], C),
                    z = r.ea([], L),
                    O = [0, 1, 0];
                  (r.dz(O, O, z), r.bY(O, O, this.params.sizeMultiplier));
                  const G = [1, 0, 0];
                  (r.dz(G, G, z), r.bY(G, G, this.params.sizeMultiplier));
                  const U =
                    (($ = O),
                    (Z = G),
                    (Y = h),
                    {
                      u_matrix: Float32Array.from(D),
                      u_up: $,
                      u_right: Z,
                      u_intensity_multiplier: Y,
                    });
                  var $, Z, Y;
                  (t.uploadCommonUniforms(p, w),
                    this.starsVx &&
                      this.starsIdx &&
                      w.draw(
                        t,
                        g.TRIANGLES,
                        wt.disabled,
                        Yt.disabled,
                        this.colorModeAlphaBlendedWriteRGB,
                        Gt.disabled,
                        U,
                        "atmosphere_stars",
                        this.starsVx,
                        this.starsIdx,
                        this.starsSegments,
                      ));
                }
              }
              function Da(c, t) {
                const s = [...c],
                  h = t.cameraWorldSizeForFog / t.worldSize,
                  p = r.bx([]);
                return (
                  r.cE(p, p, [h, h, 1]),
                  r.az(s, p, s),
                  r.az(s, t.worldToFogMatrix, s),
                  s
                );
              }
              function st(c, t, s, h, p) {
                const g = s.material,
                  x = h.context,
                  { baseColorTexture: w, metallicRoughnessTexture: S } =
                    g.pbrMetallicRoughness,
                  {
                    normalTexture: C,
                    occlusionTexture: D,
                    emissionTexture: L,
                  } = g;
                function z(G, U, $) {
                  if (
                    G &&
                    (c.push(U),
                    x.activeTexture.set(x.gl.TEXTURE0 + $),
                    G.gfxTexture)
                  ) {
                    const {
                      minFilter: Z,
                      magFilter: Y,
                      wrapS: ie,
                      wrapT: ae,
                    } = G.sampler;
                    G.gfxTexture.bindExtraParam(Z, Y, ie, ae);
                  }
                }
                (z(w, "HAS_TEXTURE_u_baseColorTexture", zr.BaseColor),
                  z(
                    S,
                    "HAS_TEXTURE_u_metallicRoughnessTexture",
                    zr.MetallicRoughness,
                  ),
                  z(C, "HAS_TEXTURE_u_normalTexture", zr.Normal),
                  z(D, "HAS_TEXTURE_u_occlusionTexture", zr.Occlusion),
                  z(L, "HAS_TEXTURE_u_emissionTexture", zr.Emission),
                  p &&
                    (p.texture ||
                      (p.texture = new r.eh(
                        h.context,
                        p.image,
                        [p.image.height, p.image.height, p.image.height],
                        x.gl.RGBA8,
                      )),
                    x.activeTexture.set(x.gl.TEXTURE0 + zr.LUT),
                    p.texture &&
                      p.texture.bind(x.gl.LINEAR, x.gl.CLAMP_TO_EDGE),
                    c.push("APPLY_LUT_ON_GPU")),
                  s.texcoordBuffer &&
                    (c.push("HAS_ATTRIBUTE_a_uv_2f"), t.push(s.texcoordBuffer)),
                  s.colorBuffer &&
                    (c.push(
                      s.colorBuffer.itemSize === 12
                        ? "HAS_ATTRIBUTE_a_color_3f"
                        : "HAS_ATTRIBUTE_a_color_4f",
                    ),
                    t.push(s.colorBuffer)),
                  s.normalBuffer &&
                    (c.push("HAS_ATTRIBUTE_a_normal_3f"),
                    t.push(s.normalBuffer)),
                  s.pbrBuffer &&
                    (c.push("HAS_ATTRIBUTE_a_pbr"),
                    c.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"),
                    t.push(s.pbrBuffer)),
                  (g.alphaMode !== "OPAQUE" && g.alphaMode !== "MASK") ||
                    c.push("UNPREMULT_TEXTURE_IN_SHADER"),
                  g.defined || c.push("DIFFUSE_SHADED"));
                const O = h.shadowRenderer;
                O &&
                  (c.push("RENDER_SHADOWS", "DEPTH_TEXTURE"),
                  O.useNormalOffset && c.push("NORMAL_OFFSET"));
              }
              function vt(c, t, s, h, p, g) {
                const x = s.paint.get("model-opacity").constantOr(1),
                  w = t.context,
                  S = new wt(
                    t.context.gl.LEQUAL,
                    wt.ReadWrite,
                    t.depthRangeFor3D,
                  ),
                  C = t.transform,
                  D = c.mesh,
                  L = D.material,
                  z = L.pbrMetallicRoughness,
                  O = t.style.fog;
                let G;
                ((G =
                  t.transform.projection.zAxisUnit === "pixels"
                    ? [...c.nodeModelMatrix]
                    : r.az([], h.zScaleMatrix, c.nodeModelMatrix)),
                  r.az(G, h.negCameraPosMatrix, G));
                const U = r.bi([], G);
                r.ee(U, U);
                const $ =
                    s.paint
                      .get("model-color-use-theme")
                      .constantOr("default") === "none",
                  Z = s.paint.get("model-emissive-strength").constantOr(0),
                  Y = zc(
                    new Float32Array(c.worldViewProjection),
                    new Float32Array(G),
                    new Float32Array(U),
                    null,
                    t,
                    x,
                    z.baseColorFactor,
                    L.emissiveFactor,
                    z.metallicFactor,
                    z.roughnessFactor,
                    L,
                    Z,
                    s,
                  ),
                  ie = { defines: [] },
                  ae = [],
                  pe = t.shadowRenderer;
                (pe && (pe.useNormalOffset = !1),
                  st(ie.defines, ae, D, t, $ ? null : s.lut));
                let ue = null;
                if (O) {
                  const me = Da(c.nodeModelMatrix, t.transform);
                  if (
                    ((ue = new Float32Array(me)), C.projection.name !== "globe")
                  ) {
                    const _e = D.aabb.min,
                      De = D.aabb.max,
                      [ze, He] = O.getOpacityForBounds(
                        me,
                        _e[0],
                        _e[1],
                        De[0],
                        De[1],
                      );
                    ie.overrideFog = ze >= Be || He >= Be;
                  }
                }
                const ce = Bs(t, s.paint.get("model-cutoff-fade-range"));
                ce.shouldRenderCutoff && ie.defines.push("RENDER_CUTOFF");
                const le = t.getOrCreateProgram("model", ie);
                (t.uploadCommonUniforms(w, le, null, ue, ce),
                  t.renderPass !== "shadow" &&
                    pe &&
                    pe.setupShadowsFromMatrix(c.nodeModelMatrix, le),
                  le.draw(
                    t,
                    w.gl.TRIANGLES,
                    S,
                    p,
                    g,
                    D.material.doubleSided ? Gt.disabled : Gt.backCCW,
                    Y,
                    s.id,
                    D.vertexBuffer,
                    D.indexBuffer,
                    D.segments,
                    s.paint,
                    t.transform.zoom,
                    void 0,
                    ae,
                  ));
              }
              function Ra(c, t, s, h, p, g, x) {
                let w;
                ((w = c.projection.name === "globe" ? r.ed(s, c) : [...s]),
                  r.az(w, w, t.matrix));
                const S = r.az([], h, w);
                if (t.meshes)
                  for (const C of t.meshes) {
                    if (C.material.alphaMode !== "BLEND") {
                      x.push({
                        mesh: C,
                        depth: 0,
                        modelIndex: p,
                        worldViewProjection: S,
                        nodeModelMatrix: w,
                      });
                      continue;
                    }
                    const D = r.ad([], C.centroid, S);
                    (!c.isOrthographic && D[2] <= 0) ||
                      g.push({
                        mesh: C,
                        depth: D[2],
                        modelIndex: p,
                        worldViewProjection: S,
                        nodeModelMatrix: w,
                      });
                  }
                if (t.children)
                  for (const C of t.children) Ra(c, C, s, h, p, g, x);
              }
              function Cn(c, t, s, h) {
                const p = s.shadowRenderer;
                if (!p) return;
                const g = p.getShadowPassDepthMode(),
                  x = p.getShadowPassColorMode(),
                  w = p.calculateShadowPassMatrixFromMatrix(t),
                  S = Zp(w);
                s.getOrCreateProgram("modelDepth", {
                  defines: s._shadowMapDebug ? [] : ["DEPTH_TEXTURE"],
                }).draw(
                  s,
                  s.context.gl.TRIANGLES,
                  g,
                  Yt.disabled,
                  x,
                  Gt.backCCW,
                  S,
                  h.id,
                  c.vertexBuffer,
                  c.indexBuffer,
                  c.segments,
                  h.paint,
                  s.transform.zoom,
                  void 0,
                  void 0,
                );
              }
              function Pe(c, t, s) {
                const h = t.updateZoomBasedPaintProperties(),
                  p = (function (g, x, w) {
                    let S,
                      C,
                      D,
                      L = g.terrain ? g.terrain.exaggeration() : 0;
                    if (g.terrain && L > 0) {
                      const z = g.terrain,
                        O = z.findDEMTileFor(w);
                      O && O.dem ? (S = r.ei.create(z, w, O)) : (L = 0);
                    }
                    if (
                      (L === 0 &&
                        ((x.terrainElevationMin = 0),
                        (x.terrainElevationMax = 0)),
                      L === x.validForExaggeration &&
                        (L === 0 ||
                          (S &&
                            S._demTile &&
                            S._demTile.tileID === x.validForDEMTile.id &&
                            S._dem._timestamp === x.validForDEMTile.timestamp)))
                    )
                      return !1;
                    for (const z in x.instancesPerModel) {
                      const O = x.instancesPerModel[z];
                      for (let G = 0; G < O.instancedDataArray.length; ++G) {
                        const U =
                          (S
                            ? L *
                              S.getElevationAt(
                                0 | O.instancedDataArray.float32[16 * G],
                                0 | O.instancedDataArray.float32[16 * G + 1],
                                !0,
                                !0,
                              )
                            : 0) + O.instancesEvaluatedElevation[G];
                        ((O.instancedDataArray.float32[16 * G + 6] = U),
                          (C = C ? Math.min(x.terrainElevationMin, U) : U),
                          (D = D ? Math.max(x.terrainElevationMax, U) : U));
                      }
                    }
                    return (
                      (x.terrainElevationMin = C || 0),
                      (x.terrainElevationMax = D || 0),
                      (x.validForExaggeration = L),
                      (x.validForDEMTile =
                        S && S._demTile
                          ? {
                              id: S._demTile.tileID,
                              timestamp: S._dem._timestamp,
                            }
                          : { id: void 0, timestamp: 0 }),
                      !0
                    );
                  })(c, t, s);
                (h || p) && ((t.uploaded = !1), t.upload(c.context));
              }
              const Ds = {
                shadowUniformsInitialized: !1,
                useSingleShadowCascade: !1,
                tileMatrix: new Float64Array(16),
                shadowTileMatrix: new Float32Array(16),
                aabb: new r.cW([0, 0, 0], [r.aj, r.aj, 0]),
              };
              function cu(c, t) {
                const s = 1 << c.canonical.z,
                  h = t.getFreeCameraOptions().position,
                  p = t.elevation,
                  g = c.canonical.x / s,
                  x = (c.canonical.x + 1) / s,
                  w = c.canonical.y / s,
                  S = (c.canonical.y + 1) / s;
                let C = t._centerAltitude;
                if (p) {
                  const O = p.getMinMaxForTile(c);
                  O && O.max > C && (C = O.max);
                }
                const D = r.ay(h.x, g, x) - h.x,
                  L = r.ay(h.y, w, S) - h.y,
                  z = r.c6(C, t.center.lat) - h.z;
                return t._zoomFromMercatorZ(Math.sqrt(D * D + L * L + z * z));
              }
              function hu(c, t, s, h, p, g, x) {
                const w = c.context,
                  S = c.renderPass === "shadow",
                  C = c.shadowRenderer,
                  D =
                    S && C
                      ? C.getShadowPassDepthMode()
                      : new wt(w.gl.LEQUAL, wt.ReadWrite, c.depthRangeFor3D),
                  L = c.isTileAffectedByFog(g);
                if (s.meshes)
                  for (const z of s.meshes) {
                    const O = ["MODEL_POSITION_ON_GPU"],
                      G = [];
                    let U, $, Z;
                    h.instancedDataArray.length > 20 &&
                      O.push("INSTANCED_ARRAYS");
                    const Y = Bs(c, t.paint.get("model-cutoff-fade-range"));
                    if (
                      (Y.shouldRenderCutoff && O.push("RENDER_CUTOFF"), S && C)
                    )
                      ((U = c.getOrCreateProgram("modelDepth", { defines: O })),
                        ($ = Zp(
                          x.shadowTileMatrix,
                          x.shadowTileMatrix,
                          Float32Array.from(s.matrix),
                        )),
                        (Z = C.getShadowPassColorMode()));
                    else {
                      (st(
                        O,
                        G,
                        z,
                        c,
                        t.paint
                          .get("model-color-use-theme")
                          .constantOr("default") === "none"
                          ? null
                          : t.lut,
                      ),
                        (U = c.getOrCreateProgram("model", {
                          defines: O,
                          overrideFog: L,
                        })));
                      const ae = z.material,
                        pe = ae.pbrMetallicRoughness,
                        ue = t.paint.get("model-opacity").constantOr(1),
                        ce = t.paint
                          .get("model-emissive-strength")
                          .constantOr(0);
                      (($ = zc(
                        g.expandedProjMatrix,
                        Float32Array.from(s.matrix),
                        new Float32Array(16),
                        null,
                        c,
                        ue,
                        pe.baseColorFactor,
                        ae.emissiveFactor,
                        pe.metallicFactor,
                        pe.roughnessFactor,
                        ae,
                        ce,
                        t,
                        p,
                      )),
                        C &&
                          (x.shadowUniformsInitialized
                            ? U.setShadowUniformValues(
                                w,
                                C.getShadowUniformValues(),
                              )
                            : (C.setupShadows(
                                g.toUnwrapped(),
                                U,
                                "model-tile",
                                g.overscaledZ,
                              ),
                              (x.shadowUniformsInitialized = !0))),
                        (Z =
                          Y.shouldRenderCutoff ||
                          ue < 1 ||
                          ae.alphaMode !== "OPAQUE"
                            ? ui.alphaBlended
                            : ui.unblended));
                    }
                    c.uploadCommonUniforms(w, U, g.toUnwrapped(), null, Y);
                    const ie = z.material.doubleSided
                      ? Gt.disabled
                      : Gt.backCCW;
                    if (h.instancedDataArray.length > 20)
                      (G.push(h.instancedDataBuffer),
                        U.draw(
                          c,
                          w.gl.TRIANGLES,
                          D,
                          Yt.disabled,
                          Z,
                          ie,
                          $,
                          t.id,
                          z.vertexBuffer,
                          z.indexBuffer,
                          z.segments,
                          t.paint,
                          c.transform.zoom,
                          void 0,
                          G,
                          h.instancedDataArray.length,
                        ));
                    else {
                      const ae = S ? "u_instance" : "u_normal_matrix";
                      for (let pe = 0; pe < h.instancedDataArray.length; ++pe)
                        (($[ae] = new Float32Array(
                          h.instancedDataArray.arrayBuffer,
                          64 * pe,
                          16,
                        )),
                          U.draw(
                            c,
                            w.gl.TRIANGLES,
                            D,
                            Yt.disabled,
                            Z,
                            ie,
                            $,
                            t.id,
                            z.vertexBuffer,
                            z.indexBuffer,
                            z.segments,
                            t.paint,
                            c.transform.zoom,
                            void 0,
                            G,
                          ));
                    }
                  }
                if (s.children)
                  for (const z of s.children) hu(c, t, z, h, p, g, x);
              }
              const Ud = [1, -1, 1];
              function sm(c, t, s, h) {
                if (!s.modelManager) return !0;
                const p = s.modelManager;
                if (!s.shadowRenderer) return !0;
                const g = s.shadowRenderer,
                  x = t.aabb;
                let w = !0,
                  S = c.maxHeight;
                if (S === 0) {
                  let D = 0;
                  for (const L in c.instancesPerModel) {
                    const z = p.getModel(L, h);
                    z
                      ? (D = Math.max(
                          D,
                          Math.max(
                            Math.max(z.aabb.max[0], z.aabb.max[1]),
                            z.aabb.max[2],
                          ),
                        ))
                      : (w = !1);
                  }
                  ((S = c.maxScale * D * 1.41 + c.maxVerticalOffset),
                    w && (c.maxHeight = S));
                }
                ((x.max[2] = S),
                  (x.min[2] += c.terrainElevationMin),
                  (x.max[2] += c.terrainElevationMax),
                  r.ad(x.min, x.min, t.tileMatrix),
                  r.ad(x.max, x.max, t.tileMatrix));
                const C = x.intersects(g.getCurrentCascadeFrustum());
                return (
                  s.currentShadowCascade === 0 &&
                    (c.isInsideFirstShadowMapFrustum = C === 2),
                  C === 0
                );
              }
              function om(c, t) {
                const s = c.uniformValues.u_cutoff_params[0],
                  h = c.uniformValues.u_cutoff_params[1],
                  p = c.uniformValues.u_cutoff_params[2],
                  g = c.uniformValues.u_cutoff_params[3];
                return h === s || g === p
                  ? 1
                  : r.ay(((t - s) / (h - s) - p) / (g - p), 0, 1);
              }
              function El(c, t, s, h) {
                if (t.pitch < 20) return 1;
                const p = t.getWorldToCameraMatrix();
                r.az(p, p, c);
                const g = r.ej(s.min[0], s.min[1], s.min[2], 1);
                let x = r.aA(r.ek(), g, p),
                  w = x,
                  S = x;
                ((g[1] = s.max[1]),
                  (x = r.aA(r.ek(), g, p)),
                  (w = x[1] < w[1] ? x : w),
                  (S = x[1] > S[1] ? x : S),
                  (g[0] = s.max[0]),
                  (x = r.aA(r.ek(), g, p)),
                  (w = x[1] < w[1] ? x : w),
                  (S = x[1] > S[1] ? x : S),
                  (g[1] = s.min[1]),
                  (x = r.aA(r.ek(), g, p)),
                  (w = x[1] < w[1] ? x : w),
                  (S = x[1] > S[1] ? x : S));
                const C = r.ay(h[0], 0, 1),
                  D = 100 * t.pixelsPerMeter * r.ay(h[1], 0, 1),
                  L = r.ay(h[2], 0, 1),
                  z = r.el(r.ek(), w, S, C),
                  O = Math.tan(0.5 * t.fovX),
                  G = -z[2] * O;
                if (D === 0) return z[1] < -Math.abs(G) ? L : 1;
                const U = (-Math.abs(G) - z[1]) / D,
                  $ = (Y, ie, ae) => (1 - ae) * Y + ae * ie,
                  Z = r.ay($(1, L, U), L, 1);
                return $(1, Z, r.ay((t.pitch - 20) / 20, 0, 1));
              }
              class U_ {}
              class j_ {
                constructor() {
                  this._storage = new Map();
                }
                getLinesFromTrianglesBuffer(t, s, h) {
                  {
                    const L = this._storage.get(s.id);
                    if (L) return ((L.lastUsedFrameIdx = t), L.buf);
                  }
                  const p = h.gl,
                    g = p.getBufferParameter(
                      p.ELEMENT_ARRAY_BUFFER,
                      p.BUFFER_SIZE,
                    ),
                    x = new ArrayBuffer(g),
                    w = new Int16Array(x);
                  p.getBufferSubData(
                    p.ELEMENT_ARRAY_BUFFER,
                    0,
                    new Int16Array(x),
                  );
                  const S = new r.en();
                  for (let L = 0; L < g / 2; L += 3) {
                    const z = w[L],
                      O = w[L + 1],
                      G = w[L + 2];
                    (S.emplaceBack(z, O),
                      S.emplaceBack(O, G),
                      S.emplaceBack(G, z));
                  }
                  const C = h.bindVertexArrayOES.current,
                    D = new U_();
                  return (
                    (D.buf = new vs(h, S)),
                    (D.lastUsedFrameIdx = t),
                    this._storage.set(s.id, D),
                    h.bindVertexArrayOES.set(C),
                    D.buf
                  );
                }
                update(t) {
                  for (const [s, h] of this._storage)
                    t - h.lastUsedFrameIdx > 30 &&
                      (h.buf.destroy(), this._storage.delete(s));
                }
                destroy() {
                  for (const [t, s] of this._storage)
                    (s.buf.destroy(), this._storage.delete(t));
                }
              }
              class am {
                constructor(t) {
                  ((this.occluderSize = 30),
                    (this.depthOffset = -1e-4),
                    t.registerParameter(this, ["Occlusion"], "occluderSize", {
                      min: 1,
                      max: 100,
                      step: 1,
                    }),
                    t.registerParameter(this, ["Occlusion"], "depthOffset", {
                      min: -0.05,
                      max: 0,
                      step: 1e-5,
                    }));
                }
              }
              const uu = r.d_([
                { type: "Float32", name: "a_pos_3f", components: 3 },
                { type: "Float32", name: "a_uv", components: 2 },
                { type: "Float32", name: "a_rainParticleData", components: 4 },
              ]);
              class jd {
                registerParameter() {}
                registerButton() {}
                registerBinding() {}
                refreshUI() {}
              }
              class Gd {
                constructor(t, s) {
                  ((this.revealStart = 11),
                    (this.revealRange = 2),
                    t.registerParameter(this, [...s, "Reveal"], "revealStart", {
                      min: 0,
                      max: 17,
                      step: 0.05,
                    }),
                    t.registerParameter(this, [...s, "Reveal"], "revealRange", {
                      min: 0.1,
                      max: 5.1,
                      step: 0.05,
                    }));
                }
              }
              const lm = r.d_([
                { type: "Float32", name: "a_pos_2f", components: 2 },
              ]);
              class du {
                destroy() {
                  (this.vignetteVx && this.vignetteVx.destroy(),
                    this.vignetteIdx && this.vignetteIdx.destroy());
                }
                draw(t, s) {
                  const h = t.getOrCreateProgram("vignette");
                  if (!this.vignetteVx || !this.vignetteIdx) {
                    const x = new r.eo(),
                      w = new r.a_();
                    (x.emplaceBack(-1, -1),
                      x.emplaceBack(1, -1),
                      x.emplaceBack(1, 1),
                      x.emplaceBack(-1, 1),
                      w.emplaceBack(0, 1, 2),
                      w.emplaceBack(0, 2, 3),
                      (this.vignetteVx = t.context.createVertexBuffer(
                        x,
                        lm.members,
                      )),
                      (this.vignetteIdx = t.context.createIndexBuffer(w)));
                  }
                  const p = r.bd.simpleSegment(0, 0, 4, 6);
                  if (this.vignetteVx && this.vignetteIdx) {
                    t.uploadCommonUniforms(t.context, h);
                    const x = {
                      u_vignetteShape: (g = {
                        vignetteShape: [
                          s.start,
                          s.range,
                          Math.pow(10, s.fadePower),
                        ],
                        vignetteColor: [
                          s.color.r,
                          s.color.g,
                          s.color.b,
                          s.color.a * s.strength,
                        ],
                      }).vignetteShape,
                      u_vignetteColor: g.vignetteColor,
                    };
                    h.draw(
                      t,
                      t.context.gl.TRIANGLES,
                      wt.disabled,
                      Yt.disabled,
                      ui.alphaBlended,
                      Gt.disabled,
                      x,
                      "vignette",
                      this.vignetteVx,
                      this.vignetteIdx,
                      p,
                    );
                  }
                  var g;
                }
              }
              class Bc {
                constructor() {
                  ((this._accumulatedOffsetX = 0),
                    (this._accumulatedOffsetY = 0),
                    (this._accumulatedElevation = 0));
                }
                update(t, s) {
                  const h = t.getFreeCameraOptions().position,
                    p = h.toAltitude(),
                    g = h.toLngLat(),
                    x = r.al(g.lng),
                    w = r.al(g.lat),
                    S = t.pixelsPerMeter / s,
                    C = x * r.eq,
                    D = r.eq * Math.log(Math.tan(Math.PI / 4 + w / 2));
                  if (this._offsetXPrev === void 0)
                    ((this._offsetXPrev = 0),
                      (this._offsetYPrev = 0),
                      (this._elevationPrev = 0),
                      (this._accumulatedOffsetX = 0),
                      (this._accumulatedOffsetY = 0),
                      (this._accumulatedElevation = 0));
                  else {
                    const L = -this._offsetYPrev + D,
                      z = -this._elevationPrev + p;
                    ((this._accumulatedOffsetX += (-this._offsetXPrev + C) * S),
                      (this._accumulatedOffsetY += L * S),
                      (this._accumulatedElevation += z * S),
                      (this._offsetXPrev = C),
                      (this._offsetYPrev = D),
                      (this._elevationPrev = p));
                  }
                }
                getPosition() {
                  return [
                    this._accumulatedOffsetX,
                    this._accumulatedOffsetY,
                    this._accumulatedElevation,
                  ];
                }
              }
              function za(c, t) {
                return [
                  -(c[0] - Math.floor(c[0] / t) * t),
                  -(c[1] - Math.floor(c[1] / t) * t),
                  -(c[2] - Math.floor(c[2] / t) * t),
                ];
              }
              function $d(c) {
                const t = r.e7(1323123451230),
                  s = [];
                for (let h = 0; h < c; ++h) {
                  const p = 2 * t() - 1,
                    g = 2 * t() - 1,
                    x = 2 * t() - 1;
                  s.push(r.cS(p, g, x));
                }
                return s;
              }
              function jo(c, t, s, h, p) {
                const g = r.ay((p - s) / (h - s), 0, 1);
                return (1 - g) * c + g * t;
              }
              class Ir {
                constructor(t) {
                  ((this._movement = new Bc()),
                    (this._accumulatedTimeFromStart = 0),
                    (this._prevTime = Date.now() / 1e3),
                    (this._vignette = new du()),
                    (this._ppmScaleFactor = t));
                }
                destroy() {
                  (this.particlesVx && this.particlesVx.destroy(),
                    this.particlesIdx && this.particlesIdx.destroy(),
                    this._vignette && this._vignette.destroy());
                }
                updateOnRender(t, s) {
                  const h = t.transform;
                  this._movement.update(h, this._ppmScaleFactor);
                  const p = h.starsProjMatrix,
                    g = r.b_([]);
                  (r.c0(g, g, r.al(90) - h._pitch), r.b$(g, g, -h.angle));
                  const x = r.c3(new Float32Array(16), g),
                    w = r.ep(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1),
                    S = r.ee([], w),
                    C = r.az([], S, x),
                    D = Date.now() / 1e3;
                  return (
                    (this._accumulatedTimeFromStart +=
                      (D - this._prevTime) * s),
                    (this._prevTime = D),
                    { projectionMatrix: p, modelviewMatrix: C }
                  );
                }
              }
              class G_ extends Ir {
                constructor(t) {
                  (super(4.25),
                    (this._params = {
                      overrideStyleParameters: !1,
                      intensity: 0.5,
                      timeFactor: 1,
                      velocityConeAperture: 0,
                      velocity: 300,
                      boxSize: 2500,
                      dropletSizeX: 1,
                      dropletSizeYScale: 10,
                      distortionStrength: 70,
                      screenThinning: {
                        intensity: 0.57,
                        start: 0.46,
                        range: 1.17,
                        fadePower: 0.17,
                        affectedRatio: 1,
                        particleOffset: -0.2,
                      },
                      color: { r: 0.66, g: 0.68, b: 0.74, a: 0.7 },
                      direction: { x: -50, y: -35 },
                      shapeDirPower: 2,
                      shapeNormalPower: 1,
                    }),
                    (this._revealParams = new Gd(t.tp, [
                      "Precipitation",
                      "Rain",
                    ])),
                    (this._vignetteParams = {
                      strength: 1,
                      start: 0.7,
                      range: 1,
                      fadePower: 0.4,
                      color: { r: 0.27, g: 0.27, b: 0.27, a: 1 },
                    }),
                    (this.particlesCount = 16e3));
                }
                update(t) {
                  const s = t.context;
                  if (!this.particlesVx) {
                    const h = $d(this.particlesCount),
                      p = new r.er(),
                      g = new r.a_();
                    let x = 0;
                    const w = r.e7(1323123451230);
                    for (let S = 0; S < h.length; ++S) {
                      const C = h[S],
                        D = [2 * w() - 1, w(), w(), w()];
                      (p.emplaceBack(C[0], C[1], C[2], -1, -1, ...D),
                        p.emplaceBack(C[0], C[1], C[2], 1, -1, ...D),
                        p.emplaceBack(C[0], C[1], C[2], 1, 1, ...D),
                        p.emplaceBack(C[0], C[1], C[2], -1, 1, ...D),
                        g.emplaceBack(x + 0, x + 1, x + 2),
                        g.emplaceBack(x + 0, x + 2, x + 3),
                        (x += 4));
                    }
                    ((this.particlesVx = s.createVertexBuffer(p, uu.members)),
                      (this.particlesIdx = s.createIndexBuffer(g)));
                  }
                }
                draw(t) {
                  if (!this._params.overrideStyleParameters && !t.style.rain)
                    return;
                  const s = this._params.overrideStyleParameters
                      ? this._revealParams
                      : { revealStart: 0, revealRange: 0.01 },
                    h = t.transform.zoom;
                  if (s.revealStart > h) return;
                  const p = jo(
                    0,
                    1,
                    s.revealStart,
                    s.revealStart + s.revealRange,
                    h,
                  );
                  if (!this.particlesVx || !this.particlesIdx) return;
                  const g = structuredClone(this._params);
                  let x = [-g.direction.x, g.direction.y, -100];
                  r.au(x, x);
                  const w = structuredClone(this._vignetteParams);
                  ((w.strength *= p),
                    g.overrideStyleParameters ||
                      ((g.intensity = t.style.rain.state.density),
                      (g.timeFactor = t.style.rain.state.intensity),
                      (g.color = structuredClone(t.style.rain.state.color)),
                      (x = structuredClone(t.style.rain.state.direction)),
                      (g.screenThinning.intensity =
                        t.style.rain.state.centerThinning),
                      (g.dropletSizeX = t.style.rain.state.dropletSize[0]),
                      (g.dropletSizeYScale =
                        t.style.rain.state.dropletSize[1] /
                        t.style.rain.state.dropletSize[0]),
                      (g.distortionStrength =
                        100 * t.style.rain.state.distortionStrength),
                      (w.strength = 1),
                      (w.color = structuredClone(
                        t.style.rain.state.vignetteColor,
                      ))));
                  const S = this.updateOnRender(t, g.timeFactor),
                    C = t.context,
                    D = C.gl,
                    L = t.transform;
                  ((this.screenTexture &&
                    this.screenTexture.size[0] === t.width &&
                    this.screenTexture.size[1] === t.height) ||
                    (this.screenTexture = new r.T(
                      C,
                      { width: t.width, height: t.height, data: null },
                      D.RGBA8,
                    )),
                    g.distortionStrength > 0 &&
                      (C.activeTexture.set(D.TEXTURE0),
                      this.screenTexture.bind(D.LINEAR, D.CLAMP_TO_EDGE),
                      D.copyTexSubImage2D(
                        D.TEXTURE_2D,
                        0,
                        0,
                        0,
                        0,
                        0,
                        t.width,
                        t.height,
                      )));
                  const z = t.getOrCreateProgram("rainParticle");
                  (t.uploadCommonUniforms(C, z),
                    C.activeTexture.set(D.TEXTURE0),
                    this.screenTexture.bind(D.LINEAR, D.CLAMP_TO_EDGE));
                  const O = [g.color.r, g.color.g, g.color.b, g.color.a],
                    G = (U, $) => {
                      const Z = za(this._movement.getPosition(), U),
                        Y = g.dropletSizeX,
                        ie = g.dropletSizeX * g.dropletSizeYScale,
                        ae = t.width / 2,
                        pe = t.height / 2,
                        ue = jo(
                          0,
                          g.screenThinning.start,
                          0,
                          1,
                          g.screenThinning.intensity,
                        ),
                        ce = jo(
                          0.001,
                          g.screenThinning.range,
                          0,
                          1,
                          g.screenThinning.intensity,
                        ),
                        le = jo(
                          0,
                          g.screenThinning.particleOffset,
                          0,
                          1,
                          g.screenThinning.intensity,
                        ),
                        me =
                          ((_e = {
                            modelview: S.modelviewMatrix,
                            projection: S.projectionMatrix,
                            time: this._accumulatedTimeFromStart,
                            camPos: Z,
                            velocityConeAperture: g.velocityConeAperture,
                            velocity: g.velocity,
                            boxSize: U,
                            rainDropletSize: [Y, ie],
                            distortionStrength: g.distortionStrength,
                            rainDirection: x,
                            color: O,
                            screenSize: [L.width, L.height],
                            thinningCenterPos: [ae, pe],
                            thinningShape: [
                              ue,
                              ce,
                              Math.pow(10, g.screenThinning.fadePower),
                            ],
                            thinningAffectedRatio:
                              g.screenThinning.affectedRatio,
                            thinningParticleOffset: le,
                            shapeDirectionalPower: g.shapeDirPower,
                            shapeNormalPower: g.shapeNormalPower,
                            mode: $ ? 0 : 1,
                          }),
                          {
                            u_modelview: Float32Array.from(_e.modelview),
                            u_projection: Float32Array.from(_e.projection),
                            u_time: _e.time,
                            u_cam_pos: _e.camPos,
                            u_texScreen: 0,
                            u_velocityConeAperture: _e.velocityConeAperture,
                            u_velocity: _e.velocity,
                            u_boxSize: _e.boxSize,
                            u_rainDropletSize: _e.rainDropletSize,
                            u_distortionStrength: _e.distortionStrength,
                            u_rainDirection: _e.rainDirection,
                            u_color: _e.color,
                            u_screenSize: _e.screenSize,
                            u_thinningCenterPos: _e.thinningCenterPos,
                            u_thinningShape: _e.thinningShape,
                            u_thinningAffectedRatio: _e.thinningAffectedRatio,
                            u_thinningParticleOffset: _e.thinningParticleOffset,
                            u_shapeDirectionalPower: _e.shapeDirectionalPower,
                            u_shapeNormalPower: _e.shapeNormalPower,
                            u_mode: _e.mode,
                          });
                      var _e;
                      const De = Math.round(g.intensity * this.particlesCount),
                        ze = r.bd.simpleSegment(0, 0, 4 * De, 2 * De);
                      z.draw(
                        t,
                        D.TRIANGLES,
                        wt.disabled,
                        Yt.disabled,
                        ui.alphaBlended,
                        Gt.disabled,
                        me,
                        "rain_particles",
                        this.particlesVx,
                        this.particlesIdx,
                        ze,
                      );
                    };
                  (g.distortionStrength > 0 && G(g.boxSize, !0),
                    G(g.boxSize, !1),
                    this._vignette.draw(t, w));
                }
              }
              const Nc = r.d_([
                { type: "Float32", name: "a_pos_3f", components: 3 },
                { type: "Float32", name: "a_uv", components: 2 },
                { type: "Float32", name: "a_snowParticleData", components: 4 },
                {
                  type: "Float32",
                  name: "a_snowParticleDataHorizontalOscillation",
                  components: 2,
                },
              ]);
              class yn extends Ir {
                constructor(t) {
                  (super(2.25),
                    (this._params = {
                      overrideStyleParameters: !1,
                      intensity: 0.85,
                      timeFactor: 0.75,
                      velocityConeAperture: 70,
                      velocity: 40,
                      horizontalOscillationRadius: 4,
                      horizontalOscillationRate: 1.5,
                      boxSize: 2e3,
                      billboardSize: 2,
                      shapeFadeStart: 0.27,
                      shapeFadePower: 0.21,
                      screenThinning: {
                        intensity: 0.4,
                        start: 0.15,
                        range: 1.4,
                        fadePower: 0.24,
                        affectedRatio: 1,
                        particleOffset: -0.2,
                      },
                      color: { r: 1, g: 1, b: 1, a: 1 },
                      direction: { x: -50, y: -35 },
                    }),
                    (this._revealParams = new Gd(t.tp, [
                      "Precipitation",
                      "Snow",
                    ])),
                    (this._vignetteParams = {
                      strength: 0.3,
                      start: 0.78,
                      range: 0.46,
                      fadePower: 0.2,
                      color: { r: 1, g: 1, b: 1, a: 1 },
                    }),
                    (this.particlesCount = 16e3));
                }
                update(t) {
                  const s = t.context;
                  if (!this.particlesVx) {
                    const h = $d(this.particlesCount),
                      p = new r.es(),
                      g = new r.a_();
                    let x = 0;
                    const w = r.e7(1323123451230);
                    for (let S = 0; S < h.length; ++S) {
                      const C = h[S],
                        D = w(),
                        L = w(),
                        z = w(),
                        O = [S / h.length, D, L, z],
                        G = [w(), w()];
                      (p.emplaceBack(C[0], C[1], C[2], -1, -1, ...O, ...G),
                        p.emplaceBack(C[0], C[1], C[2], 1, -1, ...O, ...G),
                        p.emplaceBack(C[0], C[1], C[2], 1, 1, ...O, ...G),
                        p.emplaceBack(C[0], C[1], C[2], -1, 1, ...O, ...G),
                        g.emplaceBack(x + 0, x + 1, x + 2),
                        g.emplaceBack(x + 0, x + 2, x + 3),
                        (x += 4));
                    }
                    ((this.particlesVx = s.createVertexBuffer(p, Nc.members)),
                      (this.particlesIdx = s.createIndexBuffer(g)));
                  }
                }
                draw(t) {
                  if (!this._params.overrideStyleParameters && !t.style.snow)
                    return;
                  const s = structuredClone(this._params);
                  let h = [-s.direction.x, s.direction.y, -100];
                  r.au(h, h);
                  const p = structuredClone(this._vignetteParams),
                    g = s.overrideStyleParameters
                      ? this._revealParams
                      : { revealStart: 0, revealRange: 0.01 },
                    x = t.transform.zoom;
                  if (g.revealStart > x) return;
                  const w = jo(
                    0,
                    1,
                    g.revealStart,
                    g.revealStart + g.revealRange,
                    x,
                  );
                  ((p.strength *= w),
                    s.overrideStyleParameters ||
                      ((s.intensity = t.style.snow.state.density),
                      (s.timeFactor = t.style.snow.state.intensity),
                      (s.color = structuredClone(t.style.snow.state.color)),
                      (h = structuredClone(t.style.snow.state.direction)),
                      (s.screenThinning.intensity =
                        t.style.snow.state.centerThinning),
                      (s.billboardSize = 2.79 * t.style.snow.state.flakeSize),
                      (p.strength = 1),
                      (p.color = structuredClone(
                        t.style.snow.state.vignetteColor,
                      ))));
                  const S = this.updateOnRender(t, s.timeFactor);
                  if (!this.particlesVx || !this.particlesIdx) return;
                  const C = t.context,
                    D = C.gl,
                    L = t.transform,
                    z = t.getOrCreateProgram("snowParticle");
                  (t.uploadCommonUniforms(C, z),
                    ((O, G, U) => {
                      const $ = za(this._movement.getPosition(), O),
                        Z = L.width / 2,
                        Y = L.height / 2,
                        ie = jo(
                          0,
                          U.screenThinning.start,
                          0,
                          1,
                          U.screenThinning.intensity,
                        ),
                        ae = jo(
                          0.001,
                          U.screenThinning.range,
                          0,
                          1,
                          U.screenThinning.intensity,
                        ),
                        pe = jo(
                          0,
                          U.screenThinning.particleOffset,
                          0,
                          1,
                          U.screenThinning.intensity,
                        ),
                        ue =
                          ((ce = {
                            modelview: S.modelviewMatrix,
                            projection: S.projectionMatrix,
                            time: this._accumulatedTimeFromStart,
                            camPos: $,
                            velocityConeAperture: U.velocityConeAperture,
                            velocity: U.velocity,
                            horizontalOscillationRadius:
                              U.horizontalOscillationRadius,
                            horizontalOscillationRate:
                              U.horizontalOscillationRate,
                            boxSize: O,
                            billboardSize: 1 * U.billboardSize,
                            simpleShapeParameters: [
                              U.shapeFadeStart,
                              U.shapeFadePower,
                            ],
                            screenSize: [L.width, L.height],
                            thinningCenterPos: [Z, Y],
                            thinningShape: [
                              ie,
                              ae,
                              Math.pow(10, U.screenThinning.fadePower),
                            ],
                            thinningAffectedRatio:
                              U.screenThinning.affectedRatio,
                            thinningParticleOffset: pe,
                            color: [U.color.r, U.color.g, U.color.b, U.color.a],
                            direction: h,
                          }),
                          {
                            u_modelview: Float32Array.from(ce.modelview),
                            u_projection: Float32Array.from(ce.projection),
                            u_time: ce.time,
                            u_cam_pos: ce.camPos,
                            u_velocityConeAperture: ce.velocityConeAperture,
                            u_velocity: ce.velocity,
                            u_horizontalOscillationRadius:
                              ce.horizontalOscillationRadius,
                            u_horizontalOscillationRate:
                              ce.horizontalOscillationRate,
                            u_boxSize: ce.boxSize,
                            u_billboardSize: ce.billboardSize,
                            u_simpleShapeParameters: ce.simpleShapeParameters,
                            u_screenSize: ce.screenSize,
                            u_thinningCenterPos: ce.thinningCenterPos,
                            u_thinningShape: ce.thinningShape,
                            u_thinningAffectedRatio: ce.thinningAffectedRatio,
                            u_thinningParticleOffset: ce.thinningParticleOffset,
                            u_particleColor: ce.color,
                            u_direction: ce.direction,
                          });
                      var ce;
                      const le = Math.round(U.intensity * this.particlesCount),
                        me = r.bd.simpleSegment(0, 0, 4 * le, 2 * le);
                      this.particlesVx &&
                        this.particlesIdx &&
                        z.draw(
                          t,
                          D.TRIANGLES,
                          wt.disabled,
                          Yt.disabled,
                          ui.alphaBlended,
                          Gt.disabled,
                          ue,
                          "snow_particles",
                          this.particlesVx,
                          this.particlesIdx,
                          me,
                        );
                    })(s.boxSize, 0, s),
                    this._vignette.draw(t, p));
                }
              }
              const Ai = {
                  symbol: function (c, t, s, h, p) {
                    if (c.renderPass !== "translucent") return;
                    const g = Yt.disabled,
                      x = c.colorModeForRenderPass(),
                      w = s.layout.get("text-variable-anchor"),
                      S = s.layout.get("text-size-scale-range"),
                      C = r.ay(c.scaleFactor, S[0], S[1]);
                    w &&
                      (function (z, O, G, U, $, Z, Y, ie) {
                        const ae = O.transform,
                          pe = $ === "map",
                          ue = Z === "map";
                        for (const ce of z) {
                          const le = U.getTile(ce),
                            me = le.getBucket(G);
                          if (!me || !me.text || !me.text.segments.get().length)
                            continue;
                          const _e = r.bH(me.textSizeData, ae.zoom, ie),
                            De = kh(ce, me.getProjection(), ae),
                            ze = ae.calculatePixelsToTileUnitsMatrix(le),
                            He = ro(
                              De,
                              le.tileID.canonical,
                              ue,
                              pe,
                              ae,
                              me.getProjection(),
                              ze,
                            ),
                            We = me.hasIconTextFit() && me.hasIconData();
                          _e &&
                            Yp(
                              me,
                              pe,
                              ue,
                              Y,
                              ae,
                              He,
                              ce,
                              Math.pow(2, ae.zoom - le.tileID.overscaledZ),
                              _e,
                              We,
                            );
                        }
                      })(
                        h,
                        c,
                        s,
                        t,
                        s.layout.get("text-rotation-alignment"),
                        s.layout.get("text-pitch-alignment"),
                        p,
                        C,
                      );
                    const D = s.paint.get("icon-opacity").constantOr(1) !== 0,
                      L = s.paint.get("text-opacity").constantOr(1) !== 0;
                    (s.layout.get("symbol-sort-key").constantOr(1) !== void 0 &&
                    (D || L)
                      ? bl(c, t, s, h, g, x)
                      : (D && bl(c, t, s, h, g, x, { onlyIcons: !0 }),
                        L && bl(c, t, s, h, g, x, { onlyText: !0 })),
                      t.map.showCollisionBoxes &&
                        (su(
                          c,
                          t,
                          s,
                          h,
                          s.paint.get("text-translate"),
                          s.paint.get("text-translate-anchor"),
                          !0,
                        ),
                        su(
                          c,
                          t,
                          s,
                          h,
                          s.paint.get("icon-translate"),
                          s.paint.get("icon-translate-anchor"),
                          !1,
                        )));
                  },
                  circle: function (c, t, s, h) {
                    if (c.renderPass !== "translucent") return;
                    const p = s.paint.get("circle-opacity"),
                      g = s.paint.get("circle-stroke-width"),
                      x = s.paint.get("circle-stroke-opacity"),
                      w =
                        s.layout.get("circle-sort-key").constantOr(1) !==
                        void 0,
                      S = s.paint.get("circle-emissive-strength");
                    if (
                      p.constantOr(1) === 0 &&
                      (g.constantOr(1) === 0 || x.constantOr(1) === 0)
                    )
                      return;
                    const C = c.context,
                      D = C.gl,
                      L = c.transform,
                      z = !(!c.terrain || !c.terrain.enabled),
                      O = s.layout.get("circle-elevation-reference"),
                      G = c.depthModeForSublayer(0, wt.ReadOnly),
                      U = new wt(
                        c.context.gl.LEQUAL,
                        wt.ReadOnly,
                        c.depthRangeFor3D,
                      ),
                      $ = O === "none" || z ? G : U,
                      Z = Yt.disabled,
                      Y = c.colorModeForDrapableLayerRenderPass(S),
                      ie = L.projection.name === "globe",
                      ae = [r.aD(L.center.lng), r.aH(L.center.lat)],
                      pe = [];
                    for (let ce = 0; ce < h.length; ce++) {
                      const le = h[ce],
                        me = t.getTile(le),
                        _e = me.getBucket(s);
                      if (!_e || _e.projection.name !== L.projection.name)
                        continue;
                      const De = _e.programConfigurations.get(s.id),
                        ze = _e.layoutVertexBuffer,
                        He = _e.globeExtVertexBuffer,
                        We = _e.indexBuffer,
                        et = r.dK(s),
                        Ce = [He],
                        Ve = c.isTileAffectedByFog(le);
                      (ie && et.push("PROJECTION_GLOBE_VIEW"),
                        et.push("DEPTH_D24"),
                        c.terrain &&
                          L.depthOcclusionForSymbolsAndCircles &&
                          et.push("DEPTH_OCCLUSION"),
                        _e.hasElevation &&
                          (et.push("ELEVATED_ROADS"),
                          Ce.push(_e.elevatedLayoutVertexBuffer)));
                      const Te = c.getOrCreateProgram("circle", {
                          config: De,
                          defines: et,
                          overrideFog: Ve,
                        }),
                        Ze = L.projection.createInversionMatrix(
                          L,
                          le.canonical,
                        ),
                        Oe = {
                          programConfiguration: De,
                          program: Te,
                          layoutVertexBuffer: ze,
                          dynamicBuffers: Ce,
                          indexBuffer: We,
                          uniformValues: r.dL(c, le, me, Ze, ae, s),
                          tile: me,
                        };
                      if (w) {
                        const Ke = _e.segments.get();
                        for (const ht of Ke)
                          pe.push({
                            segments: new r.bd([ht]),
                            sortKey: ht.sortKey,
                            state: Oe,
                          });
                      } else
                        pe.push({
                          segments: _e.segments,
                          sortKey: 0,
                          state: Oe,
                        });
                    }
                    w && pe.sort((ce, le) => ce.sortKey - le.sortKey);
                    const ue = {
                      useDepthForOcclusion:
                        L.depthOcclusionForSymbolsAndCircles,
                    };
                    for (const ce of pe) {
                      const {
                          programConfiguration: le,
                          program: me,
                          layoutVertexBuffer: _e,
                          dynamicBuffers: De,
                          indexBuffer: ze,
                          uniformValues: He,
                          tile: We,
                        } = ce.state,
                        et = ce.segments;
                      (c.terrain && c.terrain.setupElevationDraw(We, me, ue),
                        c.uploadCommonUniforms(C, me, We.tileID.toUnwrapped()),
                        me.draw(
                          c,
                          D.TRIANGLES,
                          $,
                          Z,
                          Y,
                          Gt.disabled,
                          He,
                          s.id,
                          _e,
                          ze,
                          et,
                          s.paint,
                          L.zoom,
                          le,
                          De,
                        ));
                    }
                  },
                  heatmap: function (c, t, s, h) {
                    if (s.paint.get("heatmap-opacity") !== 0)
                      if (c.renderPass === "offscreen") {
                        const p = c.context,
                          g = p.gl,
                          x = Yt.disabled,
                          w = new ui(
                            [g.ONE, g.ONE, g.ONE, g.ONE],
                            r.am.transparent,
                            [!0, !0, !0, !0],
                          );
                        ((function (O, G, U, $) {
                          const Z = O.gl,
                            Y = G.width * $,
                            ie = G.height * $;
                          (O.activeTexture.set(Z.TEXTURE1),
                            O.viewport.set([0, 0, Y, ie]));
                          let ae = U.heatmapFbo;
                          if (
                            !ae ||
                            (ae && (ae.width !== Y || ae.height !== ie))
                          ) {
                            ae && ae.destroy();
                            const pe = Z.createTexture();
                            (Z.bindTexture(Z.TEXTURE_2D, pe),
                              Z.texParameteri(
                                Z.TEXTURE_2D,
                                Z.TEXTURE_WRAP_S,
                                Z.CLAMP_TO_EDGE,
                              ),
                              Z.texParameteri(
                                Z.TEXTURE_2D,
                                Z.TEXTURE_WRAP_T,
                                Z.CLAMP_TO_EDGE,
                              ),
                              Z.texParameteri(
                                Z.TEXTURE_2D,
                                Z.TEXTURE_MIN_FILTER,
                                Z.LINEAR,
                              ),
                              Z.texParameteri(
                                Z.TEXTURE_2D,
                                Z.TEXTURE_MAG_FILTER,
                                Z.LINEAR,
                              ),
                              (ae = U.heatmapFbo =
                                O.createFramebuffer(Y, ie, !0, null)),
                              (function (ue, ce, le, me, _e, De) {
                                const ze = ue.gl;
                                (ze.texImage2D(
                                  ze.TEXTURE_2D,
                                  0,
                                  ue.extRenderToTextureHalfFloat
                                    ? ze.RGBA16F
                                    : ze.RGBA,
                                  _e,
                                  De,
                                  0,
                                  ze.RGBA,
                                  ue.extRenderToTextureHalfFloat
                                    ? ze.HALF_FLOAT
                                    : ze.UNSIGNED_BYTE,
                                  null,
                                ),
                                  me.colorAttachment.set(le));
                              })(O, 0, pe, ae, Y, ie));
                          } else
                            (Z.bindTexture(
                              Z.TEXTURE_2D,
                              ae.colorAttachment.get(),
                            ),
                              O.bindFramebuffer.set(ae.framebuffer));
                        })(
                          p,
                          c,
                          s,
                          c.transform.projection.name === "globe" ? 0.5 : 0.25,
                        ),
                          p.clear({ color: r.am.transparent }));
                        const S = c.transform,
                          C = S.projection.name === "globe",
                          D = C ? ["PROJECTION_GLOBE_VIEW"] : [],
                          L = C ? Gt.frontCCW : Gt.disabled,
                          z = [r.aD(S.center.lng), r.aH(S.center.lat)];
                        for (let O = 0; O < h.length; O++) {
                          const G = h[O];
                          if (t.hasRenderableParent(G)) continue;
                          const U = t.getTile(G),
                            $ = U.getBucket(s);
                          if (!$ || $.projection.name !== S.projection.name)
                            continue;
                          const Z = c.isTileAffectedByFog(G),
                            Y = $.programConfigurations.get(s.id),
                            ie = c.getOrCreateProgram("heatmap", {
                              config: Y,
                              defines: D,
                              overrideFog: Z,
                            }),
                            { zoom: ae } = c.transform;
                          (c.terrain && c.terrain.setupElevationDraw(U, ie),
                            c.uploadCommonUniforms(p, ie, G.toUnwrapped()));
                          const pe = S.projection.createInversionMatrix(
                            S,
                            G.canonical,
                          );
                          ie.draw(
                            c,
                            g.TRIANGLES,
                            wt.disabled,
                            x,
                            w,
                            L,
                            Hp(
                              c,
                              G,
                              U,
                              pe,
                              z,
                              ae,
                              s.paint.get("heatmap-intensity"),
                            ),
                            s.id,
                            $.layoutVertexBuffer,
                            $.indexBuffer,
                            $.segments,
                            s.paint,
                            c.transform.zoom,
                            Y,
                            C ? [$.globeExtVertexBuffer] : null,
                          );
                        }
                        p.viewport.set([0, 0, c.width, c.height]);
                      } else
                        c.renderPass === "translucent" &&
                          (c.context.setColorMode(c.colorModeForRenderPass()),
                          (function (p, g) {
                            const x = p.context,
                              w = x.gl,
                              S = g.heatmapFbo;
                            if (!S) return;
                            (x.activeTexture.set(w.TEXTURE0),
                              w.bindTexture(
                                w.TEXTURE_2D,
                                S.colorAttachment.get(),
                              ),
                              x.activeTexture.set(w.TEXTURE1));
                            let C = g.colorRampTexture;
                            (C ||
                              (C = g.colorRampTexture =
                                new r.T(x, g.colorRamp, w.RGBA8)),
                              C.bind(w.LINEAR, w.CLAMP_TO_EDGE),
                              p
                                .getOrCreateProgram("heatmapTexture")
                                .draw(
                                  p,
                                  w.TRIANGLES,
                                  wt.disabled,
                                  Yt.disabled,
                                  p.colorModeForRenderPass(),
                                  Gt.disabled,
                                  ((D, L, z, O) => ({
                                    u_image: 0,
                                    u_color_ramp: 1,
                                    u_opacity: L.paint.get("heatmap-opacity"),
                                  }))(0, g),
                                  g.id,
                                  p.viewportBuffer,
                                  p.quadTriangleIndexBuffer,
                                  p.viewportSegments,
                                  g.paint,
                                  p.transform.zoom,
                                ));
                          })(c, s));
                  },
                  line: function (c, t, s, h) {
                    if (c.renderPass !== "translucent") return;
                    const p = s.paint.get("line-opacity"),
                      g = s.paint.get("line-width");
                    if (p.constantOr(1) === 0 || g.constantOr(1) === 0) return;
                    const x = s.paint.get("line-emissive-strength"),
                      w = s.paint.get("line-occlusion-opacity"),
                      S = s.layout.get("line-elevation-reference"),
                      C = s.layout.get("line-width-unit") === "meters",
                      D = S === "sea",
                      L = !(!c.terrain || !c.terrain.enabled),
                      z = c.context,
                      O = z.gl;
                    if (
                      s.hasElevatedBuckets &&
                      c.transform.projection.name === "globe"
                    )
                      return;
                    const G = s.layout.get("line-cross-slope"),
                      U = G !== void 0,
                      $ = G < 1,
                      Z = c.colorModeForDrapableLayerRenderPass(x),
                      Y = c.terrain && c.terrain.renderingToTexture,
                      ie = Y ? 1 : r.q.devicePixelRatio,
                      ae = s.paint.get("line-dasharray"),
                      pe = ae.constantOr(1),
                      ue = s.layout.get("line-cap"),
                      ce = ae.constantOr(null),
                      le = ue.constantOr(null),
                      me = s.paint.get("line-pattern"),
                      _e = me.constantOr(1),
                      De = s.paint.get("line-pattern-cross-fade"),
                      ze = me.constantOr(null),
                      He = s.paint.get("line-opacity").constantOr(1);
                    let We =
                      (!_e && He !== 1) || (c.depthOcclusion && w > 0 && w < 1);
                    const et = s.paint.get("line-gradient"),
                      Ce = _e ? "linePattern" : "line",
                      Ve = r.dM(s);
                    let Te;
                    if (
                      (Y &&
                        c.terrain &&
                        c.terrain.clipOrMaskOverlapStencilType() &&
                        (We = !1),
                      w !== 0 && c.depthOcclusion)
                    ) {
                      const ht = s.paint._values["line-opacity"];
                      ht && ht.value && ht.value.kind === "constant"
                        ? (Te = ht.value)
                        : r.w(
                            `Occlusion opacity for layer ${s.id} is supported only when line-opacity isn't data-driven.`,
                          );
                    }
                    g.value.kind !== "constant" &&
                      g.value.isLineProgressConstant === !1 &&
                      Ve.push("VARIABLE_LINE_WIDTH");
                    const Ze = (ht, qe, lt, St, Et, bt) => {
                      for (const kt of ht) {
                        const Bt = t.getTile(kt);
                        if (_e && !Bt.patternsLoaded()) continue;
                        const Vt = Bt.getBucket(s);
                        if (
                          !Vt ||
                          (Vt.elevationType !== "none" && !Et) ||
                          (Vt.elevationType === "none" && Et)
                        )
                          continue;
                        c.prepareDrawTile();
                        const Zt = [...qe],
                          si = c.shadowRenderer,
                          Fi =
                            Vt.elevationType === "road" && !!si && si.enabled;
                        let nn = [0, 0, 0];
                        if (Fi) {
                          const Ti = c.style.directionalLight,
                            Un = c.style.ambientLight;
                          (Ti && Un && (nn = wa(c.style, Ti, Un)),
                            Zt.push(
                              "RENDER_SHADOWS",
                              "DEPTH_TEXTURE",
                              "NORMAL_OFFSET",
                            ));
                        }
                        const ji = Vt.programConfigurations.get(s.id);
                        let Hi = !1;
                        if (ze && Bt.imageAtlas) {
                          const Ti = r.dN.from(ze),
                            Un = Ti.getPrimary().scaleSelf(ie).toString(),
                            hn = Bt.imageAtlas.patternPositions.get(Un),
                            Ji = Ti.getSecondary(),
                            un = Ji
                              ? Bt.imageAtlas.patternPositions.get(
                                  Ji.scaleSelf(ie).toString(),
                                )
                              : null;
                          ((Hi = !!hn && !!un),
                            hn && ji.setConstantPatternPositions(hn, un));
                        }
                        De > 0 &&
                          (Hi ||
                            ji.getPatternTransitionVertexBuffer(
                              "line-pattern",
                            )) &&
                          Zt.push("LINE_PATTERN_TRANSITION");
                        const Fn = c.isTileAffectedByFog(kt),
                          ti = c.getOrCreateProgram(Ce, {
                            config: ji,
                            defines: Zt,
                            overrideFog: Fn,
                            overrideRtt: !Et && void 0,
                          });
                        if (!_e && ce && le && Bt.lineAtlas) {
                          const Ti = Bt.lineAtlas.getDash(ce, le);
                          Ti && ji.setConstantPatternPositions(Ti);
                        }
                        Fi &&
                          si.setupShadows(
                            Bt.tileID.toUnwrapped(),
                            ti,
                            "vector-tile",
                            Bt.tileID.overscaledZ,
                          );
                        let [li, gi] = s.paint.get("line-trim-offset");
                        (le === "round" || le === "square") &&
                          li !== gi &&
                          (li === 0 && (li -= 1), gi === 1 && (gi += 1));
                        const cn = Y ? kt.projMatrix : null,
                          qn = C
                            ? 1 / Vt.tileToMeter / r.aw(Bt, 1, c.transform.zoom)
                            : 1,
                          rn = C
                            ? 1 /
                              Vt.tileToMeter /
                              r.aw(Bt, 1, Math.floor(c.transform.zoom))
                            : 1,
                          Di = _e
                            ? r.dO(c, Bt, s, cn, ie, qn, rn, [li, gi], nn, De)
                            : r.dP(
                                c,
                                Bt,
                                s,
                                cn,
                                Vt.lineClipsArray.length,
                                ie,
                                qn,
                                rn,
                                [li, gi],
                                nn,
                              );
                        if (et) {
                          const Ti = Vt.gradients[s.id];
                          let Un = Ti.texture;
                          if (s.gradientVersion !== Ti.version) {
                            let hn = 256;
                            if (s.stepInterpolant) {
                              const Ji = t.getSource().maxzoom,
                                un =
                                  kt.canonical.z === Ji
                                    ? Math.ceil(
                                        1 <<
                                          (c.transform.maxZoom -
                                            kt.canonical.z),
                                      )
                                    : 1;
                              hn = r.ay(
                                r.dQ((Vt.maxLineLength / r.aj) * 1024 * un),
                                256,
                                z.maxTextureSize,
                              );
                            }
                            ((Ti.gradient = r.dR({
                              expression: s.gradientExpression(),
                              evaluationKey: "lineProgress",
                              resolution: hn,
                              image: Ti.gradient || void 0,
                              clips: Vt.lineClipsArray,
                            })),
                              Ti.texture
                                ? Ti.texture.update(Ti.gradient)
                                : (Ti.texture = new r.T(
                                    z,
                                    Ti.gradient,
                                    O.RGBA8,
                                  )),
                              (Ti.version = s.gradientVersion),
                              (Un = Ti.texture));
                          }
                          (z.activeTexture.set(O.TEXTURE1),
                            Un.bind(
                              s.stepInterpolant ? O.NEAREST : O.LINEAR,
                              O.CLAMP_TO_EDGE,
                            ));
                        }
                        (pe &&
                          (z.activeTexture.set(O.TEXTURE0),
                          Bt.lineAtlasTexture &&
                            Bt.lineAtlasTexture.bind(O.LINEAR, O.REPEAT),
                          ji.updatePaintBuffers()),
                          _e &&
                            (z.activeTexture.set(O.TEXTURE0),
                            Bt.imageAtlasTexture &&
                              Bt.imageAtlasTexture.bind(
                                O.LINEAR,
                                O.CLAMP_TO_EDGE,
                              ),
                            ji.updatePaintBuffers()),
                          Et && !D && c.terrain.setupElevationDraw(Bt, ti),
                          c.uploadCommonUniforms(z, ti, kt.toUnwrapped()));
                        const Pn = (Ti) => {
                          (Te != null && (Te.value = He * w),
                            ti.draw(
                              c,
                              O.TRIANGLES,
                              lt,
                              Ti,
                              Z,
                              Gt.disabled,
                              Di,
                              s.id,
                              Vt.layoutVertexBuffer,
                              Vt.indexBuffer,
                              Vt.segments,
                              s.paint,
                              c.transform.zoom,
                              ji,
                              [
                                Vt.layoutVertexBuffer2,
                                Vt.patternVertexBuffer,
                                Vt.zOffsetVertexBuffer,
                              ],
                            ),
                            Te != null && (Te.value = He));
                        };
                        if (We && !Et) {
                          const Ti = c.stencilModeForClipping(kt).ref;
                          Ti === 0 && Y && z.clear({ stencil: 0 });
                          const Un = { func: O.EQUAL, mask: 255 };
                          ((Di.u_alpha_discard_threshold = 0.8),
                            Pn(new Yt(Un, Ti, 255, O.KEEP, O.KEEP, O.INVERT)),
                            (Di.u_alpha_discard_threshold = 0),
                            Pn(new Yt(Un, Ti, 255, O.KEEP, O.KEEP, O.KEEP)));
                        } else
                          ((Di.u_alpha_discard_threshold =
                            We && Et && bt ? 0.8 : 0),
                            Pn(Et ? St : c.stencilModeForClipping(kt)));
                      }
                    };
                    let Oe = c.depthModeForSublayer(0, wt.ReadOnly);
                    const Ke = new wt(
                      c.depthOcclusion ? O.GREATER : O.LEQUAL,
                      wt.ReadOnly,
                      c.depthRangeFor3D,
                    );
                    if (s.hasNonElevatedBuckets) {
                      const ht = !Y && c.terrain;
                      w !== 0 && ht
                        ? r.w(
                            `Occlusion opacity for layer ${s.id} is supported on terrain only if the layer has line-z-offset enabled.`,
                          )
                        : ht
                          ? r.w(
                              `Cannot render non-elevated lines in immediate mode when terrain is enabled. Layer: ${s.id}.`,
                            )
                          : Ze(h, Ve, Oe, Yt.disabled, !1, !0);
                    }
                    if (s.hasElevatedBuckets) {
                      S === "hd-road-markup"
                        ? L || ((Oe = Ke), Ve.push("ELEVATED_ROADS"))
                        : (Ve.push("ELEVATED"),
                          (Oe = Ke),
                          U &&
                            Ve.push(
                              $
                                ? "CROSS_SLOPE_HORIZONTAL"
                                : "CROSS_SLOPE_VERTICAL",
                            ),
                          D && Ve.push("ELEVATION_REFERENCE_SEA"));
                      const ht = We ? c.stencilModeFor3D() : Yt.disabled;
                      ((c.forceTerrainMode = !0),
                        Ze(h, Ve, Oe, ht, !0, !0),
                        We && Ze(h, Ve, Oe, ht, !0, !1),
                        (c.forceTerrainMode = !1));
                    }
                    (We &&
                      (c.resetStencilClippingMasks(),
                      Y && z.clear({ stencil: 0 })),
                      w === 0 ||
                        c.depthOcclusion ||
                        Y ||
                        c.layersWithOcclusionOpacity.push(c.currentLayer));
                  },
                  fill: function (c, t, s, h) {
                    const p = s.paint.get("fill-color"),
                      g = s.paint.get("fill-opacity");
                    if (g.constantOr(1) === 0) return;
                    const x = s.paint.get("fill-emissive-strength"),
                      w = c.colorModeForDrapableLayerRenderPass(x),
                      S = s.paint.get("fill-pattern"),
                      C =
                        c.opaquePassEnabledForLayer() &&
                        !S.constantOr(1) &&
                        p.constantOr(r.am.transparent).a === 1 &&
                        g.constantOr(0) === 1
                          ? "opaque"
                          : "translucent";
                    let D = "none";
                    s.layout.get("fill-elevation-reference") !== "none"
                      ? (D = "road")
                      : s.paint.get("fill-z-offset").constantOr(1) !== 0 &&
                        (D = "offset");
                    const L = !(!c.terrain || !c.terrain.enabled),
                      z = {
                        painter: c,
                        sourceCache: t,
                        layer: s,
                        coords: h,
                        colorMode: w,
                        elevationType: D,
                        terrainEnabled: L,
                        pass: C,
                      };
                    if (c.renderPass !== "shadow")
                      if (D !== "offset") {
                        if ((Bd(z, !1), D === "road")) {
                          const O = !L && c.renderPass === "translucent";
                          (O && Fd(c, t, s, h, "geometry"),
                            Bd(z, !0, Yt.disabled),
                            O &&
                              (function (G) {
                                const {
                                    painter: U,
                                    sourceCache: $,
                                    layer: Z,
                                    coords: Y,
                                    colorMode: ie,
                                  } = G,
                                  ae = U.context.gl,
                                  pe = G.painter.shadowRenderer,
                                  ue = !!pe && pe.enabled,
                                  ce = new wt(
                                    U.context.gl.LEQUAL,
                                    wt.ReadOnly,
                                    U.depthRangeFor3D,
                                  );
                                let le = [0, 0, 0];
                                if (ue) {
                                  const _e = U.style.directionalLight,
                                    De = U.style.ambientLight;
                                  _e && De && (le = wa(U.style, _e, De));
                                }
                                const me = (_e) => {
                                  for (const De of Y) {
                                    const ze = $.getTile(De),
                                      He = ze.getBucket(Z);
                                    if (!He) continue;
                                    const We = He.elevatedStructures;
                                    if (!We) continue;
                                    let et, Ce;
                                    if (
                                      (_e
                                        ? ((et = We.renderableBridgeSegments),
                                          (Ce =
                                            We.bridgeProgramConfigurations.get(
                                              Z.id,
                                            )))
                                        : ((et = We.renderableTunnelSegments),
                                          (Ce =
                                            We.tunnelProgramConfigurations.get(
                                              Z.id,
                                            ))),
                                      !et ||
                                        et.segments[0].primitiveLength === 0)
                                    )
                                      continue;
                                    (Ce.updatePaintBuffers(),
                                      U.prepareDrawTile());
                                    const Ve = U.isTileAffectedByFog(De),
                                      Te = [];
                                    ue &&
                                      Te.push(
                                        "RENDER_SHADOWS",
                                        "DEPTH_TEXTURE",
                                        "NORMAL_OFFSET",
                                      );
                                    const Ze = U.getOrCreateProgram(
                                        "elevatedStructures",
                                        {
                                          config: Ce,
                                          overrideFog: Ve,
                                          defines: Te,
                                        },
                                      ),
                                      Oe = U.translatePosMatrix(
                                        De.projMatrix,
                                        ze,
                                        Z.paint.get("fill-translate"),
                                        Z.paint.get("fill-translate-anchor"),
                                      );
                                    ue &&
                                      pe.setupShadows(
                                        ze.tileID.toUnwrapped(),
                                        Ze,
                                        "vector-tile",
                                        ze.tileID.overscaledZ,
                                      );
                                    const Ke = P_(Oe, le);
                                    (U.uploadCommonUniforms(
                                      U.context,
                                      Ze,
                                      De.toUnwrapped(),
                                    ),
                                      Ze.draw(
                                        U,
                                        ae.TRIANGLES,
                                        ce,
                                        Yt.disabled,
                                        ie,
                                        Gt.backCCW,
                                        Ke,
                                        Z.id,
                                        We.vertexBuffer,
                                        We.indexBuffer,
                                        et,
                                        Z.paint,
                                        U.transform.zoom,
                                        Ce,
                                        [We.vertexBufferNormal],
                                      ));
                                  }
                                };
                                (me(!0), me(!1));
                              })(z));
                        }
                      } else Bd(z, !1, c.stencilModeFor3D());
                    else
                      c.shadowRenderer &&
                        D === "road" &&
                        !L &&
                        (function (O) {
                          const {
                              painter: G,
                              sourceCache: U,
                              layer: $,
                              coords: Z,
                            } = O,
                            Y = G.context.gl,
                            ie = O.painter.shadowRenderer;
                          for (const ae of Z) {
                            const pe = U.getTile(ae),
                              ue = pe.getBucket($);
                            if (!ue) continue;
                            const ce = ue.elevatedStructures;
                            if (
                              !ce ||
                              !ce.shadowCasterSegments ||
                              ce.shadowCasterSegments.segments[0]
                                .primitiveLength === 0
                            )
                              continue;
                            G.prepareDrawTile();
                            const le = ue.bufferData.programConfigurations.get(
                                $.id,
                              ),
                              me = G.isTileAffectedByFog(ae),
                              _e = G.getOrCreateProgram(
                                "elevatedStructuresDepth",
                                { config: le, overrideFog: me },
                              ),
                              De = ie.calculateShadowPassMatrixFromTile(
                                pe.tileID.toUnwrapped(),
                              );
                            G.uploadCommonUniforms(
                              G.context,
                              _e,
                              ae.toUnwrapped(),
                            );
                            const ze = { u_matrix: De, u_depth_bias: 0.001 };
                            _e.draw(
                              G,
                              Y.TRIANGLES,
                              ie.getShadowPassDepthMode(),
                              Yt.disabled,
                              ie.getShadowPassColorMode(),
                              Gt.disabled,
                              ze,
                              $.id,
                              ce.vertexBuffer,
                              ce.indexBuffer,
                              ce.shadowCasterSegments,
                              $.paint,
                              G.transform.zoom,
                              le,
                            );
                          }
                        })(z);
                  },
                  "fill-extrusion": function (c, t, s, h) {
                    const p = s.paint.get("fill-extrusion-opacity"),
                      g = c.context,
                      x = g.gl,
                      w = c.terrain,
                      S = w && w.renderingToTexture;
                    if (p === 0) return;
                    const C =
                        c.conflationActive &&
                        c.style.isLayerClipped(s, t.getSource()),
                      D = c.style.order.indexOf(s.fqid);
                    if (
                      (C &&
                        (function (L, z, O, G, U) {
                          for (const $ of G) {
                            const Z = z.getTile($).getBucket(O);
                            Z &&
                              (Z.updateReplacement($, L.replacementSource, U),
                              Z.uploadCentroid(L.context));
                          }
                        })(c, t, s, h, D),
                      w || C)
                    )
                      for (const L of h) {
                        const z = t.getTile(L).getBucket(s);
                        z && Tt(c.context, t, L, z, s, w, C);
                      }
                    if (c.renderPass === "shadow" && c.shadowRenderer) {
                      const L = c.shadowRenderer;
                      if (
                        w &&
                        p < 0.65 &&
                        s._transitionablePaint._values["fill-extrusion-opacity"]
                          .value.expression instanceof r.ab
                      )
                        return;
                      const z = L.getShadowPassDepthMode(),
                        O = L.getShadowPassColorMode();
                      co(c, t, s, h, z, Yt.disabled, O, C);
                    } else if (c.renderPass === "translucent") {
                      const L = !s.paint
                          .get("fill-extrusion-pattern")
                          .constantOr(1),
                        z = s.paint
                          .get("fill-extrusion-color")
                          .constantOr(r.am.white);
                      if (!S && z.a !== 0) {
                        const O = new wt(
                          c.context.gl.LEQUAL,
                          wt.ReadWrite,
                          c.depthRangeFor3D,
                        );
                        p === 1 && L
                          ? co(c, t, s, h, O, Yt.disabled, ui.unblended, C)
                          : (co(c, t, s, h, O, Yt.disabled, ui.disabled, C),
                            co(
                              c,
                              t,
                              s,
                              h,
                              O,
                              c.stencilModeFor3D(),
                              c.colorModeForRenderPass(),
                              C,
                            ),
                            c.resetStencilClippingMasks());
                      }
                      if (
                        c.style.enable3dLights() &&
                        L &&
                        ((!w && c.transform.projection.name !== "globe") || S)
                      ) {
                        const O = s.paint.get("fill-extrusion-opacity"),
                          G = s.paint.get(
                            "fill-extrusion-ambient-occlusion-intensity",
                          ),
                          U = s.paint.get(
                            "fill-extrusion-ambient-occlusion-ground-radius",
                          ),
                          $ = s.paint.get(
                            "fill-extrusion-flood-light-intensity",
                          ),
                          Z =
                            s.paint
                              .get("fill-extrusion-flood-light-color-use-theme")
                              .constantOr("default") === "none",
                          Y = s.paint
                            .get("fill-extrusion-flood-light-color")
                            .toNonPremultipliedRenderColor(Z ? null : s.lut)
                            .toArray01()
                            .slice(0, 3),
                          ie = G > 0 && U > 0,
                          ae = $ > 0,
                          pe = (ce, le, me) => (1 - me) * ce + me * le,
                          ue = (ce) => {
                            const le = c.depthModeForSublayer(
                                1,
                                wt.ReadOnly,
                                x.LEQUAL,
                                !0,
                              ),
                              me = s.paint.get(
                                ce
                                  ? "fill-extrusion-ambient-occlusion-ground-attenuation"
                                  : "fill-extrusion-flood-light-ground-attenuation",
                              ),
                              _e = pe(0.1, 3, me),
                              De = c._showOverdrawInspector;
                            if (!De) {
                              const ze = new Yt(
                                  { func: x.ALWAYS, mask: 255 },
                                  255,
                                  255,
                                  x.KEEP,
                                  x.KEEP,
                                  x.REPLACE,
                                ),
                                He = new ui(
                                  [x.ONE, x.ONE, x.ONE, x.ONE],
                                  r.am.transparent,
                                  [!1, !1, !1, !0],
                                  x.MIN,
                                );
                              ho(
                                c,
                                t,
                                s,
                                h,
                                le,
                                ze,
                                He,
                                Gt.disabled,
                                ce,
                                "sdf",
                                O,
                                G,
                                U,
                                $,
                                Y,
                                _e,
                                C,
                                !1,
                              );
                            }
                            {
                              const ze = De
                                  ? Yt.disabled
                                  : new Yt(
                                      { func: x.EQUAL, mask: 255 },
                                      255,
                                      255,
                                      x.KEEP,
                                      x.DECR,
                                      x.DECR,
                                    ),
                                He = De
                                  ? c.colorModeForRenderPass()
                                  : new ui(
                                      [
                                        x.ONE_MINUS_DST_ALPHA,
                                        x.DST_ALPHA,
                                        x.ONE,
                                        x.ONE,
                                      ],
                                      r.am.transparent,
                                      [!0, !0, !0, !0],
                                    );
                              ho(
                                c,
                                t,
                                s,
                                h,
                                le,
                                ze,
                                He,
                                Gt.disabled,
                                ce,
                                "color",
                                O,
                                G,
                                U,
                                $,
                                Y,
                                _e,
                                C,
                                !1,
                              );
                            }
                          };
                        if (S) {
                          const ce = (le, me, _e) => {
                            const De = c.depthModeForSublayer(
                                1,
                                wt.ReadOnly,
                                x.LEQUAL,
                                !1,
                              ),
                              ze = s.paint.get(
                                le
                                  ? "fill-extrusion-ambient-occlusion-ground-attenuation"
                                  : "fill-extrusion-flood-light-ground-attenuation",
                              ),
                              He = pe(0.1, 3, ze);
                            {
                              const We = new ui(
                                [x.ONE, x.ONE, x.ONE, x.ONE],
                                r.am.transparent,
                                [!1, !1, !1, !0],
                              );
                              ho(
                                c,
                                t,
                                s,
                                h,
                                De,
                                Yt.disabled,
                                We,
                                Gt.disabled,
                                le,
                                "clear",
                                O,
                                G,
                                U,
                                $,
                                Y,
                                He,
                                C,
                                me,
                              );
                            }
                            {
                              const We = new Yt(
                                  { func: x.ALWAYS, mask: 255 },
                                  255,
                                  255,
                                  x.KEEP,
                                  x.KEEP,
                                  x.REPLACE,
                                ),
                                et = new ui(
                                  [x.ONE, x.ONE, x.ONE, x.ONE],
                                  r.am.transparent,
                                  [!1, !1, !1, !0],
                                  x.MIN,
                                );
                              ho(
                                c,
                                t,
                                s,
                                h,
                                De,
                                We,
                                et,
                                Gt.disabled,
                                le,
                                "sdf",
                                O,
                                G,
                                U,
                                $,
                                Y,
                                He,
                                C,
                                me,
                              );
                            }
                            {
                              const We = le ? x.ZERO : x.ONE_MINUS_DST_ALPHA,
                                et = new Yt(
                                  { func: x.EQUAL, mask: 255 },
                                  255,
                                  255,
                                  x.KEEP,
                                  x.DECR,
                                  x.DECR,
                                ),
                                Ce = new ui(
                                  [
                                    We,
                                    x.DST_ALPHA,
                                    x.ONE_MINUS_DST_ALPHA,
                                    x.ZERO,
                                  ],
                                  r.am.transparent,
                                  [!0, !0, !0, !0],
                                );
                              ho(
                                c,
                                t,
                                s,
                                h,
                                De,
                                et,
                                Ce,
                                Gt.disabled,
                                le,
                                "color",
                                O,
                                G,
                                U,
                                $,
                                Y,
                                He,
                                C,
                                me,
                              );
                            }
                            {
                              const We = new ui(
                                [x.ONE, x.ONE, x.ONE, le ? x.ZERO : x.ONE],
                                r.am.transparent,
                                [!1, !1, !1, !0],
                                le ? x.FUNC_ADD : x.MAX,
                              );
                              ho(
                                c,
                                t,
                                s,
                                h,
                                De,
                                Yt.disabled,
                                We,
                                Gt.disabled,
                                le,
                                "clear",
                                O,
                                G,
                                U,
                                $,
                                Y,
                                He,
                                C,
                                me,
                                _e,
                              );
                            }
                          };
                          if (ie || ae) {
                            let le;
                            if ((c.prepareDrawTile(), w)) {
                              const me = w.drapeBufferSize[0],
                                _e = w.drapeBufferSize[1];
                              ((le = w.framebufferCopyTexture),
                                (le &&
                                  (!le ||
                                    (le.size[0] === me &&
                                      le.size[1] === _e))) ||
                                  (le && le.destroy(),
                                  (le = w.framebufferCopyTexture =
                                    new r.T(
                                      g,
                                      new r.r({ width: me, height: _e }),
                                      x.RGBA8,
                                    ))),
                                le.bind(x.LINEAR, x.CLAMP_TO_EDGE),
                                x.copyTexSubImage2D(
                                  x.TEXTURE_2D,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  me,
                                  _e,
                                ));
                            }
                            (ie && ce(!0, !1, le), ae && ce(!1, !0, le));
                          }
                        } else
                          (ie && ue(!0),
                            ae && ue(!1),
                            (ie || ae) && c.resetStencilClippingMasks());
                      }
                    }
                  },
                  building: function (c, t, s, h) {},
                  hillshade: function (c, t, s, h) {
                    if (
                      (c.renderPass !== "offscreen" &&
                        c.renderPass !== "translucent") ||
                      c.style.disableElevatedTerrain
                    )
                      return;
                    const p = c.context,
                      g = c.terrain && c.terrain.renderingToTexture,
                      [x, w] =
                        c.renderPass !== "translucent" || g
                          ? [{}, h]
                          : c.stencilConfigForOverlap(h);
                    for (const S of w) {
                      const C = t.getTile(S);
                      if (
                        C.needsHillshadePrepare &&
                        c.renderPass === "offscreen"
                      )
                        y_(c, C, s);
                      else if (c.renderPass === "translucent") {
                        const D = c.depthModeForSublayer(0, wt.ReadOnly),
                          L = s.paint.get("hillshade-emissive-strength"),
                          z = c.colorModeForDrapableLayerRenderPass(L),
                          O =
                            g && c.terrain
                              ? c.terrain.stencilModeForRTTOverlap(S)
                              : x[S.overscaledZ];
                        __(c, S, C, s, D, O, z);
                      }
                    }
                    (p.viewport.set([0, 0, c.width, c.height]),
                      c.resetStencilClippingMasks());
                  },
                  raster: function (c, t, s, h, p, g) {
                    if (
                      c.renderPass !== "translucent" ||
                      s.paint.get("raster-opacity") === 0
                    )
                      return;
                    const x = c.transform.projection.name === "globe",
                      w = s.paint.get("raster-elevation") !== 0,
                      S = w && x;
                    if (c.renderElevatedRasterBackface && !S) return;
                    const C = c.context,
                      D = C.gl,
                      L = t.getSource(),
                      z = (function (ue, ce, le, me) {
                        const _e = ce.paint.get("raster-color"),
                          De = ue.type === "raster-array",
                          ze = [],
                          He = ce.paint.get("raster-resampling"),
                          We = ce.paint.get("raster-color-mix");
                        let et = ce.paint.get("raster-color-range");
                        const Ce = [We[0], We[1], We[2], 0],
                          Ve = We[3];
                        let Te = He === "nearest" ? me.NEAREST : me.LINEAR;
                        if (
                          De &&
                          (ze.push("RASTER_ARRAY"),
                          _e || ze.push("RASTER_COLOR"),
                          He === "linear" && ze.push("RASTER_ARRAY_LINEAR"),
                          (Te = me.NEAREST),
                          !et && ue.rasterLayers)
                        ) {
                          const Ze = ue.rasterLayers.find(
                            ({ id: Oe }) => Oe === ce.sourceLayer,
                          );
                          Ze &&
                            Ze.fields &&
                            Ze.fields.range &&
                            (et = Ze.fields.range);
                        }
                        if (((et = et || [0, 1]), _e)) {
                          (ze.push("RASTER_COLOR"),
                            le.activeTexture.set(me.TEXTURE2),
                            ce.updateColorRamp(et));
                          let Ze = ce.colorRampTexture;
                          (Ze ||
                            (Ze = ce.colorRampTexture =
                              new r.T(le, ce.colorRamp, me.RGBA8)),
                            Ze.bind(me.LINEAR, me.CLAMP_TO_EDGE));
                        }
                        return {
                          mix: Ce,
                          range: et,
                          offset: Ve,
                          defines: ze,
                          resampling: Te,
                        };
                      })(L, s, C, D);
                    if (L instanceof r.aP && !h.length && !x) return;
                    const O = s.paint.get("raster-emissive-strength"),
                      G = c.colorModeForDrapableLayerRenderPass(O),
                      U = c.terrain && c.terrain.renderingToTexture,
                      $ = !c.options.moving,
                      Z =
                        s.paint.get("raster-resampling") === "nearest"
                          ? D.NEAREST
                          : D.LINEAR;
                    if (
                      L instanceof r.aP &&
                      !h.length &&
                      (L.onNorthPole || L.onSouthPole)
                    ) {
                      const ue = w ? c.stencilModeFor3D() : Yt.disabled;
                      return void Oc(
                        !!L.onNorthPole,
                        null,
                        c,
                        t,
                        s,
                        O,
                        z,
                        Gt.disabled,
                        ue,
                      );
                    }
                    if (!h.length) return;
                    const [Y, ie] =
                        L instanceof r.aP || U
                          ? [{}, h]
                          : c.stencilConfigForOverlap(h),
                      ae = ie[ie.length - 1].overscaledZ;
                    (S && z.defines.push("PROJECTION_GLOBE_VIEW"),
                      w && z.defines.push("RENDER_CUTOFF"));
                    const pe = (ue, ce, le) => {
                      for (const me of ue) {
                        const _e = me.toUnwrapped(),
                          De = t.getTile(me);
                        if (U && (!De || !De.hasData())) continue;
                        C.activeTexture.set(D.TEXTURE0);
                        const ze = O_(De, L, s, z);
                        if (!ze || !ze.texture) continue;
                        const {
                          texture: He,
                          mix: We,
                          offset: et,
                          tileSize: Ce,
                          buffer: Ve,
                        } = ze;
                        let Te, Ze;
                        U
                          ? ((Te = wt.disabled), (Ze = me.projMatrix))
                          : w
                            ? ((Te = new wt(
                                D.LEQUAL,
                                wt.ReadWrite,
                                c.depthRangeFor3D,
                              )),
                              (Ze = x
                                ? Float32Array.from(
                                    c.transform.expandedFarZProjMatrix,
                                  )
                                : c.transform.calculateProjMatrix(_e, $)))
                            : ((Te = c.depthModeForSublayer(
                                me.overscaledZ - ae,
                                s.paint.get("raster-opacity") === 1
                                  ? wt.ReadWrite
                                  : wt.ReadOnly,
                                D.LESS,
                              )),
                              (Ze = c.transform.calculateProjMatrix(_e, $)));
                        const Oe =
                            c.terrain && U
                              ? c.terrain.stencilModeForRTTOverlap(me)
                              : Y[me.overscaledZ],
                          Ke = g ? 0 : s.paint.get("raster-fade-duration");
                        De.registerFadeDuration(Ke);
                        const ht = t.findLoadedParent(me, 0),
                          qe = Ia(De, ht, t, c.transform, Ke);
                        let lt, St;
                        (c.terrain && c.terrain.prepareDrawTile(),
                          C.activeTexture.set(D.TEXTURE0),
                          He.bind(Z, D.CLAMP_TO_EDGE),
                          C.activeTexture.set(D.TEXTURE1),
                          ht
                            ? (ht.texture &&
                                ht.texture.bind(Z, D.CLAMP_TO_EDGE),
                              (lt = Math.pow(
                                2,
                                ht.tileID.overscaledZ - De.tileID.overscaledZ,
                              )),
                              (St = [
                                (De.tileID.canonical.x * lt) % 1,
                                (De.tileID.canonical.y * lt) % 1,
                              ]))
                            : He.bind(Z, D.CLAMP_TO_EDGE),
                          "useMipmap" in He &&
                            C.extTextureFilterAnisotropic &&
                            c.transform.pitch > 20 &&
                            D.texParameterf(
                              D.TEXTURE_2D,
                              C.extTextureFilterAnisotropic
                                .TEXTURE_MAX_ANISOTROPY_EXT,
                              C.extTextureFilterAnisotropicMax,
                            ));
                        const Et = c.transform;
                        let bt;
                        const kt = w ? L_(Et) : [0, 0, 0, 0];
                        let Bt,
                          Vt,
                          Zt,
                          si,
                          Fi,
                          nn = 0;
                        if (S && L instanceof r.aP && L.coordinates.length > 3)
                          ((Bt = Float32Array.from(
                            r.bh(r.dr(new r.cp(0, 0, 0))),
                          )),
                            (Vt = Float32Array.from(Et.globeMatrix)),
                            (Zt = Float32Array.from(r.dm(Et))),
                            (si = [r.aD(Et.center.lng), r.aH(Et.center.lat)]),
                            (bt = L.elevatedGlobePerspectiveTransform),
                            (Fi =
                              L.elevatedGlobeGridMatrix ||
                              new Float32Array(9)));
                        else if (S) {
                          const ti = r.dn(me.canonical);
                          ((nn = r.dp(ti.getCenter().lat)),
                            (Bt = Float32Array.from(r.bh(r.dr(me.canonical)))),
                            (Vt = Float32Array.from(Et.globeMatrix)),
                            (Zt = Float32Array.from(r.dm(Et))),
                            (si = [r.aD(Et.center.lng), r.aH(Et.center.lat)]),
                            (bt = [0, 0]),
                            (Fi = Float32Array.from(
                              r.dq(
                                me.canonical,
                                ti,
                                nn,
                                Et.worldSize / Et._pixelsPerMercatorPixel,
                              ),
                            )));
                        } else
                          ((bt =
                            L instanceof r.aP
                              ? L.perspectiveTransform
                              : [0, 0]),
                            (Bt = new Float32Array(16)),
                            (Vt = new Float32Array(9)),
                            (Zt = new Float32Array(16)),
                            (si = [0, 0]),
                            (Fi = new Float32Array(9)));
                        const ji = zd(
                            Ze,
                            Bt,
                            Vt,
                            Zt,
                            Fi,
                            St || [0, 0],
                            r.ah(c.transform.zoom),
                            si,
                            kt,
                            lt || 1,
                            qe,
                            s,
                            bt,
                            w ? s.paint.get("raster-elevation") : 0,
                            2,
                            We,
                            et,
                            z.range,
                            Ce,
                            Ve,
                            O,
                          ),
                          Hi = c.isTileAffectedByFog(me),
                          Fn = c.getOrCreateProgram("raster", {
                            defines: z.defines,
                            overrideFog: Hi,
                          });
                        if (
                          (c.uploadCommonUniforms(C, Fn, _e), L instanceof r.aP)
                        ) {
                          const ti = L.elevatedGlobeVertexBuffer,
                            li = L.elevatedGlobeIndexBuffer;
                          if (U || !x)
                            L.boundsBuffer &&
                              L.boundsSegments &&
                              Fn.draw(
                                c,
                                D.TRIANGLES,
                                Te,
                                Yt.disabled,
                                G,
                                Gt.disabled,
                                ji,
                                s.id,
                                L.boundsBuffer,
                                c.quadTriangleIndexBuffer,
                                L.boundsSegments,
                              );
                          else if (ti && li) {
                            const gi =
                              Et.zoom <= r.cL
                                ? L.elevatedGlobeSegments
                                : L.getSegmentsForLongitude(Et.center.lng);
                            gi &&
                              Fn.draw(
                                c,
                                D.TRIANGLES,
                                Te,
                                Yt.disabled,
                                G,
                                ce,
                                ji,
                                s.id,
                                ti,
                                li,
                                gi,
                              );
                          }
                        } else if (S) {
                          Te = new wt(D.LEQUAL, wt.ReadOnly, c.depthRangeFor3D);
                          const ti = c.globeSharedBuffers;
                          if (ti) {
                            const [li, gi, cn] = ti.getGridBuffers(nn, !1);
                            Fn.draw(
                              c,
                              D.TRIANGLES,
                              Te,
                              le || Oe,
                              c.colorModeForRenderPass(),
                              ce,
                              ji,
                              s.id,
                              li,
                              gi,
                              cn,
                            );
                          }
                        } else {
                          const {
                            tileBoundsBuffer: ti,
                            tileBoundsIndexBuffer: li,
                            tileBoundsSegments: gi,
                          } = c.getTileBoundsBuffers(De);
                          Fn.draw(
                            c,
                            D.TRIANGLES,
                            Te,
                            Oe,
                            G,
                            Gt.disabled,
                            ji,
                            s.id,
                            ti,
                            li,
                            gi,
                          );
                        }
                      }
                      if (!(L instanceof r.aP) && S)
                        for (const me of ue) {
                          const _e =
                            me.canonical.y === (1 << me.canonical.z) - 1;
                          (me.canonical.y === 0 &&
                            Oc(!0, me, c, t, s, O, z, ce, le || Yt.disabled),
                            _e &&
                              Oc(
                                !1,
                                me,
                                c,
                                t,
                                s,
                                O,
                                z,
                                ce === Gt.frontCW ? Gt.backCW : Gt.frontCW,
                                le || Yt.disabled,
                              ));
                        }
                    };
                    (S
                      ? pe(
                          ie,
                          c.renderElevatedRasterBackface
                            ? Gt.backCW
                            : Gt.frontCW,
                          c.stencilModeFor3D(),
                        )
                      : pe(ie, Gt.disabled, void 0),
                      c.resetStencilClippingMasks());
                  },
                  "raster-particle": function (c, t, s, h, p, g) {
                    (c.renderPass === "offscreen" &&
                      (function (x, w, S, C) {
                        if (!C.length) return;
                        const D = x.context,
                          L = D.gl,
                          z = w.getSource();
                        if (!(z instanceof Po)) return;
                        const O = Math.ceil(
                          Math.sqrt(S.paint.get("raster-particle-count")),
                        );
                        let G = S.particlePositionRGBAImage;
                        if (!G || G.width !== O) {
                          const ie = (function (ae) {
                            const pe = ae * ae,
                              ue = new Uint8Array(4 * pe),
                              ce = function (me) {
                                return (
                                  (me |= 0),
                                  (me = Math.imul(2747636419 ^ me, 2654435769)),
                                  (me = Math.imul(
                                    me ^ (me >>> 16),
                                    2654435769,
                                  )),
                                  ((me = Math.imul(
                                    me ^ (me >>> 16),
                                    2654435769,
                                  )) >>>
                                    0) /
                                    4294967296
                                );
                              },
                              le = 1 / 1.1;
                            for (let me = 0; me < pe; me++) {
                              const _e = le * (ce(2 * me + 0) + Fo),
                                De = le * (ce(2 * me + 1) + Fo),
                                ze = (255 * _e) % 1,
                                He = (255 * De) % 1,
                                We = ze,
                                et = De - He / 255,
                                Ce = He;
                              ((ue[4 * me + 0] = 255 * (_e - ze / 255)),
                                (ue[4 * me + 1] = 255 * We),
                                (ue[4 * me + 2] = 255 * et),
                                (ue[4 * me + 3] = 255 * Ce));
                            }
                            return ue;
                          })(O);
                          G = S.particlePositionRGBAImage = new r.r(
                            { width: O, height: O },
                            ie,
                          );
                        }
                        let U = S.particleFramebuffer;
                        U
                          ? U.width !== O &&
                            (U.destroy(),
                            (U = S.particleFramebuffer =
                              D.createFramebuffer(O, O, !0, null)))
                          : (U = S.particleFramebuffer =
                              D.createFramebuffer(O, O, !0, null));
                        const $ = [];
                        for (const ie of C) {
                          const ae = w.getTile(ie);
                          if (!(ae instanceof tl)) continue;
                          const pe = F_(ae, z, S);
                          if (!pe) continue;
                          const ue = [ae.tileSize, ae.tileSize];
                          let ce = S.tileFramebuffer;
                          ce ||
                            (ce = S.tileFramebuffer =
                              D.createFramebuffer(ue[0], ue[1], !0, null));
                          let le = ae.rasterParticleState;
                          le ||
                            (le = ae.rasterParticleState =
                              new Qp(D, ie, ue, G));
                          const me = le.update(S.lastInvalidatedAt);
                          le.particleTextureDimension !== O &&
                            le.updateParticleTexture(ie, G);
                          const _e = le.targetColorTexture;
                          ((le.targetColorTexture = le.backgroundColorTexture),
                            (le.backgroundColorTexture = _e));
                          const De = le.particleTexture0;
                          ((le.particleTexture0 = le.particleTexture1),
                            (le.particleTexture1 = De),
                            $.push([ie, pe, le, me]));
                        }
                        if ($.length === 0) return;
                        const Z = r.q.now(),
                          Y = S.previousDrawTimestamp
                            ? 0.001 * (Z - S.previousDrawTimestamp)
                            : 0.0167;
                        if (((S.previousDrawTimestamp = Z), S.hasColorMap())) {
                          D.activeTexture.set(L.TEXTURE0 + 2);
                          let ie = S.colorRampTexture;
                          (ie ||
                            (ie = S.colorRampTexture =
                              new r.T(D, S.colorRamp, L.RGBA8)),
                            ie.bind(L.LINEAR, L.CLAMP_TO_EDGE));
                        }
                        (D.bindFramebuffer.set(S.tileFramebuffer.framebuffer),
                          (function (ie, ae, pe) {
                            const ue = ie.context,
                              ce = ue.gl,
                              le = ae.tileFramebuffer;
                            ue.activeTexture.set(ce.TEXTURE0);
                            const me = {
                                u_texture: 0,
                                u_opacity:
                                  (1.05 *
                                    (De = ae.paint.get(
                                      "raster-particle-fade-opacity-factor",
                                    ))) /
                                  (De + 0.05),
                              },
                              _e = ie.getOrCreateProgram(
                                "rasterParticleTexture",
                                { defines: [], overrideFog: !1 },
                              );
                            var De;
                            for (const ze of pe) {
                              const [, , He, We] = ze;
                              (le.colorAttachment.set(
                                He.targetColorTexture.texture,
                              ),
                                ue.viewport.set([0, 0, le.width, le.height]),
                                ue.clear({ color: r.am.transparent }),
                                We &&
                                  (He.backgroundColorTexture.bind(
                                    ce.NEAREST,
                                    ce.CLAMP_TO_EDGE,
                                  ),
                                  _e.draw(
                                    ie,
                                    ce.TRIANGLES,
                                    wt.disabled,
                                    Yt.disabled,
                                    ui.alphaBlended,
                                    Gt.disabled,
                                    me,
                                    ae.id,
                                    ie.viewportBuffer,
                                    ie.quadTriangleIndexBuffer,
                                    ie.viewportSegments,
                                  )));
                            }
                          })(x, S, $),
                          (function (ie, ae, pe, ue) {
                            const ce = ie.context,
                              le = ce.gl,
                              me = pe.tileFramebuffer,
                              _e = ie.transform.projection.name === "globe",
                              De = pe.paint.get("raster-particle-max-speed");
                            for (const ze of ue) {
                              const [He, We, et] = ze;
                              (ce.activeTexture.set(le.TEXTURE0 + 0),
                                We.texture.bind(le.LINEAR, le.CLAMP_TO_EDGE),
                                me.colorAttachment.set(
                                  et.targetColorTexture.texture,
                                ));
                              const Ce = ie.getOrCreateProgram(
                                "rasterParticleDraw",
                                { defines: We.defines, overrideFog: !1 },
                              );
                              ce.activeTexture.set(le.TEXTURE0 + 1);
                              const Ve = We.scalarData
                                ? []
                                : [0, 1, 2, 3].map((Oe) => r.dT[Oe](He));
                              Ve.push(He);
                              const Te = He.canonical.x,
                                Ze = He.canonical.y;
                              for (const Oe of Ve) {
                                const Ke = ae.getTile(_e ? Oe.wrapped() : Oe);
                                if (!Ke) continue;
                                const ht = Ke.rasterParticleState;
                                if (!ht) continue;
                                const qe =
                                    Oe.canonical.x +
                                    (1 << Oe.canonical.z) * (Oe.wrap - He.wrap),
                                  lt = Oe.canonical.y;
                                ht.particleTexture0.bind(
                                  le.NEAREST,
                                  le.CLAMP_TO_EDGE,
                                );
                                const St = qp(
                                  1,
                                  ht.particleTexture0.size[0],
                                  [qe - Te, lt - Ze],
                                  0,
                                  We.texture.size,
                                  2,
                                  De,
                                  We.textureOffset,
                                  We.scale,
                                  We.offset,
                                );
                                Ce.draw(
                                  ie,
                                  le.POINTS,
                                  wt.disabled,
                                  Yt.disabled,
                                  ui.alphaBlended,
                                  Gt.disabled,
                                  St,
                                  pe.id,
                                  ht.particleIndexBuffer,
                                  void 0,
                                  ht.particleSegment,
                                );
                              }
                            }
                          })(x, w, S, $),
                          D.bindFramebuffer.set(
                            S.particleFramebuffer.framebuffer,
                          ),
                          (function (ie, ae, pe, ue) {
                            const ce = ie.context,
                              le = ce.gl,
                              me = ae.paint.get("raster-particle-max-speed"),
                              _e =
                                ue *
                                ae.paint.get("raster-particle-speed-factor") *
                                0.15,
                              De = (function (He) {
                                return Math.pow(He, 6);
                              })(
                                0.01 +
                                  1 *
                                    ae.paint.get(
                                      "raster-particle-reset-rate-factor",
                                    ),
                              ),
                              ze = ae.particleFramebuffer;
                            ce.viewport.set([0, 0, ze.width, ze.height]);
                            for (const He of pe) {
                              const [, We, et] = He;
                              (ce.activeTexture.set(le.TEXTURE0 + 0),
                                We.texture.bind(le.LINEAR, le.CLAMP_TO_EDGE),
                                ce.activeTexture.set(le.TEXTURE0 + 1));
                              const Ce = et.particleTexture0;
                              Ce.bind(le.NEAREST, le.CLAMP_TO_EDGE);
                              const Ve = Bo(
                                1,
                                Ce.size[0],
                                0,
                                We.texture.size,
                                me,
                                _e,
                                De,
                                We.textureOffset,
                                We.scale,
                                We.offset,
                              );
                              (ze.colorAttachment.set(
                                et.particleTexture1.texture,
                              ),
                                ce.clear({ color: r.am.transparent }),
                                ie
                                  .getOrCreateProgram("rasterParticleUpdate", {
                                    defines: We.defines,
                                  })
                                  .draw(
                                    ie,
                                    le.TRIANGLES,
                                    wt.disabled,
                                    Yt.disabled,
                                    ui.unblended,
                                    Gt.disabled,
                                    Ve,
                                    ae.id,
                                    ie.viewportBuffer,
                                    ie.quadTriangleIndexBuffer,
                                    ie.viewportSegments,
                                  ));
                            }
                          })(x, S, $, Y));
                      })(c, t, s, h),
                      c.renderPass === "translucent" &&
                        ((function (x, w, S, C, D) {
                          const L = x.context,
                            z = L.gl,
                            O = w.getSource().tileSize,
                            G =
                              5 *
                                (1 - r.af(r.cx, r.cx + 1, x.transform.zoom)) *
                                O +
                              S.paint.get("raster-particle-elevation"),
                            U = !x.options.moving,
                            $ = x.transform.projection.name === "globe";
                          if (!C.length) return;
                          const [Z, Y] = x.stencilConfigForOverlap(C),
                            ie = [];
                          $ && ie.push("PROJECTION_GLOBE_VIEW");
                          const ae = x.stencilModeFor3D();
                          for (const pe of Y) {
                            const ue = pe.toUnwrapped(),
                              ce = w.getTile(pe);
                            if (!ce.rasterParticleState) continue;
                            const le = ce.rasterParticleState,
                              me = 100;
                            ce.registerFadeDuration(me);
                            const _e = w.findLoadedParent(pe, 0),
                              De = Ia(ce, _e, w, x.transform, me);
                            let ze, He;
                            (x.terrain && x.terrain.prepareDrawTile(),
                              L.activeTexture.set(z.TEXTURE0),
                              le.targetColorTexture.bind(
                                z.LINEAR,
                                z.CLAMP_TO_EDGE,
                              ),
                              L.activeTexture.set(z.TEXTURE1),
                              _e && _e.rasterParticleState
                                ? (_e.rasterParticleState.targetColorTexture.bind(
                                    z.LINEAR,
                                    z.CLAMP_TO_EDGE,
                                  ),
                                  (ze = Math.pow(
                                    2,
                                    _e.tileID.overscaledZ -
                                      ce.tileID.overscaledZ,
                                  )),
                                  (He = [
                                    (ce.tileID.canonical.x * ze) % 1,
                                    (ce.tileID.canonical.y * ze) % 1,
                                  ]))
                                : le.targetColorTexture.bind(
                                    z.LINEAR,
                                    z.CLAMP_TO_EDGE,
                                  ));
                            const We = $
                                ? Float32Array.from(
                                    x.transform.expandedFarZProjMatrix,
                                  )
                                : x.transform.calculateProjMatrix(ue, U),
                              et = x.transform,
                              Ce = em(et),
                              Ve = r.dn(pe.canonical),
                              Te = r.dp(Ve.getCenter().lat);
                            let Ze, Oe, Ke, ht, qe;
                            $
                              ? ((Ze = Float32Array.from(
                                  r.bh(r.dr(pe.canonical)),
                                )),
                                (Oe = Float32Array.from(et.globeMatrix)),
                                (Ke = Float32Array.from(r.dm(et))),
                                (ht = [
                                  r.aD(et.center.lng),
                                  r.aH(et.center.lat),
                                ]),
                                (qe = Float32Array.from(
                                  r.dq(
                                    pe.canonical,
                                    Ve,
                                    Te,
                                    et.worldSize / et._pixelsPerMercatorPixel,
                                  ),
                                )))
                              : ((Ze = new Float32Array(16)),
                                (Oe = new Float32Array(9)),
                                (Ke = new Float32Array(16)),
                                (ht = [0, 0]),
                                (qe = new Float32Array(9)));
                            const lt = Ca(
                                We,
                                Ze,
                                Oe,
                                Ke,
                                qe,
                                He || [0, 0],
                                r.ah(x.transform.zoom),
                                ht,
                                Ce,
                                ze || 1,
                                De,
                                G,
                              ),
                              St = x.isTileAffectedByFog(pe),
                              Et = x.getOrCreateProgram("rasterParticle", {
                                defines: ie,
                                overrideFog: St,
                              });
                            if ((x.uploadCommonUniforms(L, Et, ue), $)) {
                              const bt = new wt(
                                  z.LEQUAL,
                                  wt.ReadOnly,
                                  x.depthRangeFor3D,
                                ),
                                kt = 0,
                                Bt = x.globeSharedBuffers;
                              if (Bt) {
                                const [Vt, Zt, si] = Bt.getGridBuffers(
                                  Te,
                                  kt !== 0,
                                );
                                Et.draw(
                                  x,
                                  z.TRIANGLES,
                                  bt,
                                  ae,
                                  ui.alphaBlended,
                                  x.renderElevatedRasterBackface
                                    ? Gt.frontCCW
                                    : Gt.backCCW,
                                  lt,
                                  S.id,
                                  Vt,
                                  Zt,
                                  si,
                                );
                              }
                            } else {
                              const bt = x.depthModeForSublayer(0, wt.ReadOnly),
                                kt = Z[pe.overscaledZ],
                                {
                                  tileBoundsBuffer: Bt,
                                  tileBoundsIndexBuffer: Vt,
                                  tileBoundsSegments: Zt,
                                } = x.getTileBoundsBuffers(ce);
                              Et.draw(
                                x,
                                z.TRIANGLES,
                                bt,
                                kt,
                                ui.alphaBlended,
                                Gt.disabled,
                                lt,
                                S.id,
                                Bt,
                                Vt,
                                Zt,
                              );
                            }
                          }
                          x.resetStencilClippingMasks();
                        })(c, t, s, h),
                        c.style.map.triggerRepaint()));
                  },
                  background: function (c, t, s, h) {
                    const p = s.paint.get("background-color"),
                      g =
                        s.paint
                          .get("background-color-use-theme")
                          .constantOr("default") === "none",
                      x = s.paint.get("background-opacity"),
                      w = s.paint.get("background-emissive-strength"),
                      S =
                        s.paint.get("background-pitch-alignment") ===
                        "viewport";
                    if (x === 0) return;
                    const C = c.context,
                      D = C.gl,
                      L = c.transform,
                      z = L.tileSize,
                      O = s.paint.get("background-pattern");
                    let G;
                    if (
                      O !== void 0 &&
                      (O === null ||
                        ((G = c.imageManager.getPattern(
                          r.I.from(O.toString()),
                          s.scope,
                          c.style.getLut(s.scope),
                        )),
                        !G))
                    )
                      return;
                    const U =
                      !O &&
                      p.a === 1 &&
                      x === 1 &&
                      c.opaquePassEnabledForLayer()
                        ? "opaque"
                        : "translucent";
                    if (c.renderPass !== U) return;
                    const $ = Yt.disabled,
                      Z = c.depthModeForSublayer(
                        0,
                        U === "opaque" ? wt.ReadWrite : wt.ReadOnly,
                      ),
                      Y = c.colorModeForDrapableLayerRenderPass(w),
                      ie = O ? "backgroundPattern" : "background";
                    let ae,
                      pe = h;
                    if (
                      (pe ||
                        ((ae = c.getBackgroundTiles()),
                        (pe = Object.values(ae).map((ue) => ue.tileID))),
                      O &&
                        (C.activeTexture.set(D.TEXTURE0),
                        c.imageManager.bind(c.context, s.scope)),
                      S)
                    ) {
                      const ue = c.getOrCreateProgram(ie, {
                          overrideFog: !1,
                          overrideRtt: !0,
                        }),
                        ce = new Float32Array(r.bx([])),
                        le = new r.aM(0, 0, 0, 0, 0),
                        me = O
                          ? Ld(ce, w, x, c, 0, s.scope, G, S, {
                              tileID: le,
                              tileSize: z,
                            })
                          : kd(
                              ce,
                              w,
                              x,
                              p.toPremultipliedRenderColor(g ? null : s.lut),
                            );
                      ue.draw(
                        c,
                        D.TRIANGLES,
                        Z,
                        $,
                        Y,
                        Gt.disabled,
                        me,
                        s.id,
                        c.viewportBuffer,
                        c.quadTriangleIndexBuffer,
                        c.viewportSegments,
                      );
                    } else
                      for (const ue of pe) {
                        const ce = c.isTileAffectedByFog(ue),
                          le = c.getOrCreateProgram(ie, { overrideFog: ce }),
                          me = ue.toUnwrapped(),
                          _e = h
                            ? ue.projMatrix
                            : c.transform.calculateProjMatrix(me);
                        c.prepareDrawTile();
                        const De = t
                            ? t.getTile(ue)
                            : ae
                              ? ae[ue.key]
                              : new fa(ue, z, L.zoom, c),
                          ze = O
                            ? Ld(_e, w, x, c, 0, s.scope, G, S, {
                                tileID: ue,
                                tileSize: z,
                              })
                            : kd(
                                _e,
                                w,
                                x,
                                p.toPremultipliedRenderColor(g ? null : s.lut),
                              );
                        c.uploadCommonUniforms(C, le, me);
                        const {
                          tileBoundsBuffer: He,
                          tileBoundsIndexBuffer: We,
                          tileBoundsSegments: et,
                        } = c.getTileBoundsBuffers(De);
                        le.draw(
                          c,
                          D.TRIANGLES,
                          Z,
                          $,
                          Y,
                          Gt.disabled,
                          ze,
                          s.id,
                          He,
                          We,
                          et,
                        );
                      }
                  },
                  sky: function (c, t, s) {
                    const h = c._atmosphere ? r.ah(c.transform.zoom) : 1,
                      p = s.paint.get("sky-opacity") * h;
                    if (p === 0) return;
                    const g = c.context,
                      x = s.paint.get("sky-type"),
                      w = new wt(g.gl.LEQUAL, wt.ReadOnly, [0, 1]),
                      S = (c.frameCounter / 1e3) % 1;
                    x === "atmosphere"
                      ? c.renderPass === "offscreen"
                        ? s.needsSkyboxCapture(c) &&
                          ((function (C, D, L, z) {
                            const O = C.context,
                              G = O.gl;
                            let U = D.skyboxFbo;
                            if (!U) {
                              ((U = D.skyboxFbo =
                                O.createFramebuffer(32, 32, !0, null)),
                                (D.skyboxGeometry = new Fc(O)),
                                (D.skyboxTexture = O.gl.createTexture()),
                                G.bindTexture(
                                  G.TEXTURE_CUBE_MAP,
                                  D.skyboxTexture,
                                ),
                                G.texParameteri(
                                  G.TEXTURE_CUBE_MAP,
                                  G.TEXTURE_WRAP_S,
                                  G.CLAMP_TO_EDGE,
                                ),
                                G.texParameteri(
                                  G.TEXTURE_CUBE_MAP,
                                  G.TEXTURE_WRAP_T,
                                  G.CLAMP_TO_EDGE,
                                ),
                                G.texParameteri(
                                  G.TEXTURE_CUBE_MAP,
                                  G.TEXTURE_MIN_FILTER,
                                  G.LINEAR,
                                ),
                                G.texParameteri(
                                  G.TEXTURE_CUBE_MAP,
                                  G.TEXTURE_MAG_FILTER,
                                  G.LINEAR,
                                ));
                              for (let ie = 0; ie < 6; ++ie)
                                G.texImage2D(
                                  G.TEXTURE_CUBE_MAP_POSITIVE_X + ie,
                                  0,
                                  G.RGBA,
                                  32,
                                  32,
                                  0,
                                  G.RGBA,
                                  G.UNSIGNED_BYTE,
                                  null,
                                );
                            }
                            (O.bindFramebuffer.set(U.framebuffer),
                              O.viewport.set([0, 0, 32, 32]));
                            const $ = D.getCenter(C, !0),
                              Z = C.getOrCreateProgram("skyboxCapture"),
                              Y = new Float64Array(16);
                            (r.bx(Y),
                              r.e3(Y, Y, 0.5 * -Math.PI),
                              Uo(C, D, Z, Y, $, 0),
                              r.bx(Y),
                              r.e3(Y, Y, 0.5 * Math.PI),
                              Uo(C, D, Z, Y, $, 1),
                              r.bx(Y),
                              r.cG(Y, Y, 0.5 * -Math.PI),
                              Uo(C, D, Z, Y, $, 2),
                              r.bx(Y),
                              r.cG(Y, Y, 0.5 * Math.PI),
                              Uo(C, D, Z, Y, $, 3),
                              r.bx(Y),
                              Uo(C, D, Z, Y, $, 4),
                              r.bx(Y),
                              r.e3(Y, Y, Math.PI),
                              Uo(C, D, Z, Y, $, 5),
                              O.viewport.set([0, 0, C.width, C.height]));
                          })(c, s),
                          s.markSkyboxValid(c))
                        : c.renderPass === "sky" &&
                          (function (C, D, L, z, O) {
                            const G = C.context,
                              U = G.gl,
                              $ = C.transform,
                              Z = C.getOrCreateProgram("skybox");
                            (G.activeTexture.set(U.TEXTURE0),
                              U.bindTexture(
                                U.TEXTURE_CUBE_MAP,
                                D.skyboxTexture,
                              ));
                            const Y = ((ie, ae, pe, ue, ce) => ({
                              u_matrix: ie,
                              u_sun_direction: ae,
                              u_cubemap: 0,
                              u_opacity: ue,
                              u_temporal_offset: ce,
                            }))($.skyboxMatrix, D.getCenter(C, !1), 0, z, O);
                            (C.uploadCommonUniforms(G, Z),
                              Z.draw(
                                C,
                                U.TRIANGLES,
                                L,
                                Yt.disabled,
                                C.colorModeForRenderPass(),
                                Gt.backCW,
                                Y,
                                "skybox",
                                D.skyboxGeometry.vertexBuffer,
                                D.skyboxGeometry.indexBuffer,
                                D.skyboxGeometry.segment,
                              ));
                          })(c, s, w, p, S)
                      : x === "gradient" &&
                        c.renderPass === "sky" &&
                        (function (C, D, L, z, O) {
                          const G = C.context,
                            U = G.gl,
                            $ = C.transform,
                            Z = C.getOrCreateProgram("skyboxGradient");
                          (D.skyboxGeometry || (D.skyboxGeometry = new Fc(G)),
                            G.activeTexture.set(U.TEXTURE0));
                          let Y = D.colorRampTexture;
                          (Y ||
                            (Y = D.colorRampTexture =
                              new r.T(G, D.colorRamp, U.RGBA8)),
                            Y.bind(U.LINEAR, U.CLAMP_TO_EDGE));
                          const ie = ((ae, pe, ue, ce, le) => ({
                            u_matrix: ae,
                            u_color_ramp: 0,
                            u_center_direction: pe,
                            u_radius: r.al(ue),
                            u_opacity: ce,
                            u_temporal_offset: le,
                          }))(
                            $.skyboxMatrix,
                            D.getCenter(C, !1),
                            D.paint.get("sky-gradient-radius"),
                            z,
                            O,
                          );
                          (C.uploadCommonUniforms(G, Z),
                            Z.draw(
                              C,
                              U.TRIANGLES,
                              L,
                              Yt.disabled,
                              C.colorModeForRenderPass(),
                              Gt.backCW,
                              ie,
                              "skyboxGradient",
                              D.skyboxGeometry.vertexBuffer,
                              D.skyboxGeometry.indexBuffer,
                              D.skyboxGeometry.segment,
                            ));
                        })(c, s, w, p, S);
                  },
                  custom: function (c, t, s, h) {
                    const p = c.context,
                      g = s.implementation;
                    if (
                      !c.transform.projection.unsupportedLayers ||
                      !c.transform.projection.unsupportedLayers.includes(
                        "custom",
                      ) ||
                      (c.terrain &&
                        (c.terrain.renderingToTexture ||
                          c.renderPass === "offscreen") &&
                        s.isDraped(t))
                    ) {
                      if (c.renderPass === "offscreen") {
                        const x = g.prerender;
                        if (x) {
                          if (
                            (c.setCustomLayerDefaults(),
                            p.setColorMode(c.colorModeForRenderPass()),
                            c.transform.projection.name === "globe")
                          ) {
                            const w = c.transform.pointMerc;
                            x.call(
                              g,
                              p.gl,
                              c.transform.customLayerMatrix(),
                              c.transform.getProjection(),
                              c.transform.globeToMercatorMatrix(),
                              r.ah(c.transform.zoom),
                              [w.x, w.y],
                              c.transform.pixelsPerMeterRatio,
                            );
                          } else
                            x.call(g, p.gl, c.transform.customLayerMatrix());
                          (p.setDirty(), c.setBaseState());
                        }
                      } else if (c.renderPass === "translucent") {
                        if (c.terrain && c.terrain.renderingToTexture) {
                          const w = g.renderToTile;
                          if (w) {
                            const S = h[0].canonical,
                              C = {
                                x:
                                  S.x +
                                  h[0].wrap * (g.wrapTileId ? 0 : 1 << S.z),
                                y: S.y,
                                z: S.z,
                              };
                            (p.setDepthMode(wt.disabled),
                              p.setStencilMode(Yt.disabled),
                              p.setColorMode(c.colorModeForRenderPass()),
                              c.setCustomLayerDefaults(),
                              w.call(g, p.gl, C),
                              p.setDirty(),
                              c.setBaseState());
                          }
                          return;
                        }
                        (c.setCustomLayerDefaults(),
                          p.setColorMode(c.colorModeForRenderPass()),
                          p.setStencilMode(Yt.disabled));
                        const x =
                          g.renderingMode === "3d"
                            ? new wt(
                                c.context.gl.LEQUAL,
                                wt.ReadWrite,
                                c.depthRangeFor3D,
                              )
                            : c.depthModeForSublayer(0, wt.ReadOnly);
                        if (
                          (p.setDepthMode(x),
                          c.transform.projection.name === "globe")
                        ) {
                          const w = c.transform.pointMerc;
                          g.render(
                            p.gl,
                            c.transform.customLayerMatrix(),
                            c.transform.getProjection(),
                            c.transform.globeToMercatorMatrix(),
                            r.ah(c.transform.zoom),
                            [w.x, w.y],
                            c.transform.pixelsPerMeterRatio,
                          );
                        } else g.render(p.gl, c.transform.customLayerMatrix());
                        (p.setDirty(),
                          c.setBaseState(),
                          p.bindFramebuffer.set(null));
                      }
                    } else
                      r.w(
                        "Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.",
                      );
                  },
                  model: function (c, t, s, h) {
                    if (c.renderPass === "opaque") return;
                    const p = s.paint.get("model-opacity").constantOr(1);
                    if (p === 0) return;
                    const g = s.paint.get("model-cast-shadows");
                    if (
                      c.renderPass === "shadow" &&
                      (!g ||
                        (c.terrain &&
                          p < 0.65 &&
                          s._transitionablePaint._values["model-opacity"].value
                            .expression instanceof r.ab))
                    )
                      return;
                    const x = c.shadowRenderer,
                      w = s.paint.get("model-receive-shadows");
                    x && ((x.useNormalOffset = !0), w || (x.enabled = !1));
                    const S = () => {
                        x && ((x.useNormalOffset = !0), w || (x.enabled = !0));
                      },
                      C = t.getSource();
                    if (
                      c.renderPass === "light-beam" &&
                      C.type !== "batched-model"
                    )
                      return;
                    if (C.type === "vector" || C.type === "geojson")
                      return (
                        (function (Z, Y, ie, ae, pe) {
                          const ue = Z.transform;
                          if (ue.projection.name !== "mercator")
                            return void r.w(
                              `Drawing 3D models for ${ue.projection.name} projection is not yet implemented`,
                            );
                          const ce = ue.getFreeCameraOptions().position;
                          if (!Z.modelManager) return;
                          const le = Z.modelManager;
                          ie.modelManager = le;
                          const me = Z.shadowRenderer;
                          if (
                            !ie._unevaluatedLayout._values.hasOwnProperty(
                              "model-id",
                            )
                          )
                            return;
                          const _e = ie._unevaluatedLayout._values["model-id"],
                            De = Object.assign(
                              {},
                              ie.layout.get("model-id").parameters,
                            ),
                            ze = Z.style.order.indexOf(ie.fqid);
                          for (const He of ae) {
                            const We = Y.getTile(He).getBucket(ie);
                            if (
                              !We ||
                              We.projection.name !== ue.projection.name
                            )
                              continue;
                            const et = We.getModelUris();
                            et &&
                              !We.modelsRequested &&
                              (le.addModelsFromBucket(et, pe),
                              (We.modelsRequested = !0));
                            const Ce = cu(He, ue);
                            De.zoom = Ce;
                            const Ve = _e.possiblyEvaluate(De);
                            if (
                              (Pe(Z, We, He),
                              (Ds.shadowUniformsInitialized = !1),
                              (Ds.useSingleShadowCascade =
                                !!me &&
                                me.getMaxCascadeForTile(He.toUnwrapped()) ===
                                  0),
                              Z.renderPass === "shadow" && me)
                            ) {
                              if (
                                Z.currentShadowCascade === 1 &&
                                We.isInsideFirstShadowMapFrustum
                              )
                                continue;
                              const Oe = ue.calculatePosMatrix(
                                He.toUnwrapped(),
                                ue.worldSize,
                              );
                              if (
                                (Ds.tileMatrix.set(Oe),
                                (Ds.shadowTileMatrix = Float32Array.from(
                                  me.calculateShadowPassMatrixFromMatrix(Oe),
                                )),
                                Ds.aabb.min.fill(0),
                                (Ds.aabb.max[0] = Ds.aabb.max[1] = r.aj),
                                (Ds.aabb.max[2] = 0),
                                sm(We, Ds, Z, ie.scope))
                              )
                                continue;
                            }
                            const Te = 1 << He.canonical.z,
                              Ze = [
                                ((ce.x - He.wrap) * Te - He.canonical.x) * r.aj,
                                (ce.y * Te - He.canonical.y) * r.aj,
                                ce.z * Te * r.aj,
                              ];
                            Z.conflationActive &&
                              Object.keys(We.instancesPerModel).length > 0 &&
                              Z.style.isLayerClipped(ie, Y.getSource()) &&
                              We.updateReplacement(
                                He,
                                Z.replacementSource,
                                ze,
                                pe,
                              ) &&
                              ((We.uploaded = !1), We.upload(Z.context));
                            for (let Oe in We.instancesPerModel) {
                              const Ke = We.instancesPerModel[Oe];
                              Ke.features.length > 0 &&
                                (Oe = Ve.evaluate(Ke.features[0].feature, {}));
                              const ht = le.getModel(Oe, pe);
                              if (
                                (ht ||
                                  le.hasURLBeenRequested(Oe) ||
                                  We.modelUris.includes(Oe) ||
                                  (We.modelUris.push(Oe),
                                  (We.modelsRequested = !1)),
                                ht && ht.uploaded)
                              )
                                for (const qe of ht.nodes)
                                  hu(Z, ie, qe, Ke, Ze, He, Ds);
                            }
                          }
                        })(c, t, s, h, C.type === "vector" ? s.scope : ""),
                        void S()
                      );
                    if (!C.loaded()) return;
                    if (C.type === "batched-model")
                      return (
                        (function (Z, Y, ie, ae) {
                          ie.resetLayerRenderingStats(Z);
                          const pe = Z.context,
                            ue = Z.transform,
                            ce = Z.style.fog,
                            le = Z.shadowRenderer;
                          if (ue.projection.name !== "mercator")
                            return void r.w(
                              `Drawing 3D landmark models for ${ue.projection.name} projection is not yet implemented`,
                            );
                          const me =
                              Z.transform.getFreeCameraOptions().position,
                            _e = r.bY(
                              [],
                              [me.x, me.y, me.z],
                              Z.transform.worldSize,
                            ),
                            De = r.eb([], _e),
                            ze = r.bx([]),
                            He = r.ec(ue.center.lat, ue.zoom),
                            We = r.bn([], [1, 1, 1 / He]);
                          r.bo(ze, ze, De);
                          const et = ie.paint
                              .get("model-opacity")
                              .constantOr(1),
                            Ce = new wt(
                              pe.gl.LEQUAL,
                              wt.ReadWrite,
                              Z.depthRangeFor3D,
                            ),
                            Ve = new wt(
                              pe.gl.LEQUAL,
                              wt.ReadOnly,
                              Z.depthRangeFor3D,
                            ),
                            Te = new r.cW(
                              [1 / 0, 1 / 0, 1 / 0],
                              [-1 / 0, -1 / 0, -1 / 0],
                            ),
                            Ze = Z.renderPass === "shadow",
                            Oe =
                              Ze && le
                                ? le.getCurrentCascadeFrustum()
                                : ue.getFrustum(ue.scaleZoom(ue.worldSize)),
                            Ke = ie.paint.get("model-front-cutoff"),
                            ht = Ke[2] < 1,
                            qe = Bs(Z, ie.paint.get("model-cutoff-fade-range")),
                            lt = ie.getLayerRenderingStats();
                          ((function (St, Et, bt, kt) {
                            const Bt = St.terrain
                                ? St.terrain.exaggeration()
                                : 0,
                              Vt = St.transform.zoom;
                            for (const Zt of kt) {
                              const si = Et.getTile(Zt).getBucket(bt);
                              si &&
                                (si.setFilter(bt.filter),
                                St.conflationActive &&
                                  si.updateReplacement(
                                    Zt,
                                    St.replacementSource,
                                  ),
                                si.evaluateTransform(St, bt),
                                St.terrain &&
                                  Bt > 0 &&
                                  si.elevationUpdate(
                                    St.terrain,
                                    Bt,
                                    Zt,
                                    bt.source,
                                  ),
                                si.needsReEvaluation(St, Vt, bt) &&
                                  si.evaluate(bt));
                            }
                          })(Z, Y, ie, ae),
                            (function () {
                              let St, Et, bt;
                              ht
                                ? ((St = ae.length - 1), (Et = -1), (bt = -1))
                                : ((St = 0), (Et = ae.length), (bt = 1));
                              const kt = new Float64Array(16),
                                Bt = r.ef(),
                                Vt = new r.P(0, 0);
                              for (let Zt = St; Zt !== Et; Zt += bt) {
                                const si = ae[Zt],
                                  Fi = Y.getTile(si).getBucket(ie);
                                if (!Fi || !Fi.uploaded) continue;
                                let nn = !1;
                                le &&
                                  (nn =
                                    le.getMaxCascadeForTile(
                                      si.toUnwrapped(),
                                    ) === 0);
                                const ji = ue.calculatePosMatrix(
                                    si.toUnwrapped(),
                                    ue.worldSize,
                                  ),
                                  Hi = Fi.modelTraits;
                                !Ze &&
                                  ht &&
                                  (r.bi(kt, ji),
                                  r.ad(Bt, _e, kt),
                                  (Vt.x = Bt[0]),
                                  (Vt.y = Bt[1]));
                                const Fn = [];
                                Fi.setFilter(ie.filter);
                                for (const ti of Fi.getNodesInfo()) {
                                  if (ti.hiddenByReplacement || !ti.node.meshes)
                                    continue;
                                  const li = ti.node;
                                  let gi = 0;
                                  Z.terrain &&
                                    li.elevation &&
                                    (gi =
                                      li.elevation * Z.terrain.exaggeration());
                                  const cn = (() => {
                                      const zn = ti.aabb;
                                      return (
                                        (Te.min = [...zn.min]),
                                        (Te.max = [...zn.max]),
                                        (Te.min[2] += gi),
                                        (Te.max[2] += gi),
                                        r.ad(Te.min, Te.min, ji),
                                        r.ad(Te.max, Te.max, ji),
                                        Te
                                      );
                                    })(),
                                    qn = ti.evaluatedScale;
                                  if (
                                    qn[0] <= 1 &&
                                    qn[1] <= 1 &&
                                    qn[2] <= 1 &&
                                    cn.intersects(Oe) === 0
                                  )
                                    continue;
                                  if (!Ze && ht) {
                                    const zn = 0.16666666666666666;
                                    ti.cameraCollisionOpacity =
                                      _e[0] > cn.min[0] &&
                                      _e[0] < cn.max[0] &&
                                      _e[1] > cn.min[1] &&
                                      _e[1] < cn.max[1] &&
                                      _e[2] * He < cn.max[2] &&
                                      li.footprint &&
                                      r.bS(Vt, li.footprint)
                                        ? Math.max(
                                            ti.cameraCollisionOpacity - zn,
                                            0,
                                          )
                                        : Math.min(
                                            1,
                                            ti.cameraCollisionOpacity + zn,
                                          );
                                  }
                                  const rn = [...ji],
                                    Di = 1 / r.cU(si.canonical),
                                    Pn = li.anchor ? li.anchor[0] : 0,
                                    Ti = li.anchor ? li.anchor[1] : 0;
                                  (r.bo(rn, rn, [
                                    Pn * (qn[0] - 1) +
                                      ti.evaluatedTranslation[0] * Di,
                                    Ti * (qn[1] - 1) +
                                      ti.evaluatedTranslation[1] * Di,
                                    gi + ti.evaluatedTranslation[2],
                                  ]),
                                    r.ci(qn, r.eg) || r.cE(rn, rn, qn));
                                  const Un = r.az([], rn, li.matrix),
                                    hn = r.az(
                                      [],
                                      ue.expandedFarZProjMatrix,
                                      Un,
                                    ),
                                    Ji = r.az(
                                      [],
                                      ue.expandedFarZProjMatrix,
                                      rn,
                                    ),
                                    un = r.aA([], [Pn, Ti, gi, 1], hn)[2];
                                  li.hidden = !1;
                                  let ki = et;
                                  (Ze ||
                                    (ht &&
                                      ((ki *= ti.cameraCollisionOpacity),
                                      (ki *= El(rn, ue, ti.aabb, Ke))),
                                    (ki *= om(qe, un))),
                                    ki !== 0
                                      ? Fn.push({
                                          nodeInfo: ti,
                                          depth: un,
                                          opacity: ki,
                                          wvpForNode: hn,
                                          wvpForTile: Ji,
                                          nodeModelMatrix: Un,
                                          tileModelMatrix: rn,
                                        })
                                      : (li.hidden = !0));
                                }
                                Ze ||
                                  Fn.sort((ti, li) =>
                                    !ht ||
                                    (ti.opacity === 1 && li.opacity === 1)
                                      ? ti.depth < li.depth
                                        ? -1
                                        : 1
                                      : ti.opacity === 1
                                        ? -1
                                        : li.opacity === 1
                                          ? 1
                                          : ti.depth > li.depth
                                            ? -1
                                            : 1,
                                  );
                                for (const ti of Fn) {
                                  const li = ti.nodeInfo,
                                    gi = li.node;
                                  let cn = r.az([], We, ti.tileModelMatrix);
                                  r.az(cn, ze, cn);
                                  const qn = r.bi([], cn);
                                  (r.ee(qn, qn),
                                    r.cE(qn, qn, Ud),
                                    (cn = r.az(cn, cn, gi.matrix)));
                                  const rn = Z.renderPass === "light-beam",
                                    Di =
                                      ie.paint
                                        .get("model-color-use-theme")
                                        .constantOr("default") === "none",
                                    Pn = Hi & r.em.HasMapboxMeshFeatures,
                                    Ti = Pn ? 0 : li.evaluatedRMEA[0][2];
                                  for (
                                    let Un = 0;
                                    Un < gi.meshes.length;
                                    ++Un
                                  ) {
                                    const hn = gi.meshes[Un],
                                      Ji = Un === gi.lightMeshIndex;
                                    let un = ti.wvpForNode;
                                    if (Ji) {
                                      if (
                                        !rn &&
                                        !Z.terrain &&
                                        Z.shadowRenderer
                                      ) {
                                        Z.currentLayer <
                                          Z.firstLightBeamLayer &&
                                          (Z.firstLightBeamLayer =
                                            Z.currentLayer);
                                        continue;
                                      }
                                      un = ti.wvpForTile;
                                    } else if (rn) continue;
                                    const ki = { defines: [] },
                                      zn = [];
                                    if (
                                      (!Ze &&
                                        le &&
                                        (le.useNormalOffset =
                                          !!hn.normalBuffer),
                                      st(
                                        ki.defines,
                                        zn,
                                        hn,
                                        Z,
                                        Di ? null : ie.lut,
                                      ),
                                      Pn || ki.defines.push("DIFFUSE_SHADED"),
                                      nn &&
                                        ki.defines.push(
                                          "SHADOWS_SINGLE_CASCADE",
                                        ),
                                      lt &&
                                        (Ze
                                          ? (lt.numRenderedVerticesInShadowPass +=
                                              hn.vertexArray.length)
                                          : (lt.numRenderedVerticesInTransparentPass +=
                                              hn.vertexArray.length)),
                                      Ze)
                                    ) {
                                      Cn(hn, ti.nodeModelMatrix, Z, ie);
                                      continue;
                                    }
                                    let fr = null;
                                    if (ce) {
                                      const zs = Da(
                                        ti.nodeModelMatrix,
                                        Z.transform,
                                      );
                                      if (
                                        ((fr = new Float32Array(zs)),
                                        ue.projection.name !== "globe")
                                      ) {
                                        const ws = hn.aabb.min,
                                          Hr = hn.aabb.max,
                                          [qo, ks] = ce.getOpacityForBounds(
                                            zs,
                                            ws[0],
                                            ws[1],
                                            Hr[0],
                                            Hr[1],
                                          );
                                        ki.overrideFog = qo >= Be || ks >= Be;
                                      }
                                    }
                                    const xn = hn.material;
                                    let Ci;
                                    xn.occlusionTexture &&
                                      xn.occlusionTexture.offsetScale &&
                                      ((Ci = xn.occlusionTexture.offsetScale),
                                      ki.defines.push(
                                        "OCCLUSION_TEXTURE_TRANSFORM",
                                      ));
                                    const es = Z.getOrCreateProgram(
                                      "model",
                                      ki,
                                    );
                                    (!Ze &&
                                      le &&
                                      le.setupShadowsFromMatrix(
                                        ti.tileModelMatrix,
                                        es,
                                        le.useNormalOffset,
                                      ),
                                      Z.uploadCommonUniforms(pe, es, null, fr));
                                    const $r = xn.pbrMetallicRoughness;
                                    (($r.metallicFactor = 0.9),
                                      ($r.roughnessFactor = 0.5));
                                    const cs = zc(
                                      new Float32Array(un),
                                      new Float32Array(cn),
                                      new Float32Array(qn),
                                      new Float32Array(gi.matrix),
                                      Z,
                                      ti.opacity,
                                      $r.baseColorFactor,
                                      xn.emissiveFactor,
                                      $r.metallicFactor,
                                      $r.roughnessFactor,
                                      xn,
                                      Ti,
                                      ie,
                                      [0, 0, 0],
                                      Ci,
                                    );
                                    (!Ji &&
                                      (li.hasTranslucentParts ||
                                        ti.opacity < 1) &&
                                      es.draw(
                                        Z,
                                        pe.gl.TRIANGLES,
                                        Ce,
                                        Yt.disabled,
                                        ui.disabled,
                                        Gt.backCCW,
                                        cs,
                                        ie.id,
                                        hn.vertexBuffer,
                                        hn.indexBuffer,
                                        hn.segments,
                                        ie.paint,
                                        Z.transform.zoom,
                                        void 0,
                                        zn,
                                      ),
                                      es.draw(
                                        Z,
                                        pe.gl.TRIANGLES,
                                        Ji ? Ve : Ce,
                                        Yt.disabled,
                                        Ji ||
                                          ti.opacity < 1 ||
                                          li.hasTranslucentParts
                                          ? ui.alphaBlended
                                          : ui.unblended,
                                        Gt.backCCW,
                                        cs,
                                        ie.id,
                                        hn.vertexBuffer,
                                        hn.indexBuffer,
                                        hn.segments,
                                        ie.paint,
                                        Z.transform.zoom,
                                        void 0,
                                        zn,
                                      ));
                                  }
                                }
                              }
                            })());
                        })(c, t, s, h),
                        void S()
                      );
                    if (C.type !== "model") return;
                    const D = C.getModels(),
                      L = [],
                      z = c.transform.getFreeCameraOptions().position,
                      O = r.bY([], [z.x, z.y, z.z], c.transform.worldSize);
                    r.eb(O, O);
                    const G = [],
                      U = [];
                    let $ = 0;
                    for (const Z of D) {
                      const Y = s.paint.get("model-rotation").constantOr(null),
                        ie = s.paint.get("model-scale").constantOr(null),
                        ae = s.paint.get("model-translation").constantOr(null);
                      Z.computeModelMatrix(c, Y, ie, ae, !0, !0, !1);
                      const pe = r.bx([]),
                        ue = r.ec(Z.position.lat, c.transform.zoom),
                        ce = r.bn([], [1, 1, 1 / ue]);
                      (r.bo(pe, pe, O),
                        L.push({ zScaleMatrix: ce, negCameraPosMatrix: pe }));
                      for (const le of Z.nodes)
                        Ra(
                          c.transform,
                          le,
                          Z.matrix,
                          c.transform.expandedFarZProjMatrix,
                          $,
                          G,
                          U,
                        );
                      $++;
                    }
                    if (
                      (G.sort((Z, Y) => Y.depth - Z.depth),
                      c.renderPass !== "shadow")
                    ) {
                      if (p === 1)
                        for (const Z of U)
                          vt(
                            Z,
                            c,
                            s,
                            L[Z.modelIndex],
                            Yt.disabled,
                            c.colorModeForRenderPass(),
                          );
                      else {
                        for (const Z of U)
                          vt(
                            Z,
                            c,
                            s,
                            L[Z.modelIndex],
                            Yt.disabled,
                            ui.disabled,
                          );
                        for (const Z of U)
                          vt(
                            Z,
                            c,
                            s,
                            L[Z.modelIndex],
                            c.stencilModeFor3D(),
                            c.colorModeForRenderPass(),
                          );
                        c.resetStencilClippingMasks();
                      }
                      for (const Z of G)
                        vt(
                          Z,
                          c,
                          s,
                          L[Z.modelIndex],
                          Yt.disabled,
                          c.colorModeForRenderPass(),
                        );
                      S();
                    } else {
                      for (const Z of U) Cn(Z.mesh, Z.nodeModelMatrix, c, s);
                      for (const Z of G) Cn(Z.mesh, Z.nodeModelMatrix, c, s);
                      S();
                    }
                  },
                },
                Hd = {
                  line: function (c, t, s) {
                    if (
                      ((c.hasElevatedBuckets = !1),
                      (c.hasNonElevatedBuckets = !1),
                      c._unevaluatedLayout.getValue(
                        "line-elevation-reference",
                      ) !== void 0 ||
                        c._unevaluatedLayout.getValue("line-z-offset") !==
                          void 0)
                    ) {
                      if (t) {
                        const h = t.getVisibleCoordinates();
                        for (const p of h) {
                          const g = t.getTile(p).getBucket(c);
                          if (
                            g &&
                            (g.elevationType !== "none"
                              ? (c.hasElevatedBuckets = !0)
                              : (c.hasNonElevatedBuckets = !0),
                            c.hasElevatedBuckets && c.hasNonElevatedBuckets)
                          )
                            break;
                        }
                      }
                    } else c.hasNonElevatedBuckets = !0;
                  },
                  model: function (c, t, s) {
                    const h = t.getSource();
                    if (!h.loaded()) return;
                    if (h.type === "vector" || h.type === "geojson")
                      return void (
                        s.modelManager &&
                        s.modelManager.upload(
                          s,
                          h.type === "vector" ? c.scope : "",
                        )
                      );
                    if (h.type === "batched-model" || h.type !== "model")
                      return;
                    const p = h.getModels();
                    for (const g of p) g.upload(s.context);
                  },
                  raster: function (c, t, s) {
                    const h = t.getSource();
                    if (!(h instanceof Po && h.loaded())) return;
                    const p =
                      c.sourceLayer ||
                      (h.rasterLayerIds && h.rasterLayerIds[0]);
                    if (!p) return;
                    const g =
                      c.paint.get("raster-array-band") || h.getInitialBand(p);
                    if (g == null) return;
                    const x = t.getIds().map((w) => t.getTileByID(w));
                    for (const w of x)
                      w.updateNeeded(p, g) && h.prepareTile(w, p, g);
                  },
                  "raster-particle": function (c, t, s) {
                    const h = t.getSource();
                    if (!(h instanceof Po && h.loaded())) return;
                    const p =
                      c.sourceLayer ||
                      (h.rasterLayerIds && h.rasterLayerIds[0]);
                    if (!p) return;
                    const g =
                      c.paint.get("raster-particle-array-band") ||
                      h.getInitialBand(p);
                    if (g == null) return;
                    const x = t.getIds().map((w) => t.getTileByID(w));
                    for (const w of x)
                      w.updateNeeded(p, g) && h.prepareTile(w, p, g);
                  },
                },
                po = { fill: Fd },
                Vc = {
                  fill: function (c, t, s, h) {
                    if (
                      !s.layout ||
                      s.layout.get("fill-elevation-reference") === "none"
                    )
                      return;
                    const p = c.context.gl,
                      g = new wt(p.LEQUAL, wt.ReadOnly, c.depthRangeFor3D),
                      x = new Yt(
                        { func: p.ALWAYS, mask: 255 },
                        255,
                        255,
                        p.KEEP,
                        p.KEEP,
                        p.REPLACE,
                      ),
                      w = c.transform.getFreeCameraOptions().position,
                      S = c.getOrCreateProgram(
                        "elevatedStructuresDepthReconstruct",
                        { defines: ["DEPTH_RECONSTRUCTION"] },
                      );
                    for (const C of h) {
                      const D = t.getTile(C),
                        L = D.getBucket(s);
                      if (!L) continue;
                      const z = L.elevatedStructures;
                      if (
                        !z ||
                        z.maskSegments.segments[0].primitiveLength === 0
                      )
                        continue;
                      const O = ou(C.toUnwrapped(), w),
                        G = c.translatePosMatrix(
                          C.projMatrix,
                          D,
                          s.paint.get("fill-translate"),
                          s.paint.get("fill-translate-anchor"),
                        ),
                        U = iu(G, O, 0, 0, 0);
                      S.draw(
                        c,
                        p.TRIANGLES,
                        g,
                        x,
                        ui.disabled,
                        Gt.disabled,
                        U,
                        s.id,
                        z.vertexBuffer,
                        z.indexBuffer,
                        z.maskSegments,
                        s.paint,
                        c.transform.zoom,
                      );
                    }
                  },
                };
              class Il {
                constructor(t, s, h, p, g, x) {
                  ((this.context = new k_(t, s)),
                    (this.transform = h),
                    (this._tileTextures = {}),
                    (this.frameCopies = []),
                    (this.loadTimeStamps = []),
                    (this.tp = g),
                    (this._timeStamp = r.q.now()),
                    (this._averageFPS = 0),
                    (this._fpsHistory = []),
                    (this._dt = 0),
                    (this._debugParams = {
                      forceEnablePrecipitation: !1,
                      showTerrainProxyTiles: !1,
                      fpsWindow: 30,
                      continousRedraw: !1,
                      enabledLayers: {},
                    }));
                  const w = [
                    "fill",
                    "line",
                    "symbol",
                    "circle",
                    "heatmap",
                    "fill-extrusion",
                    "building",
                    "raster",
                    "raster-particle",
                    "hillshade",
                    "model",
                    "background",
                    "sky",
                  ];
                  for (const C of w) this._debugParams.enabledLayers[C] = !0;
                  (g.registerParameter(
                    this._debugParams,
                    ["Terrain"],
                    "showTerrainProxyTiles",
                    {},
                    () => {
                      this.style.map.triggerRepaint();
                    },
                  ),
                    g.registerParameter(
                      this._debugParams,
                      ["Precipitation"],
                      "forceEnablePrecipitation",
                    ),
                    g.registerParameter(
                      this._debugParams,
                      ["FPS"],
                      "fpsWindow",
                      { min: 1, max: 100, step: 1 },
                    ),
                    g.registerBinding(
                      this._debugParams,
                      ["FPS"],
                      "continousRedraw",
                      { readonly: !0, label: "continuous redraw" },
                    ),
                    g.registerBinding(this, ["FPS"], "_averageFPS", {
                      readonly: !0,
                      label: "value",
                    }),
                    g.registerBinding(this, ["FPS"], "_averageFPS", {
                      readonly: !0,
                      label: "graph",
                      view: "graph",
                      min: 0,
                      max: 200,
                    }));
                  for (const C of w)
                    g.registerParameter(
                      this._debugParams.enabledLayers,
                      ["Debug", "Layers"],
                      C,
                    );
                  ((this.occlusionParams = new am(g)),
                    this.setup(),
                    (this.numSublayers =
                      jr.maxUnderzooming + jr.maxOverzooming + 1),
                    (this.depthEpsilon = 1 / Math.pow(2, 16)),
                    (this.deferredRenderGpuTimeQueries = []),
                    (this.gpuTimers = {}),
                    (this.frameCounter = 0),
                    (this._backgroundTiles = {}),
                    (this.conflationActive = !1),
                    (this.replacementSource = new r.et()),
                    (this.longestCutoffRange = 0),
                    (this.minCutoffZoom = 0),
                    (this._fogVisible = !1),
                    (this._cachedTileFogOpacities = {}),
                    (this._shadowRenderer = new f_(this)),
                    (this._wireframeDebugCache = new j_()),
                    (this.renderDefaultNorthPole = !0),
                    (this.renderDefaultSouthPole = !0),
                    (this.layersWithOcclusionOpacity = []));
                  const S = new r.r(
                    { width: 1, height: 1 },
                    Uint8Array.of(0, 0, 0, 0),
                  );
                  ((this.emptyDepthTexture = new r.T(this.context, S, t.RGBA8)),
                    (this._clippingActiveLastFrame = !1),
                    (this.scaleFactor = p),
                    (this.worldview = x));
                }
                updateTerrain(t, s) {
                  const h =
                    !!t &&
                    !!t.terrain &&
                    this.transform.projection.supportsTerrain;
                  if (!(h || (this._terrain && this._terrain.enabled))) return;
                  this._terrain || (this._terrain = new Mc(this, t));
                  const p = this._terrain;
                  ((this.transform.elevation = h ? p : null),
                    p.update(t, this.transform, s),
                    this.transform.elevation &&
                      !p.enabled &&
                      (this.transform.elevation = null));
                }
                _updateFog(t) {
                  const s = t.fog;
                  if (
                    !s ||
                    this.transform.projection.name === "globe" ||
                    s.getOpacity(this.transform.pitch) < 1 ||
                    s.properties.get("horizon-blend") < 0.03
                  )
                    return void (this.transform.fogCullDistSq = null);
                  const [h, p] = s.getFovAdjustedRange(this.transform._fov);
                  if (h > p) return void (this.transform.fogCullDistSq = null);
                  const g = h + 0.78 * (p - h);
                  this.transform.fogCullDistSq = g * g;
                }
                get terrain() {
                  return (this.transform._terrainEnabled() &&
                    this._terrain &&
                    this._terrain.enabled) ||
                    this._forceTerrainMode
                    ? this._terrain
                    : null;
                }
                get forceTerrainMode() {
                  return this._forceTerrainMode;
                }
                set forceTerrainMode(t) {
                  (t &&
                    !this._terrain &&
                    (this._terrain = new Mc(this, this.style)),
                    (this._forceTerrainMode = t));
                }
                get shadowRenderer() {
                  return this._shadowRenderer && this._shadowRenderer.enabled
                    ? this._shadowRenderer
                    : null;
                }
                get wireframeDebugCache() {
                  return this._wireframeDebugCache;
                }
                resize(t, s) {
                  if (
                    ((this.width = t * r.q.devicePixelRatio),
                    (this.height = s * r.q.devicePixelRatio),
                    this.context.viewport.set([0, 0, this.width, this.height]),
                    this.style)
                  )
                    for (const h of this.style.order)
                      this.style._mergedLayers[h].resize();
                }
                setup() {
                  const t = this.context,
                    s = new r.ba();
                  (s.emplaceBack(0, 0),
                    s.emplaceBack(r.aj, 0),
                    s.emplaceBack(0, r.aj),
                    s.emplaceBack(r.aj, r.aj),
                    (this.tileExtentBuffer = t.createVertexBuffer(
                      s,
                      r.bc.members,
                    )),
                    (this.tileExtentSegments = r.bd.simpleSegment(0, 0, 4, 2)));
                  const h = new r.ba();
                  (h.emplaceBack(0, 0),
                    h.emplaceBack(r.aj, 0),
                    h.emplaceBack(0, r.aj),
                    h.emplaceBack(r.aj, r.aj),
                    (this.debugBuffer = t.createVertexBuffer(h, r.bc.members)),
                    (this.debugSegments = r.bd.simpleSegment(0, 0, 4, 5)));
                  const p = new r.ba();
                  (p.emplaceBack(-1, -1),
                    p.emplaceBack(1, -1),
                    p.emplaceBack(-1, 1),
                    p.emplaceBack(1, 1),
                    (this.viewportBuffer = t.createVertexBuffer(
                      p,
                      r.bc.members,
                    )),
                    (this.viewportSegments = r.bd.simpleSegment(0, 0, 4, 2)));
                  const g = new r.aZ();
                  (g.emplaceBack(0, 0, 0, 0),
                    g.emplaceBack(r.aj, 0, r.aj, 0),
                    g.emplaceBack(0, r.aj, 0, r.aj),
                    g.emplaceBack(r.aj, r.aj, r.aj, r.aj),
                    (this.mercatorBoundsBuffer = t.createVertexBuffer(
                      g,
                      r.bf.members,
                    )),
                    (this.mercatorBoundsSegments = r.bd.simpleSegment(
                      0,
                      0,
                      4,
                      2,
                    )));
                  const x = new r.a_();
                  (x.emplaceBack(0, 1, 2),
                    x.emplaceBack(2, 1, 3),
                    (this.quadTriangleIndexBuffer = t.createIndexBuffer(x)));
                  const w = new r.bb();
                  for (const C of [0, 1, 3, 2, 0]) w.emplaceBack(C);
                  ((this.debugIndexBuffer = t.createIndexBuffer(w)),
                    (this.emptyTexture = new r.T(
                      t,
                      new r.r(
                        { width: 1, height: 1 },
                        Uint8Array.of(0, 0, 0, 0),
                      ),
                      t.gl.RGBA8,
                    )),
                    (this.identityMat = r.bz()));
                  const S = this.context.gl;
                  ((this.stencilClearMode = new Yt(
                    { func: S.ALWAYS, mask: 0 },
                    0,
                    255,
                    S.ZERO,
                    S.ZERO,
                    S.ZERO,
                  )),
                    this.loadTimeStamps.push(performance.now()));
                }
                getMercatorTileBoundsBuffers() {
                  return {
                    tileBoundsBuffer: this.mercatorBoundsBuffer,
                    tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
                    tileBoundsSegments: this.mercatorBoundsSegments,
                  };
                }
                getTileBoundsBuffers(t) {
                  return (
                    t._makeTileBoundsBuffers(
                      this.context,
                      this.transform.projection,
                    ),
                    t._tileBoundsBuffer
                      ? {
                          tileBoundsBuffer: t._tileBoundsBuffer,
                          tileBoundsIndexBuffer: t._tileBoundsIndexBuffer,
                          tileBoundsSegments: t._tileBoundsSegments,
                        }
                      : this.getMercatorTileBoundsBuffers()
                  );
                }
                clearStencil() {
                  const t = this.context.gl;
                  ((this.nextStencilID = 1),
                    (this.currentStencilSource = void 0),
                    (this._tileClippingMaskIDs = {}),
                    this.getOrCreateProgram("clippingMask").draw(
                      this,
                      t.TRIANGLES,
                      wt.disabled,
                      this.stencilClearMode,
                      ui.disabled,
                      Gt.disabled,
                      Ea(this.identityMat),
                      "$clipping",
                      this.viewportBuffer,
                      this.quadTriangleIndexBuffer,
                      this.viewportSegments,
                    ));
                }
                resetStencilClippingMasks() {
                  this.terrain ||
                    ((this.currentStencilSource = void 0),
                    (this._tileClippingMaskIDs = {}));
                }
                _renderTileClippingMasks(t, s, h) {
                  if (
                    !s ||
                    this.currentStencilSource === s.id ||
                    !t.isTileClipped() ||
                    !h ||
                    h.length === 0
                  )
                    return;
                  if (this._tileClippingMaskIDs && !this.terrain) {
                    let w = !1;
                    for (const S of h)
                      if (this._tileClippingMaskIDs[S.key] === void 0) {
                        w = !0;
                        break;
                      }
                    if (!w) return;
                  }
                  this.currentStencilSource = s.id;
                  const p = this.context,
                    g = p.gl;
                  (this.nextStencilID + h.length > 256 && this.clearStencil(),
                    p.setColorMode(ui.disabled),
                    p.setDepthMode(wt.disabled));
                  const x = this.getOrCreateProgram("clippingMask");
                  this._tileClippingMaskIDs = {};
                  for (const w of h) {
                    const S = s.getTile(w),
                      C = (this._tileClippingMaskIDs[w.key] = this
                        .nextStencilID++),
                      {
                        tileBoundsBuffer: D,
                        tileBoundsIndexBuffer: L,
                        tileBoundsSegments: z,
                      } = this.getTileBoundsBuffers(S);
                    x.draw(
                      this,
                      g.TRIANGLES,
                      wt.disabled,
                      new Yt(
                        { func: g.ALWAYS, mask: 0 },
                        C,
                        255,
                        g.KEEP,
                        g.KEEP,
                        g.REPLACE,
                      ),
                      ui.disabled,
                      Gt.disabled,
                      Ea(w.projMatrix),
                      "$clipping",
                      D,
                      L,
                      z,
                    );
                  }
                }
                stencilModeFor3D() {
                  ((this.currentStencilSource = void 0),
                    this.nextStencilID + 1 > 256 && this.clearStencil());
                  const t = this.nextStencilID++,
                    s = this.context.gl;
                  return new Yt(
                    { func: s.NOTEQUAL, mask: 255 },
                    t,
                    255,
                    s.KEEP,
                    s.KEEP,
                    s.REPLACE,
                  );
                }
                stencilModeForClipping(t) {
                  if (this.terrain)
                    return this.terrain.stencilModeForRTTOverlap(t);
                  const s = this.context.gl;
                  return new Yt(
                    { func: s.EQUAL, mask: 255 },
                    this._tileClippingMaskIDs[t.key],
                    0,
                    s.KEEP,
                    s.KEEP,
                    s.REPLACE,
                  );
                }
                stencilConfigForOverlap(t) {
                  const s = this.context.gl,
                    h = t.sort((x, w) => w.overscaledZ - x.overscaledZ),
                    p = h[h.length - 1].overscaledZ,
                    g = h[0].overscaledZ - p + 1;
                  if (g > 1) {
                    ((this.currentStencilSource = void 0),
                      this.nextStencilID + g > 256 && this.clearStencil());
                    const x = {};
                    for (let w = 0; w < g; w++)
                      x[w + p] = new Yt(
                        { func: s.GEQUAL, mask: 255 },
                        w + this.nextStencilID,
                        255,
                        s.KEEP,
                        s.KEEP,
                        s.REPLACE,
                      );
                    return ((this.nextStencilID += g), [x, h]);
                  }
                  return [{ [p]: Yt.disabled }, h];
                }
                colorModeForRenderPass() {
                  const t = this.context.gl;
                  return this._showOverdrawInspector
                    ? new ui(
                        [t.CONSTANT_COLOR, t.ONE, t.CONSTANT_COLOR, t.ONE],
                        new r.am(0.125, 0.125, 0.125, 0),
                        [!0, !0, !0, !0],
                      )
                    : this.renderPass === "opaque"
                      ? ui.unblended
                      : ui.alphaBlended;
                }
                colorModeForDrapableLayerRenderPass(t) {
                  const s = this.context.gl;
                  return this.style &&
                    this.style.enable3dLights() &&
                    this.terrain &&
                    this.terrain.renderingToTexture &&
                    this.renderPass === "translucent"
                    ? new ui(
                        [
                          s.ONE,
                          s.ONE_MINUS_SRC_ALPHA,
                          s.CONSTANT_ALPHA,
                          s.ONE_MINUS_SRC_ALPHA,
                        ],
                        new r.am(0, 0, 0, t === void 0 ? 0 : t),
                        [!0, !0, !0, !0],
                      )
                    : this.colorModeForRenderPass();
                }
                depthModeForSublayer(t, s, h, p = !1) {
                  if (this.depthOcclusion)
                    return new wt(
                      this.context.gl.GREATER,
                      wt.ReadOnly,
                      this.depthRangeFor3D,
                    );
                  if (!this.opaquePassEnabledForLayer() && !p)
                    return wt.disabled;
                  const g =
                    1 -
                    ((1 + this.currentLayer) * this.numSublayers + t) *
                      this.depthEpsilon;
                  return new wt(h || this.context.gl.LEQUAL, s, [g, g]);
                }
                opaquePassEnabledForLayer() {
                  return this.currentLayer < this.opaquePassCutoff;
                }
                blitDepth() {
                  const t = this.context.gl,
                    s = Math.ceil(this.width),
                    h = Math.ceil(this.height),
                    p = this.context.bindFramebuffer.get(),
                    g = t.getParameter(t.TEXTURE_BINDING_2D);
                  ((this.depthFBO &&
                    this.depthFBO.width === s &&
                    this.depthFBO.height === h) ||
                    (this.depthFBO &&
                      (this.depthFBO.destroy(),
                      (this.depthFBO = void 0),
                      (this.depthTexture = void 0)),
                    s !== 0 &&
                      h !== 0 &&
                      ((this.depthFBO = new Od(
                        this.context,
                        s,
                        h,
                        !1,
                        "texture",
                      )),
                      (this.depthTexture = new r.T(
                        this.context,
                        { width: s, height: h, data: null },
                        t.DEPTH24_STENCIL8,
                      )),
                      this.depthFBO.depthAttachment.set(
                        this.depthTexture.texture,
                      ))),
                    this.context.bindFramebuffer.set(p),
                    t.bindTexture(t.TEXTURE_2D, g),
                    this.depthFBO &&
                      (t.bindFramebuffer(t.READ_FRAMEBUFFER, null),
                      t.bindFramebuffer(
                        t.DRAW_FRAMEBUFFER,
                        this.depthFBO.framebuffer,
                      ),
                      t.blitFramebuffer(
                        0,
                        0,
                        s,
                        h,
                        0,
                        0,
                        s,
                        h,
                        t.DEPTH_BUFFER_BIT,
                        t.NEAREST,
                      ),
                      t.bindFramebuffer(
                        t.FRAMEBUFFER,
                        this.context.bindFramebuffer.current,
                      )));
                }
                updateAverageFPS() {
                  (this._fpsHistory.push(this._dt === 0 ? 0 : 1e3 / this._dt),
                    this._fpsHistory.length > this._debugParams.fpsWindow &&
                      this._fpsHistory.splice(
                        0,
                        this._fpsHistory.length - this._debugParams.fpsWindow,
                      ),
                    (this._averageFPS = Math.round(
                      this._fpsHistory.reduce(
                        (t, s) => t + s / this._fpsHistory.length,
                        0,
                      ),
                    )));
                }
                render(t, s) {
                  const h = r.q.now();
                  ((this._dt = h - this._timeStamp),
                    (this._timeStamp = h),
                    this._wireframeDebugCache.update(this.frameCounter),
                    (this._debugParams.continousRedraw = t.map.repaint),
                    (this.style = t),
                    (this.options = s));
                  const p = this.style._mergedLayers,
                    g = !(!this.terrain || !this.terrain.enabled),
                    x = () =>
                      this.style._getOrder(g).filter((Ce) => {
                        const Ve = p[Ce];
                        return (
                          !(Ve.type in this._debugParams.enabledLayers) ||
                          this._debugParams.enabledLayers[Ve.type]
                        );
                      });
                  let w = x(),
                    S = !1,
                    C = !1;
                  for (const Ce of w) {
                    const Ve = p[Ce];
                    (Ve.type === "circle" && (S = !0),
                      Ve.type === "symbol" &&
                        (Ve.hasInitialOcclusionOpacityProperties
                          ? (C = !0)
                          : (S = !0)));
                  }
                  let D = w.map((Ce) => p[Ce]);
                  const L = this.style._mergedSourceCaches;
                  ((this.imageManager = t.imageManager),
                    (this.modelManager = t.modelManager),
                    (this.symbolFadeChange = t.placement.symbolFadeChange(
                      r.q.now(),
                    )),
                    this.imageManager.beginFrame());
                  let z = 0,
                    O = !1;
                  for (const Ce in L) {
                    const Ve = L[Ce];
                    Ve.used &&
                      (Ve.prepare(this.context),
                      Ve.getSource().usedInConflation && ++z);
                  }
                  let G = !1;
                  for (const Ce of D)
                    Ce.isHidden(this.transform.zoom) ||
                      (Ce.type === "clip" && (G = !0), this.prepareLayer(Ce));
                  const U = {},
                    $ = {},
                    Z = {},
                    Y = {},
                    ie = {};
                  for (const Ce in L) {
                    const Ve = L[Ce];
                    ((U[Ce] = Ve.getVisibleCoordinates()),
                      ($[Ce] = U[Ce].slice().reverse()),
                      (Z[Ce] = Ve.getVisibleCoordinates(!0).reverse()),
                      (Y[Ce] = Ve.getShadowCasterCoordinates()),
                      (ie[Ce] = Ve.sortCoordinatesByDistance(U[Ce])));
                  }
                  const ae = (Ce) => {
                    const Ve = this.style.getLayerSourceCache(Ce);
                    return Ve && Ve.used ? Ve.getSource() : null;
                  };
                  if (z || G || this._clippingActiveLastFrame) {
                    const Ce = [],
                      Ve = [];
                    let Te = 0;
                    for (const Ze of D)
                      (this.isSourceForClippingOrConflation(Ze, ae(Ze)) &&
                        (Ce.push(Ze), Ve.push(Te)),
                        Te++);
                    if (
                      (Ce && (G || Ce.length > 1)) ||
                      this._clippingActiveLastFrame
                    ) {
                      G = !1;
                      const Ze = [];
                      for (let Oe = 0; Oe < Ce.length; Oe++) {
                        const Ke = Ce[Oe],
                          ht = Ve[Oe],
                          qe = this.style.getLayerSourceCache(Ke);
                        if (
                          !qe ||
                          !qe.used ||
                          (!qe.getSource().usedInConflation &&
                            Ke.type !== "clip")
                        )
                          continue;
                        let lt = r.eu,
                          St = r.bQ.None;
                        const Et = [];
                        let bt = !0;
                        if (Ke.type === "clip") {
                          lt = ht;
                          for (const kt of Ke.layout.get("clip-layer-types"))
                            St |=
                              kt === "model"
                                ? r.bQ.Model
                                : kt === "symbol"
                                  ? r.bQ.Symbol
                                  : r.bQ.FillExtrusion;
                          for (const kt of Ke.layout.get("clip-layer-scope"))
                            Et.push(kt);
                          Ke.isHidden(this.transform.zoom)
                            ? (bt = !1)
                            : (G = !0);
                        }
                        bt &&
                          Ze.push({
                            layer: Ke.fqid,
                            cache: qe,
                            order: lt,
                            clipMask: St,
                            clipScope: Et,
                          });
                      }
                      (this.replacementSource.setSources(Ze), (O = !0));
                    }
                  }
                  ((this._clippingActiveLastFrame = G),
                    O || this.replacementSource.clear(),
                    (this.conflationActive = O),
                    (this.minCutoffZoom = 0),
                    (this.longestCutoffRange = 0),
                    (this.opaquePassCutoff = 1 / 0),
                    (this._lastOcclusionLayer = -1),
                    (this.layersWithOcclusionOpacity = []));
                  for (let Ce = 0; Ce < D.length; Ce++) {
                    const Ve = D[Ce],
                      Te = Ve.cutoffRange();
                    if (
                      ((this.longestCutoffRange = Math.max(
                        Te,
                        this.longestCutoffRange,
                      )),
                      Te > 0)
                    ) {
                      const Ze = ae(Ve);
                      (Ze &&
                        (this.minCutoffZoom = Math.max(
                          Ze.minzoom,
                          this.minCutoffZoom,
                        )),
                        Ve.minzoom &&
                          (this.minCutoffZoom = Math.max(
                            Ve.minzoom,
                            this.minCutoffZoom,
                          )));
                    }
                    Ve.is3D(g) &&
                      (this.opaquePassCutoff === 1 / 0 &&
                        (this.opaquePassCutoff = Ce),
                      (this._lastOcclusionLayer = Ce));
                  }
                  const pe = this.style && this.style.fog;
                  (pe
                    ? ((this._fogVisible =
                        pe.getOpacity(this.transform.pitch) !== 0),
                      this._fogVisible &&
                        this.transform.projection.name !== "globe" &&
                        (this._fogVisible = pe.isVisibleOnFrustum(
                          this.transform.cameraFrustum,
                        )))
                    : (this._fogVisible = !1),
                    (this._cachedTileFogOpacities = {}),
                    this.terrain &&
                      (this.terrain.updateTileBinding(Z),
                      (this.opaquePassCutoff = 0),
                      (w = x()),
                      (D = w.map((Ce) => p[Ce]))));
                  const ue = this._shadowRenderer;
                  if (ue) {
                    ue.updateShadowParameters(
                      this.transform,
                      this.style.directionalLight,
                    );
                    for (const Ce in L)
                      for (const Ve of U[Ce]) {
                        let Te = { min: 0, max: 0 };
                        (this.terrain &&
                          (Te = this.terrain.getMinMaxForTile(Ve) || Te),
                          ue.addShadowReceiver(
                            Ve.toUnwrapped(),
                            Te.min,
                            Te.max,
                          ));
                      }
                  }
                  (this.transform.projection.name !== "globe" ||
                    this.globeSharedBuffers ||
                    (this.globeSharedBuffers = new r.ev(this.context)),
                    this.style.fog && this.transform.projection.supportsFog
                      ? (this._atmosphere || (this._atmosphere = new Sl(this)),
                        this._atmosphere.update(this))
                      : this._atmosphere &&
                        (this._atmosphere.destroy(),
                        (this._atmosphere = void 0)));
                  const ce =
                      this._debugParams.forceEnablePrecipitation ||
                      !(!this.style || !this.style.snow),
                    le =
                      this._debugParams.forceEnablePrecipitation ||
                      !(!this.style || !this.style.rain);
                  if (
                    (ce && !this._snow && (this._snow = new yn(this)),
                    !ce &&
                      this._snow &&
                      (this._snow.destroy(), delete this._snow),
                    le && !this._rain && (this._rain = new G_(this)),
                    !le &&
                      this._rain &&
                      (this._rain.destroy(), delete this._rain),
                    this._snow && this._snow.update(this),
                    this._rain && this._rain.update(this),
                    !Qs.has(this.context.gl))
                  )
                    return;
                  this.renderPass = "offscreen";
                  for (const Ce of D) {
                    const Ve = t.getLayerSourceCache(Ce);
                    if (
                      !Ce.hasOffscreenPass() ||
                      Ce.isHidden(this.transform.zoom)
                    )
                      continue;
                    const Te = Ve ? $[Ve.id] : void 0;
                    (Ce.type === "custom" ||
                      Ce.type === "raster" ||
                      Ce.type === "raster-particle" ||
                      Ce.isSky() ||
                      (Te && Te.length)) &&
                      this.renderLayer(this, Ve, Ce, Te);
                  }
                  ((this.depthRangeFor3D = [
                    0,
                    1 - (D.length + 2) * this.numSublayers * this.depthEpsilon,
                  ]),
                    this._shadowRenderer &&
                      ((this.renderPass = "shadow"),
                      this._shadowRenderer.drawShadowPass(this.style, Y)),
                    this.context.bindFramebuffer.set(null),
                    this.context.viewport.set([0, 0, this.width, this.height]));
                  const me =
                      this.transform.projection.name === "globe" ||
                      this.transform.isHorizonVisible(),
                    _e = (() => {
                      if (s.showOverdrawInspector) return r.am.black;
                      const Ce = this.style.fog;
                      if (Ce && this.transform.projection.supportsFog) {
                        const Ve = this.style.getLut(Ce.scope);
                        if (!me) {
                          const Te =
                              Ce.properties.get("color-use-theme") === "none",
                            Ze = Ce.properties
                              .get("color")
                              .toNonPremultipliedRenderColor(Te ? null : Ve)
                              .toArray01();
                          return new r.am(...Ze);
                        }
                        if (me) {
                          const Te =
                              Ce.properties.get("space-color-use-theme") ===
                              "none",
                            Ze = Ce.properties
                              .get("space-color")
                              .toNonPremultipliedRenderColor(Te ? null : Ve)
                              .toArray01();
                          return new r.am(...Ze);
                        }
                      }
                      return r.am.transparent;
                    })();
                  if (
                    (this.context.clear({ color: _e, depth: 1 }),
                    this.clearStencil(),
                    (this._showOverdrawInspector = s.showOverdrawInspector),
                    (this.renderPass = "opaque"),
                    this.style.fog &&
                      this.transform.projection.supportsFog &&
                      this._atmosphere &&
                      !this._showOverdrawInspector &&
                      me &&
                      this._atmosphere.drawStars(this, this.style.fog),
                    !this.terrain)
                  )
                    for (
                      this.currentLayer = w.length - 1;
                      this.currentLayer >= 0;
                      this.currentLayer--
                    ) {
                      const Ce = D[this.currentLayer],
                        Ve = t.getLayerSourceCache(Ce);
                      if (Ce.isSky()) continue;
                      const Te = Ve ? (Ce.is3D(g) ? ie : $)[Ve.id] : void 0;
                      (this._renderTileClippingMasks(Ce, Ve, Te),
                        this.renderLayer(this, Ve, Ce, Te));
                    }
                  if (
                    (this.style.fog &&
                      this.transform.projection.supportsFog &&
                      this._atmosphere &&
                      !this._showOverdrawInspector &&
                      me &&
                      this._atmosphere.drawAtmosphereGlow(this, this.style.fog),
                    (this.renderPass = "sky"),
                    (!this._atmosphere || r.ah(this.transform.zoom) > 0) &&
                      (this.transform.projection.name === "globe" ||
                        this.transform.isHorizonVisible()))
                  )
                    for (
                      this.currentLayer = 0;
                      this.currentLayer < w.length;
                      this.currentLayer++
                    ) {
                      const Ce = D[this.currentLayer],
                        Ve = t.getLayerSourceCache(Ce);
                      Ce.isSky() &&
                        this.renderLayer(this, Ve, Ce, Ve ? $[Ve.id] : void 0);
                    }
                  function De(Ce, Ve) {
                    let Te;
                    return (
                      Ve &&
                        (Te = (Ce.type === "symbol" ? Z : Ce.is3D(g) ? ie : $)[
                          Ve.id
                        ]),
                      Te
                    );
                  }
                  if (
                    ((this.renderPass = "translucent"),
                    this.transform.projection.name === "globe")
                  ) {
                    for (
                      this.renderElevatedRasterBackface = !0,
                        this.currentLayer = 0;
                      this.currentLayer < w.length;

                    ) {
                      const Ce = D[this.currentLayer];
                      if (
                        Ce.type === "raster" ||
                        Ce.type === "raster-particle"
                      ) {
                        const Ve = t.getLayerSourceCache(Ce);
                        this.renderLayer(this, Ve, Ce, De(Ce, Ve));
                      }
                      ++this.currentLayer;
                    }
                    this.renderElevatedRasterBackface = !1;
                  }
                  ((this.currentLayer = 0),
                    (this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER));
                  let ze = 0;
                  ue && (ze = ue.getShadowCastingLayerCount());
                  let He = !1,
                    We = -1;
                  for (let Ce = 0; Ce < w.length; ++Ce) {
                    const Ve = D[Ce];
                    Ve.isHidden(this.transform.zoom) ||
                      (Ve.is3D(g) && (We = Ce));
                  }
                  C && We === -1 && (S = !0);
                  let et = !1;
                  for (; this.currentLayer < w.length; ) {
                    const Ce = D[this.currentLayer],
                      Ve = t.getLayerSourceCache(Ce);
                    if (Ce.isSky()) ++this.currentLayer;
                    else if (this.terrain && this.style.isLayerDraped(Ce)) {
                      if (Ce.isHidden(this.transform.zoom)) {
                        ++this.currentLayer;
                        continue;
                      }
                      ((this.currentLayer = this.terrain.renderBatch(
                        this.currentLayer,
                      )),
                        (this._lastOcclusionLayer = Math.max(
                          this.currentLayer,
                          this._lastOcclusionLayer,
                        )));
                    } else {
                      if (!et && Ce.is3D(g) && !g) {
                        const Te = this.currentLayer,
                          Ze = (Oe) => {
                            for (
                              this.currentLayer = 0;
                              this.currentLayer < D.length;
                              this.currentLayer++
                            ) {
                              const Ke = D[this.currentLayer];
                              if (po[Ke.type]) {
                                const ht = this.style.getLayerSourceCache(Ke);
                                po[Ke.type](this, ht, Ke, De(Ke, ht), Oe);
                              }
                            }
                          };
                        (Ze("initialize"),
                          Ze("reset"),
                          (this.currentLayer = Te),
                          (et = !0));
                      }
                      if (
                        (S &&
                          !He &&
                          this.terrain &&
                          !this.transform.isOrthographic &&
                          ((He = !0), this.blitDepth()),
                        C &&
                          We !== -1 &&
                          this.currentLayer === We + 1 &&
                          !this.transform.isOrthographic &&
                          this.blitDepth(),
                        this.terrain ||
                          this._renderTileClippingMasks(
                            Ce,
                            Ve,
                            Ve ? U[Ve.id] : void 0,
                          ),
                        this.renderLayer(this, Ve, Ce, De(Ce, Ve)),
                        !this.terrain &&
                          ue &&
                          ze > 0 &&
                          Ce.hasShadowPass() &&
                          --ze == 0)
                      ) {
                        {
                          this.clearStencil();
                          const Te = this.currentLayer;
                          for (
                            this.currentLayer = 0;
                            this.currentLayer < D.length;
                            this.currentLayer++
                          ) {
                            const Ze = D[this.currentLayer];
                            if (Vc[Ze.type]) {
                              const Oe = this.style.getLayerSourceCache(Ze);
                              Vc[Ze.type](this, Oe, Ze, De(Ze, Oe));
                            }
                          }
                          this.currentLayer = Te;
                        }
                        if (
                          (ue.drawGroundShadows(),
                          this.firstLightBeamLayer <= this.currentLayer)
                        ) {
                          const Te = this.currentLayer;
                          for (
                            this.renderPass = "light-beam",
                              this.currentLayer = this.firstLightBeamLayer;
                            this.currentLayer <= Te;
                            this.currentLayer++
                          ) {
                            const Ze = D[this.currentLayer];
                            if (!Ze.hasLightBeamPass()) continue;
                            const Oe = t.getLayerSourceCache(Ze);
                            this.renderLayer(
                              this,
                              Oe,
                              Ze,
                              Oe ? $[Oe.id] : void 0,
                            );
                          }
                          ((this.currentLayer = Te),
                            (this.renderPass = "translucent"));
                        }
                      }
                      if (
                        this.currentLayer >= this._lastOcclusionLayer &&
                        this.layersWithOcclusionOpacity.length > 0
                      ) {
                        const Te = this.currentLayer;
                        this.depthOcclusion = !0;
                        for (const Ze of this.layersWithOcclusionOpacity) {
                          this.currentLayer = Ze;
                          const Oe = D[this.currentLayer],
                            Ke = t.getLayerSourceCache(Oe),
                            ht = Ke ? $[Ke.id] : void 0;
                          (this.terrain ||
                            this._renderTileClippingMasks(
                              Oe,
                              Ke,
                              Ke ? U[Ke.id] : void 0,
                            ),
                            this.renderLayer(this, Ke, Oe, ht));
                        }
                        ((this.depthOcclusion = !1),
                          (this.currentLayer = Te),
                          (this.renderPass = "translucent"),
                          (this.layersWithOcclusionOpacity = []));
                      }
                      ++this.currentLayer;
                    }
                  }
                  if (
                    (this.terrain && this.terrain.postRender(),
                    this._snow && this._snow.draw(this),
                    this._rain && this._rain.draw(this),
                    this.options.showTileBoundaries ||
                      this.options.showQueryGeometry ||
                      this.options.showTileAABBs)
                  ) {
                    let Ce = null;
                    (D.forEach((Ve) => {
                      const Te = t.getLayerSourceCache(Ve);
                      Te &&
                        !Ve.isHidden(this.transform.zoom) &&
                        Te.getVisibleCoordinates().length &&
                        (!Ce ||
                          Ce.getSource().maxzoom < Te.getSource().maxzoom) &&
                        (Ce = Te);
                    }),
                      Ce &&
                        this.options.showTileBoundaries &&
                        uo(
                          this,
                          Ce,
                          Ce.getVisibleCoordinates(),
                          r.am.red,
                          !1,
                          this.options.showParseStatus,
                        ));
                  }
                  (this.terrain &&
                    this._debugParams.showTerrainProxyTiles &&
                    uo(
                      this,
                      this.terrain.proxySourceCache,
                      this.terrain.proxyCoords,
                      new r.am(1, 0.8, 0.1, 1),
                      !0,
                      this.options.showParseStatus,
                    ),
                    this.options.showPadding &&
                      (function (Ce) {
                        const Ve = Ce.transform.padding;
                        (au(Ce, Ce.transform.height - (Ve.top || 0), 3, B_),
                          au(Ce, Ve.bottom || 0, 3, N_),
                          lu(Ce, Ve.left || 0, 3, Qr),
                          lu(Ce, Ce.transform.width - (Ve.right || 0), 3, Vd));
                        const Te = Ce.transform.centerPoint;
                        (function (Ze, Oe, Ke, ht) {
                          (Tl(Ze, Oe - 1, Ke - 10, 2, 20, ht),
                            Tl(Ze, Oe - 10, Ke - 1, 20, 2, ht));
                        })(Ce, Te.x, Ce.transform.height - Te.y, kr);
                      })(this),
                    this.context.setDefault(),
                    (this.frameCounter =
                      (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER),
                    this.tileLoaded &&
                      this.options.speedIndexTiming &&
                      (this.loadTimeStamps.push(performance.now()),
                      this.saveCanvasCopy()),
                    O || (this.conflationActive = !1));
                }
                prepareLayer(t) {
                  this.gpuTimingStart(t);
                  const { unsupportedLayers: s } = this.transform.projection,
                    h = !s || !s.includes(t.type);
                  if (
                    Hd[t.type] &&
                    (h || (this.terrain && t.type === "custom"))
                  ) {
                    const p = this.style.getLayerSourceCache(t);
                    Hd[t.type](t, p, this);
                  }
                  this.gpuTimingEnd();
                }
                renderLayer(t, s, h, p) {
                  h.isHidden(this.transform.zoom) ||
                    ((h.type === "background" ||
                      h.type === "sky" ||
                      h.type === "custom" ||
                      h.type === "model" ||
                      h.type === "raster" ||
                      h.type === "raster-particle" ||
                      (p && p.length)) &&
                      ((this.id = h.id),
                      this.gpuTimingStart(h),
                      (t.transform.projection.unsupportedLayers &&
                        t.transform.projection.unsupportedLayers.includes(
                          h.type,
                        ) &&
                        (!t.terrain || h.type !== "custom")) ||
                        h.type === "clip" ||
                        Ai[h.type](
                          t,
                          s,
                          h,
                          p,
                          this.style.placement.variableOffsets,
                          this.options.isInitialLoad,
                        ),
                      this.gpuTimingEnd()));
                }
                gpuTimingStart(t) {
                  if (!this.options.gpuTiming) return;
                  const s = this.context.extTimerQuery,
                    h = this.context.gl;
                  let p = this.gpuTimers[t.id];
                  (p ||
                    (p = this.gpuTimers[t.id] =
                      { calls: 0, cpuTime: 0, query: h.createQuery() }),
                    p.calls++,
                    h.beginQuery(s.TIME_ELAPSED_EXT, p.query));
                }
                gpuTimingDeferredRenderStart() {
                  if (this.options.gpuTimingDeferredRender) {
                    const t = this.context.extTimerQuery,
                      s = this.context.gl,
                      h = s.createQuery();
                    (this.deferredRenderGpuTimeQueries.push(h),
                      s.beginQuery(t.TIME_ELAPSED_EXT, h));
                  }
                }
                gpuTimingDeferredRenderEnd() {
                  this.options.gpuTimingDeferredRender &&
                    this.context.gl.endQuery(
                      this.context.extTimerQuery.TIME_ELAPSED_EXT,
                    );
                }
                gpuTimingEnd() {
                  this.options.gpuTiming &&
                    this.context.gl.endQuery(
                      this.context.extTimerQuery.TIME_ELAPSED_EXT,
                    );
                }
                collectGpuTimers() {
                  const t = this.gpuTimers;
                  return ((this.gpuTimers = {}), t);
                }
                collectDeferredRenderGpuQueries() {
                  const t = this.deferredRenderGpuTimeQueries;
                  return ((this.deferredRenderGpuTimeQueries = []), t);
                }
                queryGpuTimers(t) {
                  const s = {};
                  for (const h in t) {
                    const p = t[h],
                      g = this.context.extTimerQuery,
                      x =
                        g.getQueryParameter(
                          p.query,
                          this.context.gl.QUERY_RESULT,
                        ) / 1e6;
                    (g.deleteQueryEXT(p.query), (s[h] = x));
                  }
                  return s;
                }
                queryGpuTimeDeferredRender(t) {
                  if (!this.options.gpuTimingDeferredRender) return 0;
                  const s = this.context.gl;
                  let h = 0;
                  for (const p of t)
                    ((h += s.getQueryParameter(p, s.QUERY_RESULT) / 1e6),
                      s.deleteQuery(p));
                  return h;
                }
                translatePosMatrix(t, s, h, p, g) {
                  if (!h[0] && !h[1]) return t;
                  const x = g
                    ? p === "map"
                      ? this.transform.angle
                      : 0
                    : p === "viewport"
                      ? -this.transform.angle
                      : 0;
                  if (x) {
                    const C = Math.sin(x),
                      D = Math.cos(x);
                    h = [h[0] * D - h[1] * C, h[0] * C + h[1] * D];
                  }
                  const w = [
                      g ? h[0] : r.aw(s, h[0], this.transform.zoom),
                      g ? h[1] : r.aw(s, h[1], this.transform.zoom),
                      0,
                    ],
                    S = new Float32Array(16);
                  return (r.bo(S, t, w), S);
                }
                saveTileTexture(t) {
                  const s = t.size[0],
                    h = this._tileTextures[s];
                  h ? h.push(t) : (this._tileTextures[s] = [t]);
                }
                getTileTexture(t) {
                  const s = this._tileTextures[t];
                  return s && s.length > 0 ? s.pop() : null;
                }
                terrainRenderModeElevated() {
                  return (
                    (this.style &&
                      !!this.style.getTerrain() &&
                      !!this.terrain &&
                      !this.terrain.renderingToTexture) ||
                    this.forceTerrainMode
                  );
                }
                linearFloatFilteringSupported() {
                  return this.context.extTextureFloatLinear != null;
                }
                currentGlobalDefines(t, s, h) {
                  const p =
                      h === void 0
                        ? this.terrain && this.terrain.renderingToTexture
                        : h,
                    g = [];
                  return (
                    this.style &&
                      this.style.enable3dLights() &&
                      (t === "globeRaster" || t === "terrainRaster"
                        ? (g.push("LIGHTING_3D_MODE"),
                          g.push("LIGHTING_3D_ALPHA_EMISSIVENESS"))
                        : p || g.push("LIGHTING_3D_MODE")),
                    this.renderPass === "shadow" &&
                      (this._shadowMapDebug || g.push("DEPTH_TEXTURE")),
                    this.terrainRenderModeElevated() &&
                      (g.push("TERRAIN"),
                      this.linearFloatFilteringSupported() &&
                        g.push("TERRAIN_DEM_FLOAT_FORMAT")),
                    this.transform.projection.name === "globe" &&
                      g.push("GLOBE"),
                    !this._fogVisible ||
                      p ||
                      (s !== void 0 && !s) ||
                      g.push("FOG", "FOG_DITHERING"),
                    p && g.push("RENDER_TO_TEXTURE"),
                    this._showOverdrawInspector && g.push("OVERDRAW_INSPECTOR"),
                    g
                  );
                }
                getOrCreateProgram(t, s) {
                  this.cache = this.cache || {};
                  const h = (s && s.defines) || [],
                    p = s && s.config,
                    g = this.currentGlobalDefines(
                      t,
                      s && s.overrideFog,
                      s && s.overrideRtt,
                    ).concat(h),
                    x = tu.cacheKey(jh[t], t, g, p);
                  return (
                    this.cache[x] ||
                      (this.cache[x] = new tu(
                        this.context,
                        t,
                        jh[t],
                        p,
                        Xp[t],
                        g,
                      )),
                    this.cache[x]
                  );
                }
                setCustomLayerDefaults() {
                  (this.context.unbindVAO(),
                    this.context.cullFace.setDefault(),
                    this.context.frontFace.setDefault(),
                    this.context.cullFaceSide.setDefault(),
                    this.context.activeTexture.setDefault(),
                    this.context.pixelStoreUnpack.setDefault(),
                    this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                    this.context.pixelStoreUnpackFlipY.setDefault());
                }
                setBaseState() {
                  const t = this.context.gl;
                  (this.context.cullFace.set(!1),
                    this.context.viewport.set([0, 0, this.width, this.height]),
                    this.context.blendEquation.set(t.FUNC_ADD));
                }
                initDebugOverlayCanvas() {
                  this.debugOverlayCanvas == null &&
                    ((this.debugOverlayCanvas =
                      document.createElement("canvas")),
                    (this.debugOverlayCanvas.width = 512),
                    (this.debugOverlayCanvas.height = 512),
                    (this.debugOverlayTexture = new r.T(
                      this.context,
                      this.debugOverlayCanvas,
                      this.context.gl.RGBA8,
                    )));
                }
                destroy() {
                  (this._terrain && this._terrain.destroy(),
                    this._atmosphere &&
                      (this._atmosphere.destroy(), (this._atmosphere = void 0)),
                    this.globeSharedBuffers &&
                      this.globeSharedBuffers.destroy(),
                    this.emptyTexture.destroy(),
                    this.debugOverlayTexture &&
                      this.debugOverlayTexture.destroy(),
                    this._wireframeDebugCache.destroy(),
                    this.depthFBO &&
                      (this.depthFBO.destroy(),
                      (this.depthFBO = void 0),
                      (this.depthTexture = void 0)),
                    this.emptyDepthTexture && this.emptyDepthTexture.destroy());
                }
                prepareDrawTile() {
                  this.terrain && this.terrain.prepareDrawTile();
                }
                uploadCommonLightUniforms(t, s) {
                  if (this.style.enable3dLights()) {
                    const h = this.style.directionalLight,
                      p = this.style.ambientLight;
                    if (h && p) {
                      const g = ((x, w, S) => {
                        const C = x.properties.get("direction"),
                          D = x.properties.get("color-use-theme") === "none",
                          L = x.properties
                            .get("color")
                            .toNonPremultipliedRenderColor(
                              D ? null : S.getLut(x.scope),
                            )
                            .toArray01(),
                          z = x.properties.get("intensity"),
                          O = w.properties.get("color-use-theme") === "none",
                          G = w.properties
                            .get("color")
                            .toNonPremultipliedRenderColor(
                              O ? null : S.getLut(w.scope),
                            )
                            .toArray01(),
                          U = w.properties.get("intensity"),
                          $ = [C.x, C.y, C.z],
                          Z = r.dw(G, U),
                          Y = r.dw(L, z);
                        return {
                          u_lighting_ambient_color: Z,
                          u_lighting_directional_dir: $,
                          u_lighting_directional_color: Y,
                          u_ground_radiance: eu($, Y, Z),
                        };
                      })(h, p, this.style);
                      s.setLightsUniformValues(t, g);
                    }
                  }
                }
                uploadCommonUniforms(t, s, h, p, g) {
                  if (
                    (this.uploadCommonLightUniforms(t, s),
                    this.terrain && this.terrain.renderingToTexture)
                  )
                    return;
                  const x = this.style.fog;
                  if (x) {
                    const w = x.getOpacity(this.transform.pitch),
                      S = ((C, D, L, z, O, G, U, $, Z, Y, ie, ae) => {
                        const pe = C.transform,
                          ue = D.properties.get("color-use-theme") === "none",
                          ce = D.properties
                            .get("color")
                            .toNonPremultipliedRenderColor(
                              ue ? null : C.style.getLut(D.scope),
                            )
                            .toArray01();
                        ce[3] = z;
                        const le = (C.frameCounter / 1e3) % 1,
                          [me, _e] = D.properties.get("vertical-range");
                        return {
                          u_fog_matrix: L
                            ? pe.calculateFogTileMatrix(L)
                            : ae || C.identityMat,
                          u_fog_range: D.getFovAdjustedRange(pe._fov),
                          u_fog_color: ce,
                          u_fog_horizon_blend:
                            D.properties.get("horizon-blend"),
                          u_fog_vertical_limit: [Math.min(me, _e), _e],
                          u_fog_temporal_offset: le,
                          u_frustum_tl: O,
                          u_frustum_tr: G,
                          u_frustum_br: U,
                          u_frustum_bl: $,
                          u_globe_pos: Z,
                          u_globe_radius: Y,
                          u_viewport: ie,
                          u_globe_transition: r.ah(pe.zoom),
                          u_is_globe: +(pe.projection.name === "globe"),
                        };
                      })(
                        this,
                        x,
                        h,
                        w,
                        this.transform.frustumCorners.TL,
                        this.transform.frustumCorners.TR,
                        this.transform.frustumCorners.BR,
                        this.transform.frustumCorners.BL,
                        this.transform.globeCenterInViewSpace,
                        this.transform.globeRadius,
                        [
                          this.transform.width * r.q.devicePixelRatio,
                          this.transform.height * r.q.devicePixelRatio,
                        ],
                        p,
                      );
                    s.setFogUniformValues(t, S);
                  }
                  g && s.setCutoffUniformValues(t, g.uniformValues);
                }
                setTileLoadedFlag(t) {
                  this.tileLoaded = t;
                }
                saveCanvasCopy() {
                  const t = this.canvasCopy();
                  t && (this.frameCopies.push(t), (this.tileLoaded = !1));
                }
                canvasCopy() {
                  const t = this.context.gl,
                    s = t.createTexture();
                  return (
                    t.bindTexture(t.TEXTURE_2D, s),
                    t.copyTexImage2D(
                      t.TEXTURE_2D,
                      0,
                      t.RGBA,
                      0,
                      0,
                      t.drawingBufferWidth,
                      t.drawingBufferHeight,
                      0,
                    ),
                    s
                  );
                }
                getCanvasCopiesAndTimestamps() {
                  return {
                    canvasCopies: this.frameCopies,
                    timeStamps: this.loadTimeStamps,
                  };
                }
                averageElevationNeedsEasing() {
                  if (!this.transform._elevation) return !1;
                  const t = this.style && this.style.fog;
                  return !!t && t.getOpacity(this.transform.pitch) !== 0;
                }
                getBackgroundTiles() {
                  const t = this._backgroundTiles,
                    s = (this._backgroundTiles = {}),
                    h = this.transform.coveringTiles({ tileSize: 512 });
                  for (const p of h)
                    s[p.key] =
                      t[p.key] ||
                      new fa(
                        p,
                        512,
                        this.transform.tileZoom,
                        this,
                        void 0,
                        this.worldview,
                      );
                  return s;
                }
                clearBackgroundTiles() {
                  this._backgroundTiles = {};
                }
                isSourceForClippingOrConflation(t, s) {
                  return !(
                    !t.is3D(!(!this.terrain || !this.terrain.enabled)) ||
                    (t.type !== "clip" &&
                      ((t.minzoom && t.minzoom > this.transform.zoom) ||
                        ((this.style._clipLayerPresent ||
                          t.sourceLayer !== "building") &&
                          (!s || s.type !== "batched-model"))))
                  );
                }
                isTileAffectedByFog(t) {
                  if (!this.style || !this.style.fog) return !1;
                  if (this.transform.projection.name === "globe") return !0;
                  let s = this._cachedTileFogOpacities[t.key];
                  return (
                    s ||
                      (this._cachedTileFogOpacities[t.key] = s =
                        this.style.fog.getOpacityForTile(t)),
                    s[0] >= Be || s[1] >= Be
                  );
                }
                setupDepthForOcclusion(t, s, h) {
                  const p = this.context,
                    g = p.gl,
                    x = !!h;
                  var w;
                  (h ||
                    (h = {
                      u_dem: 2,
                      u_dem_prev: 4,
                      u_dem_tl: [0, 0],
                      u_dem_tl_prev: [0, 0],
                      u_dem_scale: 0,
                      u_dem_scale_prev: 0,
                      u_dem_size: 0,
                      u_dem_lerp: 1,
                      u_depth: 3,
                      u_depth_size_inv: [0, 0],
                      u_depth_range_unpack: [0, 1],
                      u_occluder_half_size: 16,
                      u_occlusion_depth_offset: -1e-4,
                      u_exaggeration: 0,
                    }),
                    p.activeTexture.set(g.TEXTURE3),
                    t && this.depthFBO && this.depthTexture
                      ? (this.depthTexture.bind(g.NEAREST, g.CLAMP_TO_EDGE),
                        (h.u_depth_size_inv = [
                          1 / this.depthFBO.width,
                          1 / this.depthFBO.height,
                        ]),
                        (h.u_depth_range_unpack = [
                          2 / ((w = this.depthRangeFor3D)[1] - w[0]),
                          -1 - (2 * w[0]) / (w[1] - w[0]),
                        ]),
                        (h.u_occluder_half_size =
                          0.5 * this.occlusionParams.occluderSize),
                        (h.u_occlusion_depth_offset =
                          this.occlusionParams.depthOffset))
                      : this.emptyDepthTexture.bind(g.NEAREST, g.CLAMP_TO_EDGE),
                    p.activeTexture.set(g.TEXTURE0),
                    x || s.setTerrainUniformValues(p, h));
                }
              }
              function Go(c, t) {
                let s = !1,
                  h = null;
                const p = () => {
                  ((h = null), s && (c(), (h = setTimeout(p, t)), (s = !1)));
                };
                return () => ((s = !0), h || p(), h);
              }
              class Wd {
                constructor(t) {
                  ((this._hashName = t && encodeURIComponent(t)),
                    r.aV(
                      ["_getCurrentHash", "_onHashChange", "_updateHash"],
                      this,
                    ),
                    (this._updateHash = Go(
                      this._updateHashUnthrottled.bind(this),
                      300,
                    )));
                }
                addTo(t) {
                  return (
                    (this._map = t),
                    window.addEventListener(
                      "hashchange",
                      this._onHashChange,
                      !1,
                    ),
                    t.on("moveend", this._updateHash),
                    this
                  );
                }
                remove() {
                  return this._map
                    ? (this._map.off("moveend", this._updateHash),
                      window.removeEventListener(
                        "hashchange",
                        this._onHashChange,
                        !1,
                      ),
                      clearTimeout(this._updateHash()),
                      (this._map = void 0),
                      this)
                    : this;
                }
                getHashString() {
                  const t = this._map;
                  if (!t) return "";
                  const s = fu(t);
                  if (this._hashName) {
                    const h = this._hashName;
                    let p = !1;
                    const g = location.hash
                      .slice(1)
                      .split("&")
                      .map((x) => {
                        const w = x.split("=")[0];
                        return w === h ? ((p = !0), `${w}=${s}`) : x;
                      })
                      .filter((x) => x);
                    return (p || g.push(`${h}=${s}`), `#${g.join("&")}`);
                  }
                  return `#${s}`;
                }
                _getCurrentHash() {
                  const t = location.hash.replace("#", "");
                  if (this._hashName) {
                    let s;
                    return (
                      t
                        .split("&")
                        .map((h) => h.split("="))
                        .forEach((h) => {
                          h[0] === this._hashName && (s = h);
                        }),
                      ((s && s[1]) || "").split("/")
                    );
                  }
                  return t.split("/");
                }
                _onHashChange() {
                  const t = this._map;
                  if (!t) return !1;
                  const s = this._getCurrentHash();
                  if (s.length >= 3 && !s.some((h) => isNaN(Number(h)))) {
                    const h =
                      t.dragRotate.isEnabled() && t.touchZoomRotate.isEnabled()
                        ? +(s[3] || 0)
                        : t.getBearing();
                    return (
                      t.jumpTo({
                        center: [+s[2], +s[1]],
                        zoom: +s[0],
                        bearing: h,
                        pitch: +(s[4] || 0),
                      }),
                      !0
                    );
                  }
                  return !1;
                }
                _updateHashUnthrottled() {
                  history.replaceState(
                    history.state,
                    "",
                    location.href.replace(/(#.+)?$/, this.getHashString()),
                  );
                }
              }
              function fu(c, t) {
                const s = c.getCenter(),
                  h = Math.round(100 * c.getZoom()) / 100,
                  p = Math.ceil(
                    (h * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10,
                  ),
                  g = Math.pow(10, p),
                  x = Math.round(s.lng * g) / g,
                  w = Math.round(s.lat * g) / g,
                  S = c.getBearing(),
                  C = c.getPitch();
                let D = t ? `/${x}/${w}/${h}` : `${h}/${w}/${x}`;
                return (
                  (S || C) && (D += "/" + Math.round(10 * S) / 10),
                  C && (D += `/${Math.round(C)}`),
                  D
                );
              }
              const Al = { linearity: 0.3, easing: r.ew(0, 0, 0.3, 1) },
                qd = r.h({ deceleration: 2500, maxSpeed: 1400 }, Al),
                Vs = r.h({ deceleration: 20, maxSpeed: 1400 }, Al),
                $o = r.h({ deceleration: 1e3, maxSpeed: 360 }, Al),
                Uc = r.h({ deceleration: 1e3, maxSpeed: 90 }, Al);
              class pu {
                constructor(t) {
                  ((this._map = t), this.clear());
                }
                clear() {
                  this._inertiaBuffer = [];
                }
                record(t) {
                  (this._drainInertiaBuffer(),
                    this._inertiaBuffer.push({ time: r.q.now(), settings: t }));
                }
                _drainInertiaBuffer() {
                  const t = this._inertiaBuffer,
                    s = r.q.now();
                  for (; t.length > 0 && s - t[0].time > 160; ) t.shift();
                }
                _onMoveEnd(t) {
                  if (
                    this._map._prefersReducedMotion() ||
                    (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
                  )
                    return;
                  const s = {
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    pan: new r.P(0, 0),
                    pinchAround: void 0,
                    around: void 0,
                  };
                  for (const { settings: g } of this._inertiaBuffer)
                    ((s.zoom += g.zoomDelta || 0),
                      (s.bearing += g.bearingDelta || 0),
                      (s.pitch += g.pitchDelta || 0),
                      g.panDelta && s.pan._add(g.panDelta),
                      g.around && (s.around = g.around),
                      g.pinchAround && (s.pinchAround = g.pinchAround));
                  const h =
                      this._inertiaBuffer[this._inertiaBuffer.length - 1].time -
                      this._inertiaBuffer[0].time,
                    p = {};
                  if (s.pan.mag()) {
                    const g = Cl(s.pan.mag(), h, r.h({}, qd, t || {}));
                    ((p.offset = s.pan.mult(g.amount / s.pan.mag())),
                      (p.center = this._map.transform.center),
                      Ml(p, g));
                  }
                  if (s.zoom) {
                    const g = Cl(s.zoom, h, Vs);
                    ((p.zoom = this._map.transform.zoom + g.amount), Ml(p, g));
                  }
                  if (s.bearing) {
                    const g = Cl(s.bearing, h, $o);
                    ((p.bearing =
                      this._map.transform.bearing + r.ay(g.amount, -179, 179)),
                      Ml(p, g));
                  }
                  if (s.pitch) {
                    const g = Cl(s.pitch, h, Uc);
                    ((p.pitch = this._map.transform.pitch + g.amount),
                      Ml(p, g));
                  }
                  if (p.zoom || p.bearing) {
                    const g =
                      s.pinchAround === void 0 ? s.around : s.pinchAround;
                    p.around = g
                      ? this._map.unproject(g)
                      : this._map.getCenter();
                  }
                  return (this.clear(), (p.noMoveStart = !0), p);
                }
              }
              function Ml(c, t) {
                (!c.duration || c.duration < t.duration) &&
                  ((c.duration = t.duration), (c.easing = t.easing));
              }
              function Cl(c, t, s) {
                const { maxSpeed: h, linearity: p, deceleration: g } = s,
                  x = r.ay((c * p) / (t / 1e3), -h, h),
                  w = Math.abs(x) / (g * p);
                return {
                  easing: s.easing,
                  duration: 1e3 * w,
                  amount: x * (w / 2),
                };
              }
              class ur extends r.A {
                preventDefault() {
                  this._defaultPrevented = !0;
                }
                get defaultPrevented() {
                  return this._defaultPrevented;
                }
                constructor(t, s, h, p = {}) {
                  const g = rt(s.getCanvasContainer(), h),
                    x = s.unproject(g);
                  (super(t, r.h({ point: g, lngLat: x, originalEvent: h }, p)),
                    (this._defaultPrevented = !1),
                    (this.target = s));
                }
              }
              class Pl extends r.A {
                preventDefault() {
                  this._defaultPrevented = !0;
                }
                get defaultPrevented() {
                  return this._defaultPrevented;
                }
                constructor(t, s, h) {
                  const p = t === "touchend" ? h.changedTouches : h.touches,
                    g = Ot(s.getCanvasContainer(), p),
                    x = g.map((S) => s.unproject(S)),
                    w = g.reduce(
                      (S, C, D, L) => S.add(C.div(L.length)),
                      new r.P(0, 0),
                    );
                  (super(t, {
                    points: g,
                    point: w,
                    lngLats: x,
                    lngLat: s.unproject(w),
                    originalEvent: h,
                  }),
                    (this._defaultPrevented = !1));
                }
              }
              class Ho extends r.A {
                preventDefault() {
                  this._defaultPrevented = !0;
                }
                get defaultPrevented() {
                  return this._defaultPrevented;
                }
                constructor(t, s) {
                  (super("wheel", { originalEvent: s }),
                    (this._defaultPrevented = !1));
                }
              }
              class Zd {
                constructor(t, s) {
                  ((this._map = t), (this._clickTolerance = s.clickTolerance));
                }
                reset() {
                  this._mousedownPos = void 0;
                }
                wheel(t) {
                  return this._firePreventable(new Ho(this._map, t));
                }
                mousedown(t, s) {
                  return (
                    (this._mousedownPos = s),
                    this._firePreventable(new ur(t.type, this._map, t))
                  );
                }
                mouseup(t) {
                  this._map.fire(new ur(t.type, this._map, t));
                }
                preclick(t) {
                  const s = r.h({}, t);
                  ((s.type = "preclick"),
                    this._map.fire(new ur(s.type, this._map, s)));
                }
                click(t, s) {
                  (this._mousedownPos &&
                    this._mousedownPos.dist(s) >= this._clickTolerance) ||
                    (this.preclick(t),
                    this._map.fire(new ur(t.type, this._map, t)));
                }
                dblclick(t) {
                  return this._firePreventable(new ur(t.type, this._map, t));
                }
                mouseover(t) {
                  this._map.fire(new ur(t.type, this._map, t));
                }
                mouseout(t) {
                  this._map.fire(new ur(t.type, this._map, t));
                }
                touchstart(t) {
                  return this._firePreventable(new Pl(t.type, this._map, t));
                }
                touchmove(t) {
                  this._map.fire(new Pl(t.type, this._map, t));
                }
                touchend(t) {
                  this._map.fire(new Pl(t.type, this._map, t));
                }
                touchcancel(t) {
                  this._map.fire(new Pl(t.type, this._map, t));
                }
                _firePreventable(t) {
                  if ((this._map.fire(t), t.defaultPrevented)) return {};
                }
                isEnabled() {
                  return !0;
                }
                isActive() {
                  return !1;
                }
                enable() {}
                disable() {}
              }
              class mu {
                constructor(t) {
                  this._map = t;
                }
                reset() {
                  ((this._delayContextMenu = !1),
                    (this._contextMenuEvent = void 0));
                }
                mousemove(t) {
                  this._map.fire(new ur(t.type, this._map, t));
                }
                mousedown() {
                  this._delayContextMenu = !0;
                }
                mouseup() {
                  ((this._delayContextMenu = !1),
                    this._contextMenuEvent &&
                      (this._map.fire(
                        new ur(
                          "contextmenu",
                          this._map,
                          this._contextMenuEvent,
                        ),
                      ),
                      delete this._contextMenuEvent));
                }
                contextmenu(t) {
                  (this._delayContextMenu
                    ? (this._contextMenuEvent = t)
                    : this._map.fire(new ur(t.type, this._map, t)),
                    this._map.listens("contextmenu") && t.preventDefault());
                }
                isEnabled() {
                  return !0;
                }
                isActive() {
                  return !1;
                }
                enable() {}
                disable() {}
              }
              class Xd {
                constructor(t, s) {
                  ((this._map = t),
                    (this._el = t.getCanvasContainer()),
                    (this._container = t.getContainer()),
                    (this._clickTolerance = s.clickTolerance || 1));
                }
                isEnabled() {
                  return !!this._enabled;
                }
                isActive() {
                  return !!this._active;
                }
                enable() {
                  this.isEnabled() || (this._enabled = !0);
                }
                disable() {
                  this.isEnabled() && (this._enabled = !1);
                }
                mousedown(t, s) {
                  this.isEnabled() &&
                    t.shiftKey &&
                    t.button === 0 &&
                    (Rt(),
                    (this._startPos = this._lastPos = s),
                    (this._active = !0));
                }
                mousemoveWindow(t, s) {
                  if (!this._active) return;
                  const h = s,
                    p = this._startPos,
                    g = this._lastPos;
                  if (
                    !p ||
                    !g ||
                    g.equals(h) ||
                    (!this._box && h.dist(p) < this._clickTolerance)
                  )
                    return;
                  ((this._lastPos = h),
                    this._box ||
                      ((this._box = xe(
                        "div",
                        "mapboxgl-boxzoom",
                        this._container,
                      )),
                      this._container.classList.add("mapboxgl-crosshair"),
                      this._fireEvent("boxzoomstart", t)));
                  const x = Math.min(p.x, h.x),
                    w = Math.max(p.x, h.x),
                    S = Math.min(p.y, h.y),
                    C = Math.max(p.y, h.y);
                  this._map._requestDomTask(() => {
                    this._box &&
                      ((this._box.style.transform = `translate(${x}px,${S}px)`),
                      (this._box.style.width = w - x + "px"),
                      (this._box.style.height = C - S + "px"));
                  });
                }
                mouseupWindow(t, s) {
                  if (!this._active) return;
                  const h = this._startPos,
                    p = s;
                  if (h && t.button === 0) {
                    if ((this.reset(), Re(), h.x !== p.x || h.y !== p.y))
                      return (
                        this._map.fire(
                          new r.A("boxzoomend", { originalEvent: t }),
                        ),
                        {
                          cameraAnimation: (g) =>
                            g.fitScreenCoordinates(
                              h,
                              p,
                              this._map.getBearing(),
                              { linear: !1 },
                            ),
                        }
                      );
                    this._fireEvent("boxzoomcancel", t);
                  }
                }
                keydown(t) {
                  this._active &&
                    t.keyCode === 27 &&
                    (this.reset(), this._fireEvent("boxzoomcancel", t));
                }
                blur() {
                  this.reset();
                }
                reset() {
                  ((this._active = !1),
                    this._container.classList.remove("mapboxgl-crosshair"),
                    this._box && (this._box.remove(), (this._box = null)),
                    Mt(),
                    delete this._startPos,
                    delete this._lastPos);
                }
                _fireEvent(t, s) {
                  return this._map.fire(new r.A(t, { originalEvent: s }));
                }
              }
              function jc(c, t) {
                const s = {};
                for (let h = 0; h < c.length; h++) s[c[h].identifier] = t[h];
                return s;
              }
              class dr {
                constructor(t) {
                  (this.reset(), (this.numTouches = t.numTouches));
                }
                reset() {
                  ((this.centroid = void 0),
                    (this.startTime = 0),
                    (this.touches = {}),
                    (this.aborted = !1));
                }
                touchstart(t, s, h) {
                  ((this.centroid || h.length > this.numTouches) &&
                    (this.aborted = !0),
                    this.aborted ||
                      (this.startTime === 0 && (this.startTime = t.timeStamp),
                      h.length === this.numTouches &&
                        ((this.centroid = (function (p) {
                          const g = new r.P(0, 0);
                          for (const x of p) g._add(x);
                          return g.div(p.length);
                        })(s)),
                        (this.touches = jc(h, s)))));
                }
                touchmove(t, s, h) {
                  if (this.aborted || !this.centroid) return;
                  const p = jc(h, s);
                  for (const g in this.touches) {
                    const x = p[g];
                    (!x || x.dist(this.touches[g]) > 30) && (this.aborted = !0);
                  }
                }
                touchend(t, s, h) {
                  if (
                    ((!this.centroid || t.timeStamp - this.startTime > 500) &&
                      (this.aborted = !0),
                    h.length === 0)
                  ) {
                    const p = !this.aborted && this.centroid;
                    if ((this.reset(), p)) return p;
                  }
                }
              }
              class Gc {
                constructor(t) {
                  ((this.singleTap = new dr(t)),
                    (this.numTaps = t.numTaps),
                    this.reset());
                }
                reset() {
                  ((this.lastTime = 1 / 0),
                    (this.lastTap = void 0),
                    (this.count = 0),
                    this.singleTap.reset());
                }
                touchstart(t, s, h) {
                  this.singleTap.touchstart(t, s, h);
                }
                touchmove(t, s, h) {
                  this.singleTap.touchmove(t, s, h);
                }
                touchend(t, s, h) {
                  const p = this.singleTap.touchend(t, s, h);
                  if (p) {
                    const g = t.timeStamp - this.lastTime < 500,
                      x = !this.lastTap || this.lastTap.dist(p) < 30;
                    if (
                      ((g && x) || this.reset(),
                      this.count++,
                      (this.lastTime = t.timeStamp),
                      (this.lastTap = p),
                      this.count === this.numTaps)
                    )
                      return (this.reset(), p);
                  }
                }
              }
              class Yd {
                constructor() {
                  ((this._zoomIn = new Gc({ numTouches: 1, numTaps: 2 })),
                    (this._zoomOut = new Gc({ numTouches: 2, numTaps: 1 })),
                    this.reset());
                }
                reset() {
                  ((this._active = !1),
                    this._zoomIn.reset(),
                    this._zoomOut.reset());
                }
                touchstart(t, s, h) {
                  (this._zoomIn.touchstart(t, s, h),
                    this._zoomOut.touchstart(t, s, h));
                }
                touchmove(t, s, h) {
                  (this._zoomIn.touchmove(t, s, h),
                    this._zoomOut.touchmove(t, s, h));
                }
                touchend(t, s, h) {
                  const p = this._zoomIn.touchend(t, s, h),
                    g = this._zoomOut.touchend(t, s, h);
                  return p
                    ? ((this._active = !0),
                      t.preventDefault(),
                      setTimeout(() => this.reset(), 0),
                      {
                        cameraAnimation: (x) =>
                          x.easeTo(
                            {
                              duration: 300,
                              zoom: x.getZoom() + 1,
                              around: x.unproject(p),
                            },
                            { originalEvent: t },
                          ),
                      })
                    : g
                      ? ((this._active = !0),
                        t.preventDefault(),
                        setTimeout(() => this.reset(), 0),
                        {
                          cameraAnimation: (x) =>
                            x.easeTo(
                              {
                                duration: 300,
                                zoom: x.getZoom() - 1,
                                around: x.unproject(g),
                              },
                              { originalEvent: t },
                            ),
                        })
                      : void 0;
                }
                touchcancel() {
                  this.reset();
                }
                enable() {
                  this._enabled = !0;
                }
                disable() {
                  ((this._enabled = !1), this.reset());
                }
                isEnabled() {
                  return this._enabled;
                }
                isActive() {
                  return this._active;
                }
              }
              const Kd = { 0: 1, 2: 2 },
                Wo = {
                  Control: "ctrlKey",
                  Alt: "altKey",
                  Shift: "shiftKey",
                  Meta: "metaKey",
                };
              class $c {
                constructor(t) {
                  (this.reset(),
                    (this._clickTolerance = t.clickTolerance || 1));
                }
                blur() {
                  this.reset();
                }
                reset() {
                  ((this._active = !1),
                    (this._moved = !1),
                    (this._lastPoint = void 0),
                    (this._eventButton = void 0));
                }
                _correctButton(t, s) {
                  return !1;
                }
                _move(t, s) {
                  return {};
                }
                mousedown(t, s) {
                  if (this._lastPoint) return;
                  const h = _i(t);
                  this._correctButton(t, h) &&
                    ((this._lastPoint = s), (this._eventButton = h));
                }
                mousemoveWindow(t, s) {
                  const h = this._lastPoint;
                  if (h) {
                    if (
                      (t.preventDefault(),
                      this._eventButton != null &&
                        (function (p, g) {
                          const x = Kd[g];
                          return p.buttons === void 0 || (p.buttons & x) !== x;
                        })(t, this._eventButton))
                    )
                      this.reset();
                    else if (this._moved || !(s.dist(h) < this._clickTolerance))
                      return (
                        (this._moved = !0),
                        (this._lastPoint = s),
                        this._move(h, s)
                      );
                  }
                }
                mouseupWindow(t) {
                  this._lastPoint &&
                    _i(t) === this._eventButton &&
                    (this._moved && Re(), this.reset());
                }
                enable() {
                  this._enabled = !0;
                }
                disable() {
                  ((this._enabled = !1), this.reset());
                }
                isEnabled() {
                  return this._enabled;
                }
                isActive() {
                  return this._active;
                }
              }
              class Jd extends $c {
                mousedown(t, s) {
                  (super.mousedown(t, s),
                    this._lastPoint && (this._active = !0));
                }
                _correctButton(t, s) {
                  return s === 0 && !t.ctrlKey;
                }
                _move(t, s) {
                  return { around: s, panDelta: s.sub(t) };
                }
              }
              class gu extends $c {
                constructor(t) {
                  (super(t),
                    (this._pitchRotateKey = t.pitchRotateKey
                      ? Wo[t.pitchRotateKey]
                      : void 0));
                }
                _correctButton(t, s) {
                  return this._pitchRotateKey
                    ? s === 0 && t[this._pitchRotateKey]
                    : (s === 0 && t.ctrlKey) || s === 2;
                }
                _move(t, s) {
                  const h = 0.8 * (s.x - t.x);
                  if (h) return ((this._active = !0), { bearingDelta: h });
                }
                contextmenu(t) {
                  this._pitchRotateKey || t.preventDefault();
                }
              }
              class ka extends $c {
                constructor(t) {
                  (super(t),
                    (this._pitchRotateKey = t.pitchRotateKey
                      ? Wo[t.pitchRotateKey]
                      : void 0));
                }
                _correctButton(t, s) {
                  return this._pitchRotateKey
                    ? s === 0 && t[this._pitchRotateKey]
                    : (s === 0 && t.ctrlKey) || s === 2;
                }
                _move(t, s) {
                  const h = -0.5 * (s.y - t.y);
                  if (h) return ((this._active = !0), { pitchDelta: h });
                }
                contextmenu(t) {
                  this._pitchRotateKey || t.preventDefault();
                }
              }
              class Qd {
                constructor(t, s) {
                  ((this._map = t),
                    (this._el = t.getCanvasContainer()),
                    (this._minTouches = 1),
                    (this._clickTolerance = s.clickTolerance || 1),
                    this.reset(),
                    r.aV(
                      ["_addTouchPanBlocker", "_showTouchPanBlockerAlert"],
                      this,
                    ));
                }
                reset() {
                  ((this._active = !1),
                    (this._touches = {}),
                    (this._sum = new r.P(0, 0)));
                }
                touchstart(t, s, h) {
                  return this._calculateTransform(t, s, h);
                }
                touchmove(t, s, h) {
                  if (this._active && !(h.length < this._minTouches)) {
                    if (
                      this._map._cooperativeGestures &&
                      !this._map.isMoving()
                    ) {
                      if (h.length === 1 && !r.ex())
                        return void this._showTouchPanBlockerAlert();
                      this._alertContainer.style.visibility !== "hidden" &&
                        ((this._alertContainer.style.visibility = "hidden"),
                        clearTimeout(this._alertTimer));
                    }
                    return (
                      t.cancelable && t.preventDefault(),
                      this._calculateTransform(t, s, h)
                    );
                  }
                }
                touchend(t, s, h) {
                  (this._calculateTransform(t, s, h),
                    this._active &&
                      h.length < this._minTouches &&
                      this.reset());
                }
                touchcancel() {
                  this.reset();
                }
                _calculateTransform(t, s, h) {
                  h.length > 0 && (this._active = !0);
                  const p = jc(h, s),
                    g = new r.P(0, 0),
                    x = new r.P(0, 0);
                  let w = 0;
                  for (const C in p) {
                    const D = p[C],
                      L = this._touches[C];
                    L && (g._add(D), x._add(D.sub(L)), w++, (p[C] = D));
                  }
                  if (((this._touches = p), w < this._minTouches || !x.mag()))
                    return;
                  const S = x.div(w);
                  return (
                    this._sum._add(S),
                    this._sum.mag() < this._clickTolerance
                      ? void 0
                      : { around: g.div(w), panDelta: S }
                  );
                }
                enable() {
                  ((this._enabled = !0),
                    this._map._cooperativeGestures &&
                      (this._addTouchPanBlocker(),
                      this._el.classList.add(
                        "mapboxgl-touch-pan-blocker-override",
                        "mapboxgl-scrollable-page",
                      )));
                }
                disable() {
                  ((this._enabled = !1),
                    this._map._cooperativeGestures &&
                      (clearTimeout(this._alertTimer),
                      this._alertContainer.remove(),
                      this._el.classList.remove(
                        "mapboxgl-touch-pan-blocker-override",
                        "mapboxgl-scrollable-page",
                      )),
                    this.reset());
                }
                isEnabled() {
                  return !!this._enabled;
                }
                isActive() {
                  return !!this._active;
                }
                _addTouchPanBlocker() {
                  this._map &&
                    !this._alertContainer &&
                    ((this._alertContainer = xe(
                      "div",
                      "mapboxgl-touch-pan-blocker",
                      this._map._container,
                    )),
                    (this._alertContainer.textContent = this._map._getUIString(
                      "TouchPanBlocker.Message",
                    )),
                    (this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`));
                }
                _showTouchPanBlockerAlert() {
                  ((this._alertContainer.style.visibility = "visible"),
                    this._alertContainer.classList.add(
                      "mapboxgl-touch-pan-blocker-show",
                    ),
                    this._alertContainer.setAttribute("role", "alert"),
                    clearTimeout(this._alertTimer),
                    (this._alertTimer = window.setTimeout(() => {
                      (this._alertContainer.classList.remove(
                        "mapboxgl-touch-pan-blocker-show",
                      ),
                        this._alertContainer.removeAttribute("role"));
                    }, 500)));
                }
              }
              class Hc {
                constructor() {
                  this.reset();
                }
                reset() {
                  ((this._active = !1), (this._firstTwoTouches = void 0));
                }
                _start(t) {}
                _move(t, s, h) {
                  return {};
                }
                touchstart(t, s, h) {
                  this._firstTwoTouches ||
                    h.length < 2 ||
                    ((this._firstTwoTouches = [
                      h[0].identifier,
                      h[1].identifier,
                    ]),
                    this._start([s[0], s[1]]));
                }
                touchmove(t, s, h) {
                  const p = this._firstTwoTouches;
                  if (!p) return;
                  t.preventDefault();
                  const [g, x] = p,
                    w = Dl(h, s, g),
                    S = Dl(h, s, x);
                  if (!w || !S) return;
                  const C = this._aroundCenter ? null : w.add(S).div(2);
                  return this._move([w, S], C, t);
                }
                touchend(t, s, h) {
                  if (!this._firstTwoTouches) return;
                  const [p, g] = this._firstTwoTouches,
                    x = Dl(h, s, p),
                    w = Dl(h, s, g);
                  (x && w) || (this._active && Re(), this.reset());
                }
                touchcancel() {
                  this.reset();
                }
                enable(t) {
                  ((this._enabled = !0),
                    (this._aroundCenter = !!t && t.around === "center"));
                }
                disable() {
                  ((this._enabled = !1), this.reset());
                }
                isEnabled() {
                  return this._enabled;
                }
                isActive() {
                  return this._active;
                }
              }
              function Dl(c, t, s) {
                for (let h = 0; h < c.length; h++)
                  if (c[h].identifier === s) return t[h];
              }
              function Wc(c, t) {
                return Math.log(c / t) / Math.LN2;
              }
              class ef extends Hc {
                reset() {
                  (super.reset(),
                    (this._distance = 0),
                    (this._startDistance = 0));
                }
                _start(t) {
                  this._startDistance = this._distance = t[0].dist(t[1]);
                }
                _move(t, s) {
                  const h = this._distance;
                  if (
                    ((this._distance = t[0].dist(t[1])),
                    this._active ||
                      !(
                        Math.abs(Wc(this._distance, this._startDistance)) < 0.1
                      ))
                  )
                    return (
                      (this._active = !0),
                      { zoomDelta: Wc(this._distance, h), pinchAround: s }
                    );
                }
              }
              function _u(c, t) {
                return (180 * c.angleWith(t)) / Math.PI;
              }
              class cm extends Hc {
                reset() {
                  (super.reset(),
                    (this._minDiameter = 0),
                    (this._startVector = void 0),
                    (this._vector = void 0));
                }
                _start(t) {
                  ((this._startVector = this._vector = t[0].sub(t[1])),
                    (this._minDiameter = t[0].dist(t[1])));
                }
                _move(t, s) {
                  const h = this._vector;
                  if (
                    ((this._vector = t[0].sub(t[1])),
                    h &&
                      (this._active || !this._isBelowThreshold(this._vector)))
                  )
                    return (
                      (this._active = !0),
                      { bearingDelta: _u(this._vector, h), pinchAround: s }
                    );
                }
                _isBelowThreshold(t) {
                  this._minDiameter = Math.min(this._minDiameter, t.mag());
                  const s = (25 / (Math.PI * this._minDiameter)) * 360,
                    h = this._startVector;
                  if (!h) return !1;
                  const p = _u(t, h);
                  return Math.abs(p) < s;
                }
              }
              function yu(c) {
                return Math.abs(c.y) > Math.abs(c.x);
              }
              class hm extends Hc {
                constructor(t) {
                  (super(), (this._map = t));
                }
                reset() {
                  (super.reset(),
                    (this._valid = void 0),
                    (this._firstMove = void 0),
                    (this._lastPoints = void 0));
                }
                _start(t) {
                  ((this._lastPoints = t),
                    yu(t[0].sub(t[1])) && (this._valid = !1));
                }
                _move(t, s, h) {
                  const p = this._lastPoints;
                  if (!p) return;
                  const g = t[0].sub(p[0]),
                    x = t[1].sub(p[1]);
                  return (this._map._cooperativeGestures &&
                    !r.ex() &&
                    h.touches.length < 3) ||
                    ((this._valid = this.gestureBeginsVertically(
                      g,
                      x,
                      h.timeStamp,
                    )),
                    !this._valid)
                    ? void 0
                    : ((this._lastPoints = t),
                      (this._active = !0),
                      { pitchDelta: ((g.y + x.y) / 2) * -0.5 });
                }
                gestureBeginsVertically(t, s, h) {
                  if (this._valid !== void 0) return this._valid;
                  const p = t.mag() >= 2,
                    g = s.mag() >= 2;
                  if (!p && !g) return;
                  if (!p || !g)
                    return (
                      this._firstMove == null && (this._firstMove = h),
                      h - this._firstMove < 100 && void 0
                    );
                  const x = t.y > 0 == s.y > 0;
                  return yu(t) && yu(s) && x;
                }
              }
              const um = { panStep: 100, bearingStep: 15, pitchStep: 10 };
              class dm {
                constructor() {
                  const t = um;
                  ((this._panStep = t.panStep),
                    (this._bearingStep = t.bearingStep),
                    (this._pitchStep = t.pitchStep),
                    (this._rotationDisabled = !1));
                }
                blur() {
                  this.reset();
                }
                reset() {
                  this._active = !1;
                }
                keydown(t) {
                  if (t.altKey || t.ctrlKey || t.metaKey) return;
                  let s = 0,
                    h = 0,
                    p = 0,
                    g = 0,
                    x = 0;
                  switch (t.keyCode) {
                    case 61:
                    case 107:
                    case 171:
                    case 187:
                      s = 1;
                      break;
                    case 189:
                    case 109:
                    case 173:
                      s = -1;
                      break;
                    case 37:
                      t.shiftKey ? (h = -1) : (t.preventDefault(), (g = -1));
                      break;
                    case 39:
                      t.shiftKey ? (h = 1) : (t.preventDefault(), (g = 1));
                      break;
                    case 38:
                      t.shiftKey ? (p = 1) : (t.preventDefault(), (x = -1));
                      break;
                    case 40:
                      t.shiftKey ? (p = -1) : (t.preventDefault(), (x = 1));
                      break;
                    default:
                      return;
                  }
                  return (
                    this._rotationDisabled && ((h = 0), (p = 0)),
                    {
                      cameraAnimation: (w) => {
                        const S = w.getZoom();
                        w.easeTo(
                          {
                            duration: 300,
                            easeId: "keyboardHandler",
                            easing: fm,
                            zoom: s
                              ? Math.round(S) + s * (t.shiftKey ? 2 : 1)
                              : S,
                            bearing: w.getBearing() + h * this._bearingStep,
                            pitch: w.getPitch() + p * this._pitchStep,
                            offset: [-g * this._panStep, -x * this._panStep],
                            center: w.getCenter(),
                          },
                          { originalEvent: t },
                        );
                      },
                    }
                  );
                }
                enable() {
                  this._enabled = !0;
                }
                disable() {
                  ((this._enabled = !1), this.reset());
                }
                isEnabled() {
                  return this._enabled;
                }
                isActive() {
                  return this._active;
                }
                disableRotation() {
                  this._rotationDisabled = !0;
                }
                enableRotation() {
                  this._rotationDisabled = !1;
                }
              }
              function fm(c) {
                return c * (2 - c);
              }
              const tf = 4.000244140625,
                pm = 1 / 450;
              class mm {
                constructor(t, s) {
                  ((this._map = t),
                    (this._el = t.getCanvasContainer()),
                    (this._handler = s),
                    (this._delta = 0),
                    (this._lastDelta = 0),
                    (this._defaultZoomRate = 0.01),
                    (this._wheelZoomRate = pm),
                    r.aV(
                      [
                        "_onTimeout",
                        "_addScrollZoomBlocker",
                        "_showBlockerAlert",
                      ],
                      this,
                    ));
                }
                setZoomRate(t) {
                  this._defaultZoomRate = t;
                }
                setWheelZoomRate(t) {
                  this._wheelZoomRate = t;
                }
                isEnabled() {
                  return !!this._enabled;
                }
                isActive() {
                  return this._active || this._finishTimeout !== void 0;
                }
                isZooming() {
                  return !!this._zooming;
                }
                enable(t) {
                  this.isEnabled() ||
                    ((this._enabled = !0),
                    (this._aroundCenter = !!t && t.around === "center"),
                    this._map._cooperativeGestures &&
                      this._addScrollZoomBlocker());
                }
                disable() {
                  this.isEnabled() &&
                    ((this._enabled = !1),
                    this._map._cooperativeGestures &&
                      (clearTimeout(this._alertTimer),
                      this._alertContainer.remove()));
                }
                wheel(t) {
                  if (!this.isEnabled()) return;
                  if (this._map._cooperativeGestures) {
                    if (!(t.ctrlKey || t.metaKey || this.isZooming() || r.ex()))
                      return void this._showBlockerAlert();
                    this._alertContainer.style.visibility !== "hidden" &&
                      ((this._alertContainer.style.visibility = "hidden"),
                      clearTimeout(this._alertTimer));
                  }
                  let s =
                    t.deltaMode === WheelEvent.DOM_DELTA_LINE
                      ? 40 * t.deltaY
                      : t.deltaY;
                  const h = r.q.now(),
                    p = h - (this._lastWheelEventTime || 0);
                  ((this._lastWheelEventTime = h),
                    s !== 0 && s % tf == 0
                      ? (this._type = "wheel")
                      : s !== 0 && Math.abs(s) < 4
                        ? (this._type = "trackpad")
                        : p > 400
                          ? ((this._type = null),
                            (this._lastValue = s),
                            (this._timeout = window.setTimeout(
                              this._onTimeout,
                              40,
                              t,
                            )))
                          : this._type ||
                            ((this._type =
                              Math.abs(p * s) < 200 ? "trackpad" : "wheel"),
                            this._timeout &&
                              (clearTimeout(this._timeout),
                              (this._timeout = null),
                              (s += this._lastValue))),
                    t.shiftKey && s && (s /= 4),
                    this._type &&
                      ((this._lastWheelEvent = t),
                      (this._delta -= s),
                      this._active || this._start(t)),
                    t.preventDefault());
                }
                _onTimeout(t) {
                  ((this._type = "wheel"),
                    (this._delta -= this._lastValue),
                    this._active || this._start(t));
                }
                _start(t) {
                  if (!this._delta) return;
                  (this._frameId && (this._frameId = null),
                    (this._active = !0),
                    this.isZooming() || (this._zooming = !0),
                    this._finishTimeout &&
                      (clearTimeout(this._finishTimeout),
                      delete this._finishTimeout));
                  const s = rt(this._el, t);
                  ((this._aroundPoint = this._aroundCenter
                    ? this._map.transform.centerPoint
                    : s),
                    (this._aroundCoord = this._map.transform.pointCoordinate3D(
                      this._aroundPoint,
                    )),
                    (this._targetZoom = void 0),
                    this._frameId ||
                      ((this._frameId = !0),
                      this._handler._triggerRenderFrame()));
                }
                renderFrame() {
                  if (
                    !this._frameId ||
                    ((this._frameId = null), !this.isActive())
                  )
                    return;
                  const t = this._map.transform;
                  this._type === "wheel" &&
                    t.projection.wrap &&
                    (t._center.lng >= 180 || t._center.lng <= -180) &&
                    ((this._prevEase = null),
                    (this._easing = null),
                    (this._lastWheelEvent = null),
                    (this._lastWheelEventTime = 0));
                  const s = () =>
                    t._terrainEnabled() && this._aroundCoord
                      ? t.computeZoomRelativeTo(this._aroundCoord)
                      : t.zoom;
                  if (this._delta !== 0) {
                    const C =
                      this._type === "wheel" && Math.abs(this._delta) > tf
                        ? this._wheelZoomRate
                        : this._defaultZoomRate;
                    let D = 2 / (1 + Math.exp(-Math.abs(this._delta * C)));
                    this._delta < 0 && D !== 0 && (D = 1 / D);
                    const L = s(),
                      z = Math.pow(2, L),
                      O =
                        typeof this._targetZoom == "number"
                          ? t.zoomScale(this._targetZoom)
                          : z;
                    ((this._targetZoom = Math.min(
                      t.maxZoom,
                      Math.max(t.minZoom, t.scaleZoom(O * D)),
                    )),
                      this._type === "wheel" &&
                        ((this._startZoom = L),
                        (this._easing = this._smoothOutEasing(200))),
                      (this._lastDelta = this._delta),
                      (this._delta = 0));
                  }
                  const h =
                      typeof this._targetZoom == "number"
                        ? this._targetZoom
                        : s(),
                    p = this._startZoom,
                    g = this._easing;
                  let x,
                    w = !1;
                  if (this._type === "wheel" && p && g) {
                    const C = Math.min(
                        (r.q.now() - this._lastWheelEventTime) / 200,
                        1,
                      ),
                      D = g(C);
                    ((x = r.ai(p, h, D)),
                      C < 1 ? this._frameId || (this._frameId = !0) : (w = !0));
                  } else ((x = h), (w = !0));
                  ((this._active = !0),
                    w &&
                      ((this._active = !1),
                      (this._finishTimeout = window.setTimeout(() => {
                        ((this._zooming = !1),
                          this._handler._triggerRenderFrame(),
                          delete this._targetZoom,
                          delete this._finishTimeout);
                      }, 200))));
                  let S = x - s();
                  return (
                    S * this._lastDelta < 0 && (S = 0),
                    {
                      noInertia: !0,
                      needsRenderFrame: !w,
                      zoomDelta: S,
                      around: this._aroundPoint,
                      aroundCoord: this._aroundCoord,
                      originalEvent: this._lastWheelEvent,
                    }
                  );
                }
                _smoothOutEasing(t) {
                  let s = r.ey;
                  if (this._prevEase) {
                    const h = this._prevEase,
                      p = (r.q.now() - h.start) / h.duration,
                      g = h.easing(p + 0.01) - h.easing(p),
                      x = (0.27 / Math.sqrt(g * g + 1e-4)) * 0.01,
                      w = Math.sqrt(0.0729 - x * x);
                    s = r.ew(x, w, 0.25, 1);
                  }
                  return (
                    (this._prevEase = {
                      start: r.q.now(),
                      duration: t,
                      easing: s,
                    }),
                    s
                  );
                }
                blur() {
                  this.reset();
                }
                reset() {
                  this._active = !1;
                }
                _addScrollZoomBlocker() {
                  this._map &&
                    !this._alertContainer &&
                    ((this._alertContainer = xe(
                      "div",
                      "mapboxgl-scroll-zoom-blocker",
                      this._map._container,
                    )),
                    (this._alertContainer.textContent = /(Mac|iPad)/i.test(
                      navigator.userAgent,
                    )
                      ? this._map._getUIString("ScrollZoomBlocker.CmdMessage")
                      : this._map._getUIString(
                          "ScrollZoomBlocker.CtrlMessage",
                        )),
                    (this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`));
                }
                _showBlockerAlert() {
                  ((this._alertContainer.style.visibility = "visible"),
                    this._alertContainer.classList.add(
                      "mapboxgl-scroll-zoom-blocker-show",
                    ),
                    this._alertContainer.setAttribute("role", "alert"),
                    clearTimeout(this._alertTimer),
                    (this._alertTimer = window.setTimeout(() => {
                      (this._alertContainer.classList.remove(
                        "mapboxgl-scroll-zoom-blocker-show",
                      ),
                        this._alertContainer.removeAttribute("role"));
                    }, 200)));
                }
              }
              class gm {
                constructor(t, s) {
                  ((this._clickZoom = t), (this._tapZoom = s));
                }
                enable() {
                  (this._clickZoom.enable(), this._tapZoom.enable());
                }
                disable() {
                  (this._clickZoom.disable(), this._tapZoom.disable());
                }
                isEnabled() {
                  return (
                    this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
                  );
                }
                isActive() {
                  return this._clickZoom.isActive() || this._tapZoom.isActive();
                }
              }
              class _m {
                constructor() {
                  this.reset();
                }
                reset() {
                  this._active = !1;
                }
                blur() {
                  this.reset();
                }
                dblclick(t, s) {
                  return (
                    t.preventDefault(),
                    {
                      cameraAnimation: (h) => {
                        h.easeTo(
                          {
                            duration: 300,
                            zoom: h.getZoom() + (t.shiftKey ? -1 : 1),
                            around: h.unproject(s),
                          },
                          { originalEvent: t },
                        );
                      },
                    }
                  );
                }
                enable() {
                  this._enabled = !0;
                }
                disable() {
                  ((this._enabled = !1), this.reset());
                }
                isEnabled() {
                  return this._enabled;
                }
                isActive() {
                  return this._active;
                }
              }
              class ym {
                constructor() {
                  ((this._tap = new Gc({ numTouches: 1, numTaps: 1 })),
                    this.reset());
                }
                reset() {
                  ((this._active = !1),
                    (this._swipePoint = void 0),
                    (this._swipeTouch = 0),
                    (this._tapTime = 0),
                    this._tap.reset());
                }
                touchstart(t, s, h) {
                  this._swipePoint ||
                    (this._tapTime &&
                      t.timeStamp - this._tapTime > 500 &&
                      this.reset(),
                    this._tapTime
                      ? h.length > 0 &&
                        ((this._swipePoint = s[0]),
                        (this._swipeTouch = h[0].identifier))
                      : this._tap.touchstart(t, s, h));
                }
                touchmove(t, s, h) {
                  if (this._tapTime) {
                    if (this._swipePoint) {
                      if (h[0].identifier !== this._swipeTouch) return;
                      const p = s[0],
                        g = p.y - this._swipePoint.y;
                      return (
                        (this._swipePoint = p),
                        t.preventDefault(),
                        (this._active = !0),
                        { zoomDelta: g / 128 }
                      );
                    }
                  } else this._tap.touchmove(t, s, h);
                }
                touchend(t, s, h) {
                  this._tapTime
                    ? this._swipePoint && h.length === 0 && this.reset()
                    : this._tap.touchend(t, s, h) &&
                      (this._tapTime = t.timeStamp);
                }
                touchcancel() {
                  this.reset();
                }
                enable() {
                  this._enabled = !0;
                }
                disable() {
                  ((this._enabled = !1), this.reset());
                }
                isEnabled() {
                  return this._enabled;
                }
                isActive() {
                  return this._active;
                }
              }
              class xm {
                constructor(t, s, h) {
                  ((this._el = t), (this._mousePan = s), (this._touchPan = h));
                }
                enable(t) {
                  ((this._inertiaOptions = t || {}),
                    this._mousePan.enable(),
                    this._touchPan.enable(),
                    this._el.classList.add("mapboxgl-touch-drag-pan"));
                }
                disable() {
                  (this._mousePan.disable(),
                    this._touchPan.disable(),
                    this._el.classList.remove("mapboxgl-touch-drag-pan"));
                }
                isEnabled() {
                  return (
                    this._mousePan.isEnabled() && this._touchPan.isEnabled()
                  );
                }
                isActive() {
                  return this._mousePan.isActive() || this._touchPan.isActive();
                }
              }
              class $_ {
                constructor(t, s, h) {
                  ((this._pitchWithRotate = t.pitchWithRotate),
                    (this._mouseRotate = s),
                    (this._mousePitch = h));
                }
                enable() {
                  (this._mouseRotate.enable(),
                    this._pitchWithRotate && this._mousePitch.enable());
                }
                disable() {
                  (this._mouseRotate.disable(), this._mousePitch.disable());
                }
                isEnabled() {
                  return (
                    this._mouseRotate.isEnabled() &&
                    (!this._pitchWithRotate || this._mousePitch.isEnabled())
                  );
                }
                isActive() {
                  return (
                    this._mouseRotate.isActive() || this._mousePitch.isActive()
                  );
                }
              }
              class H_ {
                constructor(t, s, h, p) {
                  ((this._el = t),
                    (this._touchZoom = s),
                    (this._touchRotate = h),
                    (this._tapDragZoom = p),
                    (this._rotationDisabled = !1),
                    (this._enabled = !0));
                }
                enable(t) {
                  (this._touchZoom.enable(t),
                    this._rotationDisabled || this._touchRotate.enable(t),
                    this._tapDragZoom.enable(),
                    this._el.classList.add("mapboxgl-touch-zoom-rotate"));
                }
                disable() {
                  (this._touchZoom.disable(),
                    this._touchRotate.disable(),
                    this._tapDragZoom.disable(),
                    this._el.classList.remove("mapboxgl-touch-zoom-rotate"));
                }
                isEnabled() {
                  return (
                    this._touchZoom.isEnabled() &&
                    (this._rotationDisabled || this._touchRotate.isEnabled()) &&
                    this._tapDragZoom.isEnabled()
                  );
                }
                isActive() {
                  return (
                    this._touchZoom.isActive() ||
                    this._touchRotate.isActive() ||
                    this._tapDragZoom.isActive()
                  );
                }
                disableRotation() {
                  ((this._rotationDisabled = !0), this._touchRotate.disable());
                }
                enableRotation() {
                  ((this._rotationDisabled = !1),
                    this._touchZoom.isEnabled() && this._touchRotate.enable());
                }
              }
              const xu = (c) => c.zoom || c.drag || c.pitch || c.rotate;
              class Rn extends r.A {}
              class vm {
                constructor() {
                  ((this.constants = [1, 1, 0.01]), (this.radius = 0));
                }
                setup(t, s) {
                  const h = r.at([], s, t);
                  this.radius = r.ae(
                    h[2] < 0 ? r.eA([], h, this.constants) : [h[0], h[1], 0],
                  );
                }
                projectRay(t) {
                  (r.eA(t, t, this.constants),
                    r.au(t, t),
                    r.eB(t, t, this.constants));
                  const s = r.bY([], t, this.radius);
                  if (s[2] > 0) {
                    const h = r.bY([], [0, 0, 1], r.bG(s, [0, 0, 1])),
                      p = r.bY([], r.au([], [s[0], s[1], 0]), this.radius),
                      g = r.cV([], s, r.bY([], r.at([], r.cV([], p, h), s), 2));
                    ((s[0] = g[0]), (s[1] = g[1]));
                  }
                  return s;
                }
              }
              function vu(c) {
                return (
                  (c.panDelta && c.panDelta.mag()) ||
                  c.zoomDelta ||
                  c.bearingDelta ||
                  c.pitchDelta
                );
              }
              class nf {
                constructor(t, s) {
                  ((this._map = t),
                    (this._el = this._map.getCanvasContainer()),
                    (this._handlers = []),
                    (this._handlersById = {}),
                    (this._changes = []),
                    (this._inertia = new pu(t)),
                    (this._bearingSnap = s.bearingSnap),
                    (this._previousActiveHandlers = {}),
                    (this._trackingEllipsoid = new vm()),
                    (this._dragOrigin = null),
                    (this._eventsInProgress = {}),
                    this._addDefaultHandlers(s),
                    r.aV(["handleEvent", "handleWindowEvent"], this));
                  const h = this._el;
                  this._listeners = [
                    [h, "touchstart", { passive: !0 }],
                    [h, "touchmove", { passive: !1 }],
                    [h, "touchend", void 0],
                    [h, "touchcancel", void 0],
                    [h, "mousedown", void 0],
                    [h, "mousemove", void 0],
                    [h, "mouseup", void 0],
                    [document, "mousemove", { capture: !0 }],
                    [document, "mouseup", void 0],
                    [h, "mouseover", void 0],
                    [h, "mouseout", void 0],
                    [h, "dblclick", void 0],
                    [h, "click", void 0],
                    [h, "keydown", { capture: !1 }],
                    [h, "keyup", void 0],
                    [h, "wheel", { passive: !1 }],
                    [h, "contextmenu", void 0],
                    [window, "blur", void 0],
                  ];
                  for (const [p, g, x] of this._listeners) {
                    const w =
                      p === document
                        ? this.handleWindowEvent
                        : this.handleEvent;
                    p.addEventListener(g, w, x);
                  }
                }
                destroy() {
                  for (const [t, s, h] of this._listeners) {
                    const p =
                      t === document
                        ? this.handleWindowEvent
                        : this.handleEvent;
                    t.removeEventListener(s, p, h);
                  }
                }
                _addDefaultHandlers(t) {
                  const s = this._map,
                    h = s.getCanvasContainer();
                  this._add("mapEvent", new Zd(s, t));
                  const p = (s.boxZoom = new Xd(s, t));
                  this._add("boxZoom", p);
                  const g = new Yd(),
                    x = new _m();
                  ((s.doubleClickZoom = new gm(x, g)),
                    this._add("tapZoom", g),
                    this._add("clickZoom", x));
                  const w = new ym();
                  this._add("tapDragZoom", w);
                  const S = (s.touchPitch = new hm(s));
                  this._add("touchPitch", S);
                  const C = new gu(t),
                    D = new ka(t);
                  ((s.dragRotate = new $_(t, C, D)),
                    this._add("mouseRotate", C, ["mousePitch"]),
                    this._add("mousePitch", D, ["mouseRotate"]));
                  const L = new Jd(t),
                    z = new Qd(s, t);
                  ((s.dragPan = new xm(h, L, z)),
                    this._add("mousePan", L),
                    this._add("touchPan", z, ["touchZoom", "touchRotate"]));
                  const O = new cm(),
                    G = new ef();
                  ((s.touchZoomRotate = new H_(h, G, O, w)),
                    this._add("touchRotate", O, ["touchPan", "touchZoom"]),
                    this._add("touchZoom", G, ["touchPan", "touchRotate"]),
                    this._add("blockableMapEvent", new mu(s)));
                  const U = (s.scrollZoom = new mm(s, this));
                  this._add("scrollZoom", U, ["mousePan"]);
                  const $ = (s.keyboard = new dm());
                  this._add("keyboard", $);
                  for (const Z of [
                    "boxZoom",
                    "doubleClickZoom",
                    "tapDragZoom",
                    "touchPitch",
                    "dragRotate",
                    "dragPan",
                    "touchZoomRotate",
                    "scrollZoom",
                    "keyboard",
                  ])
                    t.interactive && t[Z] && s[Z].enable(t[Z]);
                }
                _add(t, s, h) {
                  (this._handlers.push({
                    handlerName: t,
                    handler: s,
                    allowed: h,
                  }),
                    (this._handlersById[t] = s));
                }
                stop(t) {
                  if (!this._updatingCamera) {
                    for (const { handler: s } of this._handlers) s.reset();
                    (this._inertia.clear(),
                      this._fireEvents({}, {}, t),
                      (this._changes = []),
                      (this._originalZoom = void 0));
                  }
                }
                isActive() {
                  for (const { handler: t } of this._handlers)
                    if (t.isActive()) return !0;
                  return !1;
                }
                isZooming() {
                  return (
                    !!this._eventsInProgress.zoom ||
                    this._map.scrollZoom.isZooming()
                  );
                }
                isRotating() {
                  return !!this._eventsInProgress.rotate;
                }
                isMoving() {
                  return !!xu(this._eventsInProgress) || this.isZooming();
                }
                _isDragging() {
                  return !!this._eventsInProgress.drag;
                }
                _blockedByActive(t, s, h) {
                  for (const p in t)
                    if (p !== h && (!s || s.indexOf(p) < 0)) return !0;
                  return !1;
                }
                handleWindowEvent(t) {
                  this.handleEvent(t, `${t.type}Window`);
                }
                _getMapTouches(t) {
                  const s = [];
                  for (const h of t) this._el.contains(h.target) && s.push(h);
                  return s;
                }
                handleEvent(t, s) {
                  this._updatingCamera = !0;
                  const h = t.type === "renderFrame",
                    p = h ? void 0 : t,
                    g = { needsRenderFrame: !1 },
                    x = {},
                    w = {},
                    S = t.touches ? this._getMapTouches(t.touches) : void 0,
                    C = S ? Ot(this._el, S) : h ? void 0 : rt(this._el, t);
                  for (const { handlerName: z, handler: O, allowed: G } of this
                    ._handlers) {
                    if (!O.isEnabled()) continue;
                    let U;
                    (this._blockedByActive(w, G, z)
                      ? O.reset()
                      : O[s || t.type] &&
                        ((U = O[s || t.type](t, C, S)),
                        this.mergeHandlerResult(g, x, U, z, p),
                        U && U.needsRenderFrame && this._triggerRenderFrame()),
                      (U || O.isActive()) && (w[z] = O));
                  }
                  const D = {};
                  for (const z in this._previousActiveHandlers)
                    w[z] || (D[z] = p);
                  ((this._previousActiveHandlers = w),
                    (Object.keys(D).length || vu(g)) &&
                      (this._changes.push([g, x, D]),
                      this._triggerRenderFrame()),
                    (Object.keys(w).length || vu(g)) && this._map._stop(!0),
                    (this._updatingCamera = !1));
                  const { cameraAnimation: L } = g;
                  L &&
                    (this._inertia.clear(),
                    this._fireEvents({}, {}, !0),
                    (this._changes = []),
                    L(this._map));
                }
                mergeHandlerResult(t, s, h, p, g) {
                  if (!h) return;
                  r.h(t, h);
                  const x = {
                    handlerName: p,
                    originalEvent: h.originalEvent || g,
                  };
                  (h.zoomDelta !== void 0 && (s.zoom = x),
                    h.panDelta !== void 0 && (s.drag = x),
                    h.pitchDelta !== void 0 && (s.pitch = x),
                    h.bearingDelta !== void 0 && (s.rotate = x));
                }
                _applyChanges() {
                  const t = {},
                    s = {},
                    h = {};
                  for (const [p, g, x] of this._changes)
                    (p.panDelta &&
                      (t.panDelta = (t.panDelta || new r.P(0, 0))._add(
                        p.panDelta,
                      )),
                      p.zoomDelta &&
                        (t.zoomDelta = (t.zoomDelta || 0) + p.zoomDelta),
                      p.bearingDelta &&
                        (t.bearingDelta =
                          (t.bearingDelta || 0) + p.bearingDelta),
                      p.pitchDelta &&
                        (t.pitchDelta = (t.pitchDelta || 0) + p.pitchDelta),
                      p.around !== void 0 && (t.around = p.around),
                      p.aroundCoord !== void 0 &&
                        (t.aroundCoord = p.aroundCoord),
                      p.pinchAround !== void 0 &&
                        (t.pinchAround = p.pinchAround),
                      p.noInertia && (t.noInertia = p.noInertia),
                      r.h(s, g),
                      r.h(h, x));
                  (this._updateMapTransform(t, s, h), (this._changes = []));
                }
                _updateMapTransform(t, s, h) {
                  const p = this._map,
                    g = p.transform,
                    x = (Y) => [Y.x, Y.y, Y.z];
                  if (
                    ((Y) => {
                      const ie = this._eventsInProgress.drag;
                      return (
                        ie && !this._handlersById[ie.handlerName].isActive()
                      );
                    })() &&
                    !vu(t)
                  ) {
                    const Y = g.zoom;
                    ((g.cameraElevationReference = "sea"),
                      this._originalZoom != null &&
                      g._orthographicProjectionAtLowPitch &&
                      g.projection.name !== "globe" &&
                      g.pitch === 0
                        ? ((g.cameraElevationReference = "ground"),
                          (g.zoom = this._originalZoom))
                        : (g.recenterOnTerrain(),
                          (g.cameraElevationReference = "ground")),
                      Y !== g.zoom && this._map._update(!0));
                  }
                  if ((g._isCameraConstrained && p._stop(!0), !vu(t)))
                    return void this._fireEvents(s, h, !0);
                  let {
                    panDelta: w,
                    zoomDelta: S,
                    bearingDelta: C,
                    pitchDelta: D,
                    around: L,
                    aroundCoord: z,
                    pinchAround: O,
                  } = t;
                  (g._isCameraConstrained &&
                    (S > 0 && (S = 0), (g._isCameraConstrained = !1)),
                    O !== void 0 && (L = O),
                    (S ||
                      ((Y) => s[Y] && !this._eventsInProgress[Y])("drag")) &&
                      L &&
                      ((this._dragOrigin = x(g.pointCoordinate3D(L))),
                      (this._originalZoom = g.zoom),
                      this._trackingEllipsoid.setup(
                        g._camera.position,
                        this._dragOrigin,
                      )),
                    (g.cameraElevationReference = "sea"),
                    p._stop(!0),
                    (L = L || p.transform.centerPoint),
                    C && (g.bearing += C),
                    D && (g.pitch += D),
                    g._updateCameraState());
                  const G = [0, 0, 0];
                  if (w)
                    if (g.projection.name === "mercator") {
                      const Y = this._trackingEllipsoid.projectRay(
                          g.screenPointToMercatorRay(L).dir,
                        ),
                        ie = this._trackingEllipsoid.projectRay(
                          g.screenPointToMercatorRay(L.sub(w)).dir,
                        );
                      ((G[0] = ie[0] - Y[0]), (G[1] = ie[1] - Y[1]));
                    } else {
                      const Y = g.pointCoordinate(L);
                      if (g.projection.name === "globe") {
                        w = w.rotate(-g.angle);
                        const ie = g._pixelsPerMercatorPixel / g.worldSize;
                        ((G[0] = -w.x * r.ez(r.aY(Y.y)) * ie),
                          (G[1] = -w.y * r.ez(g.center.lat) * ie));
                      } else {
                        const ie = g.pointCoordinate(L.sub(w));
                        Y && ie && ((G[0] = ie.x - Y.x), (G[1] = ie.y - Y.y));
                      }
                    }
                  const U = g.zoom,
                    $ = [0, 0, 0];
                  if (S) {
                    const Y = x(z || g.pointCoordinate3D(L)),
                      ie = { dir: r.au([], r.at([], Y, g._camera.position)) };
                    if (ie.dir[2] < 0) {
                      const ae = g.zoomDeltaToMovement(Y, S);
                      r.bY($, ie.dir, ae);
                    }
                  }
                  const Z = r.cV(G, G, $);
                  (g._translateCameraConstrained(Z),
                    S && Math.abs(g.zoom - U) > 1e-4 && g.recenterOnTerrain(),
                    (g.cameraElevationReference = "ground"),
                    this._map._update(),
                    t.noInertia || this._inertia.record(t),
                    this._fireEvents(s, h, !0));
                }
                _fireEvents(t, s, h) {
                  const p = xu(this._eventsInProgress),
                    g = xu(t),
                    x = {};
                  for (const D in t) {
                    const { originalEvent: L } = t[D];
                    (this._eventsInProgress[D] || (x[`${D}start`] = L),
                      (this._eventsInProgress[D] = t[D]));
                  }
                  !p && g && this._fireEvent("movestart", g.originalEvent);
                  for (const D in x) this._fireEvent(D, x[D]);
                  g && this._fireEvent("move", g.originalEvent);
                  for (const D in t) {
                    const { originalEvent: L } = t[D];
                    this._fireEvent(D, L);
                  }
                  const w = {};
                  let S;
                  for (const D in this._eventsInProgress) {
                    const { handlerName: L, originalEvent: z } =
                      this._eventsInProgress[D];
                    this._handlersById[L].isActive() ||
                      (delete this._eventsInProgress[D],
                      (S = s[L] || z),
                      (w[`${D}end`] = S));
                  }
                  for (const D in w) this._fireEvent(D, w[D]);
                  const C = xu(this._eventsInProgress);
                  if (h && (p || g) && !C) {
                    this._updatingCamera = !0;
                    const D = this._inertia._onMoveEnd(
                        this._map.dragPan._inertiaOptions,
                      ),
                      L = (z) =>
                        z !== 0 &&
                        -this._bearingSnap < z &&
                        z < this._bearingSnap;
                    (D
                      ? (L(D.bearing || this._map.getBearing()) &&
                          (D.bearing = 0),
                        this._map.easeTo(D, { originalEvent: S }))
                      : (this._map.fire(
                          new r.A("moveend", { originalEvent: S }),
                        ),
                        L(this._map.getBearing()) && this._map.resetNorth()),
                      (this._updatingCamera = !1));
                  }
                }
                _fireEvent(t, s) {
                  this._map.fire(new r.A(t, s ? { originalEvent: s } : {}));
                }
                _requestFrame() {
                  return (
                    this._map.triggerRepaint(),
                    this._map._renderTaskQueue.add((t) => {
                      ((this._frameId = void 0),
                        this.handleEvent(
                          new Rn("renderFrame", { timeStamp: t }),
                        ),
                        this._applyChanges());
                    })
                  );
                }
                _triggerRenderFrame() {
                  this._frameId === void 0 &&
                    (this._frameId = this._requestFrame());
                }
              }
              const bm =
                "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
              class qc extends r.E {
                constructor(t, s) {
                  (super(),
                    (this._moving = !1),
                    (this._zooming = !1),
                    (this.transform = t),
                    (this._bearingSnap = s.bearingSnap),
                    (this._respectPrefersReducedMotion =
                      s.respectPrefersReducedMotion !== !1),
                    r.aV(["_renderFrameCallback"], this));
                }
                getCenter() {
                  return new r.cd(
                    this.transform.center.lng,
                    this.transform.center.lat,
                  );
                }
                setCenter(t, s) {
                  return this.jumpTo({ center: t }, s);
                }
                panBy(t, s, h) {
                  return (
                    (t = r.P.convert(t).mult(-1)),
                    this.panTo(this.transform.center, r.h({ offset: t }, s), h)
                  );
                }
                panTo(t, s, h) {
                  return this.easeTo(r.h({ center: t }, s), h);
                }
                getZoom() {
                  return this.transform.zoom;
                }
                setZoom(t, s) {
                  return (this.jumpTo({ zoom: t }, s), this);
                }
                zoomTo(t, s, h) {
                  return this.easeTo(r.h({ zoom: t }, s), h);
                }
                zoomIn(t, s) {
                  return (this.zoomTo(this.getZoom() + 1, t, s), this);
                }
                zoomOut(t, s) {
                  return (this.zoomTo(this.getZoom() - 1, t, s), this);
                }
                getBearing() {
                  return this.transform.bearing;
                }
                setBearing(t, s) {
                  return (this.jumpTo({ bearing: t }, s), this);
                }
                getPadding() {
                  return this.transform.padding;
                }
                setPadding(t, s) {
                  return (this.jumpTo({ padding: t }, s), this);
                }
                rotateTo(t, s, h) {
                  return this.easeTo(r.h({ bearing: t }, s), h);
                }
                resetNorth(t, s) {
                  return (this.rotateTo(0, r.h({ duration: 1e3 }, t), s), this);
                }
                resetNorthPitch(t, s) {
                  return (
                    this.easeTo(
                      r.h({ bearing: 0, pitch: 0, duration: 1e3 }, t),
                      s,
                    ),
                    this
                  );
                }
                snapToNorth(t, s) {
                  return Math.abs(this.getBearing()) < this._bearingSnap
                    ? this.resetNorth(t, s)
                    : this;
                }
                getPitch() {
                  return this.transform.pitch;
                }
                setPitch(t, s) {
                  return (this.jumpTo({ pitch: t }, s), this);
                }
                cameraForBounds(t, s) {
                  t = r.aG.convert(t);
                  const h = (s && s.bearing) || 0,
                    p = (s && s.pitch) || 0,
                    g = t.getNorthWest(),
                    x = t.getSouthEast();
                  return this._cameraForBounds(this.transform, g, x, h, p, s);
                }
                _extendPadding(t) {
                  const s = { top: 0, right: 0, bottom: 0, left: 0 };
                  return t == null
                    ? r.h({}, s, this.transform.padding)
                    : typeof t == "number"
                      ? { top: t, bottom: t, right: t, left: t }
                      : r.h({}, s, t);
                }
                _extendCameraOptions(t) {
                  return (
                    ((t = r.h(
                      { offset: [0, 0], maxZoom: this.transform.maxZoom },
                      t,
                    )).padding = this._extendPadding(t.padding)),
                    t
                  );
                }
                _minimumAABBFrustumDistance(t, s) {
                  const h = s.max[0] - s.min[0],
                    p = s.max[1] - s.min[1];
                  return h / p > t.aspect
                    ? h / (2 * Math.tan(0.5 * t.fovX) * t.aspect)
                    : p / (2 * Math.tan(0.5 * t.fovY) * t.aspect);
                }
                _cameraForBoundsOnGlobe(t, s, h, p, g, x) {
                  const w = t.clone(),
                    S = this._extendCameraOptions(x);
                  ((w.bearing = p), (w.pitch = g));
                  const C = r.cd.convert(s),
                    D = r.cd.convert(h),
                    L = 0.5 * (C.lat + D.lat),
                    z = 0.5 * (C.lng + D.lng),
                    O = r.eC(L, z),
                    G = r.au([], O),
                    U = r.au([], r.bF([], G, [0, 1, 0])),
                    $ = r.bF([], U, G),
                    Z = [
                      U[0],
                      U[1],
                      U[2],
                      0,
                      $[0],
                      $[1],
                      $[2],
                      0,
                      G[0],
                      G[1],
                      G[2],
                      0,
                      0,
                      0,
                      0,
                      1,
                    ],
                    Y = [
                      O,
                      r.eC(C.lat, C.lng),
                      r.eC(D.lat, C.lng),
                      r.eC(D.lat, D.lng),
                      r.eC(C.lat, D.lng),
                      r.eC(L, C.lng),
                      r.eC(L, D.lng),
                      r.eC(C.lat, z),
                      r.eC(D.lat, z),
                    ];
                  let ie = r.cW.fromPoints(
                    Y.map((Oe) => [r.bG(U, Oe), r.bG($, Oe), r.bG(G, Oe)]),
                  );
                  const ae = r.ad([], ie.center, Z);
                  (r.eD(ae) === 0 && r.eE(ae, 0, 0, 1),
                    r.au(ae, ae),
                    r.bY(ae, ae, r.aB),
                    (w.center = r.eF(ae)));
                  const pe = w.getWorldToCameraMatrix(),
                    ue = r.bi(new Float64Array(16), pe);
                  ie = r.cW.applyTransform(ie, r.az([], pe, Z));
                  const ce = this._extendAABB(ie, w, S, p);
                  if (!ce)
                    return void r.w(
                      "Map cannot fit within canvas with the given bounds, padding, and/or offset.",
                    );
                  ((ie = ce), r.ad(ae, ae, pe));
                  const le = 0.5 * (ie.max[2] - ie.min[2]),
                    me = this._minimumAABBFrustumDistance(w, ie),
                    _e = r.bY([], [0, 0, 1], le),
                    De = r.cV(_e, ae, _e),
                    ze = me + (w.pitch === 0 ? 0 : r.bD(ae, De)),
                    He = w.globeCenterInViewSpace,
                    We = r.at([], ae, [He[0], He[1], He[2]]);
                  (r.au(We, We), r.bY(We, We, ze));
                  const et = r.cV([], ae, We);
                  r.ad(et, et, ue);
                  const Ce = r.eq / r.aB,
                    Ve = r.ae(et),
                    Te = r.c6(Math.max(Ve * Ce - r.eq, Number.EPSILON), 0),
                    Ze = Math.min(w.zoomFromMercatorZAdjusted(Te), S.maxZoom);
                  return Ze > 0.5 * (r.cL + r.cx)
                    ? (w.setProjection({ name: "mercator" }),
                      (w.zoom = Ze),
                      this._cameraForBounds(w, s, h, p, g, x))
                    : { center: w.center, zoom: Ze, bearing: p, pitch: g };
                }
                _extendAABB(t, s, h, p) {
                  const g =
                      0.5 * ((h.padding.left || 0) + (h.padding.right || 0)),
                    x = 0.5 * ((h.padding.top || 0) + (h.padding.bottom || 0)),
                    w = x,
                    S = g,
                    C = g,
                    D = x,
                    L = s.width - (S + C),
                    z = s.height - (w + D),
                    O = r.at([], t.max, t.min),
                    G = Math.min(L / O[0], z / O[1]),
                    U = Math.min(s.scaleZoom(s.scale * G), h.maxZoom);
                  if (isNaN(U)) return null;
                  const $ = s.scale / s.zoomScale(U),
                    Z = new r.cW(
                      [t.min[0] - S * $, t.min[1] - D * $, t.min[2]],
                      [t.max[0] + C * $, t.max[1] + w * $, t.max[2]],
                    ),
                    Y = (
                      typeof h.offset.x == "number" &&
                      typeof h.offset.y == "number"
                        ? new r.P(h.offset.x, h.offset.y)
                        : r.P.convert(h.offset)
                    ).rotate(-r.al(p));
                  return (
                    (Z.center[0] -= Y.x * $),
                    (Z.center[1] += Y.y * $),
                    Z
                  );
                }
                queryTerrainElevation(t, s) {
                  const h = this.transform.elevation;
                  return h
                    ? ((s = r.h({}, { exaggerated: !0 }, s)),
                      h.getAtPoint(r.ac.fromLngLat(t), null, s.exaggerated))
                    : null;
                }
                _cameraForBounds(t, s, h, p, g, x) {
                  if (t.projection.name === "globe")
                    return this._cameraForBoundsOnGlobe(t, s, h, p, g, x);
                  const w = t.clone(),
                    S = this._extendCameraOptions(x);
                  ((w.bearing = p), (w.pitch = g));
                  const C = r.cd.convert(s),
                    D = r.cd.convert(h),
                    L = new r.cd(C.lng, D.lat),
                    z = new r.cd(D.lng, C.lat),
                    O = w.project(C),
                    G = w.project(D),
                    U = this.queryTerrainElevation(C),
                    $ = this.queryTerrainElevation(D),
                    Z = this.queryTerrainElevation(L),
                    Y = this.queryTerrainElevation(z),
                    ie = [
                      [O.x, O.y, Math.min(U || 0, $ || 0, Z || 0, Y || 0)],
                      [G.x, G.y, Math.max(U || 0, $ || 0, Z || 0, Y || 0)],
                    ];
                  let ae = r.cW.fromPoints(ie);
                  const pe = w.getWorldToCameraMatrix(),
                    ue = r.bi(new Float64Array(16), pe);
                  ae = r.cW.applyTransform(ae, pe);
                  const ce = this._extendAABB(ae, w, S, p);
                  if (!ce)
                    return void r.w(
                      "Map cannot fit within canvas with the given bounds, padding, and/or offset.",
                    );
                  ae = ce;
                  const le = 0.5 * r.at([], ae.max, ae.min)[2],
                    me = this._minimumAABBFrustumDistance(w, ae),
                    _e = [0, 0, 1, 0];
                  (r.aA(_e, _e, pe), r.eG(_e, _e));
                  const De = r.bY([], _e, me + le),
                    ze = r.cV([], ae.center, De);
                  (r.ad(ae.center, ae.center, ue), r.ad(ze, ze, ue));
                  const He = w.unproject(new r.P(ae.center[0], ae.center[1])),
                    We = r.eH(w.projection, He),
                    et = Math.pow(2, We),
                    Ce = Math.min(
                      w._zoomFromMercatorZ(
                        (ze[2] * w.pixelsPerMeter * et) / w.worldSize,
                      ),
                      S.maxZoom,
                    );
                  return w.mercatorFromTransition && Ce < 0.5 * (r.cL + r.cx)
                    ? (w.setProjection({ name: "globe" }),
                      (w.zoom = Ce),
                      this._cameraForBounds(w, s, h, p, g, x))
                    : { center: He, zoom: Ce, bearing: p, pitch: g };
                }
                fitBounds(t, s, h) {
                  const p = this.cameraForBounds(t, s);
                  return this._fitInternal(p, s, h);
                }
                fitScreenCoordinates(t, s, h, p, g) {
                  const x = r.P.convert(t),
                    w = r.P.convert(s),
                    S = new r.P(Math.min(x.x, w.x), Math.min(x.y, w.y)),
                    C = new r.P(Math.max(x.x, w.x), Math.max(x.y, w.y));
                  if (
                    this.transform.projection.name === "mercator" &&
                    this.transform.anyCornerOffEdge(x, w)
                  )
                    return this;
                  const D = this.transform.pointLocation3D(S),
                    L = this.transform.pointLocation3D(C),
                    z = this.transform.pointLocation3D(new r.P(S.x, C.y)),
                    O = this.transform.pointLocation3D(new r.P(C.x, S.y)),
                    G = [
                      Math.min(D.lng, L.lng, z.lng, O.lng),
                      Math.min(D.lat, L.lat, z.lat, O.lat),
                    ],
                    U = [
                      Math.max(D.lng, L.lng, z.lng, O.lng),
                      Math.max(D.lat, L.lat, z.lat, O.lat),
                    ],
                    $ = p && p.pitch ? p.pitch : this.getPitch(),
                    Z = this._cameraForBounds(this.transform, G, U, h, $, p);
                  return this._fitInternal(Z, p, g);
                }
                _fitInternal(t, s, h) {
                  return t
                    ? (s = r.h(t, s)).linear
                      ? this.easeTo(s, h)
                      : this.flyTo(s, h)
                    : this;
                }
                jumpTo(t, s) {
                  this.stop();
                  const h = t.preloadOnly
                    ? this.transform.clone()
                    : this.transform;
                  let p = !1,
                    g = !1,
                    x = !1;
                  ("zoom" in t &&
                    h.zoom !== +t.zoom &&
                    ((p = !0), (h.zoom = +t.zoom)),
                    t.center !== void 0 && (h.center = r.cd.convert(t.center)),
                    "bearing" in t &&
                      h.bearing !== +t.bearing &&
                      ((g = !0), (h.bearing = +t.bearing)),
                    "pitch" in t &&
                      h.pitch !== +t.pitch &&
                      ((x = !0), (h.pitch = +t.pitch)));
                  const w =
                    typeof t.padding == "number"
                      ? this._extendPadding(t.padding)
                      : t.padding;
                  if (t.padding != null && !h.isPaddingEqual(w))
                    if (t.retainPadding === !1) {
                      const S = h.clone();
                      ((S.padding = w),
                        h.setLocationAtPoint(h.center, S.centerPoint));
                    } else h.padding = w;
                  return t.preloadOnly
                    ? (this._preloadTiles(h), this)
                    : (this.fire(new r.A("movestart", s)).fire(
                        new r.A("move", s),
                      ),
                      p &&
                        this.fire(new r.A("zoomstart", s))
                          .fire(new r.A("zoom", s))
                          .fire(new r.A("zoomend", s)),
                      g &&
                        this.fire(new r.A("rotatestart", s))
                          .fire(new r.A("rotate", s))
                          .fire(new r.A("rotateend", s)),
                      x &&
                        this.fire(new r.A("pitchstart", s))
                          .fire(new r.A("pitch", s))
                          .fire(new r.A("pitchend", s)),
                      this.fire(new r.A("moveend", s)));
                }
                getFreeCameraOptions() {
                  return (
                    this.transform.projection.supportsFreeCamera || r.w(bm),
                    this.transform.getFreeCameraOptions()
                  );
                }
                setFreeCameraOptions(t, s) {
                  const h = this.transform;
                  if (!h.projection.supportsFreeCamera) return (r.w(bm), this);
                  this.stop();
                  const p = h.zoom,
                    g = h.pitch,
                    x = h.bearing;
                  h.setFreeCameraOptions(t);
                  const w = p !== h.zoom,
                    S = g !== h.pitch,
                    C = x !== h.bearing;
                  return (
                    this.fire(new r.A("movestart", s)).fire(new r.A("move", s)),
                    w &&
                      this.fire(new r.A("zoomstart", s))
                        .fire(new r.A("zoom", s))
                        .fire(new r.A("zoomend", s)),
                    C &&
                      this.fire(new r.A("rotatestart", s))
                        .fire(new r.A("rotate", s))
                        .fire(new r.A("rotateend", s)),
                    S &&
                      this.fire(new r.A("pitchstart", s))
                        .fire(new r.A("pitch", s))
                        .fire(new r.A("pitchend", s)),
                    this.fire(new r.A("moveend", s)),
                    this
                  );
                }
                easeTo(t, s) {
                  (this._stop(!1, t.easeId),
                    ((t = r.h(
                      { offset: [0, 0], duration: 500, easing: r.ey },
                      t,
                    )).animate === !1 ||
                      this._prefersReducedMotion(t)) &&
                      (t.duration = 0));
                  const h = this.transform,
                    p = this.getZoom(),
                    g = this.getBearing(),
                    x = this.getPitch(),
                    w = this.getPadding(),
                    S = "zoom" in t ? +t.zoom : p,
                    C =
                      "bearing" in t ? this._normalizeBearing(t.bearing, g) : g,
                    D = "pitch" in t ? +t.pitch : x,
                    L = this._extendPadding(t.padding),
                    z = r.P.convert(t.offset);
                  let O, G, U;
                  if (h.projection.name === "globe") {
                    const _e = r.ac.fromLngLat(h.center),
                      De = z.rotate(-h.angle);
                    ((_e.x += De.x / h.worldSize),
                      (_e.y += De.y / h.worldSize));
                    const ze = _e.toLngLat(),
                      He = r.cd.convert(t.center || ze);
                    (this._normalizeCenter(He),
                      (O = h.centerPoint.add(De)),
                      (G = new r.P(_e.x, _e.y).mult(h.worldSize)),
                      (U = new r.P(r.aD(He.lng), r.aH(He.lat))
                        .mult(h.worldSize)
                        .sub(G)));
                  } else {
                    O = h.centerPoint.add(z);
                    const _e = h.pointLocation(O),
                      De = r.cd.convert(t.center || _e);
                    (this._normalizeCenter(De),
                      (G = h.project(_e)),
                      (U = h.project(De).sub(G)));
                  }
                  const $ = h.zoomScale(S - p);
                  let Z, Y;
                  t.around &&
                    ((Z = r.cd.convert(t.around)), (Y = h.locationPoint(Z)));
                  const ie = this._zooming || S !== p,
                    ae = this._rotating || g !== C,
                    pe = this._pitching || D !== x,
                    ue = !h.isPaddingEqual(L),
                    ce = t.retainPadding === !1 ? h.clone() : h,
                    le = (_e) => (De) => {
                      if (
                        (ie && (_e.zoom = r.ai(p, S, De)),
                        ae && (_e.bearing = r.ai(g, C, De)),
                        pe && (_e.pitch = r.ai(x, D, De)),
                        ue &&
                          (ce.interpolatePadding(w, L, De),
                          (O = ce.centerPoint.add(z))),
                        Z)
                      )
                        _e.setLocationAtPoint(Z, Y);
                      else {
                        const ze = _e.zoomScale(_e.zoom - p),
                          He = S > p ? Math.min(2, $) : Math.max(0.5, $),
                          We = Math.pow(He, 1 - De),
                          et = _e.unproject(G.add(U.mult(De * We)).mult(ze));
                        _e.setLocationAtPoint(
                          _e.renderWorldCopies ? et.wrap() : et,
                          O,
                        );
                      }
                      return (t.preloadOnly || this._fireMoveEvents(s), _e);
                    };
                  if (t.preloadOnly) {
                    const _e = this._emulate(le, t.duration, h);
                    return (this._preloadTiles(_e), this);
                  }
                  const me = {
                    moving: this._moving,
                    zooming: this._zooming,
                    rotating: this._rotating,
                    pitching: this._pitching,
                  };
                  return (
                    (this._zooming = ie),
                    (this._rotating = ae),
                    (this._pitching = pe),
                    (this._padding = ue),
                    (this._easeId = t.easeId),
                    this._prepareEase(s, t.noMoveStart, me),
                    this._ease(
                      le(h),
                      (_e) => {
                        (h.cameraElevationReference === "sea" &&
                          h.recenterOnTerrain(),
                          this._afterEase(s, _e));
                      },
                      t,
                    ),
                    this
                  );
                }
                _prepareEase(t, s, h = {}) {
                  ((this._moving = !0),
                    (this.transform.cameraElevationReference = "sea"),
                    this.transform._orthographicProjectionAtLowPitch &&
                      this.transform.pitch === 0 &&
                      this.transform.projection.name !== "globe" &&
                      (this.transform.cameraElevationReference = "ground"),
                    s || h.moving || this.fire(new r.A("movestart", t)),
                    this._zooming &&
                      !h.zooming &&
                      this.fire(new r.A("zoomstart", t)),
                    this._rotating &&
                      !h.rotating &&
                      this.fire(new r.A("rotatestart", t)),
                    this._pitching &&
                      !h.pitching &&
                      this.fire(new r.A("pitchstart", t)));
                }
                _fireMoveEvents(t) {
                  (this.fire(new r.A("move", t)),
                    this._zooming && this.fire(new r.A("zoom", t)),
                    this._rotating && this.fire(new r.A("rotate", t)),
                    this._pitching && this.fire(new r.A("pitch", t)));
                }
                _afterEase(t, s) {
                  if (this._easeId && s && this._easeId === s) return;
                  ((this._easeId = void 0),
                    (this.transform.cameraElevationReference = "ground"));
                  const h = this._zooming,
                    p = this._rotating,
                    g = this._pitching;
                  ((this._moving = !1),
                    (this._zooming = !1),
                    (this._rotating = !1),
                    (this._pitching = !1),
                    (this._padding = !1),
                    h && this.fire(new r.A("zoomend", t)),
                    p && this.fire(new r.A("rotateend", t)),
                    g && this.fire(new r.A("pitchend", t)),
                    this.fire(new r.A("moveend", t)));
                }
                flyTo(t, s) {
                  if (this._prefersReducedMotion(t)) {
                    const Oe = r.aF(t, [
                      "center",
                      "zoom",
                      "bearing",
                      "pitch",
                      "around",
                      "padding",
                      "retainPadding",
                    ]);
                    return this.jumpTo(Oe, s);
                  }
                  (this.stop(),
                    (t = r.h(
                      { offset: [0, 0], speed: 1.2, curve: 1.42, easing: r.ey },
                      t,
                    )));
                  const h = this.transform,
                    p = this.getZoom(),
                    g = this.getBearing(),
                    x = this.getPitch(),
                    w = this.getPadding(),
                    S = "zoom" in t ? r.ay(+t.zoom, h.minZoom, h.maxZoom) : p,
                    C =
                      "bearing" in t ? this._normalizeBearing(t.bearing, g) : g,
                    D = "pitch" in t ? +t.pitch : x,
                    L = this._extendPadding(t.padding),
                    z = h.zoomScale(S - p),
                    O = r.P.convert(t.offset);
                  let G = h.centerPoint.add(O);
                  const U = h.pointLocation(G),
                    $ = r.cd.convert(t.center || U);
                  this._normalizeCenter($);
                  const Z = h.project(U),
                    Y = h.project($).sub(Z);
                  let ie = t.curve;
                  const ae = Math.max(h.width, h.height),
                    pe = ae / z,
                    ue = Y.mag();
                  if ("minZoom" in t) {
                    const Oe = r.ay(
                        Math.min(t.minZoom, p, S),
                        h.minZoom,
                        h.maxZoom,
                      ),
                      Ke = ae / h.zoomScale(Oe - p);
                    ie = Math.sqrt((Ke / ue) * 2);
                  }
                  const ce = ie * ie;
                  function le(Oe) {
                    const Ke =
                      (pe * pe - ae * ae + (Oe ? -1 : 1) * ce * ce * ue * ue) /
                      (2 * (Oe ? pe : ae) * ce * ue);
                    return Math.log(Math.sqrt(Ke * Ke + 1) - Ke);
                  }
                  function me(Oe) {
                    return (Math.exp(Oe) - Math.exp(-Oe)) / 2;
                  }
                  function _e(Oe) {
                    return (Math.exp(Oe) + Math.exp(-Oe)) / 2;
                  }
                  const De = le(0);
                  let ze = function (Oe) {
                      return _e(De) / _e(De + ie * Oe);
                    },
                    He = function (Oe) {
                      return (
                        (ae *
                          ((_e(De) * (me((Ke = De + ie * Oe)) / _e(Ke)) -
                            me(De)) /
                            ce)) /
                        ue
                      );
                      var Ke;
                    },
                    We = (le(1) - De) / ie;
                  if (Math.abs(ue) < 1e-6 || !isFinite(We)) {
                    if (Math.abs(ae - pe) < 1e-6) return this.easeTo(t, s);
                    const Oe = pe < ae ? -1 : 1;
                    ((We = Math.abs(Math.log(pe / ae)) / ie),
                      (He = function () {
                        return 0;
                      }),
                      (ze = function (Ke) {
                        return Math.exp(Oe * ie * Ke);
                      }));
                  }
                  ((t.duration =
                    "duration" in t
                      ? +t.duration
                      : (1e3 * We) /
                        ("screenSpeed" in t ? +t.screenSpeed / ie : +t.speed)),
                    t.maxDuration &&
                      t.duration > t.maxDuration &&
                      (t.duration = 0));
                  const et = g !== C,
                    Ce = D !== x,
                    Ve = !h.isPaddingEqual(L),
                    Te = t.retainPadding === !1 ? h.clone() : h,
                    Ze = (Oe) => (Ke) => {
                      const ht = Ke * We,
                        qe = 1 / ze(ht);
                      ((Oe.zoom = Ke === 1 ? S : p + Oe.scaleZoom(qe)),
                        et && (Oe.bearing = r.ai(g, C, Ke)),
                        Ce && (Oe.pitch = r.ai(x, D, Ke)),
                        Ve &&
                          (Te.interpolatePadding(w, L, Ke),
                          (G = Te.centerPoint.add(O))));
                      const lt =
                        Ke === 1
                          ? $
                          : Oe.unproject(Z.add(Y.mult(He(ht))).mult(qe));
                      return (
                        Oe.setLocationAtPoint(
                          Oe.renderWorldCopies ? lt.wrap() : lt,
                          G,
                        ),
                        Oe._updateCameraOnTerrain(),
                        t.preloadOnly || this._fireMoveEvents(s),
                        Oe
                      );
                    };
                  if (t.preloadOnly) {
                    const Oe = this._emulate(Ze, t.duration, h);
                    return (this._preloadTiles(Oe), this);
                  }
                  return (
                    (this._zooming = !0),
                    (this._rotating = et),
                    (this._pitching = Ce),
                    (this._padding = Ve),
                    this._prepareEase(s, !1),
                    this._ease(Ze(h), () => this._afterEase(s), t),
                    this
                  );
                }
                isEasing() {
                  return !!this._easeFrameId;
                }
                stop() {
                  return this._stop();
                }
                _requestRenderFrame(t) {}
                _cancelRenderFrame(t) {}
                _stop(t, s) {
                  if (
                    (this._easeFrameId &&
                      (this._cancelRenderFrame(this._easeFrameId),
                      (this._easeFrameId = void 0),
                      (this._onEaseFrame = void 0)),
                    this._onEaseEnd)
                  ) {
                    const h = this._onEaseEnd;
                    ((this._onEaseEnd = void 0), h.call(this, s));
                  }
                  if (!t) {
                    const h = this.handlers;
                    h && h.stop(!1);
                  }
                  return this;
                }
                _ease(t, s, h) {
                  h.animate === !1 || h.duration === 0
                    ? (t(1), s())
                    : ((this._easeStart = r.q.now()),
                      (this._easeOptions = h),
                      (this._onEaseFrame = t),
                      (this._onEaseEnd = s),
                      (this._easeFrameId = this._requestRenderFrame(
                        this._renderFrameCallback,
                      )));
                }
                _renderFrameCallback() {
                  const t = Math.min(
                      (r.q.now() - this._easeStart) /
                        this._easeOptions.duration,
                      1,
                    ),
                    s = this._onEaseFrame;
                  (s && s(this._easeOptions.easing(t)),
                    t < 1
                      ? (this._easeFrameId = this._requestRenderFrame(
                          this._renderFrameCallback,
                        ))
                      : this.stop());
                }
                _normalizeBearing(t, s) {
                  t = r.bX(t, -180, 180);
                  const h = Math.abs(t - s);
                  return (
                    Math.abs(t - 360 - s) < h && (t -= 360),
                    Math.abs(t + 360 - s) < h && (t += 360),
                    t
                  );
                }
                _normalizeCenter(t) {
                  const s = this.transform;
                  if (
                    s.maxBounds ||
                    (s.projection.name !== "globe" && !s.renderWorldCopies)
                  )
                    return;
                  const h = t.lng - s.center.lng;
                  t.lng += h > 180 ? -360 : h < -180 ? 360 : 0;
                }
                _prefersReducedMotion(t) {
                  return (
                    this._respectPrefersReducedMotion &&
                    r.q.prefersReducedMotion &&
                    !(t && t.essential)
                  );
                }
                _emulate(t, s, h) {
                  const p = Math.ceil((15 * s) / 1e3),
                    g = [],
                    x = t(h.clone());
                  for (let w = 0; w <= p; w++) {
                    const S = x(w / p);
                    g.push(S.clone());
                  }
                  return g;
                }
                _preloadTiles(t, s) {}
              }
              class rf {
                constructor(t = {}) {
                  ((this.options = t),
                    r.aV(
                      [
                        "_toggleAttribution",
                        "_updateEditLink",
                        "_updateData",
                        "_updateCompact",
                      ],
                      this,
                    ));
                }
                getDefaultPosition() {
                  return "bottom-right";
                }
                onAdd(t) {
                  const s = this.options && this.options.compact,
                    h = t._getUIString("AttributionControl.ToggleAttribution");
                  ((this._map = t),
                    (this._container = xe(
                      "div",
                      "mapboxgl-ctrl mapboxgl-ctrl-attrib",
                    )),
                    (this._compactButton = xe(
                      "button",
                      "mapboxgl-ctrl-attrib-button",
                      this._container,
                    )),
                    (this._compactButton.type = "button"),
                    this._compactButton.addEventListener(
                      "click",
                      this._toggleAttribution,
                    ),
                    this._compactButton.setAttribute("aria-label", h));
                  const p = xe(
                    "span",
                    "mapboxgl-ctrl-icon",
                    this._compactButton,
                  );
                  return (
                    p.setAttribute("aria-hidden", "true"),
                    p.setAttribute("title", h),
                    (this._innerContainer = xe(
                      "div",
                      "mapboxgl-ctrl-attrib-inner",
                      this._container,
                    )),
                    s && this._container.classList.add("mapboxgl-compact"),
                    this._updateAttributions(),
                    this._updateEditLink(),
                    this._map.on("styledata", this._updateData),
                    this._map.on("sourcedata", this._updateData),
                    this._map.on("moveend", this._updateEditLink),
                    s === void 0 &&
                      (this._map.on("resize", this._updateCompact),
                      this._updateCompact()),
                    this._container
                  );
                }
                onRemove() {
                  (this._container.remove(),
                    this._map.off("styledata", this._updateData),
                    this._map.off("sourcedata", this._updateData),
                    this._map.off("moveend", this._updateEditLink),
                    this._map.off("resize", this._updateCompact),
                    (this._map = void 0),
                    (this._attribHTML = void 0));
                }
                _toggleAttribution() {
                  this._container.classList.contains("mapboxgl-compact-show")
                    ? (this._container.classList.remove(
                        "mapboxgl-compact-show",
                      ),
                      this._compactButton.setAttribute(
                        "aria-expanded",
                        "false",
                      ))
                    : (this._container.classList.add("mapboxgl-compact-show"),
                      this._compactButton.setAttribute(
                        "aria-expanded",
                        "true",
                      ));
                }
                _updateEditLink() {
                  let t = this._editLink;
                  t ||
                    (t = this._editLink =
                      this._container.querySelector(".mapbox-improve-map"));
                  const s = [
                    { key: "owner", value: this.styleOwner },
                    { key: "id", value: this.styleId },
                    {
                      key: "access_token",
                      value:
                        this._map._requestManager._customAccessToken ||
                        r.e.ACCESS_TOKEN,
                    },
                  ];
                  if (t) {
                    const h = s.reduce(
                      (p, g, x) => (
                        g.value &&
                          (p += `${g.key}=${g.value}${x < s.length - 1 ? "&" : ""}`),
                        p
                      ),
                      "?",
                    );
                    ((t.href = `${r.e.FEEDBACK_URL}/${h}#${fu(this._map, !0)}`),
                      (t.rel = "noopener nofollow"));
                  }
                }
                _updateData(t) {
                  !t ||
                    (t.sourceDataType !== "metadata" &&
                      t.sourceDataType !== "visibility" &&
                      t.dataType !== "style") ||
                    (this._updateAttributions(), this._updateEditLink());
                }
                _updateAttributions() {
                  if (!this._map.style) return;
                  let t = [];
                  if (this._map.style.stylesheet) {
                    const p = this._map.style.stylesheet;
                    ((this.styleOwner = p.owner), (this.styleId = p.id));
                  }
                  const s = this._map.style._mergedSourceCaches;
                  for (const p in s) {
                    const g = s[p];
                    if (g.used) {
                      const x = g.getSource();
                      x.attribution &&
                        t.indexOf(x.attribution) < 0 &&
                        t.push(x.attribution);
                    }
                  }
                  (t.sort((p, g) => p.length - g.length),
                    (t = t.filter((p, g) => {
                      for (let x = g + 1; x < t.length; x++)
                        if (t[x].indexOf(p) >= 0) return !1;
                      return !0;
                    })),
                    this.options.customAttribution &&
                      (Array.isArray(this.options.customAttribution)
                        ? (t = [...this.options.customAttribution, ...t])
                        : t.unshift(this.options.customAttribution)));
                  const h = t.join(" | ");
                  h !== this._attribHTML &&
                    ((this._attribHTML = h),
                    t.length
                      ? ((this._innerContainer.innerHTML = h),
                        this._container.classList.remove(
                          "mapboxgl-attrib-empty",
                        ))
                      : this._container.classList.add("mapboxgl-attrib-empty"),
                    (this._editLink = null));
                }
                _updateCompact() {
                  this._map.getCanvasContainer().offsetWidth <= 640
                    ? this._container.classList.add("mapboxgl-compact")
                    : this._container.classList.remove(
                        "mapboxgl-compact",
                        "mapboxgl-compact-show",
                      );
                }
              }
              class bu {
                constructor() {
                  r.aV(["_updateLogo", "_updateCompact"], this);
                }
                onAdd(t) {
                  ((this._map = t),
                    (this._container = xe("div", "mapboxgl-ctrl")));
                  const s = xe("a", "mapboxgl-ctrl-logo");
                  return (
                    (s.target = "_blank"),
                    (s.rel = "noopener nofollow"),
                    (s.href = "https://www.mapbox.com/"),
                    s.setAttribute(
                      "aria-label",
                      this._map._getUIString("LogoControl.Title"),
                    ),
                    s.setAttribute("rel", "noopener nofollow"),
                    this._container.appendChild(s),
                    (this._container.style.display = "none"),
                    this._map.on("sourcedata", this._updateLogo),
                    this._updateLogo(),
                    this._map.on("resize", this._updateCompact),
                    this._updateCompact(),
                    this._container
                  );
                }
                onRemove() {
                  (this._container.remove(),
                    this._map.off("sourcedata", this._updateLogo),
                    this._map.off("resize", this._updateCompact));
                }
                getDefaultPosition() {
                  return "bottom-left";
                }
                _updateLogo(t) {
                  (t && t.sourceDataType !== "metadata") ||
                    (this._container.style.display = this._logoRequired()
                      ? "block"
                      : "none");
                }
                _logoRequired() {
                  if (!this._map.style) return !0;
                  const t = this._map.style._sourceCaches;
                  if (Object.entries(t).length === 0) return !0;
                  for (const s in t) {
                    const h = t[s].getSource();
                    if (h.hasOwnProperty("mapbox_logo") && !h.mapbox_logo)
                      return !1;
                  }
                  return !0;
                }
                _updateCompact() {
                  const t = this._container.children;
                  if (t.length) {
                    const s = t[0];
                    this._map.getCanvasContainer().offsetWidth < 250
                      ? s.classList.add("mapboxgl-compact")
                      : s.classList.remove("mapboxgl-compact");
                  }
                }
              }
              class Zc {
                constructor() {
                  ((this._queue = []),
                    (this._id = 0),
                    (this._cleared = !1),
                    (this._currentlyRunning = !1));
                }
                add(t) {
                  const s = ++this._id;
                  return (
                    this._queue.push({ callback: t, id: s, cancelled: !1 }),
                    s
                  );
                }
                remove(t) {
                  const s = this._currentlyRunning,
                    h = s ? this._queue.concat(s) : this._queue;
                  for (const p of h)
                    if (p.id === t) return void (p.cancelled = !0);
                }
                run(t = 0) {
                  const s = (this._currentlyRunning = this._queue);
                  this._queue = [];
                  for (const h of s)
                    if (!h.cancelled && (h.callback(t), this._cleared)) break;
                  ((this._cleared = !1), (this._currentlyRunning = !1));
                }
                clear() {
                  (this._currentlyRunning && (this._cleared = !0),
                    (this._queue = []));
                }
              }
              class mo {
                constructor(t) {
                  this.jumpTo(t);
                }
                getValue(t) {
                  if (t <= this._startTime) return this._start;
                  if (t >= this._endTime) return this._end;
                  const s = r.dk(
                    (t - this._startTime) / (this._endTime - this._startTime),
                  );
                  return this._start * (1 - s) + this._end * s;
                }
                isEasing(t) {
                  return t >= this._startTime && t <= this._endTime;
                }
                jumpTo(t) {
                  ((this._startTime = -1 / 0),
                    (this._endTime = -1 / 0),
                    (this._start = t),
                    (this._end = t));
                }
                easeTo(t, s, h) {
                  ((this._start = this.getValue(s)),
                    (this._end = t),
                    (this._startTime = s),
                    (this._endTime = s + h));
                }
              }
              const wu = {
                "AttributionControl.ToggleAttribution": "Toggle attribution",
                "FullscreenControl.Enter": "Enter fullscreen",
                "FullscreenControl.Exit": "Exit fullscreen",
                "GeolocateControl.FindMyLocation": "Find my location",
                "GeolocateControl.LocationNotAvailable":
                  "Location not available",
                "LogoControl.Title": "Mapbox homepage",
                "Map.Title": "Map",
                "NavigationControl.ResetBearing": "Reset bearing to north",
                "NavigationControl.ZoomIn": "Zoom in",
                "NavigationControl.ZoomOut": "Zoom out",
                "ScrollZoomBlocker.CtrlMessage":
                  "Use ctrl + scroll to zoom the map",
                "ScrollZoomBlocker.CmdMessage":
                  "Use  + scroll to zoom the map",
                "TouchPanBlocker.Message": "Use two fingers to move the map",
              };
              class Vn extends r.A {
                constructor(t, s, h, p) {
                  const {
                    point: g,
                    lngLat: x,
                    originalEvent: w,
                    target: S,
                  } = t;
                  (super(t.type, {
                    point: g,
                    lngLat: x,
                    originalEvent: w,
                    target: S,
                  }),
                    (this.preventDefault = () => {
                      t.preventDefault();
                    }),
                    (this.id = s),
                    (this.interaction = h),
                    (this.feature = p));
                }
              }
              class Us {
                constructor(t) {
                  ((this.map = t),
                    (this.interactionsByType = new Map()),
                    (this.delegatedInteractions = new Map()),
                    (this.typeById = new Map()),
                    (this.filters = new Map()),
                    (this.handleType = this.handleType.bind(this)),
                    (this.handleMove = this.handleMove.bind(this)),
                    (this.handleOut = this.handleOut.bind(this)),
                    (this.hoveredFeatures = new Map()),
                    (this.prevHoveredFeatures = new Map()));
                }
                add(t, s) {
                  if (this.typeById.has(t))
                    throw new Error(`Interaction id "${t}" already exists.`);
                  const h = s.filter;
                  let p = s.type;
                  (h && this.filters.set(t, r.b3(h)),
                    p === "mouseover" && (p = "mouseenter"),
                    p === "mouseout" && (p = "mouseleave"));
                  const g = this.interactionsByType.get(p) || new Map();
                  (p === "mouseenter" || p === "mouseleave"
                    ? (this.delegatedInteractions.size === 0 &&
                        (this.map.on("mousemove", this.handleMove),
                        this.map.on("mouseout", this.handleOut)),
                      this.delegatedInteractions.set(t, s))
                    : g.size === 0 && this.map.on(p, this.handleType),
                    g.size === 0 && this.interactionsByType.set(p, g),
                    g.set(t, s),
                    this.typeById.set(t, p));
                }
                get(t) {
                  const s = this.typeById.get(t);
                  if (!s) return;
                  const h = this.interactionsByType.get(s);
                  return h ? h.get(t) : void 0;
                }
                remove(t) {
                  const s = this.typeById.get(t);
                  if (!s) return;
                  (this.typeById.delete(t), this.filters.delete(t));
                  const h = this.interactionsByType.get(s);
                  h &&
                    (h.delete(t),
                    s === "mouseenter" || s === "mouseleave"
                      ? (this.delegatedInteractions.delete(t),
                        this.delegatedInteractions.size === 0 &&
                          (this.map.off("mousemove", this.handleMove),
                          this.map.off("mouseout", this.handleOut)))
                      : h.size === 0 && this.map.off(s, this.handleType));
                }
                queryTargets(t, s) {
                  const h = [];
                  for (const [p, g] of s)
                    g.target &&
                      h.push({
                        targetId: p,
                        target: g.target,
                        filter: this.filters.get(p),
                      });
                  return this.map.style.queryRenderedTargets(
                    t,
                    h,
                    this.map.transform,
                  );
                }
                handleMove(t) {
                  ((this.prevHoveredFeatures = this.hoveredFeatures),
                    (this.hoveredFeatures = new Map()));
                  const s = this.queryTargets(
                    t.point,
                    Array.from(this.delegatedInteractions).reverse(),
                  );
                  s.length && ((t.type = "mouseenter"), this.handleType(t, s));
                  const h = new Map();
                  for (const [p, { feature: g }] of this.prevHoveredFeatures)
                    this.hoveredFeatures.has(p) || h.set(g.id, g);
                  h.size &&
                    ((t.type = "mouseleave"),
                    this.handleType(t, Array.from(h.values())));
                }
                handleOut(t) {
                  const s = Array.from(this.hoveredFeatures.values()).map(
                    ({ feature: h }) => h,
                  );
                  (s.length && ((t.type = "mouseleave"), this.handleType(t, s)),
                    this.hoveredFeatures.clear());
                }
                handleType(t, s) {
                  const h = t.type === "mouseenter";
                  if (h && !this.interactionsByType.has(t.type))
                    return void r.w(
                      "mouseenter interaction required for mouseleave to work.",
                    );
                  const p = Array.from(
                      this.interactionsByType.get(t.type),
                    ).reverse(),
                    g = !!s;
                  s = s || this.queryTargets(t.point, p);
                  let x = !1;
                  const w = new Set();
                  for (const S of s) {
                    for (const [C, D] of p) {
                      if (!D.target) continue;
                      const L = S.variants ? S.variants[C] : null;
                      if (L) {
                        for (const z of L) {
                          if (Ih(z, S, w, C)) continue;
                          const O = new r.de(S, z),
                            G = ac(z, S, C);
                          g && (O.state = this.map.getFeatureState(O));
                          const U = h ? this.prevHoveredFeatures.get(G) : null,
                            $ = new Vn(t, C, D, O),
                            Z = U ? U.stop : D.handler($);
                          if (
                            (h &&
                              this.hoveredFeatures.set(G, {
                                feature: S,
                                stop: Z,
                              }),
                            Z !== !1)
                          ) {
                            x = !0;
                            break;
                          }
                        }
                        if (x) break;
                      }
                    }
                    if (x) break;
                  }
                  if (!x)
                    for (const [S, C] of p) {
                      const { handler: D, target: L } = C;
                      if (!L && D(new Vn(t, S, C, null)) !== !1) break;
                    }
                }
              }
              function Xc(c, t) {
                if (Array.isArray(c) && Array.isArray(t)) {
                  const s = new Set(c),
                    h = new Set(t);
                  return s.size === h.size && c.every((p) => h.has(p));
                }
                return r.bv(c, t);
              }
              const Tu = {
                  center: [0, 0],
                  zoom: 0,
                  bearing: 0,
                  pitch: 0,
                  minZoom: -2,
                  maxZoom: 22,
                  minPitch: 0,
                  maxPitch: 85,
                  interactive: !0,
                  scrollZoom: !0,
                  boxZoom: !0,
                  dragRotate: !0,
                  dragPan: !0,
                  keyboard: !0,
                  doubleClickZoom: !0,
                  touchZoomRotate: !0,
                  touchPitch: !0,
                  cooperativeGestures: !1,
                  performanceMetricsCollection: !0,
                  bearingSnap: 7,
                  clickTolerance: 3,
                  pitchWithRotate: !0,
                  hash: !1,
                  attributionControl: !0,
                  antialias: !1,
                  failIfMajorPerformanceCaveat: !1,
                  preserveDrawingBuffer: !1,
                  trackResize: !0,
                  renderWorldCopies: !0,
                  refreshExpiredTiles: !0,
                  minTileCacheSize: null,
                  maxTileCacheSize: null,
                  localIdeographFontFamily: "sans-serif",
                  localFontFamily: null,
                  transformRequest: null,
                  accessToken: null,
                  fadeDuration: 300,
                  respectPrefersReducedMotion: !0,
                  crossSourceCollisions: !0,
                  collectResourceTiming: !1,
                  testMode: !1,
                  precompilePrograms: !0,
                  scaleFactor: 1,
                  spriteFormat: "auto",
                },
                wm = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
              class W_ {
                constructor(t, s, h = !1) {
                  ((this._clickTolerance = 10),
                    (this.element = s),
                    (this.mouseRotate = new gu({
                      clickTolerance: t.dragRotate._mouseRotate._clickTolerance,
                    })),
                    (this.map = t),
                    h &&
                      (this.mousePitch = new ka({
                        clickTolerance:
                          t.dragRotate._mousePitch._clickTolerance,
                      })),
                    r.aV(
                      [
                        "mousedown",
                        "mousemove",
                        "mouseup",
                        "touchstart",
                        "touchmove",
                        "touchend",
                        "reset",
                      ],
                      this,
                    ),
                    s.addEventListener("mousedown", this.mousedown),
                    s.addEventListener("touchstart", this.touchstart, {
                      passive: !1,
                    }),
                    s.addEventListener("touchmove", this.touchmove),
                    s.addEventListener("touchend", this.touchend),
                    s.addEventListener("touchcancel", this.reset));
                }
                down(t, s) {
                  (this.mouseRotate.mousedown(t, s),
                    this.mousePitch && this.mousePitch.mousedown(t, s),
                    Rt());
                }
                move(t, s) {
                  const h = this.map,
                    p = this.mouseRotate.mousemoveWindow(t, s),
                    g = p && p.bearingDelta;
                  if (
                    (g && h.setBearing(h.getBearing() + g), this.mousePitch)
                  ) {
                    const x = this.mousePitch.mousemoveWindow(t, s),
                      w = x && x.pitchDelta;
                    w && h.setPitch(h.getPitch() + w);
                  }
                }
                off() {
                  const t = this.element;
                  (t.removeEventListener("mousedown", this.mousedown),
                    t.removeEventListener("touchstart", this.touchstart),
                    t.removeEventListener("touchmove", this.touchmove),
                    t.removeEventListener("touchend", this.touchend),
                    t.removeEventListener("touchcancel", this.reset),
                    this.offTemp());
                }
                offTemp() {
                  (Mt(),
                    window.removeEventListener("mousemove", this.mousemove),
                    window.removeEventListener("mouseup", this.mouseup));
                }
                mousedown(t) {
                  (this.down(
                    r.h({}, t, {
                      ctrlKey: !0,
                      preventDefault: () => t.preventDefault(),
                    }),
                    rt(this.element, t),
                  ),
                    window.addEventListener("mousemove", this.mousemove),
                    window.addEventListener("mouseup", this.mouseup));
                }
                mousemove(t) {
                  this.move(t, rt(this.element, t));
                }
                mouseup(t) {
                  (this.mouseRotate.mouseupWindow(t),
                    this.mousePitch && this.mousePitch.mouseupWindow(t),
                    this.offTemp());
                }
                touchstart(t) {
                  t.targetTouches.length !== 1
                    ? this.reset()
                    : ((this._startPos = this._lastPos =
                        Ot(this.element, t.targetTouches)[0]),
                      this.down(
                        {
                          type: "mousedown",
                          button: 0,
                          ctrlKey: !0,
                          preventDefault: () => t.preventDefault(),
                        },
                        this._startPos,
                      ));
                }
                touchmove(t) {
                  t.targetTouches.length !== 1
                    ? this.reset()
                    : ((this._lastPos = Ot(this.element, t.targetTouches)[0]),
                      this.move(
                        { preventDefault: () => t.preventDefault() },
                        this._lastPos,
                      ));
                }
                touchend(t) {
                  (t.targetTouches.length === 0 &&
                    this._startPos &&
                    this._lastPos &&
                    this._startPos.dist(this._lastPos) < this._clickTolerance &&
                    this.element.click(),
                    this.reset());
                }
                reset() {
                  (this.mouseRotate.reset(),
                    this.mousePitch && this.mousePitch.reset(),
                    delete this._startPos,
                    delete this._lastPos,
                    this.offTemp());
                }
              }
              function Rl(c, t, s) {
                if (((c = new r.cd(c.lng, c.lat)), t)) {
                  const h = new r.cd(c.lng - 360, c.lat),
                    p = new r.cd(c.lng + 360, c.lat),
                    g = 360 * Math.ceil(Math.abs(c.lng - s.center.lng) / 360),
                    x = s.locationPoint3D(c).distSqr(t),
                    w = t.x < 0 || t.y < 0 || t.x > s.width || t.y > s.height;
                  s.locationPoint3D(h).distSqr(t) < x &&
                  (w || Math.abs(h.lng - s.center.lng) < g)
                    ? (c = h)
                    : s.locationPoint3D(p).distSqr(t) < x &&
                      (w || Math.abs(p.lng - s.center.lng) < g) &&
                      (c = p);
                }
                for (; Math.abs(c.lng - s.center.lng) > 180; ) {
                  const h = s.locationPoint3D(c);
                  if (h.x >= 0 && h.y >= 0 && h.x <= s.width && h.y <= s.height)
                    break;
                  c.lng > s.center.lng ? (c.lng -= 360) : (c.lng += 360);
                }
                return c;
              }
              const sf = {
                  center: "translate(-50%,-50%)",
                  top: "translate(-50%,0)",
                  "top-left": "translate(0,0)",
                  "top-right": "translate(-100%,0)",
                  bottom: "translate(-50%,-100%)",
                  "bottom-left": "translate(0,-100%)",
                  "bottom-right": "translate(-100%,-100%)",
                  left: "translate(0,-50%)",
                  right: "translate(-100%,-50%)",
                },
                js = {
                  rotation: 0,
                  rotationAlignment: "auto",
                  pitchAlignment: "auto",
                  occludedOpacity: 0.2,
                  altitude: 0,
                };
              class Yc extends r.E {
                constructor(t, s) {
                  (super(),
                    (t instanceof HTMLElement || s) &&
                      (t = r.h({ element: t }, s)),
                    r.aV(
                      [
                        "_update",
                        "_onMove",
                        "_onUp",
                        "_addDragHandler",
                        "_onMapClick",
                        "_onKeyPress",
                        "_clearFadeTimer",
                      ],
                      this,
                    ));
                  const {
                    anchor: h = "center",
                    color: p = "#3FB1CE",
                    scale: g = 1,
                    draggable: x = !1,
                    clickTolerance: w = 0,
                    rotation: S = js.rotation,
                    rotationAlignment: C = js.rotationAlignment,
                    pitchAlignment: D = js.pitchAlignment,
                    occludedOpacity: L = js.occludedOpacity,
                    altitude: z = js.altitude,
                  } = t || {};
                  ((this._anchor = h),
                    (this._color = p),
                    (this._scale = g),
                    (this._draggable = x),
                    (this._clickTolerance = w),
                    (this._rotation = S),
                    (this._rotationAlignment = C),
                    (this._pitchAlignment = D),
                    (this._occludedOpacity = L),
                    (this._altitude = z),
                    (this._state = "inactive"),
                    (this._isDragging = !1),
                    (this._updateMoving = () => this._update(!0)),
                    t && t.element
                      ? ((this._element = t.element),
                        (this._offset = r.P.convert((t && t.offset) || [0, 0])))
                      : ((this._defaultMarker = !0),
                        (this._element = this._createDefaultMarker()),
                        (this._offset = r.P.convert(
                          (t && t.offset) || [0, -14],
                        ))),
                    this._element.hasAttribute("aria-label") ||
                      this._element.setAttribute("aria-label", "Map marker"),
                    this._element.hasAttribute("role") ||
                      this._element.setAttribute("role", "img"),
                    this._element.classList.add("mapboxgl-marker"),
                    this._element.addEventListener("dragstart", (U) => {
                      U.preventDefault();
                    }),
                    this._element.addEventListener("mousedown", (U) => {
                      U.preventDefault();
                    }));
                  const O = this._element.classList;
                  for (const U in sf) O.remove(`mapboxgl-marker-anchor-${U}`);
                  O.add(`mapboxgl-marker-anchor-${this._anchor}`);
                  const G =
                    t && t.className ? t.className.trim().split(/\s+/) : [];
                  (O.add(...G), (this._popup = null));
                }
                _createDefaultMarker() {
                  const t = xe("div"),
                    s = we(
                      "svg",
                      {
                        display: "block",
                        height: 41 * this._scale + "px",
                        width: 27 * this._scale + "px",
                        viewBox: "0 0 27 41",
                      },
                      t,
                    );
                  if (this._altitude === 0) {
                    const h = we(
                      "radialGradient",
                      { id: "shadowGradient" },
                      we("defs", {}, s),
                    );
                    (we("stop", { offset: "10%", "stop-opacity": 0.4 }, h),
                      we("stop", { offset: "100%", "stop-opacity": 0.05 }, h),
                      we(
                        "ellipse",
                        {
                          cx: 13.5,
                          cy: 34.8,
                          rx: 10.5,
                          ry: 5.25,
                          fill: "url(#shadowGradient)",
                        },
                        s,
                      ));
                  }
                  return (
                    we(
                      "path",
                      {
                        fill: this._color,
                        d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z",
                      },
                      s,
                    ),
                    we(
                      "path",
                      {
                        opacity: 0.25,
                        d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z",
                      },
                      s,
                    ),
                    we(
                      "circle",
                      { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 },
                      s,
                    ),
                    t
                  );
                }
                addTo(t) {
                  return (
                    t === this._map ||
                      (this.remove(),
                      (this._map = t),
                      t.getCanvasContainer().appendChild(this._element),
                      t.on("move", this._updateMoving),
                      t.on("moveend", this._update),
                      t.on("remove", this._clearFadeTimer),
                      t._addMarker(this),
                      this.setDraggable(this._draggable),
                      this._update(),
                      t.on("click", this._onMapClick)),
                    this
                  );
                }
                remove() {
                  const t = this._map;
                  return (
                    t &&
                      (t.off("click", this._onMapClick),
                      t.off("move", this._updateMoving),
                      t.off("moveend", this._update),
                      t.off("mousedown", this._addDragHandler),
                      t.off("touchstart", this._addDragHandler),
                      t.off("mouseup", this._onUp),
                      t.off("touchend", this._onUp),
                      t.off("mousemove", this._onMove),
                      t.off("touchmove", this._onMove),
                      t.off("remove", this._clearFadeTimer),
                      t._removeMarker(this),
                      (this._map = void 0)),
                    this._clearFadeTimer(),
                    this._element.remove(),
                    this._popup && this._popup.remove(),
                    this
                  );
                }
                getLngLat() {
                  return this._lngLat;
                }
                setLngLat(t) {
                  return (
                    (this._lngLat = r.cd.convert(t)),
                    (this._pos = null),
                    this._popup && this._popup.setLngLat(this._lngLat),
                    this._update(!0),
                    this
                  );
                }
                setAltitude(t) {
                  return (
                    t === this._altitude ||
                      (this._defaultMarker &&
                        ((this._altitude === 0 && t !== 0) ||
                          (this._altitude !== 0 && t === 0)) &&
                        (this._element = this._createDefaultMarker()),
                      (this._altitude = t || js.altitude),
                      this._update()),
                    this
                  );
                }
                getAltitude() {
                  return this._altitude;
                }
                getElement() {
                  return this._element;
                }
                setPopup(t) {
                  if (
                    (this._popup &&
                      (this._popup.remove(),
                      (this._popup = null),
                      this._element.removeAttribute("role"),
                      this._element.removeEventListener(
                        "keypress",
                        this._onKeyPress,
                      ),
                      this._originalTabIndex ||
                        this._element.removeAttribute("tabindex")),
                    t)
                  ) {
                    if (!("offset" in t.options)) {
                      const p = Math.sqrt(Math.pow(13.5, 2) / 2);
                      t.options.offset = this._defaultMarker
                        ? {
                            top: [0, 0],
                            "top-left": [0, 0],
                            "top-right": [0, 0],
                            bottom: [0, -38.1],
                            "bottom-left": [p, -1 * (38.1 - 13.5 + p)],
                            "bottom-right": [-p, -1 * (38.1 - 13.5 + p)],
                            left: [13.5, -1 * (38.1 - 13.5)],
                            right: [-13.5, -1 * (38.1 - 13.5)],
                          }
                        : this._offset;
                    }
                    ((this._popup = t),
                      (t._marker = this),
                      (t._altitude = this._altitude),
                      this._lngLat && this._popup.setLngLat(this._lngLat),
                      this._element.setAttribute("role", "button"),
                      (this._originalTabIndex =
                        this._element.getAttribute("tabindex")),
                      this._originalTabIndex ||
                        this._element.setAttribute("tabindex", "0"),
                      this._element.addEventListener(
                        "keypress",
                        this._onKeyPress,
                      ),
                      this._element.setAttribute("aria-expanded", "false"));
                  }
                  return this;
                }
                _onKeyPress(t) {
                  const s = t.code,
                    h = t.charCode || t.keyCode;
                  (s !== "Space" && s !== "Enter" && h !== 32 && h !== 13) ||
                    this.togglePopup();
                }
                _onMapClick(t) {
                  const s = t.originalEvent.target,
                    h = this._element;
                  this._popup &&
                    (s === h || h.contains(s)) &&
                    this.togglePopup();
                }
                getPopup() {
                  return this._popup;
                }
                togglePopup() {
                  const t = this._popup;
                  return t
                    ? (t.isOpen()
                        ? (t.remove(),
                          this._element.setAttribute("aria-expanded", "false"))
                        : this._map &&
                          (t.addTo(this._map),
                          this._element.setAttribute("aria-expanded", "true")),
                      this)
                    : this;
                }
                _behindTerrain() {
                  const t = this._map,
                    s = this._pos;
                  if (!t || !s) return !1;
                  const h = t.unproject(s, this._altitude),
                    p = t.getFreeCameraOptions();
                  if (!p.position) return !1;
                  const g = p.position.toLngLat();
                  return g.distanceTo(h) < 0.9 * g.distanceTo(this._lngLat);
                }
                _evaluateOpacity() {
                  const t = this._map;
                  if (!t) return;
                  const s = this._pos;
                  if (
                    !s ||
                    s.x < 0 ||
                    s.x > t.transform.width ||
                    s.y < 0 ||
                    s.y > t.transform.height
                  )
                    return void this._clearFadeTimer();
                  const h = t.unproject(s, this._altitude);
                  let p;
                  (t._showingGlobe() && r.eK(t.transform, this._lngLat)
                    ? (p = 0)
                    : ((p = 1 - t._queryFogOpacity(h)),
                      t.transform._terrainEnabled() &&
                        t.getTerrain() &&
                        this._behindTerrain() &&
                        (p *= this._occludedOpacity)),
                    (this._element.style.opacity = `${p}`),
                    (this._element.style.pointerEvents =
                      p > 0 ? "auto" : "none"),
                    this._popup && this._popup._setOpacity(p),
                    (this._fadeTimer = null));
                }
                _clearFadeTimer() {
                  this._fadeTimer &&
                    (clearTimeout(this._fadeTimer), (this._fadeTimer = null));
                }
                _updateDOM() {
                  const t = this._pos;
                  if (!t || !this._map) return;
                  const s = this._offset.mult(this._scale);
                  this._element.style.transform = `
            translate(${t.x}px,${t.y}px)
            ${sf[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${s.x}px,${s.y}px)
        `;
                }
                _calculateXYTransform() {
                  const t = this._pos,
                    s = this._map,
                    h = this.getPitchAlignment();
                  if (!s || !t || h !== "map") return "";
                  if (!s._showingGlobe()) {
                    const S = s.getPitch();
                    return S ? `rotateX(${S}deg)` : "";
                  }
                  const p = r.cJ(r.eL(s.transform, this._lngLat)),
                    g = t.sub(r.eM(s.transform)),
                    x = Math.abs(g.x) + Math.abs(g.y);
                  if (x === 0) return "";
                  const w = p / x;
                  return `rotateX(${-g.y * w}deg) rotateY(${g.x * w}deg)`;
                }
                _calculateZTransform() {
                  const t = this._pos,
                    s = this._map;
                  if (!s || !t) return "";
                  let h = 0;
                  const p = this.getRotationAlignment();
                  if (p === "map")
                    if (s._showingGlobe()) {
                      const g = s.project(
                          new r.cd(this._lngLat.lng, this._lngLat.lat + 0.001),
                          this._altitude,
                        ),
                        x = s
                          .project(
                            new r.cd(
                              this._lngLat.lng,
                              this._lngLat.lat - 0.001,
                            ),
                            this._altitude,
                          )
                          .sub(g);
                      h = r.cJ(Math.atan2(x.y, x.x)) - 90;
                    } else h = -s.getBearing();
                  else if (p === "horizon") {
                    const g = r.af(4, 6, s.getZoom()),
                      x = r.eM(s.transform);
                    x.y += g * s.transform.height;
                    const w = t.sub(x),
                      S = r.cJ(Math.atan2(w.y, w.x));
                    h = (S > 90 ? S - 270 : S + 90) * (1 - g);
                  }
                  return ((h += this._rotation), h ? `rotateZ(${h}deg)` : "");
                }
                _update(t) {
                  cancelAnimationFrame(this._updateFrameId);
                  const s = this._map;
                  s &&
                    (s.transform.renderWorldCopies &&
                      (this._lngLat = Rl(this._lngLat, this._pos, s.transform)),
                    (this._pos = s.project(this._lngLat, this._altitude)),
                    t === !0
                      ? (this._updateFrameId = requestAnimationFrame(() => {
                          this._element &&
                            this._pos &&
                            this._anchor &&
                            ((this._pos = this._pos.round()),
                            this._updateDOM());
                        }))
                      : (this._pos = this._pos.round()),
                    s._requestDomTask(() => {
                      this._map &&
                        (this._element &&
                          this._pos &&
                          this._anchor &&
                          this._updateDOM(),
                        (s._showingGlobe() || s.getTerrain() || s.getFog()) &&
                          !this._fadeTimer &&
                          (this._fadeTimer = window.setTimeout(
                            this._evaluateOpacity.bind(this),
                            60,
                          )));
                    }));
                }
                getOffset() {
                  return this._offset;
                }
                setOffset(t) {
                  return (
                    (this._offset = r.P.convert(t)),
                    this._update(),
                    this
                  );
                }
                addClassName(t) {
                  return (this._element.classList.add(t), this);
                }
                removeClassName(t) {
                  return (this._element.classList.remove(t), this);
                }
                toggleClassName(t) {
                  return this._element.classList.toggle(t);
                }
                _onMove(t) {
                  const s = this._map;
                  if (!s) return;
                  const h = this._pointerdownPos,
                    p = this._positionDelta;
                  if (h && p) {
                    if (!this._isDragging) {
                      const g = this._clickTolerance || s._clickTolerance;
                      if (t.point.dist(h) < g) return;
                      this._isDragging = !0;
                    }
                    ((this._pos = t.point.sub(p)),
                      (this._lngLat = s.unproject(this._pos, this._altitude)),
                      this.setLngLat(this._lngLat),
                      (this._element.style.pointerEvents = "none"),
                      this._state === "pending" &&
                        ((this._state = "active"),
                        this.fire(new r.A("dragstart"))),
                      this.fire(new r.A("drag")));
                  }
                }
                _onUp() {
                  ((this._element.style.pointerEvents = "auto"),
                    (this._positionDelta = null),
                    (this._pointerdownPos = null),
                    (this._isDragging = !1));
                  const t = this._map;
                  (t &&
                    (t.off("mousemove", this._onMove),
                    t.off("touchmove", this._onMove)),
                    this._state === "active" && this.fire(new r.A("dragend")),
                    (this._state = "inactive"));
                }
                _addDragHandler(t) {
                  const s = this._map,
                    h = this._pos;
                  s &&
                    h &&
                    this._element.contains(t.originalEvent.target) &&
                    (t.preventDefault(),
                    (this._positionDelta = t.point.sub(h)),
                    (this._pointerdownPos = t.point),
                    (this._state = "pending"),
                    s.on("mousemove", this._onMove),
                    s.on("touchmove", this._onMove),
                    s.once("mouseup", this._onUp),
                    s.once("touchend", this._onUp));
                }
                setDraggable(t) {
                  this._draggable = !!t;
                  const s = this._map;
                  return (
                    s &&
                      (t
                        ? (s.on("mousedown", this._addDragHandler),
                          s.on("touchstart", this._addDragHandler))
                        : (s.off("mousedown", this._addDragHandler),
                          s.off("touchstart", this._addDragHandler))),
                    this
                  );
                }
                isDraggable() {
                  return this._draggable;
                }
                setRotation(t) {
                  return (
                    (this._rotation = t || js.rotation),
                    this._update(),
                    this
                  );
                }
                getRotation() {
                  return this._rotation;
                }
                setRotationAlignment(t) {
                  return (
                    (this._rotationAlignment = t || js.rotationAlignment),
                    this._update(),
                    this
                  );
                }
                getRotationAlignment() {
                  return this._rotationAlignment === "auto" ||
                    (this._rotationAlignment === "horizon" &&
                      this._map &&
                      !this._map._showingGlobe())
                    ? "viewport"
                    : this._rotationAlignment;
                }
                setPitchAlignment(t) {
                  return (
                    (this._pitchAlignment = t || js.pitchAlignment),
                    this._update(),
                    this
                  );
                }
                getPitchAlignment() {
                  return this._pitchAlignment === "auto"
                    ? this.getRotationAlignment()
                    : this._pitchAlignment;
                }
                setOccludedOpacity(t) {
                  return (
                    (this._occludedOpacity = t || js.occludedOpacity),
                    this._update(),
                    this
                  );
                }
                getOccludedOpacity() {
                  return this._occludedOpacity;
                }
              }
              const of = {
                  positionOptions: {
                    enableHighAccuracy: !1,
                    maximumAge: 0,
                    timeout: 6e3,
                  },
                  fitBoundsOptions: { maxZoom: 15 },
                  trackUserLocation: !1,
                  showAccuracyCircle: !0,
                  showUserLocation: !0,
                  showUserHeading: !1,
                },
                Kc = { maxWidth: 100, unit: "metric" },
                zl = {
                  kilometer: "km",
                  meter: "m",
                  mile: "mi",
                  foot: "ft",
                  "nautical-mile": "nm",
                },
                go = {
                  closeButton: !0,
                  closeOnClick: !0,
                  focusAfterOpen: !0,
                  className: "",
                  maxWidth: "240px",
                  altitude: 0,
                },
                Rs = [
                  "a[href]",
                  "[tabindex]:not([tabindex='-1'])",
                  "[contenteditable]:not([contenteditable='false'])",
                  "button:not([disabled])",
                  "input:not([disabled])",
                  "select:not([disabled])",
                  "textarea:not([disabled])",
                ].join(", ");
              function bs(c = new r.P(0, 0), t = "bottom") {
                if (typeof c == "number") {
                  const s = Math.round(Math.sqrt(0.5 * Math.pow(c, 2)));
                  switch (t) {
                    case "top":
                      return new r.P(0, c);
                    case "top-left":
                      return new r.P(s, s);
                    case "top-right":
                      return new r.P(-s, s);
                    case "bottom":
                      return new r.P(0, -c);
                    case "bottom-left":
                      return new r.P(s, -s);
                    case "bottom-right":
                      return new r.P(-s, -s);
                    case "left":
                      return new r.P(c, 0);
                    case "right":
                      return new r.P(-c, 0);
                  }
                  return new r.P(0, 0);
                }
                return c instanceof r.P || Array.isArray(c)
                  ? r.P.convert(c)
                  : r.P.convert(c[t] || [0, 0]);
              }
              return {
                version: F,
                supported: Ie.supported,
                setRTLTextPlugin: r.eQ,
                getRTLTextPluginStatus: r.eP,
                Map: class extends qc {
                  constructor(c) {
                    q.mark(B.create);
                    const t = c;
                    if (
                      (c = r.h({}, Tu, c)).minZoom != null &&
                      c.maxZoom != null &&
                      c.minZoom > c.maxZoom
                    )
                      throw new Error(
                        "maxZoom must be greater than or equal to minZoom",
                      );
                    if (
                      c.minPitch != null &&
                      c.maxPitch != null &&
                      c.minPitch > c.maxPitch
                    )
                      throw new Error(
                        "maxPitch must be greater than or equal to minPitch",
                      );
                    if (c.minPitch != null && c.minPitch < 0)
                      throw new Error(
                        "minPitch must be greater than or equal to 0",
                      );
                    if (c.maxPitch != null && c.maxPitch > 85)
                      throw new Error(
                        "maxPitch must be less than or equal to 85",
                      );
                    if (
                      (c.antialias &&
                        r.eI(window) &&
                        ((c.antialias = !1),
                        r.w(
                          "Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609",
                        )),
                      super(
                        new ud(
                          c.minZoom,
                          c.maxZoom,
                          c.minPitch,
                          c.maxPitch,
                          c.renderWorldCopies,
                          null,
                          null,
                        ),
                        c,
                      ),
                      (this._repaint = !!c.repaint),
                      (this._interactive = c.interactive),
                      (this._minTileCacheSize = c.minTileCacheSize),
                      (this._maxTileCacheSize = c.maxTileCacheSize),
                      (this._failIfMajorPerformanceCaveat =
                        c.failIfMajorPerformanceCaveat),
                      (this._preserveDrawingBuffer = c.preserveDrawingBuffer),
                      (this._antialias = c.antialias),
                      (this._trackResize = c.trackResize),
                      (this._bearingSnap = c.bearingSnap),
                      (this._refreshExpiredTiles = c.refreshExpiredTiles),
                      (this._fadeDuration = c.fadeDuration),
                      (this._isInitialLoad = !0),
                      (this._crossSourceCollisions = c.crossSourceCollisions),
                      (this._collectResourceTiming = c.collectResourceTiming),
                      (this._language = this._parseLanguage(c.language)),
                      (this._worldview = c.worldview),
                      (this._renderTaskQueue = new Zc()),
                      (this._domRenderTaskQueue = new Zc()),
                      (this._controls = []),
                      (this._markers = []),
                      (this._popups = []),
                      (this._mapId = r.a$()),
                      (this._locale = r.h({}, wu, c.locale)),
                      (this._clickTolerance = c.clickTolerance),
                      (this._cooperativeGestures = c.cooperativeGestures),
                      (this._performanceMetricsCollection =
                        c.performanceMetricsCollection),
                      (this._tessellationStep = c.tessellationStep),
                      (this._containerWidth = 0),
                      (this._containerHeight = 0),
                      (this._showParseStatus = !0),
                      (this._precompilePrograms = c.precompilePrograms),
                      (this._scaleFactorChanged = !1),
                      (this._averageElevationLastSampledAt = -1 / 0),
                      (this._averageElevationExaggeration = 0),
                      (this._averageElevation = new mo(0)),
                      (this._interactionRange = [1 / 0, -1 / 0]),
                      (this._visibilityHidden = 0),
                      (this._useExplicitProjection = !1),
                      (this._frameId = 0),
                      (this._scaleFactor = c.scaleFactor),
                      (this._requestManager = new wi(
                        c.transformRequest,
                        c.accessToken,
                        c.testMode,
                      )),
                      (this._silenceAuthErrors = !!c.testMode),
                      (this._contextCreateOptions = c.contextCreateOptions
                        ? Object.assign({}, c.contextCreateOptions)
                        : {}),
                      typeof c.container == "string")
                    ) {
                      const s = document.getElementById(c.container);
                      if (!s)
                        throw new Error(
                          `Container '${c.container.toString()}' not found.`,
                        );
                      this._container = s;
                    } else {
                      if (!(c.container instanceof HTMLElement))
                        throw new Error(
                          "Invalid type: 'container' must be a String or HTMLElement.",
                        );
                      this._container = c.container;
                    }
                    if (
                      (this._container.childNodes.length > 0 &&
                        r.w(
                          "The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead.",
                        ),
                      c.maxBounds && this.setMaxBounds(c.maxBounds),
                      (this._spriteFormat = c.spriteFormat),
                      r.aV(
                        [
                          "_onWindowOnline",
                          "_onWindowResize",
                          "_onVisibilityChange",
                          "_onMapScroll",
                          "_contextLost",
                          "_contextRestored",
                        ],
                        this,
                      ),
                      this._setupContainer(),
                      this._tp || (this._tp = new jd()),
                      this._tp.registerParameter(
                        this,
                        ["Debug"],
                        "showOverdrawInspector",
                      ),
                      this._tp.registerParameter(
                        this,
                        ["Debug"],
                        "showTileBoundaries",
                      ),
                      this._tp.registerParameter(
                        this,
                        ["Debug"],
                        "showParseStatus",
                      ),
                      this._tp.registerParameter(this, ["Debug"], "repaint"),
                      this._tp.registerParameter(
                        this,
                        ["Debug"],
                        "showTileAABBs",
                      ),
                      this._tp.registerParameter(
                        this,
                        ["Debug"],
                        "showPadding",
                      ),
                      this._tp.registerParameter(
                        this,
                        ["Debug"],
                        "showCollisionBoxes",
                        { noSave: !0 },
                      ),
                      this._tp.registerParameter(
                        this.transform,
                        ["Debug"],
                        "freezeTileCoverage",
                        { noSave: !0 },
                        () => {
                          this._update();
                        },
                      ),
                      this._tp.registerParameter(
                        this,
                        ["Debug", "Wireframe"],
                        "showTerrainWireframe",
                      ),
                      this._tp.registerParameter(
                        this,
                        ["Debug", "Wireframe"],
                        "showLayers2DWireframe",
                      ),
                      this._tp.registerParameter(
                        this,
                        ["Debug", "Wireframe"],
                        "showLayers3DWireframe",
                      ),
                      this._tp.registerParameter(
                        this,
                        ["Scaling"],
                        "_scaleFactor",
                        { min: 0.1, max: 10, step: 0.1 },
                        () => {
                          this.setScaleFactor(this._scaleFactor);
                        },
                      ),
                      this._setupPainter(),
                      this.painter === void 0)
                    )
                      throw new Error("Failed to initialize WebGL.");
                    if (
                      (this.on("move", () => this._update(!1)),
                      this.on("moveend", () => this._update(!1)),
                      this.on("zoom", () => this._update(!0)),
                      (this._fullscreenchangeEvent =
                        "onfullscreenchange" in document
                          ? "fullscreenchange"
                          : "webkitfullscreenchange"),
                      window.addEventListener(
                        "online",
                        this._onWindowOnline,
                        !1,
                      ),
                      window.addEventListener(
                        "resize",
                        this._onWindowResize,
                        !1,
                      ),
                      window.addEventListener(
                        "orientationchange",
                        this._onWindowResize,
                        !1,
                      ),
                      window.addEventListener(
                        this._fullscreenchangeEvent,
                        this._onWindowResize,
                        !1,
                      ),
                      window.addEventListener(
                        "visibilitychange",
                        this._onVisibilityChange,
                        !1,
                      ),
                      (this.handlers = new nf(this, c)),
                      (this._localFontFamily = c.localFontFamily),
                      (this._localIdeographFontFamily =
                        c.localIdeographFontFamily),
                      (c.style || !c.testMode) &&
                        this.setStyle(c.style || r.e.DEFAULT_STYLE, {
                          config: c.config,
                          localFontFamily: this._localFontFamily,
                          localIdeographFontFamily:
                            this._localIdeographFontFamily,
                        }),
                      c.projection && this.setProjection(c.projection),
                      (this.indoor = new p_(this)),
                      c.hash &&
                        (this._hash = new Wd(
                          (typeof c.hash == "string" && c.hash) || void 0,
                        ).addTo(this)),
                      !this._hash || !this._hash._onHashChange())
                    ) {
                      ((t.center == null && t.zoom == null) ||
                        (this.transform._unmodified = !1),
                        this.jumpTo({
                          center: c.center,
                          zoom: c.zoom,
                          bearing: c.bearing,
                          pitch: c.pitch,
                        }));
                      const s = c.bounds;
                      s &&
                        (this.resize(),
                        this.fitBounds(
                          s,
                          r.h({}, c.fitBoundsOptions, { duration: 0 }),
                        ));
                    }
                    (this.resize(),
                      c.attributionControl &&
                        this.addControl(
                          new rf({ customAttribution: c.customAttribution }),
                        ),
                      (this._logoControl = new bu()),
                      this.addControl(this._logoControl, c.logoPosition),
                      this.on("style.load", () => {
                        (this.transform.unmodified &&
                          this.jumpTo(this.style.stylesheet),
                          this._postStyleLoadEvent());
                      }),
                      this.on("data", (s) => {
                        (this._update(s.dataType === "style"),
                          this.fire(new r.A(`${s.dataType}data`, s)));
                      }),
                      this.on("dataloading", (s) => {
                        this.fire(new r.A(`${s.dataType}dataloading`, s));
                      }),
                      (this._interactions = new Us(this)));
                  }
                  _getMapId() {
                    return this._mapId;
                  }
                  addControl(c, t) {
                    if (
                      (t === void 0 &&
                        (t = c.getDefaultPosition
                          ? c.getDefaultPosition()
                          : "top-right"),
                      !c || !c.onAdd)
                    )
                      return this.fire(
                        new r.z(
                          new Error(
                            "Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.",
                          ),
                        ),
                      );
                    const s = c.onAdd(this);
                    this._controls.push(c);
                    const h = this._controlPositions[t];
                    return (
                      t.indexOf("bottom") !== -1
                        ? h.insertBefore(s, h.firstChild)
                        : h.appendChild(s),
                      this
                    );
                  }
                  removeControl(c) {
                    if (!c || !c.onRemove)
                      return this.fire(
                        new r.z(
                          new Error(
                            "Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.",
                          ),
                        ),
                      );
                    const t = this._controls.indexOf(c);
                    return (
                      t > -1 && this._controls.splice(t, 1),
                      c.onRemove(this),
                      this
                    );
                  }
                  hasControl(c) {
                    return this._controls.indexOf(c) > -1;
                  }
                  getContainer() {
                    return this._container;
                  }
                  getCanvasContainer() {
                    return this._canvasContainer;
                  }
                  getCanvas() {
                    return this._canvas;
                  }
                  resize(c) {
                    if (
                      (this._updateContainerDimensions(),
                      this._containerWidth === this.transform.width &&
                        this._containerHeight === this.transform.height)
                    )
                      return this;
                    (this._resizeCanvas(
                      this._containerWidth,
                      this._containerHeight,
                    ),
                      this.transform.resize(
                        this._containerWidth,
                        this._containerHeight,
                      ),
                      this.painter.resize(
                        Math.ceil(this._containerWidth),
                        Math.ceil(this._containerHeight),
                      ));
                    const t = !this._moving;
                    return (
                      t &&
                        this.fire(new r.A("movestart", c)).fire(
                          new r.A("move", c),
                        ),
                      this.fire(new r.A("resize", c)),
                      t && this.fire(new r.A("moveend", c)),
                      this
                    );
                  }
                  getBounds() {
                    return this.transform.getBounds();
                  }
                  getMaxBounds() {
                    return this.transform.getMaxBounds() || null;
                  }
                  setMaxBounds(c) {
                    return (
                      this.transform.setMaxBounds(r.aG.convert(c)),
                      this._update()
                    );
                  }
                  setMinZoom(c) {
                    if ((c = c ?? -2) >= -2 && c <= this.transform.maxZoom)
                      return (
                        (this.transform.minZoom = c),
                        this._update(),
                        this.getZoom() < c
                          ? this.setZoom(c)
                          : this.fire(new r.A("zoomstart"))
                              .fire(new r.A("zoom"))
                              .fire(new r.A("zoomend")),
                        this
                      );
                    throw new Error(
                      "minZoom must be between -2 and the current maxZoom, inclusive",
                    );
                  }
                  getMinZoom() {
                    return this.transform.minZoom;
                  }
                  setMaxZoom(c) {
                    if ((c = c ?? 22) >= this.transform.minZoom)
                      return (
                        (this.transform.maxZoom = c),
                        this._update(),
                        this.getZoom() > c
                          ? this.setZoom(c)
                          : this.fire(new r.A("zoomstart"))
                              .fire(new r.A("zoom"))
                              .fire(new r.A("zoomend")),
                        this
                      );
                    throw new Error(
                      "maxZoom must be greater than the current minZoom",
                    );
                  }
                  getMaxZoom() {
                    return this.transform.maxZoom;
                  }
                  setMinPitch(c) {
                    if ((c = c ?? 0) < 0)
                      throw new Error(
                        "minPitch must be greater than or equal to 0",
                      );
                    if (c >= 0 && c <= this.transform.maxPitch)
                      return (
                        (this.transform.minPitch = c),
                        this._update(),
                        this.getPitch() < c
                          ? this.setPitch(c)
                          : this.fire(new r.A("pitchstart"))
                              .fire(new r.A("pitch"))
                              .fire(new r.A("pitchend")),
                        this
                      );
                    throw new Error(
                      "minPitch must be between 0 and the current maxPitch, inclusive",
                    );
                  }
                  getMinPitch() {
                    return this.transform.minPitch;
                  }
                  setMaxPitch(c) {
                    if ((c = c ?? 85) > 85)
                      throw new Error(
                        "maxPitch must be less than or equal to 85",
                      );
                    if (c >= this.transform.minPitch)
                      return (
                        (this.transform.maxPitch = c),
                        this._update(),
                        this.getPitch() > c
                          ? this.setPitch(c)
                          : this.fire(new r.A("pitchstart"))
                              .fire(new r.A("pitch"))
                              .fire(new r.A("pitchend")),
                        this
                      );
                    throw new Error(
                      "maxPitch must be greater than or equal to minPitch",
                    );
                  }
                  getMaxPitch() {
                    return this.transform.maxPitch;
                  }
                  getScaleFactor() {
                    return this._scaleFactor;
                  }
                  setScaleFactor(c) {
                    return (
                      (this._scaleFactor = c),
                      (this.painter.scaleFactor = c),
                      this._tp.refreshUI(),
                      (this._scaleFactorChanged = !0),
                      this.style._updateFilteredLayers(
                        (t) => t.type === "symbol",
                      ),
                      this._update(!0),
                      this
                    );
                  }
                  getRenderWorldCopies() {
                    return this.transform.renderWorldCopies;
                  }
                  setRenderWorldCopies(c) {
                    return (
                      (this.transform.renderWorldCopies = c),
                      this.transform.renderWorldCopies ||
                        this._forceMarkerAndPopupUpdate(!0),
                      this._update()
                    );
                  }
                  getLanguage() {
                    return this._language;
                  }
                  _parseLanguage(c) {
                    return c === "auto"
                      ? navigator.language
                      : Array.isArray(c)
                        ? c.length === 0
                          ? void 0
                          : c.map((t) =>
                              t === "auto" ? navigator.language : t,
                            )
                        : c;
                  }
                  setLanguage(c) {
                    const t = this._parseLanguage(c);
                    if (!this.style || t === this._language) return this;
                    ((this._language = t), this.style.reloadSources());
                    for (const s of this._controls)
                      s._setLanguage && s._setLanguage(this._language);
                    return this;
                  }
                  getWorldview() {
                    return this._worldview;
                  }
                  setWorldview(c) {
                    return this.style && c !== this._worldview
                      ? ((this._worldview = c),
                        (this._styleDirty = !0),
                        this.style.reloadSources(),
                        this)
                      : this;
                  }
                  getProjection() {
                    return this.transform.mercatorFromTransition
                      ? { name: "globe", center: [0, 0] }
                      : this.transform.getProjection();
                  }
                  _showingGlobe() {
                    return this.transform.projection.name === "globe";
                  }
                  setProjection(c) {
                    return (
                      this._lazyInitEmptyStyle(),
                      c
                        ? typeof c == "string" && (c = { name: c })
                        : (c = null),
                      (this._useExplicitProjection = !!c),
                      this._prioritizeAndUpdateProjection(
                        c,
                        this.style.projection,
                      )
                    );
                  }
                  _updateProjectionTransition() {
                    if (this.getProjection().name !== "globe") return;
                    const c = this.transform,
                      t = c.projection.name;
                    let s;
                    (t === "globe" && c.zoom >= r.cx
                      ? (c.setMercatorFromTransition(), (s = !0))
                      : t === "mercator" &&
                        c.zoom < r.cx &&
                        (c.setProjection({ name: "globe" }), (s = !0)),
                      s &&
                        (this.style.applyProjectionUpdate(),
                        this.style._forceSymbolLayerUpdate(),
                        this._update(!0)));
                  }
                  _prioritizeAndUpdateProjection(c, t) {
                    return this._updateProjection(
                      c || t || { name: "mercator" },
                    );
                  }
                  _updateProjection(c) {
                    let t;
                    return (
                      (t =
                        c.name === "globe" && this.transform.zoom >= r.cx
                          ? this.transform.setMercatorFromTransition()
                          : this.transform.setProjection(c)),
                      this.style.applyProjectionUpdate(),
                      t &&
                        (this.painter.clearBackgroundTiles(),
                        this.style.clearSources(),
                        this._update(!0),
                        this._forceMarkerAndPopupUpdate(!0)),
                      this
                    );
                  }
                  project(c, t) {
                    return this.transform.locationPoint3D(r.cd.convert(c), t);
                  }
                  unproject(c, t) {
                    return this.transform.pointLocation3D(r.P.convert(c), t);
                  }
                  isMoving() {
                    return (
                      this._moving ||
                      (this.handlers && this.handlers.isMoving()) ||
                      !1
                    );
                  }
                  isZooming() {
                    return (
                      this._zooming ||
                      (this.handlers && this.handlers.isZooming()) ||
                      !1
                    );
                  }
                  isRotating() {
                    return (
                      this._rotating ||
                      (this.handlers && this.handlers.isRotating()) ||
                      !1
                    );
                  }
                  _isDragging() {
                    return (this.handlers && this.handlers._isDragging()) || !1;
                  }
                  _createDelegatedListener(c, t, s) {
                    const h = (p) => {
                      let g = [];
                      if (Array.isArray(t)) {
                        const x = t.filter((w) => this.getLayer(w));
                        g = x.length
                          ? this.queryRenderedFeatures(p, { layers: x })
                          : [];
                      } else g = this.queryRenderedFeatures(p, { target: t });
                      return g;
                    };
                    if (c === "mouseenter" || c === "mouseover") {
                      let p = !1;
                      return {
                        listener: s,
                        targets: t,
                        delegates: {
                          mousemove: (x) => {
                            const w = h(x.point);
                            w.length
                              ? p ||
                                ((p = !0),
                                s.call(
                                  this,
                                  new ur(c, this, x.originalEvent, {
                                    features: w,
                                  }),
                                ))
                              : (p = !1);
                          },
                          mouseout: () => {
                            p = !1;
                          },
                        },
                      };
                    }
                    if (c === "mouseleave" || c === "mouseout") {
                      let p = !1;
                      return {
                        listener: s,
                        targets: t,
                        delegates: {
                          mousemove: (w) => {
                            h(w.point).length
                              ? (p = !0)
                              : p &&
                                ((p = !1),
                                s.call(this, new ur(c, this, w.originalEvent)));
                          },
                          mouseout: (w) => {
                            p &&
                              ((p = !1),
                              s.call(this, new ur(c, this, w.originalEvent)));
                          },
                        },
                      };
                    }
                    {
                      const p = (g) => {
                        const x = h(g.point);
                        x.length &&
                          ((g.features = x),
                          s.call(this, g),
                          delete g.features);
                      };
                      return { listener: s, targets: t, delegates: { [c]: p } };
                    }
                  }
                  on(c, t, s) {
                    if (typeof t == "function" || s === void 0)
                      return super.on(c, t);
                    if (
                      (typeof t == "string" && (t = [t]),
                      !this._areTargetsValid(t))
                    )
                      return this;
                    const h = this._createDelegatedListener(c, t, s);
                    ((this._delegatedListeners =
                      this._delegatedListeners || {}),
                      (this._delegatedListeners[c] =
                        this._delegatedListeners[c] || []),
                      this._delegatedListeners[c].push(h));
                    for (const p in h.delegates) this.on(p, h.delegates[p]);
                    return this;
                  }
                  once(c, t, s) {
                    if (typeof t == "function" || s === void 0)
                      return super.once(c, t);
                    if (
                      (typeof t == "string" && (t = [t]),
                      !this._areTargetsValid(t))
                    )
                      return this;
                    const h = this._createDelegatedListener(c, t, s);
                    for (const p in h.delegates) this.once(p, h.delegates[p]);
                    return this;
                  }
                  off(c, t, s) {
                    if (typeof t == "function" || s === void 0)
                      return super.off(c, t);
                    if (
                      (typeof t == "string" && (t = [t]),
                      !this._areTargetsValid(t))
                    )
                      return this;
                    const h = this._delegatedListeners
                      ? this._delegatedListeners[c]
                      : void 0;
                    return (
                      h &&
                        ((p) => {
                          for (let g = 0; g < p.length; g++) {
                            const x = p[g];
                            if (x.listener === s && Xc(x.targets, t)) {
                              for (const w in x.delegates)
                                this.off(w, x.delegates[w]);
                              return (p.splice(g, 1), this);
                            }
                          }
                        })(h),
                      this
                    );
                  }
                  queryRenderedFeatures(c, t) {
                    if (!this.style) return [];
                    if (
                      (c === void 0 ||
                        c instanceof r.P ||
                        Array.isArray(c) ||
                        t !== void 0 ||
                        ((t = c), (c = void 0)),
                      (c = c || [
                        [0, 0],
                        [this.transform.width, this.transform.height],
                      ]),
                      !t)
                    ) {
                      const g = this.style.queryRenderedFeatures(
                          c,
                          void 0,
                          this.transform,
                        ),
                        x = this.style.queryRenderedFeatureset(
                          c,
                          void 0,
                          this.transform,
                        );
                      return g.concat(x);
                    }
                    let s = !0;
                    if (
                      t.target &&
                      ((s = this._isTargetValid(t.target)), s && !t.layers)
                    )
                      return this.style.queryRenderedFeatureset(
                        c,
                        t,
                        this.transform,
                      );
                    let h = !0;
                    if (t.layers && Array.isArray(t.layers)) {
                      for (const g of t.layers)
                        if (!this._isValidId(g)) {
                          h = !1;
                          break;
                        }
                      if (h && !t.target)
                        return this.style.queryRenderedFeatures(
                          c,
                          t,
                          this.transform,
                        );
                    }
                    let p = [];
                    return (
                      h &&
                        (p = p.concat(
                          this.style.queryRenderedFeatures(
                            c,
                            t,
                            this.transform,
                          ),
                        )),
                      s &&
                        (p = p.concat(
                          this.style.queryRenderedFeatureset(
                            c,
                            t,
                            this.transform,
                          ),
                        )),
                      p
                    );
                  }
                  querySourceFeatures(c, t) {
                    return !c || (typeof c == "string" && !this._isValidId(c))
                      ? []
                      : this.style.querySourceFeatures(c, t);
                  }
                  isPointOnSurface(c) {
                    const { name: t } = this.transform.projection;
                    return (
                      t !== "globe" &&
                        t !== "mercator" &&
                        r.w(
                          `${t} projection does not support isPointOnSurface, this API may behave unexpectedly.`,
                        ),
                      this.transform.isPointOnSurface(r.P.convert(c))
                    );
                  }
                  addInteraction(c, t) {
                    return (this._interactions.add(c, t), this);
                  }
                  removeInteraction(c) {
                    return (this._interactions.remove(c), this);
                  }
                  getCooperativeGestures() {
                    return this._cooperativeGestures;
                  }
                  setCooperativeGestures(c) {
                    return ((this._cooperativeGestures = c), this);
                  }
                  setStyle(c, t) {
                    return (
                      (t = r.h(
                        {},
                        {
                          localIdeographFontFamily:
                            this._localIdeographFontFamily,
                          localFontFamily: this._localFontFamily,
                        },
                        t,
                      )),
                      this.style &&
                      c &&
                      t.diff !== !1 &&
                      t.localFontFamily === this._localFontFamily &&
                      t.localIdeographFontFamily ===
                        this._localIdeographFontFamily &&
                      !t.config
                        ? (this.style._diffStyle(
                            c,
                            (s, h) => {
                              if (s) {
                                const p =
                                  typeof s == "string"
                                    ? s
                                    : s instanceof Error
                                      ? s.message
                                      : s.error;
                                (r.w(
                                  `Unable to perform style diff: ${p}. Rebuilding the style from scratch.`,
                                ),
                                  this._updateStyle(c, t));
                              } else h && this._update(!0);
                            },
                            () => this._postStyleLoadEvent(),
                          ),
                          this)
                        : ((this._localIdeographFontFamily =
                            t.localIdeographFontFamily),
                          (this._localFontFamily = t.localFontFamily),
                          this._updateStyle(c, t))
                    );
                  }
                  _getUIString(c) {
                    const t = this._locale[c];
                    if (t == null) throw new Error(`Missing UI string '${c}'`);
                    return t;
                  }
                  _updateStyle(c, t) {
                    if (
                      (this.style &&
                        (this.style.setEventedParent(null),
                        this.style._remove(),
                        (this.style = void 0)),
                      c)
                    ) {
                      const s = r.h({}, t);
                      (t &&
                        t.config &&
                        ((s.initialConfig = t.config), delete s.config),
                        (this.style = new Er(this, s).load(c)),
                        this.style.setEventedParent(this, {
                          style: this.style,
                        }));
                    }
                    return (this._updateTerrain(), this);
                  }
                  _lazyInitEmptyStyle() {
                    this.style ||
                      ((this.style = new Er(this, {})),
                      this.style.setEventedParent(this, { style: this.style }),
                      this.style.loadEmpty());
                  }
                  getStyle() {
                    if (this.style) return this.style.serialize();
                  }
                  isStyleLoaded() {
                    return this.style
                      ? this.style.loaded()
                      : (r.w("There is no style added to the map."), !1);
                  }
                  _isValidId(c) {
                    return c == null
                      ? (this.fire(new r.z(new Error("IDs can't be empty."))),
                        !1)
                      : !r.d8(c) ||
                          (this.fire(
                            new r.z(
                              new Error(
                                `IDs can't contain special symbols: "${c}".`,
                              ),
                            ),
                          ),
                          !1);
                  }
                  _isTargetValid(c) {
                    return "featuresetId" in c
                      ? this._isValidId(
                          "importId" in c ? c.importId : c.featuresetId,
                        )
                      : "layerId" in c && this._isValidId(c.layerId);
                  }
                  _areTargetsValid(c) {
                    if (Array.isArray(c)) {
                      for (const t of c) if (!this._isValidId(t)) return !1;
                      return !0;
                    }
                    return this._isTargetValid(c);
                  }
                  addSource(c, t) {
                    return this._isValidId(c)
                      ? (this._lazyInitEmptyStyle(),
                        this.style.addSource(c, t),
                        this._update(!0))
                      : this;
                  }
                  isSourceLoaded(c) {
                    return (
                      !!this._isValidId(c) &&
                      !!this.style &&
                      this.style._isSourceCacheLoaded(c)
                    );
                  }
                  areTilesLoaded() {
                    return this.style.areTilesLoaded();
                  }
                  addSourceType(c, t, s) {
                    (this._lazyInitEmptyStyle(),
                      this.style.addSourceType(c, t, s));
                  }
                  removeSource(c) {
                    return this._isValidId(c)
                      ? (this.style.removeSource(c),
                        this._updateTerrain(),
                        this._update(!0))
                      : this;
                  }
                  getSource(c) {
                    return this._isValidId(c)
                      ? this.style.getOwnSource(c)
                      : null;
                  }
                  addImage(
                    c,
                    t,
                    {
                      pixelRatio: s = 1,
                      sdf: h = !1,
                      stretchX: p,
                      stretchY: g,
                      content: x,
                    } = {},
                  ) {
                    this._lazyInitEmptyStyle();
                    const w = r.I.from(c);
                    if (
                      t instanceof HTMLImageElement ||
                      (ImageBitmap && t instanceof ImageBitmap)
                    ) {
                      const {
                        width: S,
                        height: C,
                        data: D,
                      } = r.q.getImageData(t);
                      this.style.addImage(w, {
                        data: new r.r({ width: S, height: C }, D),
                        pixelRatio: s,
                        stretchX: p,
                        stretchY: g,
                        content: x,
                        sdf: h,
                        version: 0,
                        usvg: !1,
                      });
                    } else if (t.width === void 0 || t.height === void 0)
                      this.fire(
                        new r.z(
                          new Error(
                            "Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`",
                          ),
                        ),
                      );
                    else {
                      const { width: S, height: C } = t,
                        D = t;
                      (this.style.addImage(w, {
                        data: new r.r(
                          { width: S, height: C },
                          new Uint8Array(D.data),
                        ),
                        pixelRatio: s,
                        stretchX: p,
                        stretchY: g,
                        content: x,
                        sdf: h,
                        usvg: !1,
                        version: 0,
                        userImage: D,
                      }),
                        D.onAdd && D.onAdd(this, c));
                    }
                  }
                  updateImage(c, t) {
                    this._lazyInitEmptyStyle();
                    const s = r.I.from(c),
                      h = this.style.getImage(s);
                    if (!h)
                      return void this.fire(
                        new r.z(
                          new Error(
                            "The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.",
                          ),
                        ),
                      );
                    const p =
                        t instanceof HTMLImageElement ||
                        (ImageBitmap && t instanceof ImageBitmap)
                          ? r.q.getImageData(t)
                          : t,
                      { width: g, height: x, data: w } = p;
                    if (g === void 0 || x === void 0)
                      return void this.fire(
                        new r.z(
                          new Error(
                            "Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`",
                          ),
                        ),
                      );
                    if (
                      g !== (h.usvg ? h.icon.usvg_tree.width : h.data.width) ||
                      x !== (h.usvg ? h.icon.usvg_tree.height : h.data.height)
                    )
                      return void this.fire(
                        new r.z(
                          new Error(`The width and height of the updated image (${g}, ${x})
                must be that same as the previous version of the image
                (${h.data.width}, ${h.data.height})`),
                        ),
                      );
                    const S = !(
                      t instanceof HTMLImageElement ||
                      (ImageBitmap && t instanceof ImageBitmap)
                    );
                    let C = !1;
                    (h.usvg
                      ? ((h.data = new r.r(
                          { width: g, height: x },
                          new Uint8Array(w),
                        )),
                        (h.usvg = !1),
                        (h.icon = void 0),
                        (C = !0))
                      : h.data.replace(w, S),
                      this.style.updateImage(s, h, C));
                  }
                  hasImage(c) {
                    return c
                      ? !!this.style && !!this.style.getImage(r.I.from(c))
                      : (this.fire(
                          new r.z(new Error("Missing required image id")),
                        ),
                        !1);
                  }
                  removeImage(c) {
                    this.style.removeImage(r.I.from(c));
                  }
                  loadImage(c, t) {
                    r.o(
                      this._requestManager.transformRequest(c, r.R.Image),
                      (s, h) => {
                        t(
                          s,
                          h instanceof HTMLImageElement
                            ? r.q.getImageData(h)
                            : h,
                        );
                      },
                    );
                  }
                  listImages() {
                    return this.style.listImages().map((c) => c.name);
                  }
                  addModel(c, t) {
                    (this._lazyInitEmptyStyle(), this.style.addModel(c, t));
                  }
                  hasModel(c) {
                    return c
                      ? this.style.hasModel(c)
                      : (this.fire(
                          new r.z(new Error("Missing required model id")),
                        ),
                        !1);
                  }
                  removeModel(c) {
                    this.style.removeModel(c);
                  }
                  listModels() {
                    return this.style.listModels();
                  }
                  addLayer(c, t) {
                    return this._isValidId(c.id)
                      ? (this._lazyInitEmptyStyle(),
                        this.style.addLayer(c, t),
                        this._update(!0))
                      : this;
                  }
                  getSlot(c) {
                    const t = this.getLayer(c);
                    return (t && t.slot) || null;
                  }
                  setSlot(c, t) {
                    return (
                      this.style.setSlot(c, t),
                      this.style.mergeLayers(),
                      this._update(!0)
                    );
                  }
                  addImport(c, t) {
                    return (
                      this.style
                        .addImport(c, t)
                        .catch((s) =>
                          this.fire(
                            new r.z(new Error("Failed to add import", s)),
                          ),
                        ),
                      this
                    );
                  }
                  updateImport(c, t) {
                    return typeof t != "string" && t.id !== c
                      ? (this.removeImport(c), this.addImport(t))
                      : (this.style.updateImport(c, t), this._update(!0));
                  }
                  removeImport(c) {
                    return (this.style.removeImport(c), this);
                  }
                  moveImport(c, t) {
                    return (this.style.moveImport(c, t), this._update(!0));
                  }
                  moveLayer(c, t) {
                    return this._isValidId(c)
                      ? (this.style.moveLayer(c, t), this._update(!0))
                      : this;
                  }
                  removeLayer(c) {
                    return this._isValidId(c)
                      ? (this.style.removeLayer(c), this._update(!0))
                      : this;
                  }
                  getLayer(c) {
                    if (!this._isValidId(c)) return null;
                    const t = this.style.getOwnLayer(c);
                    return t
                      ? t.type === "custom"
                        ? t.implementation
                        : t.serialize()
                      : void 0;
                  }
                  getSlots() {
                    return this.style.getSlots();
                  }
                  setLayerZoomRange(c, t, s) {
                    return this._isValidId(c)
                      ? (this.style.setLayerZoomRange(c, t, s),
                        this._update(!0))
                      : this;
                  }
                  setFilter(c, t, s = {}) {
                    return this._isValidId(c)
                      ? (this.style.setFilter(c, t, s), this._update(!0))
                      : this;
                  }
                  getFilter(c) {
                    return this._isValidId(c) ? this.style.getFilter(c) : null;
                  }
                  setPaintProperty(c, t, s, h = {}) {
                    return this._isValidId(c)
                      ? (this.style.setPaintProperty(c, t, s, h),
                        this._update(!0))
                      : this;
                  }
                  getPaintProperty(c, t) {
                    return this._isValidId(c)
                      ? this.style.getPaintProperty(c, t)
                      : null;
                  }
                  setLayoutProperty(c, t, s, h = {}) {
                    return this._isValidId(c)
                      ? (this.style.setLayoutProperty(c, t, s, h),
                        this._update(!0))
                      : this;
                  }
                  getLayoutProperty(c, t) {
                    return this._isValidId(c)
                      ? this.style.getLayoutProperty(c, t)
                      : null;
                  }
                  getGlyphsUrl() {
                    return this.style.getGlyphsUrl();
                  }
                  setGlyphsUrl(c) {
                    return (this.style.setGlyphsUrl(c), this._update(!0));
                  }
                  getSchema(c) {
                    return this.style.getSchema(c);
                  }
                  setSchema(c, t) {
                    return (this.style.setSchema(c, t), this._update(!0));
                  }
                  getConfig(c) {
                    return this.style.getConfig(c);
                  }
                  setConfig(c, t) {
                    return (this.style.setConfig(c, t), this._update(!0));
                  }
                  getConfigProperty(c, t) {
                    return this.style.getConfigProperty(c, t);
                  }
                  setConfigProperty(c, t, s) {
                    return (
                      this.style.setConfigProperty(c, t, s),
                      this._update(!0)
                    );
                  }
                  getFeaturesetDescriptors(c) {
                    return this.style.getFeaturesetDescriptors(c);
                  }
                  setLights(c) {
                    if (
                      (this._lazyInitEmptyStyle(),
                      c && c.length === 1 && c[0].type === "flat")
                    ) {
                      const t = c[0];
                      t.properties
                        ? this.style.setFlatLight(t.properties, t.id, {})
                        : this.style.setFlatLight({}, "flat");
                    } else
                      (this.style.setLights(c),
                        this.painter.terrain &&
                          (this.painter.terrain.invalidateRenderCache = !0));
                    return this._update(!0);
                  }
                  getLights() {
                    const c = this.style.getLights() || [];
                    return (
                      c.length === 0 &&
                        c.push({
                          id: this.style.light.id,
                          type: "flat",
                          properties: this.style.getFlatLight(),
                        }),
                      c
                    );
                  }
                  setLight(c, t = {}) {
                    return (
                      console.log(
                        "The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead.",
                      ),
                      this.setLights([
                        { id: "flat", type: "flat", properties: c },
                      ])
                    );
                  }
                  getLight() {
                    return (
                      console.log(
                        "The `map.getLight` function is deprecated, prefer using `map.getLights` instead.",
                      ),
                      this.style.getFlatLight()
                    );
                  }
                  setTerrain(c) {
                    return (
                      this._lazyInitEmptyStyle(),
                      !c && this.transform.projection.requiresDraping
                        ? this.style.setTerrainForDraping()
                        : this.style.setTerrain(c),
                      (this._averageElevationLastSampledAt = -1 / 0),
                      this._update(!0)
                    );
                  }
                  getTerrain() {
                    return this.style ? this.style.getTerrain() : null;
                  }
                  setFog(c) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.setFog(c),
                      this._update(!0)
                    );
                  }
                  getFog() {
                    return this.style ? this.style.getFog() : null;
                  }
                  setSnow(c) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.setSnow(c),
                      this._update(!0)
                    );
                  }
                  getSnow() {
                    return this.style ? this.style.getSnow() : null;
                  }
                  setRain(c) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.setRain(c),
                      this._update(!0)
                    );
                  }
                  getRain() {
                    return this.style ? this.style.getRain() : null;
                  }
                  setColorTheme(c) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.setColorTheme(c),
                      this._update(!0)
                    );
                  }
                  setImportColorTheme(c, t) {
                    return (
                      this._lazyInitEmptyStyle(),
                      this.style.setImportColorTheme(c, t),
                      this._update(!0)
                    );
                  }
                  setCamera(c) {
                    return (
                      this.style.setCamera(c),
                      this._triggerCameraUpdate(c)
                    );
                  }
                  _triggerCameraUpdate(c) {
                    return this._update(
                      this.transform.setOrthographicProjectionAtLowPitch(
                        c["camera-projection"] === "orthographic",
                      ),
                    );
                  }
                  getCamera() {
                    return this.style.camera;
                  }
                  _queryFogOpacity(c) {
                    return this.style && this.style.fog
                      ? this.style.fog.getOpacityAtLatLng(
                          r.cd.convert(c),
                          this.transform,
                        )
                      : 0;
                  }
                  setFeatureState(c, t) {
                    return c.source && !this._isValidId(c.source)
                      ? this
                      : (this.style.setFeatureState(c, t), this._update());
                  }
                  removeFeatureState(c, t) {
                    return c.source && !this._isValidId(c.source)
                      ? this
                      : (this.style.removeFeatureState(c, t), this._update());
                  }
                  getFeatureState(c) {
                    return c.source && !this._isValidId(c.source)
                      ? null
                      : this.style.getFeatureState(c);
                  }
                  _updateContainerDimensions() {
                    if (!this._container) return;
                    const c =
                        this._container.getBoundingClientRect().width || 400,
                      t = this._container.getBoundingClientRect().height || 300;
                    let s,
                      h,
                      p,
                      g = this._container;
                    for (; g && (!h || !p); ) {
                      const x = window.getComputedStyle(g).transform;
                      (x &&
                        x !== "none" &&
                        ((s = x.match(/matrix.*\((.+)\)/)[1].split(", ")),
                        s[0] && s[0] !== "0" && s[0] !== "1" && (h = s[0]),
                        s[3] && s[3] !== "0" && s[3] !== "1" && (p = s[3])),
                        (g = g.parentElement));
                    }
                    ((this._containerWidth = h ? Math.abs(c / h) : c),
                      (this._containerHeight = p ? Math.abs(t / p) : t));
                  }
                  _detectMissingCSS() {
                    window
                      .getComputedStyle(this._missingCSSCanary)
                      .getPropertyValue("background-color") !==
                      "rgb(250, 128, 114)" &&
                      r.w(
                        "This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.",
                      );
                  }
                  _setupContainer() {
                    const c = this._container;
                    (c.classList.add("mapboxgl-map"),
                      ((this._missingCSSCanary = xe(
                        "div",
                        "mapboxgl-canary",
                        c,
                      )).style.visibility = "hidden"),
                      this._detectMissingCSS());
                    const t = (this._canvasContainer = xe(
                      "div",
                      "mapboxgl-canvas-container",
                      c,
                    ));
                    ((this._canvas = xe("canvas", "mapboxgl-canvas", t)),
                      this._interactive &&
                        (t.classList.add("mapboxgl-interactive"),
                        this._canvas.setAttribute("tabindex", "0")),
                      this._canvas.addEventListener(
                        "webglcontextlost",
                        this._contextLost,
                        !1,
                      ),
                      this._canvas.addEventListener(
                        "webglcontextrestored",
                        this._contextRestored,
                        !1,
                      ),
                      this._canvas.setAttribute(
                        "aria-label",
                        this._getUIString("Map.Title"),
                      ),
                      this._canvas.setAttribute("role", "region"),
                      this._updateContainerDimensions(),
                      this._resizeCanvas(
                        this._containerWidth,
                        this._containerHeight,
                      ));
                    const s = (this._controlContainer = xe(
                        "div",
                        "mapboxgl-control-container",
                        c,
                      )),
                      h = (this._controlPositions = {});
                    ([
                      "top-left",
                      "top",
                      "top-right",
                      "right",
                      "bottom-right",
                      "bottom",
                      "bottom-left",
                      "left",
                    ].forEach((p) => {
                      h[p] = xe("div", `mapboxgl-ctrl-${p}`, s);
                    }),
                      this._container.addEventListener(
                        "scroll",
                        this._onMapScroll,
                        !1,
                      ));
                  }
                  _resizeCanvas(c, t) {
                    const s = r.q.devicePixelRatio || 1;
                    ((this._canvas.width = s * Math.ceil(c)),
                      (this._canvas.height = s * Math.ceil(t)),
                      (this._canvas.style.width = `${c}px`),
                      (this._canvas.style.height = `${t}px`));
                  }
                  _addMarker(c) {
                    this._markers.push(c);
                  }
                  _removeMarker(c) {
                    const t = this._markers.indexOf(c);
                    t !== -1 && this._markers.splice(t, 1);
                  }
                  _addPopup(c) {
                    this._popups.push(c);
                  }
                  _removePopup(c) {
                    const t = this._popups.indexOf(c);
                    t !== -1 && this._popups.splice(t, 1);
                  }
                  _setupPainter() {
                    const c = r.h({}, Ie.supported.webGLContextAttributes, {
                        failIfMajorPerformanceCaveat:
                          this._failIfMajorPerformanceCaveat,
                        preserveDrawingBuffer: this._preserveDrawingBuffer,
                        antialias: this._antialias || !1,
                      }),
                      t = this._canvas.getContext("webgl2", c);
                    t
                      ? (Is(t, !0),
                        (this.painter = new Il(
                          t,
                          this._contextCreateOptions,
                          this.transform,
                          this._scaleFactor,
                          this._tp,
                          this._worldview,
                        )),
                        this.on("data", (s) => {
                          s.dataType === "source" &&
                            this.painter.setTileLoadedFlag(!0);
                        }),
                        r.l.testSupport(t))
                      : this.fire(
                          new r.z(new Error("Failed to initialize WebGL")),
                        );
                  }
                  _contextLost(c) {
                    (c.preventDefault(),
                      this._frame &&
                        (this._frame.cancel(), (this._frame = null)),
                      this.fire(
                        new r.A("webglcontextlost", { originalEvent: c }),
                      ));
                  }
                  _contextRestored(c) {
                    (this._setupPainter(),
                      this.painter.resize(
                        Math.ceil(this._containerWidth),
                        Math.ceil(this._containerHeight),
                      ),
                      this._updateTerrain(),
                      this.style &&
                        (this.style.reloadModels(), this.style.clearSources()),
                      this._update(),
                      this.fire(
                        new r.A("webglcontextrestored", { originalEvent: c }),
                      ));
                  }
                  _onMapScroll(c) {
                    if (c.target === this._container)
                      return (
                        (this._container.scrollTop = 0),
                        (this._container.scrollLeft = 0),
                        !1
                      );
                  }
                  idle() {
                    return !this.isMoving() && this.loaded();
                  }
                  loaded() {
                    return (
                      !this._styleDirty &&
                      !this._sourcesDirty &&
                      !!this.style &&
                      this.style.loaded()
                    );
                  }
                  frameReady() {
                    return this.loaded() && !this._placementDirty;
                  }
                  _update(c) {
                    return this.style
                      ? ((this._styleDirty = this._styleDirty || c),
                        (this._sourcesDirty = !0),
                        this.triggerRepaint(),
                        this)
                      : this;
                  }
                  _requestRenderFrame(c) {
                    return (this._update(), this._renderTaskQueue.add(c));
                  }
                  _cancelRenderFrame(c) {
                    this._renderTaskQueue.remove(c);
                  }
                  _requestDomTask(c) {
                    !this.loaded() || (this.loaded() && !this.isMoving())
                      ? c()
                      : this._domRenderTaskQueue.add(c);
                  }
                  _render(c) {
                    let t;
                    (this.fire(new r.A("renderstart")), ++this._frameId);
                    const s = this.painter.context.extTimerQuery,
                      h = r.q.now(),
                      p = this.painter.context.gl;
                    if (
                      (this.listens("gpu-timing-frame") &&
                        ((t = p.createQuery()),
                        p.beginQuery(s.TIME_ELAPSED_EXT, t)),
                      this.painter.context.setDirty(),
                      this.painter.setBaseState(),
                      (this.isMoving() ||
                        this.isRotating() ||
                        this.isZooming()) &&
                        ((this._interactionRange[0] = Math.min(
                          this._interactionRange[0],
                          performance.now(),
                        )),
                        (this._interactionRange[1] = Math.max(
                          this._interactionRange[1],
                          performance.now(),
                        ))),
                      this._renderTaskQueue.run(c),
                      this._domRenderTaskQueue.run(c),
                      this._removed)
                    )
                      return;
                    this._updateProjectionTransition();
                    const g = this._isInitialLoad ? 0 : this._fadeDuration;
                    if (this.style && this._styleDirty) {
                      this._styleDirty = !1;
                      const C = this.transform.zoom,
                        D = this.transform.pitch,
                        L = r.q.now(),
                        z = new r.aa(C, {
                          now: L,
                          fadeDuration: g,
                          pitch: D,
                          transition: this.style.transition,
                          worldview: this._worldview,
                        });
                      this.style.update(z);
                    }
                    this.style &&
                      this.style.hasFogTransition() &&
                      ((this.style._markersNeedUpdate = !0),
                      (this._sourcesDirty = !0));
                    let x = !1;
                    this.style && this._sourcesDirty
                      ? ((this._sourcesDirty = !1),
                        this.painter._updateFog(this.style),
                        this._updateTerrain(),
                        (x = this._updateAverageElevation(h)),
                        this.style.updateSources(this.transform),
                        this.style.updateImageProviders(),
                        this.isMoving() || this._forceMarkerAndPopupUpdate())
                      : (x = this._updateAverageElevation(h));
                    const w =
                      this.style &&
                      this.style._updatePlacement(
                        this.painter,
                        this.painter.transform,
                        this.showCollisionBoxes,
                        g,
                        this._crossSourceCollisions,
                        this.painter.replacementSource,
                        this._scaleFactorChanged,
                      );
                    if (
                      (this._scaleFactorChanged &&
                        (this._scaleFactorChanged = !1),
                      w && (this._placementDirty = w.needsRerender),
                      this.style &&
                        this.painter.render(this.style, {
                          showTileBoundaries: this.showTileBoundaries,
                          showParseStatus: this.showParseStatus,
                          wireframe: {
                            terrain: this.showTerrainWireframe,
                            layers2D: this.showLayers2DWireframe,
                            layers3D: this.showLayers3DWireframe,
                          },
                          showOverdrawInspector: this._showOverdrawInspector,
                          showQueryGeometry: !!this._showQueryGeometry,
                          showTileAABBs: this.showTileAABBs,
                          rotating: this.isRotating(),
                          zooming: this.isZooming(),
                          moving: this.isMoving(),
                          fadeDuration: g,
                          isInitialLoad: this._isInitialLoad,
                          showPadding: this.showPadding,
                          gpuTiming: !!this.listens("gpu-timing-layer"),
                          gpuTimingDeferredRender: !!this.listens(
                            "gpu-timing-deferred-render",
                          ),
                          speedIndexTiming: this.speedIndexTiming,
                        }),
                      this.fire(new r.A("render")),
                      this.loaded() &&
                        !this._loaded &&
                        ((this._loaded = !0),
                        q.mark(B.load),
                        this.fire(new r.A("load"))),
                      this.style &&
                        this.style.hasTransitions() &&
                        (this._styleDirty = !0),
                      this.style &&
                        (this.style.snow || this.style.rain) &&
                        (this._styleDirty = !0),
                      this.style &&
                        this.style.imageManager.hasPatternsInFlight() &&
                        (this._styleDirty = !0),
                      this.style &&
                        !this.style.modelManager.isLoaded() &&
                        (this._styleDirty = !0),
                      this.style &&
                        !this._placementDirty &&
                        this.style._releaseSymbolFadeTiles(),
                      t)
                    ) {
                      const C = r.q.now() - h;
                      (p.endQuery(s.TIME_ELAPSED_EXT),
                        setTimeout(() => {
                          const D =
                            p.getQueryParameter(t, p.QUERY_RESULT) / 1e6;
                          (p.deleteQuery(t),
                            this.fire(
                              new r.A("gpu-timing-frame", {
                                cpuTime: C,
                                gpuTime: D,
                              }),
                            ));
                        }, 50));
                    }
                    if (this.listens("gpu-timing-layer")) {
                      const C = this.painter.collectGpuTimers();
                      setTimeout(() => {
                        const D = this.painter.queryGpuTimers(C);
                        this.fire(
                          new r.A("gpu-timing-layer", { layerTimes: D }),
                        );
                      }, 50);
                    }
                    if (this.listens("gpu-timing-deferred-render")) {
                      const C = this.painter.collectDeferredRenderGpuQueries();
                      setTimeout(() => {
                        const D = this.painter.queryGpuTimeDeferredRender(C);
                        this.fire(
                          new r.A("gpu-timing-deferred-render", { gpuTime: D }),
                        );
                      }, 50);
                    }
                    const S =
                      this._sourcesDirty ||
                      this._styleDirty ||
                      this._placementDirty ||
                      x;
                    if (S || this._repaint) this.triggerRepaint();
                    else {
                      const C = this.idle();
                      if ((C && (x = this._updateAverageElevation(h, !0)), x))
                        this.triggerRepaint();
                      else if (
                        (this._triggerFrame(!1),
                        C &&
                          (this.fire(new r.A("idle")),
                          (this._isInitialLoad = !1),
                          this.speedIndexTiming))
                      ) {
                        const D = this._calculateSpeedIndex();
                        (this.fire(
                          new r.A("speedindexcompleted", { speedIndex: D }),
                        ),
                          (this.speedIndexTiming = !1));
                      }
                    }
                    !this._loaded ||
                      this._fullyLoaded ||
                      S ||
                      ((this._fullyLoaded = !0),
                      q.mark(B.fullLoad),
                      this._performanceMetricsCollection &&
                        ps(this._requestManager._customAccessToken, {
                          width: this.painter.width,
                          height: this.painter.height,
                          interactionRange: this._interactionRange,
                          visibilityHidden: this._visibilityHidden,
                          terrainEnabled: !!this.painter.style.getTerrain(),
                          fogEnabled: !!this.painter.style.getFog(),
                          projection: this.getProjection().name,
                          zoom: this.transform.zoom,
                          renderer: this.painter.context.renderer,
                          vendor: this.painter.context.vendor,
                        }),
                      this._authenticate());
                  }
                  _forceMarkerAndPopupUpdate(c) {
                    for (const t of this._markers)
                      (c &&
                        !this.getRenderWorldCopies() &&
                        (t._lngLat = t._lngLat.wrap()),
                        t._update());
                    for (const t of this._popups)
                      (!c ||
                        this.getRenderWorldCopies() ||
                        t._trackPointer ||
                        (t._lngLat = t._lngLat.wrap()),
                        t._update());
                  }
                  _updateAverageElevation(c, t = !1) {
                    const s = (p) => (
                      (this.transform.averageElevation = p),
                      this._update(!1),
                      !0
                    );
                    if (!this.painter.averageElevationNeedsEasing())
                      return this.transform.averageElevation !== 0 && s(0);
                    const h =
                      this.transform.elevation &&
                      this.transform.elevation.exaggeration() !==
                        this._averageElevationExaggeration;
                    if (
                      h ||
                      ((t || c - this._averageElevationLastSampledAt > 500) &&
                        !this._averageElevation.isEasing(c))
                    ) {
                      const p = this.transform.averageElevation;
                      let g = this.transform.sampleAverageElevation();
                      (this.transform.elevation != null &&
                        (this._averageElevationExaggeration =
                          this.transform.elevation.exaggeration()),
                        isNaN(g)
                          ? (g = 0)
                          : (this._averageElevationLastSampledAt = c));
                      const x = Math.abs(p - g);
                      if (x > 1) {
                        if (this._isInitialLoad || h)
                          return (this._averageElevation.jumpTo(g), s(g));
                        this._averageElevation.easeTo(g, c, 300);
                      } else if (x > 1e-4)
                        return (this._averageElevation.jumpTo(g), s(g));
                    }
                    return (
                      !!this._averageElevation.isEasing(c) &&
                      s(this._averageElevation.getValue(c))
                    );
                  }
                  _authenticate() {
                    (Za(
                      this._getMapId(),
                      this._requestManager._skuToken,
                      this._requestManager._customAccessToken,
                      (c) => {
                        if (c && (c.message === Ri || c.status === 401)) {
                          const t = this.painter.context.gl;
                          (Is(t, !1),
                            this._logoControl instanceof bu &&
                              this._logoControl._updateLogo(),
                            t &&
                              t.clear(
                                t.DEPTH_BUFFER_BIT |
                                  t.COLOR_BUFFER_BIT |
                                  t.STENCIL_BUFFER_BIT,
                              ),
                            this._silenceAuthErrors ||
                              this.fire(
                                new r.z(
                                  new Error(
                                    "A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/",
                                  ),
                                ),
                              ));
                        }
                      },
                    ),
                      qr(
                        this._getMapId(),
                        this._requestManager._skuToken,
                        this._requestManager._customAccessToken,
                        () => {},
                      ));
                  }
                  _postStyleLoadEvent() {
                    this.style.globalId &&
                      wn(this._requestManager._customAccessToken, {
                        map: this,
                        style: this.style.globalId,
                        importedStyles: this.style.getImportGlobalIds(),
                      });
                  }
                  _updateTerrain() {
                    const c = this._isDragging();
                    this.painter.updateTerrain(this.style, c);
                  }
                  _calculateSpeedIndex() {
                    const c = this.painter.canvasCopy(),
                      t = this.painter.getCanvasCopiesAndTimestamps();
                    t.timeStamps.push(performance.now());
                    const s = this.painter.context.gl,
                      h = s.createFramebuffer();
                    function p(g) {
                      s.framebufferTexture2D(
                        s.FRAMEBUFFER,
                        s.COLOR_ATTACHMENT0,
                        s.TEXTURE_2D,
                        g,
                        0,
                      );
                      const x = new Uint8Array(
                        s.drawingBufferWidth * s.drawingBufferHeight * 4,
                      );
                      return (
                        s.readPixels(
                          0,
                          0,
                          s.drawingBufferWidth,
                          s.drawingBufferHeight,
                          s.RGBA,
                          s.UNSIGNED_BYTE,
                          x,
                        ),
                        x
                      );
                    }
                    return (
                      s.bindFramebuffer(s.FRAMEBUFFER, h),
                      this._canvasPixelComparison(
                        p(c),
                        t.canvasCopies.map(p),
                        t.timeStamps,
                      )
                    );
                  }
                  _canvasPixelComparison(c, t, s) {
                    let h = s[1] - s[0];
                    const p = c.length / 4;
                    for (let g = 0; g < t.length; g++) {
                      const x = t[g];
                      let w = 0;
                      for (let S = 0; S < x.length; S += 4)
                        x[S] === c[S] &&
                          x[S + 1] === c[S + 1] &&
                          x[S + 2] === c[S + 2] &&
                          x[S + 3] === c[S + 3] &&
                          (w += 1);
                      h += (s[g + 2] - s[g + 1]) * (1 - w / p);
                    }
                    return h;
                  }
                  remove() {
                    this._hash && this._hash.remove();
                    for (const t of this._controls) t.onRemove(this);
                    ((this._controls = []),
                      this._frame &&
                        (this._frame.cancel(), (this._frame = null)),
                      this._renderTaskQueue.clear(),
                      this._domRenderTaskQueue.clear(),
                      this.style && this.style.destroy(),
                      this.indoor.destroy(),
                      this.painter.destroy(),
                      this.handlers && this.handlers.destroy(),
                      (this.handlers = void 0),
                      this.setStyle(null),
                      window.removeEventListener(
                        "resize",
                        this._onWindowResize,
                        !1,
                      ),
                      window.removeEventListener(
                        "orientationchange",
                        this._onWindowResize,
                        !1,
                      ),
                      window.removeEventListener(
                        this._fullscreenchangeEvent,
                        this._onWindowResize,
                        !1,
                      ),
                      window.removeEventListener(
                        "online",
                        this._onWindowOnline,
                        !1,
                      ),
                      window.removeEventListener(
                        "visibilitychange",
                        this._onVisibilityChange,
                        !1,
                      ));
                    const c =
                      this.painter.context.gl.getExtension(
                        "WEBGL_lose_context",
                      );
                    (c && c.loseContext(),
                      this._canvas.removeEventListener(
                        "webglcontextlost",
                        this._contextLost,
                        !1,
                      ),
                      this._canvas.removeEventListener(
                        "webglcontextrestored",
                        this._contextRestored,
                        !1,
                      ),
                      this._canvasContainer.remove(),
                      this._controlContainer.remove(),
                      this._missingCSSCanary.remove(),
                      (this._canvas = void 0),
                      (this._canvasContainer = void 0),
                      (this._controlContainer = void 0),
                      (this._missingCSSCanary = void 0),
                      this._container.classList.remove("mapboxgl-map"),
                      this._container.removeEventListener(
                        "scroll",
                        this._onMapScroll,
                        !1,
                      ),
                      Qs.delete(this.painter.context.gl),
                      mn.remove(),
                      fs.remove(),
                      (this._removed = !0),
                      this.fire(new r.A("remove")));
                  }
                  triggerRepaint() {
                    this._triggerFrame(!0);
                  }
                  _triggerFrame(c) {
                    ((this._renderNextFrame = this._renderNextFrame || c),
                      this.style &&
                        !this._frame &&
                        (this._frame = r.q.frame((t) => {
                          const s = !!this._renderNextFrame;
                          ((this._frame = null),
                            (this._renderNextFrame = null),
                            s && this._render(t));
                        })));
                  }
                  _preloadTiles(c) {
                    const t = this.style ? this.style.getSourceCaches() : [];
                    return (
                      r.bt(
                        t,
                        (s, h) => s._preloadTiles(c, h),
                        () => {
                          this.triggerRepaint();
                        },
                      ),
                      this
                    );
                  }
                  _onWindowOnline() {
                    this._update();
                  }
                  _onWindowResize(c) {
                    this._trackResize &&
                      this.resize({ originalEvent: c })._update();
                  }
                  _onVisibilityChange() {
                    document.visibilityState === "hidden" &&
                      this._visibilityHidden++;
                  }
                  get showTileBoundaries() {
                    return !!this._showTileBoundaries;
                  }
                  set showTileBoundaries(c) {
                    this._showTileBoundaries !== c &&
                      ((this._showTileBoundaries = c),
                      this._tp.refreshUI(),
                      this._update());
                  }
                  get showParseStatus() {
                    return !!this._showParseStatus;
                  }
                  set showParseStatus(c) {
                    this._showParseStatus !== c &&
                      ((this._showParseStatus = c),
                      this._tp.refreshUI(),
                      this._update());
                  }
                  get showTerrainWireframe() {
                    return !!this._showTerrainWireframe;
                  }
                  set showTerrainWireframe(c) {
                    this._showTerrainWireframe !== c &&
                      ((this._showTerrainWireframe = c),
                      this._tp.refreshUI(),
                      this._update());
                  }
                  get showLayers2DWireframe() {
                    return !!this._showLayers2DWireframe;
                  }
                  set showLayers2DWireframe(c) {
                    this._showLayers2DWireframe !== c &&
                      ((this._showLayers2DWireframe = c),
                      this._tp.refreshUI(),
                      this._update());
                  }
                  get showLayers3DWireframe() {
                    return !!this._showLayers3DWireframe;
                  }
                  set showLayers3DWireframe(c) {
                    this._showLayers3DWireframe !== c &&
                      ((this._showLayers3DWireframe = c),
                      this._tp.refreshUI(),
                      this._update());
                  }
                  get speedIndexTiming() {
                    return !!this._speedIndexTiming;
                  }
                  set speedIndexTiming(c) {
                    this._speedIndexTiming !== c &&
                      ((this._speedIndexTiming = c), this._update());
                  }
                  get showPadding() {
                    return !!this._showPadding;
                  }
                  set showPadding(c) {
                    this._showPadding !== c &&
                      ((this._showPadding = c),
                      this._tp.refreshUI(),
                      this._update());
                  }
                  get showCollisionBoxes() {
                    return !!this._showCollisionBoxes;
                  }
                  set showCollisionBoxes(c) {
                    this._showCollisionBoxes !== c &&
                      ((this._showCollisionBoxes = c),
                      this._tp.refreshUI(),
                      c
                        ? this.style._generateCollisionBoxes()
                        : this._update());
                  }
                  get showOverdrawInspector() {
                    return !!this._showOverdrawInspector;
                  }
                  set showOverdrawInspector(c) {
                    this._showOverdrawInspector !== c &&
                      ((this._showOverdrawInspector = c),
                      this._tp.refreshUI(),
                      this._update());
                  }
                  get repaint() {
                    return !!this._repaint;
                  }
                  set repaint(c) {
                    this._repaint !== c &&
                      ((this._repaint = c),
                      this._tp.refreshUI(),
                      this.triggerRepaint());
                  }
                  get vertices() {
                    return !!this._vertices;
                  }
                  set vertices(c) {
                    ((this._vertices = c), this._update());
                  }
                  get showTileAABBs() {
                    return !!this._showTileAABBs;
                  }
                  set showTileAABBs(c) {
                    this._showTileAABBs !== c &&
                      ((this._showTileAABBs = c),
                      this._tp.refreshUI(),
                      c && this._update());
                  }
                  _setCacheLimits(c, t) {
                    r.eJ(c, t);
                  }
                  get version() {
                    return F;
                  }
                },
                NavigationControl: class {
                  constructor(c = {}) {
                    ((this.options = r.h({}, wm, c)),
                      (this._container = xe(
                        "div",
                        "mapboxgl-ctrl mapboxgl-ctrl-group",
                      )),
                      this._container.addEventListener("contextmenu", (t) =>
                        t.preventDefault(),
                      ),
                      this.options.showZoom &&
                        (r.aV(["_setButtonTitle", "_updateZoomButtons"], this),
                        (this._zoomInButton = this._createButton(
                          "mapboxgl-ctrl-zoom-in",
                          (t) => {
                            this._map &&
                              this._map.zoomIn({}, { originalEvent: t });
                          },
                        )),
                        xe(
                          "span",
                          "mapboxgl-ctrl-icon",
                          this._zoomInButton,
                        ).setAttribute("aria-hidden", "true"),
                        (this._zoomOutButton = this._createButton(
                          "mapboxgl-ctrl-zoom-out",
                          (t) => {
                            this._map &&
                              this._map.zoomOut({}, { originalEvent: t });
                          },
                        )),
                        xe(
                          "span",
                          "mapboxgl-ctrl-icon",
                          this._zoomOutButton,
                        ).setAttribute("aria-hidden", "true")),
                      this.options.showCompass &&
                        (r.aV(["_rotateCompassArrow"], this),
                        (this._compass = this._createButton(
                          "mapboxgl-ctrl-compass",
                          (t) => {
                            const s = this._map;
                            s &&
                              (this.options.visualizePitch
                                ? s.resetNorthPitch({}, { originalEvent: t })
                                : s.resetNorth({}, { originalEvent: t }));
                          },
                        )),
                        (this._compassIcon = xe(
                          "span",
                          "mapboxgl-ctrl-icon",
                          this._compass,
                        )),
                        this._compassIcon.setAttribute("aria-hidden", "true")));
                  }
                  _updateZoomButtons() {
                    const c = this._map;
                    if (!c) return;
                    const t = c.getZoom(),
                      s = t === c.getMaxZoom(),
                      h = t === c.getMinZoom();
                    ((this._zoomInButton.disabled = s),
                      (this._zoomOutButton.disabled = h),
                      this._zoomInButton.setAttribute(
                        "aria-disabled",
                        s.toString(),
                      ),
                      this._zoomOutButton.setAttribute(
                        "aria-disabled",
                        h.toString(),
                      ));
                  }
                  _rotateCompassArrow() {
                    const c = this._map;
                    if (!c) return;
                    const t = this.options.visualizePitch
                      ? `scale(${1 / Math.pow(Math.cos(c.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${c.transform.pitch}deg) rotateZ(${c.transform.angle * (180 / Math.PI)}deg)`
                      : `rotate(${c.transform.angle * (180 / Math.PI)}deg)`;
                    c._requestDomTask(() => {
                      this._compassIcon &&
                        (this._compassIcon.style.transform = t);
                    });
                  }
                  onAdd(c) {
                    return (
                      (this._map = c),
                      this.options.showZoom &&
                        (this._setButtonTitle(this._zoomInButton, "ZoomIn"),
                        this._setButtonTitle(this._zoomOutButton, "ZoomOut"),
                        c.on("zoom", this._updateZoomButtons),
                        this._updateZoomButtons()),
                      this.options.showCompass &&
                        (this._setButtonTitle(this._compass, "ResetBearing"),
                        this.options.visualizePitch &&
                          c.on("pitch", this._rotateCompassArrow),
                        c.on("rotate", this._rotateCompassArrow),
                        this._rotateCompassArrow(),
                        (this._handler = new W_(
                          c,
                          this._compass,
                          this.options.visualizePitch,
                        ))),
                      this._container
                    );
                  }
                  onRemove() {
                    const c = this._map;
                    c &&
                      (this._container.remove(),
                      this.options.showZoom &&
                        c.off("zoom", this._updateZoomButtons),
                      this.options.showCompass &&
                        (this.options.visualizePitch &&
                          c.off("pitch", this._rotateCompassArrow),
                        c.off("rotate", this._rotateCompassArrow),
                        this._handler && this._handler.off(),
                        (this._handler = void 0)),
                      (this._map = void 0));
                  }
                  _createButton(c, t) {
                    const s = xe("button", c, this._container);
                    return (
                      (s.type = "button"),
                      s.addEventListener("click", t),
                      s
                    );
                  }
                  _setButtonTitle(c, t) {
                    if (!this._map) return;
                    const s = this._map._getUIString(`NavigationControl.${t}`);
                    (c.setAttribute("aria-label", s),
                      c.firstElementChild &&
                        c.firstElementChild.setAttribute("title", s));
                  }
                },
                GeolocateControl: class extends r.E {
                  constructor(c = {}) {
                    super();
                    const t = navigator.geolocation;
                    ((this.options = r.h({ geolocation: t }, of, c)),
                      r.aV(
                        [
                          "_onSuccess",
                          "_onError",
                          "_onZoom",
                          "_finish",
                          "_setupUI",
                          "_updateCamera",
                          "_updateMarker",
                          "_updateMarkerRotation",
                          "_onDeviceOrientation",
                        ],
                        this,
                      ),
                      (this._updateMarkerRotationThrottled = Go(
                        this._updateMarkerRotation,
                        20,
                      )),
                      (this._numberOfWatches = 0));
                  }
                  onAdd(c) {
                    return (
                      (this._map = c),
                      (this._container = xe(
                        "div",
                        "mapboxgl-ctrl mapboxgl-ctrl-group",
                      )),
                      this._checkGeolocationSupport(this._setupUI),
                      this._container
                    );
                  }
                  onRemove() {
                    (this._geolocationWatchID !== void 0 &&
                      (this.options.geolocation.clearWatch(
                        this._geolocationWatchID,
                      ),
                      (this._geolocationWatchID = void 0)),
                      this.options.showUserLocation &&
                        this._userLocationDotMarker &&
                        this._userLocationDotMarker.remove(),
                      this.options.showAccuracyCircle &&
                        this._accuracyCircleMarker &&
                        this._accuracyCircleMarker.remove(),
                      this._container.remove(),
                      this._map.off("zoom", this._onZoom),
                      (this._map = void 0),
                      (this._numberOfWatches = 0),
                      (this._noTimeout = !1));
                  }
                  _checkGeolocationSupport(c) {
                    const t = (s = !!this.options.geolocation) => {
                      ((this._supportsGeolocation = s), c(s));
                    };
                    this._supportsGeolocation !== void 0
                      ? c(this._supportsGeolocation)
                      : navigator.permissions !== void 0
                        ? navigator.permissions
                            .query({ name: "geolocation" })
                            .then((s) => t(s.state !== "denied"))
                            .catch(() => t())
                        : t();
                  }
                  _isOutOfMapMaxBounds(c) {
                    const t = this._map.getMaxBounds(),
                      s = c.coords;
                    return (
                      !!t &&
                      (s.longitude < t.getWest() ||
                        s.longitude > t.getEast() ||
                        s.latitude < t.getSouth() ||
                        s.latitude > t.getNorth())
                    );
                  }
                  _setErrorState() {
                    switch (this._watchState) {
                      case "WAITING_ACTIVE":
                        ((this._watchState = "ACTIVE_ERROR"),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-active",
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-active-error",
                          ));
                        break;
                      case "ACTIVE_LOCK":
                        ((this._watchState = "ACTIVE_ERROR"),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-active",
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-active-error",
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting",
                          ));
                        break;
                      case "BACKGROUND":
                        ((this._watchState = "BACKGROUND_ERROR"),
                          this._geolocateButton.classList.remove(
                            "mapboxgl-ctrl-geolocate-background",
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-background-error",
                          ),
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting",
                          ));
                    }
                  }
                  _onSuccess(c) {
                    if (this._map) {
                      if (this._isOutOfMapMaxBounds(c))
                        return (
                          this._setErrorState(),
                          this.fire(new r.A("outofmaxbounds", c)),
                          this._updateMarker(),
                          void this._finish()
                        );
                      if (this.options.trackUserLocation)
                        switch (
                          ((this._lastKnownPosition = c), this._watchState)
                        ) {
                          case "WAITING_ACTIVE":
                          case "ACTIVE_LOCK":
                          case "ACTIVE_ERROR":
                            ((this._watchState = "ACTIVE_LOCK"),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-waiting",
                              ),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-active-error",
                              ),
                              this._geolocateButton.classList.add(
                                "mapboxgl-ctrl-geolocate-active",
                              ));
                            break;
                          case "BACKGROUND":
                          case "BACKGROUND_ERROR":
                            ((this._watchState = "BACKGROUND"),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-waiting",
                              ),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-background-error",
                              ),
                              this._geolocateButton.classList.add(
                                "mapboxgl-ctrl-geolocate-background",
                              ));
                        }
                      (this.options.showUserLocation &&
                        this._watchState !== "OFF" &&
                        this._updateMarker(c),
                        (this.options.trackUserLocation &&
                          this._watchState !== "ACTIVE_LOCK") ||
                          this._updateCamera(c),
                        this.options.showUserLocation &&
                          this._userLocationDotMarker.removeClassName(
                            "mapboxgl-user-location-dot-stale",
                          ),
                        this.fire(new r.A("geolocate", c)),
                        this._finish());
                    }
                  }
                  _updateCamera(c) {
                    const t = new r.cd(c.coords.longitude, c.coords.latitude),
                      s = c.coords.accuracy,
                      h = this._map.getBearing(),
                      p = r.h({ bearing: h }, this.options.fitBoundsOptions);
                    this._map.fitBounds(t.toBounds(s), p, {
                      geolocateSource: !0,
                    });
                  }
                  _updateMarker(c) {
                    if (c) {
                      const t = new r.cd(c.coords.longitude, c.coords.latitude);
                      (this._accuracyCircleMarker.setLngLat(t).addTo(this._map),
                        this._userLocationDotMarker
                          .setLngLat(t)
                          .addTo(this._map),
                        (this._accuracy = c.coords.accuracy),
                        this.options.showUserLocation &&
                          this.options.showAccuracyCircle &&
                          this._updateCircleRadius());
                    } else
                      (this._userLocationDotMarker.remove(),
                        this._accuracyCircleMarker.remove());
                  }
                  _updateCircleRadius() {
                    const c = this._map.transform,
                      t = r.c6(1, c._center.lat) * c.worldSize,
                      s = Math.ceil(2 * this._accuracy * t);
                    ((this._circleElement.style.width = `${s}px`),
                      (this._circleElement.style.height = `${s}px`));
                  }
                  _onZoom() {
                    this.options.showUserLocation &&
                      this.options.showAccuracyCircle &&
                      this._updateCircleRadius();
                  }
                  _updateMarkerRotation() {
                    this._userLocationDotMarker &&
                    typeof this._heading == "number"
                      ? (this._userLocationDotMarker.setRotation(this._heading),
                        this._userLocationDotMarker.addClassName(
                          "mapboxgl-user-location-show-heading",
                        ))
                      : (this._userLocationDotMarker.removeClassName(
                          "mapboxgl-user-location-show-heading",
                        ),
                        this._userLocationDotMarker.setRotation(0));
                  }
                  _onError(c) {
                    if (this._map) {
                      if (this.options.trackUserLocation)
                        if (c.code === 1) {
                          ((this._watchState = "OFF"),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-waiting",
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-active",
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-active-error",
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background",
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background-error",
                            ),
                            (this._geolocateButton.disabled = !0));
                          const t = this._map._getUIString(
                            "GeolocateControl.LocationNotAvailable",
                          );
                          (this._geolocateButton.setAttribute("aria-label", t),
                            this._geolocateButton.firstElementChild &&
                              this._geolocateButton.firstElementChild.setAttribute(
                                "title",
                                t,
                              ),
                            this._geolocationWatchID !== void 0 &&
                              this._clearWatch());
                        } else {
                          if (c.code === 3 && this._noTimeout) return;
                          this._setErrorState();
                        }
                      (this._watchState !== "OFF" &&
                        this.options.showUserLocation &&
                        this._userLocationDotMarker.addClassName(
                          "mapboxgl-user-location-dot-stale",
                        ),
                        this.fire(new r.A("error", c)),
                        this._finish());
                    }
                  }
                  _finish() {
                    (this._timeoutId && clearTimeout(this._timeoutId),
                      (this._timeoutId = void 0));
                  }
                  _setupUI(c) {
                    if (this._map !== void 0) {
                      if (
                        (this._container.addEventListener("contextmenu", (t) =>
                          t.preventDefault(),
                        ),
                        (this._geolocateButton = xe(
                          "button",
                          "mapboxgl-ctrl-geolocate",
                          this._container,
                        )),
                        xe(
                          "span",
                          "mapboxgl-ctrl-icon",
                          this._geolocateButton,
                        ).setAttribute("aria-hidden", "true"),
                        (this._geolocateButton.type = "button"),
                        c === !1)
                      ) {
                        r.w(
                          "Geolocation support is not available so the GeolocateControl will be disabled.",
                        );
                        const t = this._map._getUIString(
                          "GeolocateControl.LocationNotAvailable",
                        );
                        ((this._geolocateButton.disabled = !0),
                          this._geolocateButton.setAttribute("aria-label", t),
                          this._geolocateButton.firstElementChild &&
                            this._geolocateButton.firstElementChild.setAttribute(
                              "title",
                              t,
                            ));
                      } else {
                        const t = this._map._getUIString(
                          "GeolocateControl.FindMyLocation",
                        );
                        (this._geolocateButton.setAttribute("aria-label", t),
                          this._geolocateButton.firstElementChild &&
                            this._geolocateButton.firstElementChild.setAttribute(
                              "title",
                              t,
                            ));
                      }
                      (this.options.trackUserLocation &&
                        (this._geolocateButton.setAttribute(
                          "aria-pressed",
                          "false",
                        ),
                        (this._watchState = "OFF")),
                        this.options.showUserLocation &&
                          ((this._dotElement = xe(
                            "div",
                            "mapboxgl-user-location",
                          )),
                          this._dotElement.appendChild(
                            xe("div", "mapboxgl-user-location-dot"),
                          ),
                          this._dotElement.appendChild(
                            xe("div", "mapboxgl-user-location-heading"),
                          ),
                          (this._userLocationDotMarker = new Yc({
                            element: this._dotElement,
                            rotationAlignment: "map",
                            pitchAlignment: "map",
                          })),
                          (this._circleElement = xe(
                            "div",
                            "mapboxgl-user-location-accuracy-circle",
                          )),
                          (this._accuracyCircleMarker = new Yc({
                            element: this._circleElement,
                            pitchAlignment: "map",
                          })),
                          this.options.trackUserLocation &&
                            (this._watchState = "OFF"),
                          this._map.on("zoom", this._onZoom)),
                        this._geolocateButton.addEventListener(
                          "click",
                          this.trigger.bind(this),
                        ),
                        (this._setup = !0),
                        this.options.trackUserLocation &&
                          this._map.on("movestart", (t) => {
                            t.geolocateSource ||
                              this._watchState !== "ACTIVE_LOCK" ||
                              (t.originalEvent &&
                                t.originalEvent.type === "resize") ||
                              ((this._watchState = "BACKGROUND"),
                              this._geolocateButton.classList.add(
                                "mapboxgl-ctrl-geolocate-background",
                              ),
                              this._geolocateButton.classList.remove(
                                "mapboxgl-ctrl-geolocate-active",
                              ),
                              this.fire(new r.A("trackuserlocationend")));
                          }));
                    }
                  }
                  _onDeviceOrientation(c) {
                    this._userLocationDotMarker &&
                      (c.webkitCompassHeading
                        ? (this._heading = c.webkitCompassHeading)
                        : c.absolute === !0 && (this._heading = -1 * c.alpha),
                      this._updateMarkerRotationThrottled());
                  }
                  trigger() {
                    if (!this._setup)
                      return (
                        r.w(
                          "Geolocate control triggered before added to a map",
                        ),
                        !1
                      );
                    if (this.options.trackUserLocation) {
                      switch (this._watchState) {
                        case "OFF":
                          ((this._watchState = "WAITING_ACTIVE"),
                            this.fire(new r.A("trackuserlocationstart")));
                          break;
                        case "WAITING_ACTIVE":
                        case "ACTIVE_LOCK":
                        case "ACTIVE_ERROR":
                        case "BACKGROUND_ERROR":
                          (this._numberOfWatches--,
                            (this._noTimeout = !1),
                            (this._watchState = "OFF"),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-waiting",
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-active",
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-active-error",
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background",
                            ),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background-error",
                            ),
                            this.fire(new r.A("trackuserlocationend")));
                          break;
                        case "BACKGROUND":
                          ((this._watchState = "ACTIVE_LOCK"),
                            this._geolocateButton.classList.remove(
                              "mapboxgl-ctrl-geolocate-background",
                            ),
                            this._lastKnownPosition &&
                              this._updateCamera(this._lastKnownPosition),
                            this.fire(new r.A("trackuserlocationstart")));
                      }
                      switch (this._watchState) {
                        case "WAITING_ACTIVE":
                          (this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting",
                          ),
                            this._geolocateButton.classList.add(
                              "mapboxgl-ctrl-geolocate-active",
                            ));
                          break;
                        case "ACTIVE_LOCK":
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-active",
                          );
                          break;
                        case "ACTIVE_ERROR":
                          (this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting",
                          ),
                            this._geolocateButton.classList.add(
                              "mapboxgl-ctrl-geolocate-active-error",
                            ));
                          break;
                        case "BACKGROUND":
                          this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-background",
                          );
                          break;
                        case "BACKGROUND_ERROR":
                          (this._geolocateButton.classList.add(
                            "mapboxgl-ctrl-geolocate-waiting",
                          ),
                            this._geolocateButton.classList.add(
                              "mapboxgl-ctrl-geolocate-background-error",
                            ));
                      }
                      if (
                        this._watchState === "OFF" &&
                        this._geolocationWatchID !== void 0
                      )
                        this._clearWatch();
                      else if (this._geolocationWatchID === void 0) {
                        let c;
                        (this._geolocateButton.classList.add(
                          "mapboxgl-ctrl-geolocate-waiting",
                        ),
                          this._geolocateButton.setAttribute(
                            "aria-pressed",
                            "true",
                          ),
                          this._numberOfWatches++,
                          this._numberOfWatches > 1
                            ? ((c = { maximumAge: 6e5, timeout: 0 }),
                              (this._noTimeout = !0))
                            : ((c = this.options.positionOptions),
                              (this._noTimeout = !1)),
                          (this._geolocationWatchID =
                            this.options.geolocation.watchPosition(
                              this._onSuccess,
                              this._onError,
                              c,
                            )),
                          this.options.showUserHeading &&
                            this._addDeviceOrientationListener());
                      }
                    } else
                      (this.options.geolocation.getCurrentPosition(
                        this._onSuccess,
                        this._onError,
                        this.options.positionOptions,
                      ),
                        (this._timeoutId = window.setTimeout(
                          this._finish,
                          1e4,
                        )));
                    return !0;
                  }
                  _addDeviceOrientationListener() {
                    const c = () => {
                      "ondeviceorientationabsolute" in window
                        ? window.addEventListener(
                            "deviceorientationabsolute",
                            this._onDeviceOrientation,
                          )
                        : window.addEventListener(
                            "deviceorientation",
                            this._onDeviceOrientation,
                          );
                    };
                    typeof DeviceMotionEvent < "u" &&
                    typeof DeviceMotionEvent.requestPermission == "function"
                      ? DeviceOrientationEvent.requestPermission()
                          .then((t) => {
                            t === "granted" && c();
                          })
                          .catch(console.error)
                      : c();
                  }
                  _clearWatch() {
                    (this.options.geolocation.clearWatch(
                      this._geolocationWatchID,
                    ),
                      window.removeEventListener(
                        "deviceorientation",
                        this._onDeviceOrientation,
                      ),
                      window.removeEventListener(
                        "deviceorientationabsolute",
                        this._onDeviceOrientation,
                      ),
                      (this._geolocationWatchID = void 0),
                      this._geolocateButton.classList.remove(
                        "mapboxgl-ctrl-geolocate-waiting",
                      ),
                      this._geolocateButton.setAttribute(
                        "aria-pressed",
                        "false",
                      ),
                      this.options.showUserLocation &&
                        this._updateMarker(null));
                  }
                },
                AttributionControl: rf,
                ScaleControl: class {
                  constructor(c = {}) {
                    ((this.options = r.h({}, Kc, c)),
                      (this._isNumberFormatSupported = (function () {
                        try {
                          return (
                            new Intl.NumberFormat("en", {
                              style: "unit",
                              unitDisplay: "short",
                              unit: "meter",
                            }),
                            !0
                          );
                        } catch {
                          return !1;
                        }
                      })()),
                      r.aV(["_update", "_setScale", "setUnit"], this));
                  }
                  getDefaultPosition() {
                    return "bottom-left";
                  }
                  _update() {
                    const c = this.options.maxWidth || 100,
                      t = this._map,
                      s = t._containerHeight / 2,
                      h = t._containerWidth / 2 - c / 2,
                      p = t.unproject([h, s]),
                      g = t.unproject([h + c, s]),
                      x = p.distanceTo(g);
                    if (this.options.unit === "imperial") {
                      const w = 3.2808 * x;
                      w > 5280
                        ? this._setScale(c, w / 5280, "mile")
                        : this._setScale(c, w, "foot");
                    } else
                      this.options.unit === "nautical"
                        ? this._setScale(c, x / 1852, "nautical-mile")
                        : x >= 1e3
                          ? this._setScale(c, x / 1e3, "kilometer")
                          : this._setScale(c, x, "meter");
                  }
                  _setScale(c, t, s) {
                    this._map._requestDomTask(() => {
                      const h = (function (g) {
                          const x = Math.pow(10, `${Math.floor(g)}`.length - 1);
                          let w = g / x;
                          return (
                            (w =
                              w >= 10
                                ? 10
                                : w >= 5
                                  ? 5
                                  : w >= 3
                                    ? 3
                                    : w >= 2
                                      ? 2
                                      : w >= 1
                                        ? 1
                                        : (function (S) {
                                            const C = Math.pow(
                                              10,
                                              Math.ceil(
                                                -Math.log(S) / Math.LN10,
                                              ),
                                            );
                                            return Math.round(S * C) / C;
                                          })(w)),
                            x * w
                          );
                        })(t),
                        p = h / t;
                      ((this._container.innerHTML =
                        this._isNumberFormatSupported && s !== "nautical-mile"
                          ? new Intl.NumberFormat(this._language, {
                              style: "unit",
                              unitDisplay: "short",
                              unit: s,
                            }).format(h)
                          : `${h}&nbsp;${zl[s]}`),
                        (this._container.style.width = c * p + "px"));
                    });
                  }
                  onAdd(c) {
                    return (
                      (this._map = c),
                      (this._language = c.getLanguage()),
                      (this._container = xe(
                        "div",
                        "mapboxgl-ctrl mapboxgl-ctrl-scale",
                        c.getContainer(),
                      )),
                      (this._container.dir = "auto"),
                      this._map.on("move", this._update),
                      this._update(),
                      this._container
                    );
                  }
                  onRemove() {
                    (this._container.remove(),
                      this._map.off("move", this._update),
                      (this._map = void 0));
                  }
                  _setLanguage(c) {
                    ((this._language = c), this._update());
                  }
                  setUnit(c) {
                    ((this.options.unit = c), this._update());
                  }
                },
                FullscreenControl: class {
                  constructor(c = {}) {
                    ((this._fullscreen = !1),
                      c &&
                        c.container &&
                        (c.container instanceof HTMLElement
                          ? (this._container = c.container)
                          : r.w(
                              "Full screen control 'container' must be a DOM element.",
                            )),
                      r.aV(["_onClickFullscreen", "_changeIcon"], this),
                      "onfullscreenchange" in document
                        ? (this._fullscreenchange = "fullscreenchange")
                        : "onwebkitfullscreenchange" in document &&
                          (this._fullscreenchange = "webkitfullscreenchange"));
                  }
                  onAdd(c) {
                    return (
                      (this._map = c),
                      this._container ||
                        (this._container = this._map.getContainer()),
                      (this._controlContainer = xe(
                        "div",
                        "mapboxgl-ctrl mapboxgl-ctrl-group",
                      )),
                      this._checkFullscreenSupport()
                        ? this._setupUI()
                        : ((this._controlContainer.style.display = "none"),
                          r.w("This device does not support fullscreen mode.")),
                      this._controlContainer
                    );
                  }
                  onRemove() {
                    (this._controlContainer.remove(),
                      (this._map = null),
                      document.removeEventListener(
                        this._fullscreenchange,
                        this._changeIcon,
                      ));
                  }
                  _checkFullscreenSupport() {
                    return !(
                      !document.fullscreenEnabled &&
                      !document.webkitFullscreenEnabled
                    );
                  }
                  _setupUI() {
                    const c = (this._fullscreenButton = xe(
                      "button",
                      "mapboxgl-ctrl-fullscreen",
                      this._controlContainer,
                    ));
                    (xe("span", "mapboxgl-ctrl-icon", c).setAttribute(
                      "aria-hidden",
                      "true",
                    ),
                      (c.type = "button"),
                      this._updateTitle(),
                      this._fullscreenButton.addEventListener(
                        "click",
                        this._onClickFullscreen,
                      ),
                      document.addEventListener(
                        this._fullscreenchange,
                        this._changeIcon,
                      ));
                  }
                  _updateTitle() {
                    const c = this._getTitle();
                    (this._fullscreenButton.setAttribute("aria-label", c),
                      this._fullscreenButton.firstElementChild &&
                        this._fullscreenButton.firstElementChild.setAttribute(
                          "title",
                          c,
                        ));
                  }
                  _getTitle() {
                    return this._map._getUIString(
                      this._isFullscreen()
                        ? "FullscreenControl.Exit"
                        : "FullscreenControl.Enter",
                    );
                  }
                  _isFullscreen() {
                    return this._fullscreen;
                  }
                  _changeIcon() {
                    ((document.fullscreenElement ||
                      document.webkitFullscreenElement) ===
                      this._container) !==
                      this._fullscreen &&
                      ((this._fullscreen = !this._fullscreen),
                      this._fullscreenButton.classList.toggle(
                        "mapboxgl-ctrl-shrink",
                      ),
                      this._fullscreenButton.classList.toggle(
                        "mapboxgl-ctrl-fullscreen",
                      ),
                      this._updateTitle());
                  }
                  _onClickFullscreen() {
                    this._isFullscreen()
                      ? document.exitFullscreen
                        ? document.exitFullscreen()
                        : document.webkitCancelFullScreen &&
                          document.webkitCancelFullScreen()
                      : this._container.requestFullscreen
                        ? this._container.requestFullscreen()
                        : this._container.webkitRequestFullscreen &&
                          this._container.webkitRequestFullscreen();
                  }
                },
                Popup: class extends r.E {
                  constructor(c) {
                    (super(),
                      (this.options = r.h(Object.create(go), c)),
                      (this._altitude = this.options.altitude),
                      r.aV(
                        ["_update", "_onClose", "remove", "_onMouseEvent"],
                        this,
                      ),
                      (this._classList = new Set(
                        c && c.className ? c.className.trim().split(/\s+/) : [],
                      )));
                  }
                  addTo(c) {
                    return (
                      this._map && this.remove(),
                      (this._map = c),
                      this.options.closeOnClick &&
                        c.on("preclick", this._onClose),
                      this.options.closeOnMove && c.on("move", this._onClose),
                      c.on("remove", this.remove),
                      this._update(),
                      c._addPopup(this),
                      this._focusFirstElement(),
                      this._trackPointer
                        ? (c.on("mousemove", this._onMouseEvent),
                          c.on("mouseup", this._onMouseEvent),
                          c._canvasContainer.classList.add(
                            "mapboxgl-track-pointer",
                          ))
                        : c.on("move", this._update),
                      this.fire(new r.A("open")),
                      this
                    );
                  }
                  isOpen() {
                    return !!this._map;
                  }
                  remove() {
                    (this._content && this._content.remove(),
                      this._container &&
                        (this._container.remove(), (this._container = void 0)));
                    const c = this._map;
                    return (
                      c &&
                        (c.off("move", this._update),
                        c.off("move", this._onClose),
                        c.off("preclick", this._onClose),
                        c.off("click", this._onClose),
                        c.off("remove", this.remove),
                        c.off("mousemove", this._onMouseEvent),
                        c.off("mouseup", this._onMouseEvent),
                        c.off("drag", this._onMouseEvent),
                        c._canvasContainer &&
                          c._canvasContainer.classList.remove(
                            "mapboxgl-track-pointer",
                          ),
                        c._removePopup(this),
                        (this._map = void 0)),
                      this.fire(new r.A("close")),
                      this
                    );
                  }
                  getLngLat() {
                    return this._lngLat;
                  }
                  setLngLat(c) {
                    ((this._lngLat = r.cd.convert(c)),
                      (this._pos = null),
                      (this._trackPointer = !1),
                      this._update());
                    const t = this._map;
                    return (
                      t &&
                        (t.on("move", this._update),
                        t.off("mousemove", this._onMouseEvent),
                        t._canvasContainer.classList.remove(
                          "mapboxgl-track-pointer",
                        )),
                      this
                    );
                  }
                  getAltitude() {
                    return this._altitude;
                  }
                  setAltitude(c) {
                    return ((this._altitude = c), this._update(), this);
                  }
                  trackPointer() {
                    ((this._trackPointer = !0),
                      (this._pos = null),
                      this._update());
                    const c = this._map;
                    return (
                      c &&
                        (c.off("move", this._update),
                        c.on("mousemove", this._onMouseEvent),
                        c.on("drag", this._onMouseEvent),
                        c._canvasContainer.classList.add(
                          "mapboxgl-track-pointer",
                        )),
                      this
                    );
                  }
                  getElement() {
                    return this._container;
                  }
                  setText(c) {
                    return this.setDOMContent(document.createTextNode(c));
                  }
                  setHTML(c) {
                    const t = document.createDocumentFragment(),
                      s = document.createElement("body");
                    let h;
                    for (s.innerHTML = c; (h = s.firstChild), h; )
                      t.appendChild(h);
                    return this.setDOMContent(t);
                  }
                  getMaxWidth() {
                    return this._container && this._container.style.maxWidth;
                  }
                  setMaxWidth(c) {
                    return ((this.options.maxWidth = c), this._update(), this);
                  }
                  setDOMContent(c) {
                    let t = this._content;
                    if (t)
                      for (; t.hasChildNodes(); )
                        t.firstChild && t.removeChild(t.firstChild);
                    else
                      t = this._content = xe(
                        "div",
                        "mapboxgl-popup-content",
                        this._container || void 0,
                      );
                    if ((t.appendChild(c), this.options.closeButton)) {
                      const s = (this._closeButton = xe(
                        "button",
                        "mapboxgl-popup-close-button",
                        t,
                      ));
                      ((s.type = "button"),
                        s.setAttribute("aria-label", "Close popup"),
                        (s.innerHTML =
                          '<span aria-hidden="true">&#215;</span>'),
                        s.addEventListener("click", this._onClose));
                    }
                    return (this._update(), this._focusFirstElement(), this);
                  }
                  addClassName(c) {
                    return (
                      this._classList.add(c),
                      this._updateClassList(),
                      this
                    );
                  }
                  removeClassName(c) {
                    return (
                      this._classList.delete(c),
                      this._updateClassList(),
                      this
                    );
                  }
                  setOffset(c) {
                    return ((this.options.offset = c), this._update(), this);
                  }
                  toggleClassName(c) {
                    let t;
                    return (
                      this._classList.delete(c)
                        ? (t = !1)
                        : (this._classList.add(c), (t = !0)),
                      this._updateClassList(),
                      t
                    );
                  }
                  _onMouseEvent(c) {
                    this._update(c.point);
                  }
                  _getAnchor(c) {
                    if (this.options.anchor) return this.options.anchor;
                    const t = this._map,
                      s = this._container,
                      h = this._pos;
                    if (!t || !s || !h) return "bottom";
                    const p = s.offsetWidth,
                      g = s.offsetHeight,
                      x = h.x < p / 2,
                      w = h.x > t.transform.width - p / 2;
                    if (h.y + c < g)
                      return x ? "top-left" : w ? "top-right" : "top";
                    if (h.y > t.transform.height - g) {
                      if (x) return "bottom-left";
                      if (w) return "bottom-right";
                    }
                    return x ? "left" : w ? "right" : "bottom";
                  }
                  _updateClassList() {
                    const c = this._container;
                    if (!c) return;
                    const t = [...this._classList];
                    (t.push("mapboxgl-popup"),
                      this._anchor &&
                        t.push(`mapboxgl-popup-anchor-${this._anchor}`),
                      this._trackPointer &&
                        t.push("mapboxgl-popup-track-pointer"),
                      (c.className = t.join(" ")));
                  }
                  _update(c) {
                    const t = this._map,
                      s = this._content;
                    if (!t || (!this._lngLat && !this._trackPointer) || !s)
                      return;
                    let h = this._container;
                    if (
                      (h ||
                        ((h = this._container =
                          xe("div", "mapboxgl-popup", t.getContainer())),
                        (this._tip = xe("div", "mapboxgl-popup-tip", h)),
                        h.appendChild(s)),
                      this.options.maxWidth &&
                        h.style.maxWidth !== this.options.maxWidth &&
                        (h.style.maxWidth = this.options.maxWidth),
                      t.transform.renderWorldCopies &&
                        !this._trackPointer &&
                        (this._lngLat = Rl(
                          this._lngLat,
                          this._pos,
                          t.transform,
                        )),
                      !this._trackPointer || c)
                    ) {
                      const p = (this._pos =
                          this._trackPointer && c instanceof r.P
                            ? c
                            : t.project(this._lngLat, this._altitude)),
                        g = bs(this.options.offset),
                        x = (this._anchor = this._getAnchor(g.y)),
                        w = bs(this.options.offset, x),
                        S = p.add(w).round();
                      t._requestDomTask(() => {
                        this._container &&
                          x &&
                          (this._container.style.transform = `${sf[x]} translate(${S.x}px,${S.y}px)`);
                      });
                    }
                    if (!this._marker && t._showingGlobe()) {
                      const p = r.eK(t.transform, this._lngLat) ? 0 : 1;
                      this._setOpacity(p);
                    }
                    this._updateClassList();
                  }
                  _focusFirstElement() {
                    if (!this.options.focusAfterOpen || !this._container)
                      return;
                    const c = this._container.querySelector(Rs);
                    c && c.focus();
                  }
                  _onClose() {
                    this.remove();
                  }
                  _setOpacity(c) {
                    (this._container &&
                      (this._container.style.opacity = `${c}`),
                      this._content &&
                        (this._content.style.pointerEvents = c
                          ? "auto"
                          : "none"));
                  }
                },
                Marker: Yc,
                Style: Er,
                LngLat: r.cd,
                LngLatBounds: r.aG,
                Point: r.P,
                MercatorCoordinate: r.ac,
                FreeCameraOptions: Ip,
                Evented: r.E,
                config: r.e,
                prewarm: r.eO,
                clearPrewarmedResources: r.eN,
                get accessToken() {
                  return r.e.ACCESS_TOKEN;
                },
                set accessToken(c) {
                  r.e.ACCESS_TOKEN = c;
                },
                get baseApiUrl() {
                  return r.e.API_URL;
                },
                set baseApiUrl(c) {
                  r.e.API_URL = c;
                },
                get workerCount() {
                  return r.eX.workerCount;
                },
                set workerCount(c) {
                  r.eX.workerCount = c;
                },
                get maxParallelImageRequests() {
                  return r.e.MAX_PARALLEL_IMAGE_REQUESTS;
                },
                set maxParallelImageRequests(c) {
                  r.e.MAX_PARALLEL_IMAGE_REQUESTS = c;
                },
                clearStorage(c) {
                  r.eW(c);
                },
                get workerUrl() {
                  return r.eV.workerUrl;
                },
                set workerUrl(c) {
                  r.eV.workerUrl = c;
                },
                get workerClass() {
                  return r.eV.workerClass;
                },
                set workerClass(c) {
                  r.eV.workerClass = c;
                },
                get workerParams() {
                  return r.eV.workerParams;
                },
                set workerParams(c) {
                  r.eV.workerParams = c;
                },
                get dracoUrl() {
                  return r.eU();
                },
                set dracoUrl(c) {
                  r.eT(c);
                },
                get meshoptUrl() {
                  return r.eS();
                },
                set meshoptUrl(c) {
                  r.eR(c);
                },
                setNow: r.q.setNow,
                restoreNow: r.q.restoreNow,
              };
            }));
          var P = T;
          return P;
        });
      })(Fg)),
    Fg.exports
  );
}
var RA = DA();
const cL = FT(RA);
/**
 * @license lucide-vue-next v0.516.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const zA = VT("chevron-down", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }],
]);
/**
 * @license lucide-vue-next v0.516.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const kA = VT("x", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }],
]);
var Gu = {},
  dw;
function LA() {
  if (dw) return Gu;
  ((dw = 1), (Gu.attr = m), (Gu.tagClose = l), (Gu.tag = f), (Gu.encode = y));
  function m(T) {
    return T && T.length
      ? " " +
          T.map(function (I) {
            return I[0] + '="' + I[1] + '"';
          }).join(" ")
      : "";
  }
  function l(T, I) {
    return "<" + T + m(I) + "/>";
  }
  function f(T, I, P) {
    return "<" + T + m(P) + ">" + I + "</" + T + ">";
  }
  function y(T) {
    return (T === null ? "" : T.toString())
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;");
  }
  return Gu;
}
var cx, fw;
function OA() {
  if (fw) return cx;
  fw = 1;
  var m = LA(),
    l = m.tag,
    f = m.encode;
  cx = function (rt, Ot) {
    return (
      (Ot = Ot || {
        documentName: void 0,
        documentDescription: void 0,
        name: "name",
        description: "description",
        simplestyle: !1,
        timestamp: "timestamp",
      }),
      '<?xml version="1.0" encoding="UTF-8"?>' +
        l("kml", l("Document", I(Ot) + P(Ot) + T(rt, Ot)), [
          ["xmlns", "http://www.opengis.net/kml/2.2"],
        ])
    );
  };
  function y(Re, rt) {
    return function (Ot) {
      if (!Ot.properties || !q.valid(Ot.geometry)) return "";
      var _i = q.any(Ot.geometry);
      if (!_i) return "";
      var qt = "",
        pi = "";
      if (Re.simplestyle) {
        var Ri = Rt(Ot.properties);
        Ri &&
          (q.isPoint(Ot.geometry) && Ie(Ot.properties)
            ? (rt.indexOf(Ri) === -1 &&
                ((qt = xe(Ot.properties, Ri)), rt.push(Ri)),
              (pi = l("styleUrl", "#" + Ri)))
            : (q.isPolygon(Ot.geometry) || q.isLine(Ot.geometry)) &&
              Qe(Ot.properties) &&
              (rt.indexOf(Ri) === -1 &&
                ((qt = gt(Ot.properties, Ri)), rt.push(Ri)),
              (pi = l("styleUrl", "#" + Ri))));
      }
      return (
        qt +
        l(
          "Placemark",
          r(Ot.properties, Re) +
            F(Ot.properties, Re) +
            fe(Ot.properties) +
            B(Ot.properties, Re) +
            _i +
            pi,
        )
      );
    };
  }
  function T(Re, rt) {
    if (!Re.type) return "";
    var Ot = [];
    switch (Re.type) {
      case "FeatureCollection":
        return Re.features ? Re.features.map(y(rt, Ot)).join("") : "";
      case "Feature":
        return y(rt, Ot)(Re);
      default:
        return y(rt, Ot)({ type: "Feature", geometry: Re, properties: {} });
    }
  }
  function I(Re) {
    return Re.documentName !== void 0 ? l("name", Re.documentName) : "";
  }
  function P(Re) {
    return Re.documentDescription !== void 0
      ? l("description", Re.documentDescription)
      : "";
  }
  function r(Re, rt) {
    return Re[rt.name] ? l("name", f(Re[rt.name])) : "";
  }
  function F(Re, rt) {
    return Re[rt.description] ? l("description", f(Re[rt.description])) : "";
  }
  function B(Re, rt) {
    return Re[rt.timestamp]
      ? l("TimeStamp", l("when", f(Re[rt.timestamp])))
      : "";
  }
  var q = {
    Point: function (Re) {
      return l("Point", l("coordinates", Re.coordinates.join(",")));
    },
    LineString: function (Re) {
      return l("LineString", l("coordinates", ne(Re.coordinates)));
    },
    Polygon: function (Re) {
      if (!Re.coordinates.length) return "";
      var rt = Re.coordinates[0],
        Ot = Re.coordinates.slice(1),
        _i = l("outerBoundaryIs", l("LinearRing", l("coordinates", ne(rt)))),
        qt = Ot.map(function (pi) {
          return l(
            "innerBoundaryIs",
            l("LinearRing", l("coordinates", ne(pi))),
          );
        }).join("");
      return l("Polygon", _i + qt);
    },
    MultiPoint: function (Re) {
      return Re.coordinates.length
        ? l(
            "MultiGeometry",
            Re.coordinates
              .map(function (rt) {
                return q.Point({ coordinates: rt });
              })
              .join(""),
          )
        : "";
    },
    MultiPolygon: function (Re) {
      return Re.coordinates.length
        ? l(
            "MultiGeometry",
            Re.coordinates
              .map(function (rt) {
                return q.Polygon({ coordinates: rt });
              })
              .join(""),
          )
        : "";
    },
    MultiLineString: function (Re) {
      return Re.coordinates.length
        ? l(
            "MultiGeometry",
            Re.coordinates
              .map(function (rt) {
                return q.LineString({ coordinates: rt });
              })
              .join(""),
          )
        : "";
    },
    GeometryCollection: function (Re) {
      return l("MultiGeometry", Re.geometries.map(q.any).join(""));
    },
    valid: function (Re) {
      return (
        Re &&
        Re.type &&
        (Re.coordinates ||
          (Re.type === "GeometryCollection" &&
            Re.geometries &&
            Re.geometries.every(q.valid)))
      );
    },
    any: function (Re) {
      return q[Re.type] ? q[Re.type](Re) : "";
    },
    isPoint: function (Re) {
      return Re.type === "Point" || Re.type === "MultiPoint";
    },
    isPolygon: function (Re) {
      return Re.type === "Polygon" || Re.type === "MultiPolygon";
    },
    isLine: function (Re) {
      return Re.type === "LineString" || Re.type === "MultiLineString";
    },
  };
  function ne(Re) {
    return Re.map(function (rt) {
      return rt.join(",");
    }).join(" ");
  }
  function fe(Re) {
    return l("ExtendedData", pt(Re).map(de).join(""));
  }
  function de(Re) {
    return l("Data", l("value", f(Re[1])), [["name", f(Re[0])]]);
  }
  function Ie(Re) {
    return !!(Re["marker-size"] || Re["marker-symbol"] || Re["marker-color"]);
  }
  function xe(Re, rt) {
    return l("Style", l("IconStyle", l("Icon", l("href", we(Re)))) + Ae(), [
      ["id", rt],
    ]);
  }
  function we(Re) {
    var rt = Re["marker-size"] || "medium",
      Ot = Re["marker-symbol"] ? "-" + Re["marker-symbol"] : "",
      _i = (Re["marker-color"] || "7e7e7e").replace("#", "");
    return (
      "https://api.tiles.mapbox.com/v3/marker/pin-" +
      rt.charAt(0) +
      Ot +
      "+" +
      _i +
      ".png"
    );
  }
  function Ae(Re) {
    return l("hotSpot", "", [
      ["xunits", "fraction"],
      ["yunits", "fraction"],
      ["x", 0.5],
      ["y", 0.5],
    ]);
  }
  function Qe(Re) {
    for (var rt in Re)
      if (
        {
          stroke: !0,
          "stroke-opacity": !0,
          "stroke-width": !0,
          fill: !0,
          "fill-opacity": !0,
        }[rt]
      )
        return !0;
  }
  function gt(Re, rt) {
    var Ot = l("LineStyle", [
        l("color", Mt(Re.stroke, Re["stroke-opacity"]) || "ff555555") +
          l("width", Re["stroke-width"] === void 0 ? 2 : Re["stroke-width"]),
      ]),
      _i = "";
    return (
      (Re.fill || Re["fill-opacity"]) &&
        (_i = l("PolyStyle", [
          l("color", Mt(Re.fill, Re["fill-opacity"]) || "88555555"),
        ])),
      l("Style", Ot + _i, [["id", rt]])
    );
  }
  function Rt(Re) {
    var rt = "";
    return (
      Re["marker-symbol"] && (rt = rt + "ms" + Re["marker-symbol"]),
      Re["marker-color"] &&
        (rt = rt + "mc" + Re["marker-color"].replace("#", "")),
      Re["marker-size"] && (rt = rt + "ms" + Re["marker-size"]),
      Re.stroke && (rt = rt + "s" + Re.stroke.replace("#", "")),
      Re["stroke-width"] &&
        (rt = rt + "sw" + Re["stroke-width"].toString().replace(".", "")),
      Re["stroke-opacity"] &&
        (rt = rt + "mo" + Re["stroke-opacity"].toString().replace(".", "")),
      Re.fill && (rt = rt + "f" + Re.fill.replace("#", "")),
      Re["fill-opacity"] &&
        (rt = rt + "fo" + Re["fill-opacity"].toString().replace(".", "")),
      rt
    );
  }
  function Mt(Re, rt) {
    if (typeof Re != "string") return "";
    if (((Re = Re.replace("#", "").toLowerCase()), Re.length === 3))
      Re = Re[0] + Re[0] + Re[1] + Re[1] + Re[2] + Re[2];
    else if (Re.length !== 6) return "";
    var Ot = Re[0] + Re[1],
      _i = Re[2] + Re[3],
      qt = Re[4] + Re[5],
      pi = "ff";
    return (
      typeof rt == "number" &&
        rt >= 0 &&
        rt <= 1 &&
        ((pi = (rt * 255).toString(16)),
        pi.indexOf(".") > -1 && (pi = pi.substr(0, pi.indexOf("."))),
        pi.length < 2 && (pi = "0" + pi)),
      pi + qt + _i + Ot
    );
  }
  function pt(Re) {
    var rt = [];
    for (var Ot in Re) rt.push([Ot, Re[Ot]]);
    return rt;
  }
  return cx;
}
var FA = OA();
const pw = FT(FA),
  BA = { class: "flex flex-wrap gap-2 justify-center mt-6" },
  GT = aa({
    __name: "DownloadMapData",
    props: { dataForDownload: {} },
    setup(m) {
      const l = m,
        f = (B) => B.mostRecentAlerts !== void 0 && B.previousAlerts !== void 0,
        y = () => {
          if (!l.dataForDownload || f(l.dataForDownload)) {
            console.error(
              "No valid GeoJSON Feature data available to convert to CSV.",
            );
            return;
          }
          const { geometry: B, properties: q } = l.dataForDownload;
          if (!q) {
            console.error("No properties found in GeoJSON data.");
            return;
          }
          const ne = { ...q };
          ((ne.geographicCentroid = `[${q.geographicCentroid}]`),
            delete ne.coordinates,
            delete ne.YYYYMM);
          const fe = Object.keys(ne),
            de = Object.values(ne).map((Rt) =>
              typeof Rt == "string" && Rt.includes(",")
                ? `"${Rt.replace(/"/g, '""')}"`
                : Rt,
            ),
            Ie = fe.indexOf("type");
          (Ie > -1 && (fe.splice(Ie, 1), de.splice(Ie, 1)),
            fe.push("type"),
            de.push(`"${B.type}"`));
          const xe = JSON.stringify(B.coordinates);
          (fe.push("coordinates"), de.push(`"${xe}"`));
          const we = [fe.join(","), de.join(",")].join(`
`);
          let Ae;
          q.alertID
            ? (Ae = `${q.alertID}.csv`)
            : q.ID
              ? (Ae = `${q.ID}.csv`)
              : (Ae = "data.csv");
          const Qe = new Blob([we], { type: "text/csv" }),
            gt = document.createElement("a");
          ((gt.href = URL.createObjectURL(Qe)),
            (gt.download = Ae),
            document.body.appendChild(gt),
            gt.click(),
            document.body.removeChild(gt),
            URL.revokeObjectURL(gt.href));
        },
        T = () => {
          if (!l.dataForDownload || f(l.dataForDownload)) {
            console.error(
              "No valid GeoJSON Feature data available to convert to CSV.",
            );
            return;
          }
          const B = { ...l.dataForDownload };
          if (!B.properties) {
            console.error("No properties found in GeoJSON data.");
            return;
          }
          delete B.properties.YYYYMM;
          let q;
          B.properties.alertID
            ? (q = `${B.properties.alertID}.geojson`)
            : B.properties.ID
              ? (q = `${B.properties.ID}.geojson`)
              : (q = "data.csv");
          const ne = JSON.stringify(B, null, 2),
            fe = new Blob([ne], { type: "application/json" }),
            de = document.createElement("a");
          ((de.href = URL.createObjectURL(fe)),
            (de.download = q),
            document.body.appendChild(de),
            de.click(),
            document.body.removeChild(de),
            URL.revokeObjectURL(de.href));
        },
        I = () => {
          if (!l.dataForDownload || f(l.dataForDownload)) {
            console.error(
              "No valid GeoJSON Feature data available to convert to CSV.",
            );
            return;
          }
          const B = pw(l.dataForDownload),
            { properties: q } = l.dataForDownload;
          if (!q) {
            console.error("No properties found in GeoJSON data.");
            return;
          }
          let ne;
          q.alertID
            ? (ne = `${q.alertID}.kml`)
            : q.ID
              ? (ne = `${q.ID}.kml`)
              : (ne = "data.kml");
          const fe = new Blob([B], {
              type: "application/vnd.google-earth.kml+xml",
            }),
            de = document.createElement("a");
          ((de.href = URL.createObjectURL(fe)),
            (de.download = ne),
            document.body.appendChild(de),
            de.click(),
            document.body.removeChild(de),
            URL.revokeObjectURL(de.href));
        },
        P = () => {
          if (!l.dataForDownload || !f(l.dataForDownload)) {
            console.warn("No valid AlertsData available to download as CSV.");
            return;
          }
          const B = [
            ...l.dataForDownload.previousAlerts.features,
            ...l.dataForDownload.mostRecentAlerts.features,
          ];
          let q = "",
            ne = !1;
          B.forEach((xe) => {
            const { geometry: we, properties: Ae } = xe,
              Qe = { ...Ae };
            (delete Qe.image_url,
              delete Qe.image_caption,
              delete Qe.preview_link,
              delete Qe.YYYYMM);
            const gt = JSON.stringify(we.coordinates);
            Qe.coordinates = gt;
            const Rt = Object.keys(Qe),
              Mt = Object.values(Qe).map((pt) =>
                typeof pt == "string" && pt.includes(",")
                  ? `"${pt.replace(/"/g, '""')}"`
                  : pt,
              );
            (Rt.push("geometry type"),
              Mt.push(`"${we.type}"`),
              ne ||
                ((q +=
                  Rt.join(",") +
                  `
`),
                (ne = !0)),
              (q +=
                Mt.join(",") +
                `
`));
          });
          const fe =
              B[0].properties && B[0].properties.territory
                ? `${B[0].properties.territory}_alerts.csv`
                : "alerts.csv",
            de = new Blob([q], { type: "text/csv" }),
            Ie = document.createElement("a");
          ((Ie.href = URL.createObjectURL(de)),
            (Ie.download = fe),
            document.body.appendChild(Ie),
            Ie.click(),
            document.body.removeChild(Ie),
            URL.revokeObjectURL(Ie.href));
        },
        r = () => {
          if (!l.dataForDownload || !f(l.dataForDownload)) {
            console.warn("No valid AlertsData available to download as CSV.");
            return;
          }
          const B = [
            ...l.dataForDownload.previousAlerts.features,
            ...l.dataForDownload.mostRecentAlerts.features,
          ];
          B.forEach((xe) => {
            xe.properties &&
              (delete xe.properties.image_url,
              delete xe.properties.image_caption,
              delete xe.properties.preview_link,
              delete xe.properties.YYYYMM);
          });
          const q = { type: "FeatureCollection", features: B },
            ne =
              B[0].properties && B[0].properties.territory
                ? `${B[0].properties.territory}_alerts.geojson`
                : "alerts.geojson",
            fe = JSON.stringify(q, null, 2),
            de = new Blob([fe], { type: "application/json" }),
            Ie = document.createElement("a");
          ((Ie.href = URL.createObjectURL(de)),
            (Ie.download = ne),
            document.body.appendChild(Ie),
            Ie.click(),
            document.body.removeChild(Ie),
            URL.revokeObjectURL(Ie.href));
        },
        F = () => {
          if (!l.dataForDownload || !f(l.dataForDownload)) {
            console.warn("No valid AlertsData available to download as CSV.");
            return;
          }
          const B = [
              ...l.dataForDownload.previousAlerts.features,
              ...l.dataForDownload.mostRecentAlerts.features,
            ],
            ne = pw({ type: "FeatureCollection", features: B }),
            fe =
              B[0].properties && B[0].properties.territory
                ? `${B[0].properties.territory}_alerts.kml`
                : "alerts.kml",
            de = new Blob([ne], {
              type: "application/vnd.google-earth.kml+xml",
            }),
            Ie = document.createElement("a");
          ((Ie.href = URL.createObjectURL(de)),
            (Ie.download = fe),
            document.body.appendChild(Ie),
            Ie.click(),
            document.body.removeChild(Ie),
            URL.revokeObjectURL(Ie.href));
        };
      return (B, q) => (
        Xi(),
        pn("div", BA, [
          ci(
            "button",
            {
              class:
                "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-blue-500 text-white hover:bg-blue-600 h-10 px-4 py-2 shadow-sm hover:shadow-md active:scale-[0.98]",
              onClick:
                q[0] || (q[0] = (ne) => (f(l.dataForDownload) ? P() : y())),
            },
            An(B.$t("downloadCSV")),
            1,
          ),
          ci(
            "button",
            {
              class:
                "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-blue-500 text-white hover:bg-blue-600 h-10 px-4 py-2 shadow-sm hover:shadow-md active:scale-[0.98]",
              onClick:
                q[1] || (q[1] = (ne) => (f(l.dataForDownload) ? r() : T())),
            },
            An(B.$t("downloadGeoJSON")),
            1,
          ),
          ci(
            "button",
            {
              class:
                "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-blue-500 text-white hover:bg-blue-600 h-10 px-4 py-2 shadow-sm hover:shadow-md active:scale-[0.98]",
              onClick:
                q[2] || (q[2] = (ne) => (f(l.dataForDownload) ? F() : I())),
            },
            An(B.$t("downloadKML")),
            1,
          ),
        ])
      );
    },
  });
(function () {
  try {
    if (typeof document < "u") {
      var m = document.createElement("style");
      (m.appendChild(
        document.createTextNode(
          '.vue-slider-dot{position:absolute;transition:all 0s;z-index:5}.vue-slider-dot:focus{outline:none}.vue-slider-dot-tooltip{position:absolute;visibility:hidden}.vue-slider-dot-hover:hover .vue-slider-dot-tooltip,.vue-slider-dot-tooltip-show{visibility:visible}.vue-slider-dot-tooltip-top{top:-10px;left:50%;transform:translate(-50%,-100%)}.vue-slider-dot-tooltip-bottom{bottom:-10px;left:50%;transform:translate(-50%,100%)}.vue-slider-dot-tooltip-left{left:-10px;top:50%;transform:translate(-100%,-50%)}.vue-slider-dot-tooltip-right{right:-10px;top:50%;transform:translate(100%,-50%)}.vue-slider-marks{position:relative;width:100%;height:100%}.vue-slider-mark{position:absolute;z-index:1}.vue-slider-ltr .vue-slider-mark,.vue-slider-rtl .vue-slider-mark{width:0;height:100%;top:50%}.vue-slider-ltr .vue-slider-mark-step,.vue-slider-rtl .vue-slider-mark-step{top:0}.vue-slider-ltr .vue-slider-mark-label,.vue-slider-rtl .vue-slider-mark-label{top:100%;margin-top:10px}.vue-slider-ltr .vue-slider-mark{transform:translate(-50%,-50%)}.vue-slider-ltr .vue-slider-mark-step{left:0}.vue-slider-ltr .vue-slider-mark-label{left:50%;transform:translate(-50%)}.vue-slider-rtl .vue-slider-mark{transform:translate(50%,-50%)}.vue-slider-rtl .vue-slider-mark-step{right:0}.vue-slider-rtl .vue-slider-mark-label{right:50%;transform:translate(50%)}.vue-slider-ttb .vue-slider-mark,.vue-slider-btt .vue-slider-mark{width:100%;height:0;left:50%}.vue-slider-ttb .vue-slider-mark-step,.vue-slider-btt .vue-slider-mark-step{left:0}.vue-slider-ttb .vue-slider-mark-label,.vue-slider-btt .vue-slider-mark-label{left:100%;margin-left:10px}.vue-slider-btt .vue-slider-mark{transform:translate(-50%,50%)}.vue-slider-btt .vue-slider-mark-step{top:0}.vue-slider-btt .vue-slider-mark-label{top:50%;transform:translateY(-50%)}.vue-slider-ttb .vue-slider-mark{transform:translate(-50%,-50%)}.vue-slider-ttb .vue-slider-mark-step{bottom:0}.vue-slider-ttb .vue-slider-mark-label{bottom:50%;transform:translateY(50%)}.vue-slider-mark-step,.vue-slider-mark-label{position:absolute}.vue-slider-disabled{opacity:.5;cursor:not-allowed}.vue-slider-rail{background-color:#ccc;border-radius:15px}.vue-slider-process{background-color:#3498db;border-radius:15px}.vue-slider-mark{z-index:4}.vue-slider-mark:first-child .vue-slider-mark-step,.vue-slider-mark:last-child .vue-slider-mark-step{display:none}.vue-slider-mark-step{width:100%;height:100%;border-radius:50%;background-color:#00000029}.vue-slider-mark-label{font-size:14px;white-space:nowrap}.vue-slider-dot-handle{cursor:pointer;width:100%;height:100%;border-radius:50%;background-color:#fff;box-sizing:border-box;box-shadow:.5px .5px 2px 1px #00000052}.vue-slider-dot-handle-focus{box-shadow:0 0 1px 2px #3498db5c}.vue-slider-dot-handle-disabled{cursor:not-allowed;background-color:#ccc}.vue-slider-dot-tooltip-inner{font-size:14px;white-space:nowrap;padding:2px 5px;min-width:20px;text-align:center;color:#fff;border-radius:5px;border-color:#3498db;background-color:#3498db;box-sizing:content-box}.vue-slider-dot-tooltip-inner:after{content:"";position:absolute}.vue-slider-dot-tooltip-inner-top:after{top:100%;left:50%;transform:translate(-50%);height:0;width:0;border-color:transparent;border-style:solid;border-width:5px;border-top-color:inherit}.vue-slider-dot-tooltip-inner-bottom:after{bottom:100%;left:50%;transform:translate(-50%);height:0;width:0;border-color:transparent;border-style:solid;border-width:5px;border-bottom-color:inherit}.vue-slider-dot-tooltip-inner-left:after{left:100%;top:50%;transform:translateY(-50%);height:0;width:0;border-color:transparent;border-style:solid;border-width:5px;border-left-color:inherit}.vue-slider-dot-tooltip-inner-right:after{right:100%;top:50%;transform:translateY(-50%);height:0;width:0;border-color:transparent;border-style:solid;border-width:5px;border-right-color:inherit}.vue-slider-dot-tooltip-wrapper{opacity:0;transition:all .3s}.vue-slider-dot-tooltip-wrapper-show{opacity:1}.vue-slider{position:relative;box-sizing:content-box;-webkit-user-select:none;user-select:none;display:block;-webkit-tap-highlight-color:rgba(0,0,0,0)}.vue-slider-rail{position:relative;width:100%;height:100%;transition-property:width,height,left,right,top,bottom}.vue-slider-process{position:absolute;z-index:1}',
        ),
      ),
        document.head.appendChild(m));
    }
  } catch (l) {
    console.error("vite-plugin-css-injected-by-js", l);
  }
})();
var NA = Object.defineProperty,
  VA = (m, l, f) =>
    l in m
      ? NA(m, l, { enumerable: !0, configurable: !0, writable: !0, value: f })
      : (m[l] = f),
  mr = (m, l, f) => (VA(m, typeof l != "symbol" ? l + "" : l, f), f);
const Ux = (m, l) => {
    const f = m.__vccOpts || m;
    for (const [y, T] of l) f[y] = T;
    return f;
  },
  UA = {
    emits: ["drag-start"],
    props: {
      value: { type: [Number, String], default: 0 },
      tooltip: { type: String, required: !0 },
      dotStyle: { type: Array, default: () => ({}) },
      tooltipStyle: { type: Array, default: () => ({}) },
      tooltipPlacement: { type: String, required: !0 },
      tooltipFormatter: {
        type: [String, Array, Object, Function],
        default: void 0,
      },
      focus: { type: Boolean, default: !1 },
      disabled: { type: Boolean, default: !1 },
    },
    computed: {
      dotClasses() {
        return [
          "vue-slider-dot",
          {
            "vue-slider-dot-hover":
              this.tooltip === "hover" || this.tooltip === "active",
            "vue-slider-dot-disabled": this.disabled,
            "vue-slider-dot-focus": this.focus,
          },
        ];
      },
      handleClasses() {
        return [
          "vue-slider-dot-handle",
          {
            "vue-slider-dot-handle-disabled": this.disabled,
            "vue-slider-dot-handle-focus": this.focus,
          },
        ];
      },
      tooltipClasses() {
        return [
          "vue-slider-dot-tooltip",
          [`vue-slider-dot-tooltip-${this.tooltipPlacement}`],
          { "vue-slider-dot-tooltip-show": this.showTooltip },
        ];
      },
      tooltipInnerClasses() {
        return [
          "vue-slider-dot-tooltip-inner",
          [`vue-slider-dot-tooltip-inner-${this.tooltipPlacement}`],
          {
            "vue-slider-dot-tooltip-inner-disabled": this.disabled,
            "vue-slider-dot-tooltip-inner-focus": this.focus,
          },
        ];
      },
      showTooltip() {
        switch (this.tooltip) {
          case "always":
            return !0;
          case "none":
            return !1;
          case "focus":
          case "active":
            return !!this.focus;
          default:
            return !1;
        }
      },
      tooltipValue() {
        return this.tooltipFormatter
          ? typeof this.tooltipFormatter == "string"
            ? this.tooltipFormatter.replace(/\{value\}/, String(this.value))
            : this.tooltipFormatter(this.value)
          : this.value;
      },
    },
    methods: {
      dragStart(m) {
        if (this.disabled) return !1;
        this.$emit("drag-start");
      },
    },
  },
  jA = ["aria-valuetext"],
  GA = { class: "vue-slider-dot-tooltip-text" };
function $A(m, l, f, y, T, I) {
  return (
    Xi(),
    pn(
      "div",
      {
        ref: "dot",
        class: ra(I.dotClasses),
        "aria-valuetext": I.tooltipValue,
        onMousedown:
          l[0] || (l[0] = (...P) => I.dragStart && I.dragStart(...P)),
        onTouchstartPassive:
          l[1] || (l[1] = (...P) => I.dragStart && I.dragStart(...P)),
      },
      [
        bo(m.$slots, "dot", {}, () => [
          ci(
            "div",
            { class: ra(I.handleClasses), style: sa(f.dotStyle) },
            null,
            6,
          ),
        ]),
        f.tooltip !== "none"
          ? (Xi(),
            pn(
              "div",
              { key: 0, class: ra(I.tooltipClasses) },
              [
                bo(m.$slots, "tooltip", {}, () => [
                  ci(
                    "div",
                    {
                      class: ra(I.tooltipInnerClasses),
                      style: sa(f.tooltipStyle),
                    },
                    [ci("span", GA, An(I.tooltipValue), 1)],
                    6,
                  ),
                ]),
              ],
              2,
            ))
          : Fr("", !0),
      ],
      42,
      jA,
    )
  );
}
const $T = Ux(UA, [["render", $A]]),
  HA = {
    props: {
      mark: { type: Object, required: !0 },
      hideLabel: { type: Boolean, default: !1 },
      stepStyle: { type: Object, default: void 0 },
      stepActiveStyle: { type: Object, default: void 0 },
      labelStyle: { type: Object, default: void 0 },
      labelActiveStyle: { type: Object, default: void 0 },
    },
    computed: {
      marksClasses() {
        return [
          "vue-slider-mark",
          { "vue-slider-mark-active": this.mark.active },
        ];
      },
      stepClasses() {
        return [
          "vue-slider-mark-step",
          { "vue-slider-mark-step-active": this.mark.active },
        ];
      },
      labelClasses() {
        return [
          "vue-slider-mark-label",
          { "vue-slider-mark-label-active": this.mark.active },
        ];
      },
    },
    methods: {
      labelClickHandle(m) {
        (m.stopPropagation(), this.$emit("pressLabel", this.mark.pos));
      },
    },
  };
function WA(m, l, f, y, T, I) {
  return (
    Xi(),
    pn(
      "div",
      { class: ra(I.marksClasses) },
      [
        bo(m.$slots, "step", {}, () => [
          ci(
            "div",
            {
              class: ra(I.stepClasses),
              style: sa([
                f.stepStyle,
                f.mark.style,
                f.mark.active ? f.stepActiveStyle : null,
                f.mark.active ? f.mark.activeStyle : null,
              ]),
            },
            null,
            6,
          ),
        ]),
        f.hideLabel
          ? Fr("", !0)
          : bo(m.$slots, "label", { key: 0 }, () => [
              ci(
                "div",
                {
                  class: ra(I.labelClasses),
                  style: sa([
                    f.labelStyle,
                    f.mark.labelStyle,
                    f.mark.active ? f.labelActiveStyle : null,
                    f.mark.active ? f.mark.labelActiveStyle : null,
                  ]),
                  onClick:
                    l[0] ||
                    (l[0] = (...P) =>
                      I.labelClickHandle && I.labelClickHandle(...P)),
                },
                An(f.mark.label),
                7,
              ),
            ]),
      ],
      2,
    )
  );
}
const HT = Ux(HA, [["render", WA]]),
  $f = (m) => (typeof m == "number" ? `${m}px` : m),
  qA = (m) => {
    const l = document.documentElement,
      f = document.body,
      y = m.getBoundingClientRect();
    return {
      y:
        y.top +
        (window.pageYOffset || l.scrollTop) -
        (l.clientTop || f.clientTop || 0),
      x:
        y.left +
        (window.pageXOffset || l.scrollLeft) -
        (l.clientLeft || f.clientLeft || 0),
    };
  },
  ZA = (m, l, f) => {
    const y = "targetTouches" in m ? m.targetTouches[0] : m,
      T = qA(l),
      I = { x: y.pageX - T.x, y: y.pageY - T.y };
    return {
      x: f ? l.offsetWidth - I.x : I.x,
      y: f ? l.offsetHeight - I.y : I.y,
    };
  },
  XA = (m, l) => {
    if (l.hook) {
      const f = l.hook(m);
      if (typeof f == "function") return f;
      if (!f) return null;
    }
    switch (m.keyCode) {
      case 38:
        return (f) => (l.direction === "ttb" ? f - 1 : f + 1);
      case 39:
        return (f) => (l.direction === "rtl" ? f - 1 : f + 1);
      case 40:
        return (f) => (l.direction === "ttb" ? f + 1 : f - 1);
      case 37:
        return (f) => (l.direction === "rtl" ? f + 1 : f - 1);
      case 35:
        return () => l.max;
      case 36:
        return () => l.min;
      case 33:
        return (f) => f + 10;
      case 34:
        return (f) => f - 10;
      default:
        return null;
    }
  };
class Na {
  constructor(l) {
    (mr(this, "num"), (this.num = l));
  }
  decimal(l, f) {
    const y = this.num,
      T = this.getDecimalLen(y),
      I = this.getDecimalLen(l);
    let P = 0;
    switch (f) {
      case "+":
        ((P = this.getExponent(T, I)),
          (this.num = (this.safeRoundUp(y, P) + this.safeRoundUp(l, P)) / P));
        break;
      case "-":
        ((P = this.getExponent(T, I)),
          (this.num = (this.safeRoundUp(y, P) - this.safeRoundUp(l, P)) / P));
        break;
      case "*":
        this.num =
          this.safeRoundUp(
            this.safeRoundUp(y, this.getExponent(T)),
            this.safeRoundUp(l, this.getExponent(I)),
          ) / this.getExponent(T + I);
        break;
      case "/":
        ((P = this.getExponent(T, I)),
          (this.num = this.safeRoundUp(y, P) / this.safeRoundUp(l, P)));
        break;
      case "%":
        ((P = this.getExponent(T, I)),
          (this.num = (this.safeRoundUp(y, P) % this.safeRoundUp(l, P)) / P));
        break;
    }
    return this;
  }
  plus(l) {
    return this.decimal(l, "+");
  }
  minus(l) {
    return this.decimal(l, "-");
  }
  multiply(l) {
    return this.decimal(l, "*");
  }
  divide(l) {
    return this.decimal(l, "/");
  }
  remainder(l) {
    return this.decimal(l, "%");
  }
  toNumber() {
    return this.num;
  }
  getDecimalLen(l) {
    const f = `${l}`.split("e");
    return (`${f[0]}`.split(".")[1] || "").length - (f[1] ? +f[1] : 0);
  }
  getExponent(l, f) {
    return Math.pow(10, f !== void 0 ? Math.max(l, f) : l);
  }
  safeRoundUp(l, f) {
    return Math.round(l * f);
  }
}
const YA = {
  1: 'The type of the "value" is illegal',
  2: 'The prop "interval" is invalid, "(max - min)" must be divisible by "interval"',
  3: 'The "value" must be greater than or equal to the "min".',
  4: 'The "value" must be less than or equal to the "max".',
  5: 'When "order" is false, the parameters "minRange", "maxRange", "fixed", "enabled" are invalid.',
};
class KA {
  constructor(l) {
    (mr(this, "dotsPos", []),
      mr(this, "dotsValue", []),
      mr(this, "data"),
      mr(this, "enableCross"),
      mr(this, "fixed"),
      mr(this, "max"),
      mr(this, "min"),
      mr(this, "interval"),
      mr(this, "minRange"),
      mr(this, "maxRange"),
      mr(this, "order"),
      mr(this, "marks"),
      mr(this, "included"),
      mr(this, "process"),
      mr(this, "adsorb"),
      mr(this, "dotOptions"),
      mr(this, "onError"),
      mr(this, "cacheRangeDir", {}),
      (this.data = l.data),
      (this.max = l.max),
      (this.min = l.min),
      (this.interval = l.interval),
      (this.order = l.order),
      (this.marks = l.marks),
      (this.included = l.included),
      (this.process = l.process),
      (this.adsorb = l.adsorb),
      (this.dotOptions = l.dotOptions),
      (this.onError = l.onError),
      this.order
        ? ((this.minRange = l.minRange || 0),
          (this.maxRange = l.maxRange || 0),
          (this.enableCross = l.enableCross),
          (this.fixed = l.fixed))
        : ((l.minRange || l.maxRange || !l.enableCross || l.fixed) &&
            this.emitError(5),
          (this.minRange = 0),
          (this.maxRange = 0),
          (this.enableCross = !0),
          (this.fixed = !1)),
      this.setValue(l.value));
  }
  setValue(l) {
    this.setDotsValue(
      Array.isArray(l)
        ? this.order
          ? [...l].sort(
              (f, y) => this.getIndexByValue(f) - this.getIndexByValue(y),
            )
          : [...l]
        : [l],
      !0,
    );
  }
  setDotsValue(l, f) {
    ((this.dotsValue = l), f && this.syncDotsPos());
  }
  setDotsPos(l) {
    const f = this.order ? [...l].sort((y, T) => y - T) : l;
    ((this.dotsPos = f),
      this.setDotsValue(
        f.map((y) => this.getValueByPos(y)),
        this.adsorb,
      ));
  }
  getValueByPos(l) {
    let f = this.parsePos(l);
    if (this.included) {
      let y = 100;
      this.markList.forEach((T) => {
        const I = Math.abs(T.pos - l);
        I < y && ((y = I), (f = T.value));
      });
    }
    return f;
  }
  syncDotsPos() {
    this.dotsPos = this.dotsValue.map((l) => this.parseValue(l));
  }
  get markList() {
    if (!this.marks) return [];
    const l = (f, y) => {
      const T = this.parseValue(f);
      return {
        pos: T,
        value: f,
        label: f,
        active: this.isActiveByPos(T),
        ...y,
      };
    };
    return this.marks === !0
      ? this.getValues().map((f) => l(f))
      : Object.prototype.toString.call(this.marks) === "[object Object]"
        ? Object.keys(this.marks)
            .sort((f, y) => +f - +y)
            .map((f) => {
              const y = this.marks[f];
              return l(f, typeof y != "string" ? y : { label: y });
            })
        : Array.isArray(this.marks)
          ? this.marks.map((f) => l(f))
          : typeof this.marks == "function"
            ? this.getValues()
                .map((f) => ({ value: f, result: this.marks(f) }))
                .filter(({ result: f }) => !!f)
                .map(({ value: f, result: y }) => l(f, y))
            : [];
  }
  getRecentDot(l) {
    const f = this.dotsPos
      .filter(
        (y, T) => !(this.getDotOption(T) && this.getDotOption(T).disabled),
      )
      .map((y) => Math.abs(y - l));
    return f.indexOf(Math.min(...f));
  }
  getIndexByValue(l) {
    return this.data
      ? this.data.indexOf(l)
      : new Na(+l).minus(this.min).divide(this.interval).toNumber();
  }
  getValueByIndex(l) {
    return (
      l < 0 ? (l = 0) : l > this.total && (l = this.total),
      this.data
        ? this.data[l]
        : new Na(l).multiply(this.interval).plus(this.min).toNumber()
    );
  }
  setDotPos(l, f) {
    l = this.getValidPos(l, f).pos;
    const y = l - this.dotsPos[f];
    if (!y) return;
    let T = new Array(this.dotsPos.length);
    (this.fixed
      ? (T = this.getFixedChangePosArr(y, f))
      : this.minRange || this.maxRange
        ? (T = this.getLimitRangeChangePosArr(l, y, f))
        : (T[f] = y),
      this.setDotsPos(this.dotsPos.map((I, P) => I + (T[P] || 0))));
  }
  getFixedChangePosArr(l, f) {
    return (
      this.dotsPos.forEach((y, T) => {
        if (T !== f) {
          const { pos: I, inRange: P } = this.getValidPos(y + l, T);
          P || (l = Math.min(Math.abs(I - y), Math.abs(l)) * (l < 0 ? -1 : 1));
        }
      }),
      this.dotsPos.map((y) => l)
    );
  }
  getLimitRangeChangePosArr(l, f, y) {
    const T = [{ index: y, changePos: f }],
      I = f;
    return (
      [this.minRange, this.maxRange].forEach((P, r) => {
        if (!P) return !1;
        const F = r === 0,
          B = f > 0;
        let q = 0;
        F ? (q = B ? 1 : -1) : (q = B ? -1 : 1);
        const ne = (xe, we) => {
          const Ae = Math.abs(xe - we);
          return F ? Ae < this.minRangeDir : Ae > this.maxRangeDir;
        };
        let fe = y + q,
          de = this.dotsPos[fe],
          Ie = l;
        for (; this.isPos(de) && ne(de, Ie); ) {
          const { pos: xe } = this.getValidPos(de + I, fe);
          (T.push({ index: fe, changePos: xe - de }),
            (fe = fe + q),
            (Ie = xe),
            (de = this.dotsPos[fe]));
        }
      }),
      this.dotsPos.map((P, r) => {
        const F = T.filter((B) => B.index === r);
        return F.length ? F[0].changePos : 0;
      })
    );
  }
  isPos(l) {
    return typeof l == "number";
  }
  getValidPos(l, f) {
    const y = this.valuePosRange[f];
    let T = !0;
    return (
      l < y[0] ? ((l = y[0]), (T = !1)) : l > y[1] && ((l = y[1]), (T = !1)),
      { pos: l, inRange: T }
    );
  }
  parseValue(l) {
    if (this.data) l = this.data.indexOf(l);
    else if (typeof l == "number" || typeof l == "string") {
      if (((l = +l), l < this.min)) return (this.emitError(3), 0);
      if (l > this.max) return (this.emitError(4), 0);
      if (typeof l != "number" || l !== l) return (this.emitError(1), 0);
      l = new Na(l).minus(this.min).divide(this.interval).toNumber();
    }
    const f = new Na(l).multiply(this.gap).toNumber();
    return f < 0 ? 0 : f > 100 ? 100 : f;
  }
  parsePos(l) {
    const f = Math.round(l / this.gap);
    return this.getValueByIndex(f);
  }
  isActiveByPos(l) {
    return this.processArray.some(([f, y]) => l >= f && l <= y);
  }
  getValues() {
    if (this.data) return this.data;
    {
      const l = [];
      for (let f = 0; f <= this.total; f++)
        l.push(new Na(f).multiply(this.interval).plus(this.min).toNumber());
      return l;
    }
  }
  getRangeDir(l) {
    return l
      ? new Na(l)
          .divide(
            new Na(this.data ? this.data.length - 1 : this.max)
              .minus(this.data ? 0 : this.min)
              .toNumber(),
          )
          .multiply(100)
          .toNumber()
      : 100;
  }
  emitError(l) {
    this.onError && this.onError(l, YA[l]);
  }
  get processArray() {
    if (this.process) {
      if (typeof this.process == "function") return this.process(this.dotsPos);
      if (this.dotsPos.length === 1) return [[0, this.dotsPos[0]]];
      if (this.dotsPos.length > 1)
        return [[Math.min(...this.dotsPos), Math.max(...this.dotsPos)]];
    }
    return [];
  }
  get total() {
    let l = 0;
    return (
      this.data
        ? (l = this.data.length - 1)
        : (l = new Na(this.max)
            .minus(this.min)
            .divide(this.interval)
            .toNumber()),
      l - Math.floor(l) !== 0 ? (this.emitError(2), 0) : l
    );
  }
  get gap() {
    return 100 / this.total;
  }
  get minRangeDir() {
    return this.cacheRangeDir[this.minRange]
      ? this.cacheRangeDir[this.minRange]
      : (this.cacheRangeDir[this.minRange] = this.getRangeDir(this.minRange));
  }
  get maxRangeDir() {
    return this.cacheRangeDir[this.maxRange]
      ? this.cacheRangeDir[this.maxRange]
      : (this.cacheRangeDir[this.maxRange] = this.getRangeDir(this.maxRange));
  }
  getDotOption(l) {
    return Array.isArray(this.dotOptions)
      ? this.dotOptions[l]
      : this.dotOptions;
  }
  getDotRange(l, f, y) {
    if (!this.dotOptions) return y;
    const T = this.getDotOption(l);
    return T && T[f] !== void 0 ? this.parseValue(T[f]) : y;
  }
  get valuePosRange() {
    const l = this.dotsPos,
      f = [];
    return (
      l.forEach((y, T) => {
        f.push([
          Math.max(
            this.minRange ? this.minRangeDir * T : 0,
            this.enableCross ? 0 : l[T - 1] || 0,
            this.getDotRange(T, "min", 0),
          ),
          Math.min(
            this.minRange ? 100 - this.minRangeDir * (l.length - 1 - T) : 100,
            this.enableCross ? 100 : l[T + 1] || 100,
            this.getDotRange(T, "max", 100),
          ),
        ]);
      }),
      f
    );
  }
  get dotsIndex() {
    return this.dotsValue.map((l) => this.getIndexByValue(l));
  }
}
class JA {
  constructor(l) {
    (mr(this, "map"), mr(this, "states", 0), (this.map = l));
  }
  add(l) {
    this.states |= l;
  }
  delete(l) {
    this.states &= ~l;
  }
  toggle(l) {
    this.has(l) ? this.delete(l) : this.add(l);
  }
  has(l) {
    return !!(this.states & l);
  }
}
const hx = 4,
  Wr = { None: 0, Drag: 2, Focus: 4 },
  QA = {
    emits: [
      "update:modelValue",
      "change",
      "drag-start",
      "drag-end",
      "dragging",
      "error",
    ],
    components: { VueSliderDot: $T, VueSliderMark: HT },
    props: {
      modelValue: { type: [Number, String, Array], default: 0 },
      silent: { type: Boolean, default: !1 },
      direction: {
        type: String,
        default: "ltr",
        validator: (m) => ["ltr", "rtl", "ttb", "btt"].indexOf(m) > -1,
      },
      width: { type: [Number, String], default: void 0 },
      height: { type: [Number, String], default: void 0 },
      dotSize: { type: [Array, Number], default: 14 },
      contained: { type: Boolean, default: !1 },
      min: { type: Number, default: 0 },
      max: { type: Number, default: 100 },
      interval: { type: Number, default: 1 },
      disabled: { type: Boolean, default: !1 },
      clickable: { type: Boolean, default: !0 },
      dragOnClick: { type: Boolean, default: !0 },
      duration: { type: Number, default: 0.5 },
      data: { type: [Object, Array], default: void 0 },
      dataValue: { type: String, default: "value" },
      dataLabel: { type: String, default: "label" },
      lazy: { type: Boolean, default: !1 },
      tooltip: {
        type: String,
        default: "active",
        validator: (m) =>
          ["none", "always", "focus", "hover", "active"].indexOf(m) > -1,
      },
      tooltipPlacement: {
        type: [String, Array],
        default: void 0,
        validator: (m) =>
          (Array.isArray(m) ? m : [m]).every(
            (l) => ["top", "right", "bottom", "left"].indexOf(l) > -1,
          ),
      },
      tooltipFormatter: { type: [String, Array, Function], default: "" },
      useKeyboard: { type: Boolean, default: !0 },
      keydownHook: { type: [Boolean, Function], default: void 0 },
      enableCross: { type: Boolean, default: !0 },
      fixed: { type: Boolean, default: !1 },
      order: { type: Boolean, default: !0 },
      minRange: { type: Number, default: void 0 },
      maxRange: { type: Number, default: void 0 },
      marks: { type: [Boolean, Object, Array, Function], default: !1 },
      process: { type: [Boolean, Function], default: !0 },
      zoom: { type: [Number], default: void 0 },
      included: { type: [Boolean], default: !1 },
      adsorb: { type: [Boolean], default: !1 },
      hideLabel: { type: [Boolean], default: !1 },
      dotOptions: { type: Object, default: void 0 },
      dotAttrs: { type: Object, default: void 0 },
      railStyle: { type: Object, default: null },
      processStyle: { type: Object, default: null },
      dotStyle: { type: Object, default: null },
      tooltipStyle: { type: Object, default: null },
      stepStyle: { type: Object, default: null },
      stepActiveStyle: { type: Object, default: null },
      labelStyle: { type: Object, default: null },
      labelActiveStyle: { type: Object, default: null },
    },
    data() {
      return { control: null, states: new JA(Wr), scale: 1, focusDotIndex: 0 };
    },
    computed: {
      tailSize() {
        return $f((this.isHorizontal ? this.height : this.width) || hx);
      },
      containerClasses() {
        return [
          "vue-slider",
          [`vue-slider-${this.direction}`],
          { "vue-slider-disabled": this.disabled },
        ];
      },
      containerStyles() {
        const [m, l] = Array.isArray(this.dotSize)
            ? this.dotSize
            : [this.dotSize, this.dotSize],
          f = this.width ? $f(this.width) : this.isHorizontal ? "auto" : $f(hx),
          y = this.height
            ? $f(this.height)
            : this.isHorizontal
              ? $f(hx)
              : "auto";
        return {
          padding: this.contained
            ? `${l / 2}px ${m / 2}px`
            : this.isHorizontal
              ? `${l / 2}px 0`
              : `0 ${m / 2}px`,
          width: f,
          height: y,
        };
      },
      processArray() {
        return this.control.processArray.map(([m, l, f], y) => {
          m > l && ([m, l] = [l, m]);
          const T = this.isHorizontal ? "width" : "height";
          return {
            start: m,
            end: l,
            index: y,
            style: {
              [this.isHorizontal ? "height" : "width"]: "100%",
              [this.isHorizontal ? "top" : "left"]: 0,
              [this.mainDirection]: `${m}%`,
              [T]: `${l - m}%`,
              transitionProperty: `${T},${this.mainDirection}`,
              transitionDuration: `${this.animateTime}s`,
              ...this.processStyle,
              ...f,
            },
          };
        });
      },
      dotBaseStyle() {
        const [m, l] = Array.isArray(this.dotSize)
          ? this.dotSize
          : [this.dotSize, this.dotSize];
        let f;
        return (
          this.isHorizontal
            ? (f = {
                transform: `translate(${this.isReverse ? "50%" : "-50%"}, -50%)`,
                "-WebkitTransform": `translate(${this.isReverse ? "50%" : "-50%"}, -50%)`,
                top: "50%",
                [this.direction === "ltr" ? "left" : "right"]: "0",
              })
            : (f = {
                transform: `translate(-50%, ${this.isReverse ? "50%" : "-50%"})`,
                "-WebkitTransform": `translate(-50%, ${this.isReverse ? "50%" : "-50%"})`,
                left: "50%",
                [this.direction === "btt" ? "bottom" : "top"]: "0",
              }),
          { width: `${m}px`, height: `${l}px`, ...f }
        );
      },
      mainDirection() {
        switch (this.direction) {
          case "ltr":
            return "left";
          case "rtl":
            return "right";
          case "btt":
            return "bottom";
          case "ttb":
            return "top";
        }
      },
      isHorizontal() {
        return this.direction === "ltr" || this.direction === "rtl";
      },
      isReverse() {
        return this.direction === "rtl" || this.direction === "btt";
      },
      tooltipDirections() {
        const m = this.tooltipPlacement || (this.isHorizontal ? "top" : "left");
        return Array.isArray(m) ? m : this.dots.map(() => m);
      },
      dots() {
        return this.control.dotsPos.map((m, l) => ({
          pos: m,
          index: l,
          value: this.control.dotsValue[l],
          focus: this.states.has(Wr.Focus) && this.focusDotIndex === l,
          disabled: this.disabled,
          style: this.dotStyle,
          ...((Array.isArray(this.dotOptions)
            ? this.dotOptions[l]
            : this.dotOptions) || {}),
        }));
      },
      animateTime() {
        return this.states.has(Wr.Drag) ? 0 : this.duration;
      },
      canSort() {
        return (
          this.order &&
          !this.minRange &&
          !this.maxRange &&
          !this.fixed &&
          this.enableCross
        );
      },
      sliderData() {
        return this.isObjectArrayData(this.data)
          ? this.data.map((m) => m[this.dataValue])
          : this.isObjectData(this.data)
            ? Object.keys(this.data)
            : this.data;
      },
      sliderMarks() {
        if (this.marks) return this.marks;
        if (this.isObjectArrayData(this.data))
          return (m) => {
            const l = { label: m };
            return (
              this.data.some((f) =>
                f[this.dataValue] === m
                  ? ((l.label = f[this.dataLabel]), !0)
                  : !1,
              ),
              l
            );
          };
        if (this.isObjectData(this.data)) return this.data;
      },
      sliderTooltipFormatter() {
        if (this.tooltipFormatter) return this.tooltipFormatter;
        if (this.isObjectArrayData(this.data))
          return (m) => {
            let l = "" + m;
            return (
              this.data.some((f) =>
                f[this.dataValue] === m ? ((l = f[this.dataLabel]), !0) : !1,
              ),
              l
            );
          };
        if (this.isObjectData(this.data)) {
          const m = this.data;
          return (l) => m[l];
        }
      },
      isNotSync() {
        const m = this.control.dotsValue;
        return Array.isArray(this.modelValue)
          ? this.modelValue.length !== m.length ||
              this.modelValue.some((l, f) => l !== m[f])
          : this.modelValue !== m[0];
      },
      dragRange() {
        const m = this.dots[this.focusDotIndex - 1],
          l = this.dots[this.focusDotIndex + 1];
        return [m ? m.pos : -1 / 0, l ? l.pos : 1 / 0];
      },
    },
    created() {
      this.initControl();
    },
    mounted() {
      this.bindEvent();
    },
    beforeUnmount() {
      this.unbindEvent();
    },
    methods: {
      isObjectData(m) {
        return !!m && Object.prototype.toString.call(m) === "[object Object]";
      },
      isObjectArrayData(m) {
        return (
          !!m && Array.isArray(m) && m.length > 0 && typeof m[0] == "object"
        );
      },
      bindEvent() {
        (document.addEventListener("touchmove", this.dragMove, { passive: !1 }),
          document.addEventListener("touchend", this.dragEnd, { passive: !1 }),
          document.addEventListener("mousedown", this.blurHandle),
          document.addEventListener("mousemove", this.dragMove, {
            passive: !1,
          }),
          document.addEventListener("mouseup", this.dragEnd),
          document.addEventListener("mouseleave", this.dragEnd),
          document.addEventListener("keydown", this.keydownHandle));
      },
      unbindEvent() {
        (document.removeEventListener("touchmove", this.dragMove),
          document.removeEventListener("touchend", this.dragEnd),
          document.removeEventListener("mousedown", this.blurHandle),
          document.removeEventListener("mousemove", this.dragMove),
          document.removeEventListener("mouseup", this.dragEnd),
          document.removeEventListener("mouseleave", this.dragEnd),
          document.removeEventListener("keydown", this.keydownHandle));
      },
      setScale() {
        const m = new Na(
          Math.floor(
            this.isHorizontal
              ? this.$refs.rail.offsetWidth
              : this.$refs.rail.offsetHeight,
          ),
        );
        (this.zoom !== void 0 && m.multiply(this.zoom),
          m.divide(100),
          (this.scale = m.toNumber()));
      },
      initControl() {
        ((this.control = new KA({
          value: this.modelValue,
          data: this.sliderData,
          enableCross: this.enableCross,
          fixed: this.fixed,
          max: this.max,
          min: this.min,
          interval: this.interval,
          minRange: this.minRange,
          maxRange: this.maxRange,
          order: this.order,
          marks: this.sliderMarks,
          included: this.included,
          process: this.process,
          adsorb: this.adsorb,
          dotOptions: this.dotOptions,
          onError: this.emitError,
        })),
          this.syncValueByPos(),
          [
            "data",
            "enableCross",
            "fixed",
            "max",
            "min",
            "interval",
            "minRange",
            "maxRange",
            "order",
            "marks",
            "process",
            "adsorb",
            "included",
            "dotOptions",
          ].forEach((m) => {
            this.$watch(m, (l) => {
              if (
                m === "data" &&
                Array.isArray(this.control.data) &&
                Array.isArray(l) &&
                this.control.data.length === l.length &&
                l.every((f, y) => f === this.control.data[y])
              )
                return !1;
              switch (m) {
                case "data":
                case "dataLabel":
                case "dataValue":
                  this.control.data = this.sliderData;
                  break;
                case "mark":
                  this.control.marks = this.sliderMarks;
                  break;
                default:
                  this.control[m] = l;
              }
              ["data", "max", "min", "interval"].indexOf(m) > -1 &&
                this.control.syncDotsPos();
            });
          }));
      },
      syncValueByPos() {
        const m = this.control.dotsValue;
        if (
          this.isDiff(
            m,
            Array.isArray(this.modelValue)
              ? this.modelValue
              : [this.modelValue],
          )
        ) {
          const l = m.length === 1 ? m[0] : [...m];
          (this.$emit("change", l, this.focusDotIndex),
            this.$emit("update:modelValue", l, this.focusDotIndex));
        }
      },
      isDiff(m, l) {
        return m.length !== l.length || m.some((f, y) => f !== l[y]);
      },
      emitError(m, l) {
        (this.silent || console.error(`[VueSlider error]: ${l}`),
          this.$emit("error", m, l));
      },
      dragStartOnProcess(m) {
        if (this.dragOnClick) {
          this.setScale();
          const l = this.getPosByEvent(m),
            f = this.control.getRecentDot(l);
          if (this.dots[f].disabled) return;
          (this.dragStart(f),
            this.control.setDotPos(l, this.focusDotIndex),
            this.lazy || this.syncValueByPos());
        }
      },
      dragStart(m) {
        ((this.focusDotIndex = m),
          this.setScale(),
          this.states.add(Wr.Drag),
          this.states.add(Wr.Focus),
          this.$emit("drag-start", this.focusDotIndex));
      },
      dragMove(m) {
        if (!this.states.has(Wr.Drag)) return !1;
        m.preventDefault();
        const l = this.getPosByEvent(m);
        (this.isCrossDot(l),
          this.control.setDotPos(l, this.focusDotIndex),
          this.lazy || this.syncValueByPos());
        const f = this.control.dotsValue;
        this.$emit(
          "dragging",
          f.length === 1 ? f[0] : [...f],
          this.focusDotIndex,
        );
      },
      isCrossDot(m) {
        if (this.canSort) {
          const l = this.focusDotIndex;
          let f = m;
          if (
            (f > this.dragRange[1]
              ? ((f = this.dragRange[1]), this.focusDotIndex++)
              : f < this.dragRange[0] &&
                ((f = this.dragRange[0]), this.focusDotIndex--),
            l !== this.focusDotIndex)
          ) {
            const y = this.$refs[`dot-${this.focusDotIndex}`];
            (y && y.$el && y.$el.focus(), this.control.setDotPos(f, l));
          }
        }
      },
      dragEnd(m) {
        if (!this.states.has(Wr.Drag)) return !1;
        setTimeout(() => {
          (this.lazy && this.syncValueByPos(),
            this.included && this.isNotSync
              ? this.control.setValue(this.modelValue)
              : this.control.syncDotsPos(),
            this.states.delete(Wr.Drag),
            (!this.useKeyboard || "targetTouches" in m) &&
              this.states.delete(Wr.Focus),
            this.$emit("drag-end", this.focusDotIndex));
        });
      },
      blurHandle(m) {
        if (
          !this.states.has(Wr.Focus) ||
          !this.$refs.container ||
          this.$refs.container.contains(m.target)
        )
          return !1;
        this.states.delete(Wr.Focus);
      },
      clickHandle(m) {
        if (!this.clickable || this.disabled) return !1;
        if (this.states.has(Wr.Drag)) return;
        this.setScale();
        const l = this.getPosByEvent(m);
        this.setValueByPos(l);
      },
      focus(m = 0) {
        (this.states.add(Wr.Focus), (this.focusDotIndex = m));
      },
      blur() {
        this.states.delete(Wr.Focus);
      },
      getValue() {
        const m = this.control.dotsValue;
        return m.length === 1 ? m[0] : m;
      },
      getIndex() {
        const m = this.control.dotsIndex;
        return m.length === 1 ? m[0] : m;
      },
      setValue(m) {
        (this.control.setValue(Array.isArray(m) ? [...m] : [m]),
          this.syncValueByPos());
      },
      setIndex(m) {
        const l = Array.isArray(m)
          ? m.map((f) => this.control.getValueByIndex(f))
          : this.control.getValueByIndex(m);
        this.setValue(l);
      },
      setValueByPos(m) {
        const l = this.control.getRecentDot(m);
        if (this.disabled || this.dots[l].disabled) return !1;
        ((this.focusDotIndex = l),
          this.control.setDotPos(m, l),
          this.syncValueByPos(),
          this.useKeyboard && this.states.add(Wr.Focus),
          setTimeout(() => {
            this.included && this.isNotSync
              ? this.control.setValue(this.modelValue)
              : this.control.syncDotsPos();
          }));
      },
      keydownHandle(m) {
        if (!this.useKeyboard || !this.states.has(Wr.Focus)) return !1;
        const l = this.included && this.marks,
          f = XA(m, {
            direction: this.direction,
            max: l ? this.control.markList.length - 1 : this.control.total,
            min: 0,
            hook: this.keydownHook,
          });
        if (f) {
          m.preventDefault();
          let y = -1,
            T = 0;
          (l
            ? (this.control.markList.some((I, P) =>
                I.value === this.control.dotsValue[this.focusDotIndex]
                  ? ((y = f(P)), !0)
                  : !1,
              ),
              y < 0
                ? (y = 0)
                : y > this.control.markList.length - 1 &&
                  (y = this.control.markList.length - 1),
              (T = this.control.markList[y].pos))
            : ((y = f(
                this.control.getIndexByValue(
                  this.control.dotsValue[this.focusDotIndex],
                ),
              )),
              (T = this.control.parseValue(this.control.getValueByIndex(y)))),
            this.isCrossDot(T),
            this.control.setDotPos(T, this.focusDotIndex),
            this.syncValueByPos());
        }
      },
      getPosByEvent(m) {
        return (
          ZA(m, this.$refs.rail, this.isReverse)[
            this.isHorizontal ? "x" : "y"
          ] / this.scale
        );
      },
    },
    watch: {
      modelValue: {
        handler() {
          this.control &&
            !this.states.has(Wr.Drag) &&
            this.isNotSync &&
            (this.control.setValue(this.modelValue), this.syncValueByPos());
        },
        deep: !0,
      },
    },
  },
  eM = { key: 0, class: "vue-slider-marks" };
function tM(m, l, f, y, T, I) {
  const P = hw("VueSliderMark"),
    r = hw("VueSliderDot");
  return (
    Xi(),
    pn(
      "div",
      Ws(
        {
          ref: "container",
          class: I.containerClasses,
          style: I.containerStyles,
          onClick:
            l[1] || (l[1] = (...F) => I.clickHandle && I.clickHandle(...F)),
          onTouchstartPassive:
            l[2] ||
            (l[2] = (...F) =>
              I.dragStartOnProcess && I.dragStartOnProcess(...F)),
          onMousedown:
            l[3] ||
            (l[3] = (...F) =>
              I.dragStartOnProcess && I.dragStartOnProcess(...F)),
        },
        m.$attrs,
      ),
      [
        ci(
          "div",
          { ref: "rail", class: "vue-slider-rail", style: sa(f.railStyle) },
          [
            (Xi(!0),
            pn(
              Yf,
              null,
              Og(I.processArray, (F, B) =>
                bo(m.$slots, "process", Ws({ ref_for: !0 }, { ...F }), () => [
                  (Xi(),
                  pn(
                    "div",
                    {
                      class: "vue-slider-process",
                      key: `process-${B}`,
                      style: sa(F.style),
                    },
                    null,
                    4,
                  )),
                ]),
              ),
              256,
            )),
            I.sliderMarks
              ? (Xi(),
                pn("div", eM, [
                  (Xi(!0),
                  pn(
                    Yf,
                    null,
                    Og(T.control.markList, (F, B) =>
                      bo(
                        m.$slots,
                        "mark",
                        Ws({ ref_for: !0 }, { ...F }),
                        () => [
                          (Xi(),
                          rp(
                            P,
                            {
                              key: `mark-${B}`,
                              mark: F,
                              hideLabel: f.hideLabel,
                              style: sa({
                                [I.isHorizontal ? "height" : "width"]: "100%",
                                [I.isHorizontal ? "width" : "height"]:
                                  I.tailSize,
                                [I.mainDirection]: `${F.pos}%`,
                              }),
                              stepStyle: f.stepStyle,
                              stepActiveStyle: f.stepActiveStyle,
                              labelStyle: f.labelStyle,
                              labelActiveStyle: f.labelActiveStyle,
                              onPressLabel: (q) =>
                                f.clickable && I.setValueByPos(q),
                            },
                            {
                              step: mh(() => [
                                bo(
                                  m.$slots,
                                  "step",
                                  Ws({ ref_for: !0 }, { ...F }),
                                ),
                              ]),
                              label: mh(() => [
                                bo(
                                  m.$slots,
                                  "label",
                                  Ws({ ref_for: !0 }, { ...F }),
                                ),
                              ]),
                              _: 2,
                            },
                            1032,
                            [
                              "mark",
                              "hideLabel",
                              "style",
                              "stepStyle",
                              "stepActiveStyle",
                              "labelStyle",
                              "labelActiveStyle",
                              "onPressLabel",
                            ],
                          )),
                        ],
                      ),
                    ),
                    256,
                  )),
                ]))
              : Fr("", !0),
            (Xi(!0),
            pn(
              Yf,
              null,
              Og(
                I.dots,
                (F, B) => (
                  Xi(),
                  pn(
                    Yf,
                    null,
                    [
                      Lt(
                        r,
                        Ws(
                          {
                            ref_for: !0,
                            ref: `dot-${B}`,
                            value: F.value,
                            disabled: F.disabled,
                            focus: F.focus,
                            "dot-style": [
                              F.style,
                              F.disabled ? F.disabledStyle : null,
                              F.focus ? F.focusStyle : null,
                            ],
                            tooltip: F.tooltip || f.tooltip,
                            "tooltip-style": [
                              f.tooltipStyle,
                              F.tooltipStyle,
                              F.disabled ? F.tooltipDisabledStyle : null,
                              F.focus ? F.tooltipFocusStyle : null,
                            ],
                            "tooltip-formatter": Array.isArray(
                              I.sliderTooltipFormatter,
                            )
                              ? I.sliderTooltipFormatter[B]
                              : I.sliderTooltipFormatter,
                            "tooltip-placement": I.tooltipDirections[B],
                            style: [
                              I.dotBaseStyle,
                              {
                                [I.mainDirection]: `${F.pos}%`,
                                transition: `${I.mainDirection} ${I.animateTime}s`,
                              },
                            ],
                            "onDrag-start": () => I.dragStart(B),
                            role: "slider",
                            "aria-valuenow": F.value,
                            "aria-valuemin": this.min,
                            "aria-valuemax": this.max,
                            "aria-orientation": this.isHorizontal
                              ? "horizontal"
                              : "vertical",
                            tabindex: "0",
                            onFocus: () => !F.disabled && I.focus(B),
                            onBlur: l[0] || (l[0] = () => I.blur()),
                          },
                          { ...f.dotAttrs },
                        ),
                        {
                          dot: mh(() => [
                            bo(m.$slots, "dot", Ws({ ref_for: !0 }, { ...F })),
                          ]),
                          tooltip: mh(() => [
                            bo(
                              m.$slots,
                              "tooltip",
                              Ws({ ref_for: !0 }, { ...F }),
                            ),
                          ]),
                          _: 2,
                        },
                        1040,
                        [
                          "value",
                          "disabled",
                          "focus",
                          "dot-style",
                          "tooltip",
                          "tooltip-style",
                          "tooltip-formatter",
                          "tooltip-placement",
                          "style",
                          "onDrag-start",
                          "aria-valuenow",
                          "aria-valuemin",
                          "aria-valuemax",
                          "aria-orientation",
                          "onFocus",
                        ],
                      ),
                      bo(
                        m.$slots,
                        "default",
                        Ws({ ref_for: !0 }, { value: I.getValue() }),
                      ),
                    ],
                    64,
                  )
                ),
              ),
              256,
            )),
          ],
          4,
        ),
      ],
      16,
    )
  );
}
const jx = Ux(QA, [["render", tM]]);
jx.VueSliderMark = HT;
jx.VueSliderDot = $T;
const iM = { class: "mt-4 mb-10" },
  nM = { class: "text-2xl font-semibold mb-2" },
  rM = { class: "mb-6" },
  sM = aa({
    __name: "AlertsSlider",
    props: { dateOptions: Array },
    emits: ["date-range-changed"],
    setup(m, { emit: l }) {
      const f = m;
      bh(() => {
        f.dateOptions &&
          f.dateOptions.length > 0 &&
          (y.value = [
            f.dateOptions[0],
            f.dateOptions[f.dateOptions.length - 1],
          ]);
      });
      const y = $n(),
        T = $n(!1),
        I = l;
      return (
        Yl(y, (P) => {
          T.value && I("date-range-changed", P);
        }),
        (P, r) => (
          Xi(),
          pn("div", iM, [
            ci("h3", nM, An(P.$t("selectAlertDateRange")), 1),
            ci("div", rM, [
              Lt(
                sr(jx),
                {
                  modelValue: sr(y),
                  "onUpdate:modelValue":
                    r[0] || (r[0] = (F) => (Wu(y) ? (y.value = F) : null)),
                  class: "date-slider",
                  contained: !0,
                  data: m.dateOptions,
                  height: 8,
                  "hide-label": !0,
                  marks: !0,
                  tooltip: "always",
                  "tooltip-placement": "bottom",
                  onDragStart: r[1] || (r[1] = (F) => (T.value = !0)),
                },
                null,
                8,
                ["modelValue", "data"],
              ),
            ]),
          ])
        )
      );
    },
  });
/*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */ function vp(m) {
  return (m + 0.5) | 0;
}
const ql = (m, l, f) => Math.max(Math.min(m, f), l);
function Jf(m) {
  return ql(vp(m * 2.55), 0, 255);
}
function Xl(m) {
  return ql(vp(m * 255), 0, 255);
}
function ja(m) {
  return ql(vp(m / 2.55) / 100, 0, 1);
}
function mw(m) {
  return ql(vp(m * 100), 0, 100);
}
const Hs = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15,
  },
  Ex = [..."0123456789ABCDEF"],
  oM = (m) => Ex[m & 15],
  aM = (m) => Ex[(m & 240) >> 4] + Ex[m & 15],
  vg = (m) => (m & 240) >> 4 === (m & 15),
  lM = (m) => vg(m.r) && vg(m.g) && vg(m.b) && vg(m.a);
function cM(m) {
  var l = m.length,
    f;
  return (
    m[0] === "#" &&
      (l === 4 || l === 5
        ? (f = {
            r: 255 & (Hs[m[1]] * 17),
            g: 255 & (Hs[m[2]] * 17),
            b: 255 & (Hs[m[3]] * 17),
            a: l === 5 ? Hs[m[4]] * 17 : 255,
          })
        : (l === 7 || l === 9) &&
          (f = {
            r: (Hs[m[1]] << 4) | Hs[m[2]],
            g: (Hs[m[3]] << 4) | Hs[m[4]],
            b: (Hs[m[5]] << 4) | Hs[m[6]],
            a: l === 9 ? (Hs[m[7]] << 4) | Hs[m[8]] : 255,
          })),
    f
  );
}
const hM = (m, l) => (m < 255 ? l(m) : "");
function uM(m) {
  var l = lM(m) ? oM : aM;
  return m ? "#" + l(m.r) + l(m.g) + l(m.b) + hM(m.a, l) : void 0;
}
const dM =
  /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function WT(m, l, f) {
  const y = l * Math.min(f, 1 - f),
    T = (I, P = (I + m / 30) % 12) =>
      f - y * Math.max(Math.min(P - 3, 9 - P, 1), -1);
  return [T(0), T(8), T(4)];
}
function fM(m, l, f) {
  const y = (T, I = (T + m / 60) % 6) =>
    f - f * l * Math.max(Math.min(I, 4 - I, 1), 0);
  return [y(5), y(3), y(1)];
}
function pM(m, l, f) {
  const y = WT(m, 1, 0.5);
  let T;
  for (l + f > 1 && ((T = 1 / (l + f)), (l *= T), (f *= T)), T = 0; T < 3; T++)
    ((y[T] *= 1 - l - f), (y[T] += l));
  return y;
}
function mM(m, l, f, y, T) {
  return m === T
    ? (l - f) / y + (l < f ? 6 : 0)
    : l === T
      ? (f - m) / y + 2
      : (m - l) / y + 4;
}
function Gx(m) {
  const f = m.r / 255,
    y = m.g / 255,
    T = m.b / 255,
    I = Math.max(f, y, T),
    P = Math.min(f, y, T),
    r = (I + P) / 2;
  let F, B, q;
  return (
    I !== P &&
      ((q = I - P),
      (B = r > 0.5 ? q / (2 - I - P) : q / (I + P)),
      (F = mM(f, y, T, q, I)),
      (F = F * 60 + 0.5)),
    [F | 0, B || 0, r]
  );
}
function $x(m, l, f, y) {
  return (Array.isArray(l) ? m(l[0], l[1], l[2]) : m(l, f, y)).map(Xl);
}
function Hx(m, l, f) {
  return $x(WT, m, l, f);
}
function gM(m, l, f) {
  return $x(pM, m, l, f);
}
function _M(m, l, f) {
  return $x(fM, m, l, f);
}
function qT(m) {
  return ((m % 360) + 360) % 360;
}
function yM(m) {
  const l = dM.exec(m);
  let f = 255,
    y;
  if (!l) return;
  l[5] !== y && (f = l[6] ? Jf(+l[5]) : Xl(+l[5]));
  const T = qT(+l[2]),
    I = +l[3] / 100,
    P = +l[4] / 100;
  return (
    l[1] === "hwb"
      ? (y = gM(T, I, P))
      : l[1] === "hsv"
        ? (y = _M(T, I, P))
        : (y = Hx(T, I, P)),
    { r: y[0], g: y[1], b: y[2], a: f }
  );
}
function xM(m, l) {
  var f = Gx(m);
  ((f[0] = qT(f[0] + l)),
    (f = Hx(f)),
    (m.r = f[0]),
    (m.g = f[1]),
    (m.b = f[2]));
}
function vM(m) {
  if (!m) return;
  const l = Gx(m),
    f = l[0],
    y = mw(l[1]),
    T = mw(l[2]);
  return m.a < 255
    ? `hsla(${f}, ${y}%, ${T}%, ${ja(m.a)})`
    : `hsl(${f}, ${y}%, ${T}%)`;
}
const gw = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh",
  },
  _w = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32",
  };
function bM() {
  const m = {},
    l = Object.keys(_w),
    f = Object.keys(gw);
  let y, T, I, P, r;
  for (y = 0; y < l.length; y++) {
    for (P = r = l[y], T = 0; T < f.length; T++)
      ((I = f[T]), (r = r.replace(I, gw[I])));
    ((I = parseInt(_w[P], 16)),
      (m[r] = [(I >> 16) & 255, (I >> 8) & 255, I & 255]));
  }
  return m;
}
let bg;
function wM(m) {
  bg || ((bg = bM()), (bg.transparent = [0, 0, 0, 0]));
  const l = bg[m.toLowerCase()];
  return l && { r: l[0], g: l[1], b: l[2], a: l.length === 4 ? l[3] : 255 };
}
const TM =
  /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function SM(m) {
  const l = TM.exec(m);
  let f = 255,
    y,
    T,
    I;
  if (l) {
    if (l[7] !== y) {
      const P = +l[7];
      f = l[8] ? Jf(P) : ql(P * 255, 0, 255);
    }
    return (
      (y = +l[1]),
      (T = +l[3]),
      (I = +l[5]),
      (y = 255 & (l[2] ? Jf(y) : ql(y, 0, 255))),
      (T = 255 & (l[4] ? Jf(T) : ql(T, 0, 255))),
      (I = 255 & (l[6] ? Jf(I) : ql(I, 0, 255))),
      { r: y, g: T, b: I, a: f }
    );
  }
}
function EM(m) {
  return (
    m &&
    (m.a < 255
      ? `rgba(${m.r}, ${m.g}, ${m.b}, ${ja(m.a)})`
      : `rgb(${m.r}, ${m.g}, ${m.b})`)
  );
}
const ux = (m) =>
    m <= 0.0031308 ? m * 12.92 : Math.pow(m, 1 / 2.4) * 1.055 - 0.055,
  $u = (m) => (m <= 0.04045 ? m / 12.92 : Math.pow((m + 0.055) / 1.055, 2.4));
function IM(m, l, f) {
  const y = $u(ja(m.r)),
    T = $u(ja(m.g)),
    I = $u(ja(m.b));
  return {
    r: Xl(ux(y + f * ($u(ja(l.r)) - y))),
    g: Xl(ux(T + f * ($u(ja(l.g)) - T))),
    b: Xl(ux(I + f * ($u(ja(l.b)) - I))),
    a: m.a + f * (l.a - m.a),
  };
}
function wg(m, l, f) {
  if (m) {
    let y = Gx(m);
    ((y[l] = Math.max(0, Math.min(y[l] + y[l] * f, l === 0 ? 360 : 1))),
      (y = Hx(y)),
      (m.r = y[0]),
      (m.g = y[1]),
      (m.b = y[2]));
  }
}
function ZT(m, l) {
  return m && Object.assign(l || {}, m);
}
function yw(m) {
  var l = { r: 0, g: 0, b: 0, a: 255 };
  return (
    Array.isArray(m)
      ? m.length >= 3 &&
        ((l = { r: m[0], g: m[1], b: m[2], a: 255 }),
        m.length > 3 && (l.a = Xl(m[3])))
      : ((l = ZT(m, { r: 0, g: 0, b: 0, a: 1 })), (l.a = Xl(l.a))),
    l
  );
}
function AM(m) {
  return m.charAt(0) === "r" ? SM(m) : yM(m);
}
class fp {
  constructor(l) {
    if (l instanceof fp) return l;
    const f = typeof l;
    let y;
    (f === "object"
      ? (y = yw(l))
      : f === "string" && (y = cM(l) || wM(l) || AM(l)),
      (this._rgb = y),
      (this._valid = !!y));
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var l = ZT(this._rgb);
    return (l && (l.a = ja(l.a)), l);
  }
  set rgb(l) {
    this._rgb = yw(l);
  }
  rgbString() {
    return this._valid ? EM(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? uM(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? vM(this._rgb) : void 0;
  }
  mix(l, f) {
    if (l) {
      const y = this.rgb,
        T = l.rgb;
      let I;
      const P = f === I ? 0.5 : f,
        r = 2 * P - 1,
        F = y.a - T.a,
        B = ((r * F === -1 ? r : (r + F) / (1 + r * F)) + 1) / 2;
      ((I = 1 - B),
        (y.r = 255 & (B * y.r + I * T.r + 0.5)),
        (y.g = 255 & (B * y.g + I * T.g + 0.5)),
        (y.b = 255 & (B * y.b + I * T.b + 0.5)),
        (y.a = P * y.a + (1 - P) * T.a),
        (this.rgb = y));
    }
    return this;
  }
  interpolate(l, f) {
    return (l && (this._rgb = IM(this._rgb, l._rgb, f)), this);
  }
  clone() {
    return new fp(this.rgb);
  }
  alpha(l) {
    return ((this._rgb.a = Xl(l)), this);
  }
  clearer(l) {
    const f = this._rgb;
    return ((f.a *= 1 - l), this);
  }
  greyscale() {
    const l = this._rgb,
      f = vp(l.r * 0.3 + l.g * 0.59 + l.b * 0.11);
    return ((l.r = l.g = l.b = f), this);
  }
  opaquer(l) {
    const f = this._rgb;
    return ((f.a *= 1 + l), this);
  }
  negate() {
    const l = this._rgb;
    return ((l.r = 255 - l.r), (l.g = 255 - l.g), (l.b = 255 - l.b), this);
  }
  lighten(l) {
    return (wg(this._rgb, 2, l), this);
  }
  darken(l) {
    return (wg(this._rgb, 2, -l), this);
  }
  saturate(l) {
    return (wg(this._rgb, 1, l), this);
  }
  desaturate(l) {
    return (wg(this._rgb, 1, -l), this);
  }
  rotate(l) {
    return (xM(this._rgb, l), this);
  }
}
/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */ function Ba() {}
const MM = (() => {
  let m = 0;
  return () => m++;
})();
function Jn(m) {
  return m == null;
}
function Nr(m) {
  if (Array.isArray && Array.isArray(m)) return !0;
  const l = Object.prototype.toString.call(m);
  return l.slice(0, 7) === "[object" && l.slice(-6) === "Array]";
}
function Nn(m) {
  return m !== null && Object.prototype.toString.call(m) === "[object Object]";
}
function Ys(m) {
  return (typeof m == "number" || m instanceof Number) && isFinite(+m);
}
function ea(m, l) {
  return Ys(m) ? m : l;
}
function Dn(m, l) {
  return typeof m > "u" ? l : m;
}
const CM = (m, l) =>
  typeof m == "string" && m.endsWith("%") ? (parseFloat(m) / 100) * l : +m;
function er(m, l, f) {
  if (m && typeof m.call == "function") return m.apply(f, l);
}
function jn(m, l, f, y) {
  let T, I, P;
  if (Nr(m)) for (I = m.length, T = 0; T < I; T++) l.call(f, m[T], T);
  else if (Nn(m))
    for (P = Object.keys(m), I = P.length, T = 0; T < I; T++)
      l.call(f, m[P[T]], P[T]);
}
function jg(m, l) {
  let f, y, T, I;
  if (!m || !l || m.length !== l.length) return !1;
  for (f = 0, y = m.length; f < y; ++f)
    if (
      ((T = m[f]),
      (I = l[f]),
      T.datasetIndex !== I.datasetIndex || T.index !== I.index)
    )
      return !1;
  return !0;
}
function Gg(m) {
  if (Nr(m)) return m.map(Gg);
  if (Nn(m)) {
    const l = Object.create(null),
      f = Object.keys(m),
      y = f.length;
    let T = 0;
    for (; T < y; ++T) l[f[T]] = Gg(m[f[T]]);
    return l;
  }
  return m;
}
function XT(m) {
  return ["__proto__", "prototype", "constructor"].indexOf(m) === -1;
}
function PM(m, l, f, y) {
  if (!XT(m)) return;
  const T = l[m],
    I = f[m];
  Nn(T) && Nn(I) ? pp(T, I, y) : (l[m] = Gg(I));
}
function pp(m, l, f) {
  const y = Nr(l) ? l : [l],
    T = y.length;
  if (!Nn(m)) return m;
  f = f || {};
  const I = f.merger || PM;
  let P;
  for (let r = 0; r < T; ++r) {
    if (((P = y[r]), !Nn(P))) continue;
    const F = Object.keys(P);
    for (let B = 0, q = F.length; B < q; ++B) I(F[B], m, P, f);
  }
  return m;
}
function sp(m, l) {
  return pp(m, l, { merger: DM });
}
function DM(m, l, f) {
  if (!XT(m)) return;
  const y = l[m],
    T = f[m];
  Nn(y) && Nn(T)
    ? sp(y, T)
    : Object.prototype.hasOwnProperty.call(l, m) || (l[m] = Gg(T));
}
const xw = { "": (m) => m, x: (m) => m.x, y: (m) => m.y };
function RM(m) {
  const l = m.split("."),
    f = [];
  let y = "";
  for (const T of l)
    ((y += T),
      y.endsWith("\\") ? (y = y.slice(0, -1) + ".") : (f.push(y), (y = "")));
  return f;
}
function zM(m) {
  const l = RM(m);
  return (f) => {
    for (const y of l) {
      if (y === "") break;
      f = f && f[y];
    }
    return f;
  };
}
function $g(m, l) {
  return (xw[l] || (xw[l] = zM(l)))(m);
}
function Wx(m) {
  return m.charAt(0).toUpperCase() + m.slice(1);
}
const Hg = (m) => typeof m < "u",
  Kl = (m) => typeof m == "function",
  vw = (m, l) => {
    if (m.size !== l.size) return !1;
    for (const f of m) if (!l.has(f)) return !1;
    return !0;
  };
function kM(m) {
  return m.type === "mouseup" || m.type === "click" || m.type === "contextmenu";
}
const Vr = Math.PI,
  oa = 2 * Vr,
  LM = oa + Vr,
  Wg = Number.POSITIVE_INFINITY,
  OM = Vr / 180,
  wo = Vr / 2,
  hh = Vr / 4,
  bw = (Vr * 2) / 3,
  YT = Math.log10,
  Yu = Math.sign;
function op(m, l, f) {
  return Math.abs(m - l) < f;
}
function ww(m) {
  const l = Math.round(m);
  m = op(m, l, m / 1e3) ? l : m;
  const f = Math.pow(10, Math.floor(YT(m))),
    y = m / f;
  return (y <= 1 ? 1 : y <= 2 ? 2 : y <= 5 ? 5 : 10) * f;
}
function FM(m) {
  const l = [],
    f = Math.sqrt(m);
  let y;
  for (y = 1; y < f; y++) m % y === 0 && (l.push(y), l.push(m / y));
  return (f === (f | 0) && l.push(f), l.sort((T, I) => T - I).pop(), l);
}
function BM(m) {
  return (
    typeof m == "symbol" ||
    (typeof m == "object" &&
      m !== null &&
      !(Symbol.toPrimitive in m || "toString" in m || "valueOf" in m))
  );
}
function mp(m) {
  return !BM(m) && !isNaN(parseFloat(m)) && isFinite(m);
}
function NM(m, l) {
  const f = Math.round(m);
  return f - l <= m && f + l >= m;
}
function VM(m, l, f) {
  let y, T, I;
  for (y = 0, T = m.length; y < T; y++)
    ((I = m[y][f]),
      isNaN(I) || ((l.min = Math.min(l.min, I)), (l.max = Math.max(l.max, I))));
}
function gh(m) {
  return m * (Vr / 180);
}
function UM(m) {
  return m * (180 / Vr);
}
function Tw(m) {
  if (!Ys(m)) return;
  let l = 1,
    f = 0;
  for (; Math.round(m * l) / l !== m; ) ((l *= 10), f++);
  return f;
}
function jM(m, l) {
  const f = l.x - m.x,
    y = l.y - m.y,
    T = Math.sqrt(f * f + y * y);
  let I = Math.atan2(y, f);
  return (I < -0.5 * Vr && (I += oa), { angle: I, distance: T });
}
function Ix(m, l) {
  return Math.sqrt(Math.pow(l.x - m.x, 2) + Math.pow(l.y - m.y, 2));
}
function GM(m, l) {
  return ((m - l + LM) % oa) - Vr;
}
function Wl(m) {
  return ((m % oa) + oa) % oa;
}
function KT(m, l, f, y) {
  const T = Wl(m),
    I = Wl(l),
    P = Wl(f),
    r = Wl(I - T),
    F = Wl(P - T),
    B = Wl(T - I),
    q = Wl(T - P);
  return T === I || T === P || (y && I === P) || (r > F && B < q);
}
function qs(m, l, f) {
  return Math.max(l, Math.min(f, m));
}
function $M(m) {
  return qs(m, -32768, 32767);
}
function Qf(m, l, f, y = 1e-6) {
  return m >= Math.min(l, f) - y && m <= Math.max(l, f) + y;
}
function qx(m, l, f) {
  f = f || ((P) => m[P] < l);
  let y = m.length - 1,
    T = 0,
    I;
  for (; y - T > 1; ) ((I = (T + y) >> 1), f(I) ? (T = I) : (y = I));
  return { lo: T, hi: y };
}
const _h = (m, l, f, y) =>
    qx(
      m,
      f,
      y
        ? (T) => {
            const I = m[T][l];
            return I < f || (I === f && m[T + 1][l] === f);
          }
        : (T) => m[T][l] < f,
    ),
  HM = (m, l, f) => qx(m, f, (y) => m[y][l] >= f);
function WM(m, l, f) {
  let y = 0,
    T = m.length;
  for (; y < T && m[y] < l; ) y++;
  for (; T > y && m[T - 1] > f; ) T--;
  return y > 0 || T < m.length ? m.slice(y, T) : m;
}
const JT = ["push", "pop", "shift", "splice", "unshift"];
function qM(m, l) {
  if (m._chartjs) {
    m._chartjs.listeners.push(l);
    return;
  }
  (Object.defineProperty(m, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: { listeners: [l] },
  }),
    JT.forEach((f) => {
      const y = "_onData" + Wx(f),
        T = m[f];
      Object.defineProperty(m, f, {
        configurable: !0,
        enumerable: !1,
        value(...I) {
          const P = T.apply(this, I);
          return (
            m._chartjs.listeners.forEach((r) => {
              typeof r[y] == "function" && r[y](...I);
            }),
            P
          );
        },
      });
    }));
}
function Sw(m, l) {
  const f = m._chartjs;
  if (!f) return;
  const y = f.listeners,
    T = y.indexOf(l);
  (T !== -1 && y.splice(T, 1),
    !(y.length > 0) &&
      (JT.forEach((I) => {
        delete m[I];
      }),
      delete m._chartjs));
}
function ZM(m) {
  const l = new Set(m);
  return l.size === m.length ? m : Array.from(l);
}
const QT = (function () {
  return typeof window > "u"
    ? function (m) {
        return m();
      }
    : window.requestAnimationFrame;
})();
function e2(m, l) {
  let f = [],
    y = !1;
  return function (...T) {
    ((f = T),
      y ||
        ((y = !0),
        QT.call(window, () => {
          ((y = !1), m.apply(l, f));
        })));
  };
}
function XM(m, l) {
  let f;
  return function (...y) {
    return (
      l ? (clearTimeout(f), (f = setTimeout(m, l, y))) : m.apply(this, y),
      l
    );
  };
}
const Zx = (m) => (m === "start" ? "left" : m === "end" ? "right" : "center"),
  ns = (m, l, f) => (m === "start" ? l : m === "end" ? f : (l + f) / 2),
  YM = (m, l, f, y) =>
    m === (y ? "left" : "right") ? f : m === "center" ? (l + f) / 2 : l;
function KM(m, l, f) {
  const y = l.length;
  let T = 0,
    I = y;
  if (m._sorted) {
    const { iScale: P, vScale: r, _parsed: F } = m,
      B = m.dataset && m.dataset.options ? m.dataset.options.spanGaps : null,
      q = P.axis,
      { min: ne, max: fe, minDefined: de, maxDefined: Ie } = P.getUserBounds();
    if (de) {
      if (
        ((T = Math.min(
          _h(F, q, ne).lo,
          f ? y : _h(l, q, P.getPixelForValue(ne)).lo,
        )),
        B)
      ) {
        const xe = F.slice(0, T + 1)
          .reverse()
          .findIndex((we) => !Jn(we[r.axis]));
        T -= Math.max(0, xe);
      }
      T = qs(T, 0, y - 1);
    }
    if (Ie) {
      let xe = Math.max(
        _h(F, P.axis, fe, !0).hi + 1,
        f ? 0 : _h(l, q, P.getPixelForValue(fe), !0).hi + 1,
      );
      if (B) {
        const we = F.slice(xe - 1).findIndex((Ae) => !Jn(Ae[r.axis]));
        xe += Math.max(0, we);
      }
      I = qs(xe, T, y) - T;
    } else I = y - T;
  }
  return { start: T, count: I };
}
function JM(m) {
  const { xScale: l, yScale: f, _scaleRanges: y } = m,
    T = { xmin: l.min, xmax: l.max, ymin: f.min, ymax: f.max };
  if (!y) return ((m._scaleRanges = T), !0);
  const I =
    y.xmin !== l.min ||
    y.xmax !== l.max ||
    y.ymin !== f.min ||
    y.ymax !== f.max;
  return (Object.assign(y, T), I);
}
const Tg = (m) => m === 0 || m === 1,
  Ew = (m, l, f) =>
    -(Math.pow(2, 10 * (m -= 1)) * Math.sin(((m - l) * oa) / f)),
  Iw = (m, l, f) => Math.pow(2, -10 * m) * Math.sin(((m - l) * oa) / f) + 1,
  ap = {
    linear: (m) => m,
    easeInQuad: (m) => m * m,
    easeOutQuad: (m) => -m * (m - 2),
    easeInOutQuad: (m) =>
      (m /= 0.5) < 1 ? 0.5 * m * m : -0.5 * (--m * (m - 2) - 1),
    easeInCubic: (m) => m * m * m,
    easeOutCubic: (m) => (m -= 1) * m * m + 1,
    easeInOutCubic: (m) =>
      (m /= 0.5) < 1 ? 0.5 * m * m * m : 0.5 * ((m -= 2) * m * m + 2),
    easeInQuart: (m) => m * m * m * m,
    easeOutQuart: (m) => -((m -= 1) * m * m * m - 1),
    easeInOutQuart: (m) =>
      (m /= 0.5) < 1 ? 0.5 * m * m * m * m : -0.5 * ((m -= 2) * m * m * m - 2),
    easeInQuint: (m) => m * m * m * m * m,
    easeOutQuint: (m) => (m -= 1) * m * m * m * m + 1,
    easeInOutQuint: (m) =>
      (m /= 0.5) < 1
        ? 0.5 * m * m * m * m * m
        : 0.5 * ((m -= 2) * m * m * m * m + 2),
    easeInSine: (m) => -Math.cos(m * wo) + 1,
    easeOutSine: (m) => Math.sin(m * wo),
    easeInOutSine: (m) => -0.5 * (Math.cos(Vr * m) - 1),
    easeInExpo: (m) => (m === 0 ? 0 : Math.pow(2, 10 * (m - 1))),
    easeOutExpo: (m) => (m === 1 ? 1 : -Math.pow(2, -10 * m) + 1),
    easeInOutExpo: (m) =>
      Tg(m)
        ? m
        : m < 0.5
          ? 0.5 * Math.pow(2, 10 * (m * 2 - 1))
          : 0.5 * (-Math.pow(2, -10 * (m * 2 - 1)) + 2),
    easeInCirc: (m) => (m >= 1 ? m : -(Math.sqrt(1 - m * m) - 1)),
    easeOutCirc: (m) => Math.sqrt(1 - (m -= 1) * m),
    easeInOutCirc: (m) =>
      (m /= 0.5) < 1
        ? -0.5 * (Math.sqrt(1 - m * m) - 1)
        : 0.5 * (Math.sqrt(1 - (m -= 2) * m) + 1),
    easeInElastic: (m) => (Tg(m) ? m : Ew(m, 0.075, 0.3)),
    easeOutElastic: (m) => (Tg(m) ? m : Iw(m, 0.075, 0.3)),
    easeInOutElastic(m) {
      return Tg(m)
        ? m
        : m < 0.5
          ? 0.5 * Ew(m * 2, 0.1125, 0.45)
          : 0.5 + 0.5 * Iw(m * 2 - 1, 0.1125, 0.45);
    },
    easeInBack(m) {
      return m * m * ((1.70158 + 1) * m - 1.70158);
    },
    easeOutBack(m) {
      return (m -= 1) * m * ((1.70158 + 1) * m + 1.70158) + 1;
    },
    easeInOutBack(m) {
      let l = 1.70158;
      return (m /= 0.5) < 1
        ? 0.5 * (m * m * (((l *= 1.525) + 1) * m - l))
        : 0.5 * ((m -= 2) * m * (((l *= 1.525) + 1) * m + l) + 2);
    },
    easeInBounce: (m) => 1 - ap.easeOutBounce(1 - m),
    easeOutBounce(m) {
      return m < 1 / 2.75
        ? 7.5625 * m * m
        : m < 2 / 2.75
          ? 7.5625 * (m -= 1.5 / 2.75) * m + 0.75
          : m < 2.5 / 2.75
            ? 7.5625 * (m -= 2.25 / 2.75) * m + 0.9375
            : 7.5625 * (m -= 2.625 / 2.75) * m + 0.984375;
    },
    easeInOutBounce: (m) =>
      m < 0.5
        ? ap.easeInBounce(m * 2) * 0.5
        : ap.easeOutBounce(m * 2 - 1) * 0.5 + 0.5,
  };
function Xx(m) {
  if (m && typeof m == "object") {
    const l = m.toString();
    return l === "[object CanvasPattern]" || l === "[object CanvasGradient]";
  }
  return !1;
}
function Aw(m) {
  return Xx(m) ? m : new fp(m);
}
function dx(m) {
  return Xx(m) ? m : new fp(m).saturate(0.5).darken(0.1).hexString();
}
const QM = ["x", "y", "borderWidth", "radius", "tension"],
  eC = ["color", "borderColor", "backgroundColor"];
function tC(m) {
  (m.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0,
  }),
    m.describe("animation", {
      _fallback: !1,
      _indexable: !1,
      _scriptable: (l) =>
        l !== "onProgress" && l !== "onComplete" && l !== "fn",
    }),
    m.set("animations", {
      colors: { type: "color", properties: eC },
      numbers: { type: "number", properties: QM },
    }),
    m.describe("animations", { _fallback: "animation" }),
    m.set("transitions", {
      active: { animation: { duration: 400 } },
      resize: { animation: { duration: 0 } },
      show: {
        animations: {
          colors: { from: "transparent" },
          visible: { type: "boolean", duration: 0 },
        },
      },
      hide: {
        animations: {
          colors: { to: "transparent" },
          visible: { type: "boolean", easing: "linear", fn: (l) => l | 0 },
        },
      },
    }));
}
function iC(m) {
  m.set("layout", {
    autoPadding: !0,
    padding: { top: 0, right: 0, bottom: 0, left: 0 },
  });
}
const Mw = new Map();
function nC(m, l) {
  l = l || {};
  const f = m + JSON.stringify(l);
  let y = Mw.get(f);
  return (y || ((y = new Intl.NumberFormat(m, l)), Mw.set(f, y)), y);
}
function t2(m, l, f) {
  return nC(l, f).format(m);
}
const rC = {
  values(m) {
    return Nr(m) ? m : "" + m;
  },
  numeric(m, l, f) {
    if (m === 0) return "0";
    const y = this.chart.options.locale;
    let T,
      I = m;
    if (f.length > 1) {
      const B = Math.max(Math.abs(f[0].value), Math.abs(f[f.length - 1].value));
      ((B < 1e-4 || B > 1e15) && (T = "scientific"), (I = sC(m, f)));
    }
    const P = YT(Math.abs(I)),
      r = isNaN(P) ? 1 : Math.max(Math.min(-1 * Math.floor(P), 20), 0),
      F = { notation: T, minimumFractionDigits: r, maximumFractionDigits: r };
    return (Object.assign(F, this.options.ticks.format), t2(m, y, F));
  },
};
function sC(m, l) {
  let f = l.length > 3 ? l[2].value - l[1].value : l[1].value - l[0].value;
  return (
    Math.abs(f) >= 1 && m !== Math.floor(m) && (f = m - Math.floor(m)),
    f
  );
}
var i2 = { formatters: rC };
function oC(m) {
  (m.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (l, f) => f.lineWidth,
      tickColor: (l, f) => f.color,
      offset: !1,
    },
    border: { display: !0, dash: [], dashOffset: 0, width: 1 },
    title: { display: !1, text: "", padding: { top: 4, bottom: 4 } },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: i2.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2,
    },
  }),
    m.route("scale.ticks", "color", "", "color"),
    m.route("scale.grid", "color", "", "borderColor"),
    m.route("scale.border", "color", "", "borderColor"),
    m.route("scale.title", "color", "", "color"),
    m.describe("scale", {
      _fallback: !1,
      _scriptable: (l) =>
        !l.startsWith("before") &&
        !l.startsWith("after") &&
        l !== "callback" &&
        l !== "parser",
      _indexable: (l) =>
        l !== "borderDash" && l !== "tickBorderDash" && l !== "dash",
    }),
    m.describe("scales", { _fallback: "scale" }),
    m.describe("scale.ticks", {
      _scriptable: (l) => l !== "backdropPadding" && l !== "callback",
      _indexable: (l) => l !== "backdropPadding",
    }));
}
const wh = Object.create(null),
  Ax = Object.create(null);
function lp(m, l) {
  if (!l) return m;
  const f = l.split(".");
  for (let y = 0, T = f.length; y < T; ++y) {
    const I = f[y];
    m = m[I] || (m[I] = Object.create(null));
  }
  return m;
}
function fx(m, l, f) {
  return typeof l == "string" ? pp(lp(m, l), f) : pp(lp(m, ""), l);
}
class aC {
  constructor(l, f) {
    ((this.animation = void 0),
      (this.backgroundColor = "rgba(0,0,0,0.1)"),
      (this.borderColor = "rgba(0,0,0,0.1)"),
      (this.color = "#666"),
      (this.datasets = {}),
      (this.devicePixelRatio = (y) => y.chart.platform.getDevicePixelRatio()),
      (this.elements = {}),
      (this.events = [
        "mousemove",
        "mouseout",
        "click",
        "touchstart",
        "touchmove",
      ]),
      (this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: "normal",
        lineHeight: 1.2,
        weight: null,
      }),
      (this.hover = {}),
      (this.hoverBackgroundColor = (y, T) => dx(T.backgroundColor)),
      (this.hoverBorderColor = (y, T) => dx(T.borderColor)),
      (this.hoverColor = (y, T) => dx(T.color)),
      (this.indexAxis = "x"),
      (this.interaction = {
        mode: "nearest",
        intersect: !0,
        includeInvisible: !1,
      }),
      (this.maintainAspectRatio = !0),
      (this.onHover = null),
      (this.onClick = null),
      (this.parsing = !0),
      (this.plugins = {}),
      (this.responsive = !0),
      (this.scale = void 0),
      (this.scales = {}),
      (this.showLine = !0),
      (this.drawActiveElementsOnTop = !0),
      this.describe(l),
      this.apply(f));
  }
  set(l, f) {
    return fx(this, l, f);
  }
  get(l) {
    return lp(this, l);
  }
  describe(l, f) {
    return fx(Ax, l, f);
  }
  override(l, f) {
    return fx(wh, l, f);
  }
  route(l, f, y, T) {
    const I = lp(this, l),
      P = lp(this, y),
      r = "_" + f;
    Object.defineProperties(I, {
      [r]: { value: I[f], writable: !0 },
      [f]: {
        enumerable: !0,
        get() {
          const F = this[r],
            B = P[T];
          return Nn(F) ? Object.assign({}, B, F) : Dn(F, B);
        },
        set(F) {
          this[r] = F;
        },
      },
    });
  }
  apply(l) {
    l.forEach((f) => f(this));
  }
}
var gr = new aC(
  {
    _scriptable: (m) => !m.startsWith("on"),
    _indexable: (m) => m !== "events",
    hover: { _fallback: "interaction" },
    interaction: { _scriptable: !1, _indexable: !1 },
  },
  [tC, iC, oC],
);
function lC(m) {
  return !m || Jn(m.size) || Jn(m.family)
    ? null
    : (m.style ? m.style + " " : "") +
        (m.weight ? m.weight + " " : "") +
        m.size +
        "px " +
        m.family;
}
function Cw(m, l, f, y, T) {
  let I = l[T];
  return (
    I || ((I = l[T] = m.measureText(T).width), f.push(T)),
    I > y && (y = I),
    y
  );
}
function uh(m, l, f) {
  const y = m.currentDevicePixelRatio,
    T = f !== 0 ? Math.max(f / 2, 0.5) : 0;
  return Math.round((l - T) * y) / y + T;
}
function Pw(m, l) {
  (!l && !m) ||
    ((l = l || m.getContext("2d")),
    l.save(),
    l.resetTransform(),
    l.clearRect(0, 0, m.width, m.height),
    l.restore());
}
function Mx(m, l, f, y) {
  n2(m, l, f, y, null);
}
function n2(m, l, f, y, T) {
  let I, P, r, F, B, q, ne, fe;
  const de = l.pointStyle,
    Ie = l.rotation,
    xe = l.radius;
  let we = (Ie || 0) * OM;
  if (
    de &&
    typeof de == "object" &&
    ((I = de.toString()),
    I === "[object HTMLImageElement]" || I === "[object HTMLCanvasElement]")
  ) {
    (m.save(),
      m.translate(f, y),
      m.rotate(we),
      m.drawImage(de, -de.width / 2, -de.height / 2, de.width, de.height),
      m.restore());
    return;
  }
  if (!(isNaN(xe) || xe <= 0)) {
    switch ((m.beginPath(), de)) {
      default:
        (T ? m.ellipse(f, y, T / 2, xe, 0, 0, oa) : m.arc(f, y, xe, 0, oa),
          m.closePath());
        break;
      case "triangle":
        ((q = T ? T / 2 : xe),
          m.moveTo(f + Math.sin(we) * q, y - Math.cos(we) * xe),
          (we += bw),
          m.lineTo(f + Math.sin(we) * q, y - Math.cos(we) * xe),
          (we += bw),
          m.lineTo(f + Math.sin(we) * q, y - Math.cos(we) * xe),
          m.closePath());
        break;
      case "rectRounded":
        ((B = xe * 0.516),
          (F = xe - B),
          (P = Math.cos(we + hh) * F),
          (ne = Math.cos(we + hh) * (T ? T / 2 - B : F)),
          (r = Math.sin(we + hh) * F),
          (fe = Math.sin(we + hh) * (T ? T / 2 - B : F)),
          m.arc(f - ne, y - r, B, we - Vr, we - wo),
          m.arc(f + fe, y - P, B, we - wo, we),
          m.arc(f + ne, y + r, B, we, we + wo),
          m.arc(f - fe, y + P, B, we + wo, we + Vr),
          m.closePath());
        break;
      case "rect":
        if (!Ie) {
          ((F = Math.SQRT1_2 * xe),
            (q = T ? T / 2 : F),
            m.rect(f - q, y - F, 2 * q, 2 * F));
          break;
        }
        we += hh;
      case "rectRot":
        ((ne = Math.cos(we) * (T ? T / 2 : xe)),
          (P = Math.cos(we) * xe),
          (r = Math.sin(we) * xe),
          (fe = Math.sin(we) * (T ? T / 2 : xe)),
          m.moveTo(f - ne, y - r),
          m.lineTo(f + fe, y - P),
          m.lineTo(f + ne, y + r),
          m.lineTo(f - fe, y + P),
          m.closePath());
        break;
      case "crossRot":
        we += hh;
      case "cross":
        ((ne = Math.cos(we) * (T ? T / 2 : xe)),
          (P = Math.cos(we) * xe),
          (r = Math.sin(we) * xe),
          (fe = Math.sin(we) * (T ? T / 2 : xe)),
          m.moveTo(f - ne, y - r),
          m.lineTo(f + ne, y + r),
          m.moveTo(f + fe, y - P),
          m.lineTo(f - fe, y + P));
        break;
      case "star":
        ((ne = Math.cos(we) * (T ? T / 2 : xe)),
          (P = Math.cos(we) * xe),
          (r = Math.sin(we) * xe),
          (fe = Math.sin(we) * (T ? T / 2 : xe)),
          m.moveTo(f - ne, y - r),
          m.lineTo(f + ne, y + r),
          m.moveTo(f + fe, y - P),
          m.lineTo(f - fe, y + P),
          (we += hh),
          (ne = Math.cos(we) * (T ? T / 2 : xe)),
          (P = Math.cos(we) * xe),
          (r = Math.sin(we) * xe),
          (fe = Math.sin(we) * (T ? T / 2 : xe)),
          m.moveTo(f - ne, y - r),
          m.lineTo(f + ne, y + r),
          m.moveTo(f + fe, y - P),
          m.lineTo(f - fe, y + P));
        break;
      case "line":
        ((P = T ? T / 2 : Math.cos(we) * xe),
          (r = Math.sin(we) * xe),
          m.moveTo(f - P, y - r),
          m.lineTo(f + P, y + r));
        break;
      case "dash":
        (m.moveTo(f, y),
          m.lineTo(f + Math.cos(we) * (T ? T / 2 : xe), y + Math.sin(we) * xe));
        break;
      case !1:
        m.closePath();
        break;
    }
    (m.fill(), l.borderWidth > 0 && m.stroke());
  }
}
function gp(m, l, f) {
  return (
    (f = f || 0.5),
    !l ||
      (m &&
        m.x > l.left - f &&
        m.x < l.right + f &&
        m.y > l.top - f &&
        m.y < l.bottom + f)
  );
}
function Yx(m, l) {
  (m.save(),
    m.beginPath(),
    m.rect(l.left, l.top, l.right - l.left, l.bottom - l.top),
    m.clip());
}
function Kx(m) {
  m.restore();
}
function cC(m, l, f, y, T) {
  if (!l) return m.lineTo(f.x, f.y);
  if (T === "middle") {
    const I = (l.x + f.x) / 2;
    (m.lineTo(I, l.y), m.lineTo(I, f.y));
  } else (T === "after") != !!y ? m.lineTo(l.x, f.y) : m.lineTo(f.x, l.y);
  m.lineTo(f.x, f.y);
}
function hC(m, l, f, y) {
  if (!l) return m.lineTo(f.x, f.y);
  m.bezierCurveTo(
    y ? l.cp1x : l.cp2x,
    y ? l.cp1y : l.cp2y,
    y ? f.cp2x : f.cp1x,
    y ? f.cp2y : f.cp1y,
    f.x,
    f.y,
  );
}
function uC(m, l) {
  (l.translation && m.translate(l.translation[0], l.translation[1]),
    Jn(l.rotation) || m.rotate(l.rotation),
    l.color && (m.fillStyle = l.color),
    l.textAlign && (m.textAlign = l.textAlign),
    l.textBaseline && (m.textBaseline = l.textBaseline));
}
function dC(m, l, f, y, T) {
  if (T.strikethrough || T.underline) {
    const I = m.measureText(y),
      P = l - I.actualBoundingBoxLeft,
      r = l + I.actualBoundingBoxRight,
      F = f - I.actualBoundingBoxAscent,
      B = f + I.actualBoundingBoxDescent,
      q = T.strikethrough ? (F + B) / 2 : B;
    ((m.strokeStyle = m.fillStyle),
      m.beginPath(),
      (m.lineWidth = T.decorationWidth || 2),
      m.moveTo(P, q),
      m.lineTo(r, q),
      m.stroke());
  }
}
function fC(m, l) {
  const f = m.fillStyle;
  ((m.fillStyle = l.color),
    m.fillRect(l.left, l.top, l.width, l.height),
    (m.fillStyle = f));
}
function _p(m, l, f, y, T, I = {}) {
  const P = Nr(l) ? l : [l],
    r = I.strokeWidth > 0 && I.strokeColor !== "";
  let F, B;
  for (m.save(), m.font = T.string, uC(m, I), F = 0; F < P.length; ++F)
    ((B = P[F]),
      I.backdrop && fC(m, I.backdrop),
      r &&
        (I.strokeColor && (m.strokeStyle = I.strokeColor),
        Jn(I.strokeWidth) || (m.lineWidth = I.strokeWidth),
        m.strokeText(B, f, y, I.maxWidth)),
      m.fillText(B, f, y, I.maxWidth),
      dC(m, f, y, B, I),
      (y += Number(T.lineHeight)));
  m.restore();
}
function Cx(m, l) {
  const { x: f, y, w: T, h: I, radius: P } = l;
  (m.arc(f + P.topLeft, y + P.topLeft, P.topLeft, 1.5 * Vr, Vr, !0),
    m.lineTo(f, y + I - P.bottomLeft),
    m.arc(f + P.bottomLeft, y + I - P.bottomLeft, P.bottomLeft, Vr, wo, !0),
    m.lineTo(f + T - P.bottomRight, y + I),
    m.arc(
      f + T - P.bottomRight,
      y + I - P.bottomRight,
      P.bottomRight,
      wo,
      0,
      !0,
    ),
    m.lineTo(f + T, y + P.topRight),
    m.arc(f + T - P.topRight, y + P.topRight, P.topRight, 0, -wo, !0),
    m.lineTo(f + P.topLeft, y));
}
const pC = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,
  mC = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function gC(m, l) {
  const f = ("" + m).match(pC);
  if (!f || f[1] === "normal") return l * 1.2;
  switch (((m = +f[2]), f[3])) {
    case "px":
      return m;
    case "%":
      m /= 100;
      break;
  }
  return l * m;
}
const _C = (m) => +m || 0;
function r2(m, l) {
  const f = {},
    y = Nn(l),
    T = y ? Object.keys(l) : l,
    I = Nn(m) ? (y ? (P) => Dn(m[P], m[l[P]]) : (P) => m[P]) : () => m;
  for (const P of T) f[P] = _C(I(P));
  return f;
}
function yC(m) {
  return r2(m, { top: "y", right: "x", bottom: "y", left: "x" });
}
function cp(m) {
  return r2(m, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
}
function Ks(m) {
  const l = yC(m);
  return ((l.width = l.left + l.right), (l.height = l.top + l.bottom), l);
}
function rs(m, l) {
  ((m = m || {}), (l = l || gr.font));
  let f = Dn(m.size, l.size);
  typeof f == "string" && (f = parseInt(f, 10));
  let y = Dn(m.style, l.style);
  y &&
    !("" + y).match(mC) &&
    (console.warn('Invalid font style specified: "' + y + '"'), (y = void 0));
  const T = {
    family: Dn(m.family, l.family),
    lineHeight: gC(Dn(m.lineHeight, l.lineHeight), f),
    size: f,
    style: y,
    weight: Dn(m.weight, l.weight),
    string: "",
  };
  return ((T.string = lC(T)), T);
}
function Sg(m, l, f, y) {
  let T, I, P;
  for (T = 0, I = m.length; T < I; ++T)
    if (((P = m[T]), P !== void 0 && P !== void 0)) return P;
}
function xC(m, l, f) {
  const { min: y, max: T } = m,
    I = CM(l, (T - y) / 2),
    P = (r, F) => (f && r === 0 ? 0 : r + F);
  return { min: P(y, -Math.abs(I)), max: P(T, I) };
}
function Th(m, l) {
  return Object.assign(Object.create(m), l);
}
function Jx(m, l = [""], f, y, T = () => m[0]) {
  const I = f || m;
  typeof y > "u" && (y = l2("_fallback", m));
  const P = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: m,
    _rootScopes: I,
    _fallback: y,
    _getTarget: T,
    override: (r) => Jx([r, ...m], l, I, y),
  };
  return new Proxy(P, {
    deleteProperty(r, F) {
      return (delete r[F], delete r._keys, delete m[0][F], !0);
    },
    get(r, F) {
      return o2(r, F, () => AC(F, l, m, r));
    },
    getOwnPropertyDescriptor(r, F) {
      return Reflect.getOwnPropertyDescriptor(r._scopes[0], F);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(m[0]);
    },
    has(r, F) {
      return Rw(r).includes(F);
    },
    ownKeys(r) {
      return Rw(r);
    },
    set(r, F, B) {
      const q = r._storage || (r._storage = T());
      return ((r[F] = q[F] = B), delete r._keys, !0);
    },
  });
}
function Ku(m, l, f, y) {
  const T = {
    _cacheable: !1,
    _proxy: m,
    _context: l,
    _subProxy: f,
    _stack: new Set(),
    _descriptors: s2(m, y),
    setContext: (I) => Ku(m, I, f, y),
    override: (I) => Ku(m.override(I), l, f, y),
  };
  return new Proxy(T, {
    deleteProperty(I, P) {
      return (delete I[P], delete m[P], !0);
    },
    get(I, P, r) {
      return o2(I, P, () => bC(I, P, r));
    },
    getOwnPropertyDescriptor(I, P) {
      return I._descriptors.allKeys
        ? Reflect.has(m, P)
          ? { enumerable: !0, configurable: !0 }
          : void 0
        : Reflect.getOwnPropertyDescriptor(m, P);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(m);
    },
    has(I, P) {
      return Reflect.has(m, P);
    },
    ownKeys() {
      return Reflect.ownKeys(m);
    },
    set(I, P, r) {
      return ((m[P] = r), delete I[P], !0);
    },
  });
}
function s2(m, l = { scriptable: !0, indexable: !0 }) {
  const {
    _scriptable: f = l.scriptable,
    _indexable: y = l.indexable,
    _allKeys: T = l.allKeys,
  } = m;
  return {
    allKeys: T,
    scriptable: f,
    indexable: y,
    isScriptable: Kl(f) ? f : () => f,
    isIndexable: Kl(y) ? y : () => y,
  };
}
const vC = (m, l) => (m ? m + Wx(l) : l),
  Qx = (m, l) =>
    Nn(l) &&
    m !== "adapters" &&
    (Object.getPrototypeOf(l) === null || l.constructor === Object);
function o2(m, l, f) {
  if (Object.prototype.hasOwnProperty.call(m, l) || l === "constructor")
    return m[l];
  const y = f();
  return ((m[l] = y), y);
}
function bC(m, l, f) {
  const { _proxy: y, _context: T, _subProxy: I, _descriptors: P } = m;
  let r = y[l];
  return (
    Kl(r) && P.isScriptable(l) && (r = wC(l, r, m, f)),
    Nr(r) && r.length && (r = TC(l, r, m, P.isIndexable)),
    Qx(l, r) && (r = Ku(r, T, I && I[l], P)),
    r
  );
}
function wC(m, l, f, y) {
  const { _proxy: T, _context: I, _subProxy: P, _stack: r } = f;
  if (r.has(m))
    throw new Error(
      "Recursion detected: " + Array.from(r).join("->") + "->" + m,
    );
  r.add(m);
  let F = l(I, P || y);
  return (r.delete(m), Qx(m, F) && (F = ev(T._scopes, T, m, F)), F);
}
function TC(m, l, f, y) {
  const { _proxy: T, _context: I, _subProxy: P, _descriptors: r } = f;
  if (typeof I.index < "u" && y(m)) return l[I.index % l.length];
  if (Nn(l[0])) {
    const F = l,
      B = T._scopes.filter((q) => q !== F);
    l = [];
    for (const q of F) {
      const ne = ev(B, T, m, q);
      l.push(Ku(ne, I, P && P[m], r));
    }
  }
  return l;
}
function a2(m, l, f) {
  return Kl(m) ? m(l, f) : m;
}
const SC = (m, l) => (m === !0 ? l : typeof m == "string" ? $g(l, m) : void 0);
function EC(m, l, f, y, T) {
  for (const I of l) {
    const P = SC(f, I);
    if (P) {
      m.add(P);
      const r = a2(P._fallback, f, T);
      if (typeof r < "u" && r !== f && r !== y) return r;
    } else if (P === !1 && typeof y < "u" && f !== y) return null;
  }
  return !1;
}
function ev(m, l, f, y) {
  const T = l._rootScopes,
    I = a2(l._fallback, f, y),
    P = [...m, ...T],
    r = new Set();
  r.add(y);
  let F = Dw(r, P, f, I || f, y);
  return F === null ||
    (typeof I < "u" && I !== f && ((F = Dw(r, P, I, F, y)), F === null))
    ? !1
    : Jx(Array.from(r), [""], T, I, () => IC(l, f, y));
}
function Dw(m, l, f, y, T) {
  for (; f; ) f = EC(m, l, f, y, T);
  return f;
}
function IC(m, l, f) {
  const y = m._getTarget();
  l in y || (y[l] = {});
  const T = y[l];
  return Nr(T) && Nn(f) ? f : T || {};
}
function AC(m, l, f, y) {
  let T;
  for (const I of l)
    if (((T = l2(vC(I, m), f)), typeof T < "u"))
      return Qx(m, T) ? ev(f, y, m, T) : T;
}
function l2(m, l) {
  for (const f of l) {
    if (!f) continue;
    const y = f[m];
    if (typeof y < "u") return y;
  }
}
function Rw(m) {
  let l = m._keys;
  return (l || (l = m._keys = MC(m._scopes)), l);
}
function MC(m) {
  const l = new Set();
  for (const f of m)
    for (const y of Object.keys(f).filter((T) => !T.startsWith("_"))) l.add(y);
  return Array.from(l);
}
const CC = Number.EPSILON || 1e-14,
  Ju = (m, l) => l < m.length && !m[l].skip && m[l],
  c2 = (m) => (m === "x" ? "y" : "x");
function PC(m, l, f, y) {
  const T = m.skip ? l : m,
    I = l,
    P = f.skip ? l : f,
    r = Ix(I, T),
    F = Ix(P, I);
  let B = r / (r + F),
    q = F / (r + F);
  ((B = isNaN(B) ? 0 : B), (q = isNaN(q) ? 0 : q));
  const ne = y * B,
    fe = y * q;
  return {
    previous: { x: I.x - ne * (P.x - T.x), y: I.y - ne * (P.y - T.y) },
    next: { x: I.x + fe * (P.x - T.x), y: I.y + fe * (P.y - T.y) },
  };
}
function DC(m, l, f) {
  const y = m.length;
  let T,
    I,
    P,
    r,
    F,
    B = Ju(m, 0);
  for (let q = 0; q < y - 1; ++q)
    if (((F = B), (B = Ju(m, q + 1)), !(!F || !B))) {
      if (op(l[q], 0, CC)) {
        f[q] = f[q + 1] = 0;
        continue;
      }
      ((T = f[q] / l[q]),
        (I = f[q + 1] / l[q]),
        (r = Math.pow(T, 2) + Math.pow(I, 2)),
        !(r <= 9) &&
          ((P = 3 / Math.sqrt(r)),
          (f[q] = T * P * l[q]),
          (f[q + 1] = I * P * l[q])));
    }
}
function RC(m, l, f = "x") {
  const y = c2(f),
    T = m.length;
  let I,
    P,
    r,
    F = Ju(m, 0);
  for (let B = 0; B < T; ++B) {
    if (((P = r), (r = F), (F = Ju(m, B + 1)), !r)) continue;
    const q = r[f],
      ne = r[y];
    (P &&
      ((I = (q - P[f]) / 3),
      (r[`cp1${f}`] = q - I),
      (r[`cp1${y}`] = ne - I * l[B])),
      F &&
        ((I = (F[f] - q) / 3),
        (r[`cp2${f}`] = q + I),
        (r[`cp2${y}`] = ne + I * l[B])));
  }
}
function zC(m, l = "x") {
  const f = c2(l),
    y = m.length,
    T = Array(y).fill(0),
    I = Array(y);
  let P,
    r,
    F,
    B = Ju(m, 0);
  for (P = 0; P < y; ++P)
    if (((r = F), (F = B), (B = Ju(m, P + 1)), !!F)) {
      if (B) {
        const q = B[l] - F[l];
        T[P] = q !== 0 ? (B[f] - F[f]) / q : 0;
      }
      I[P] = r
        ? B
          ? Yu(T[P - 1]) !== Yu(T[P])
            ? 0
            : (T[P - 1] + T[P]) / 2
          : T[P - 1]
        : T[P];
    }
  (DC(m, T, I), RC(m, I, l));
}
function Eg(m, l, f) {
  return Math.max(Math.min(m, f), l);
}
function kC(m, l) {
  let f,
    y,
    T,
    I,
    P,
    r = gp(m[0], l);
  for (f = 0, y = m.length; f < y; ++f)
    ((P = I),
      (I = r),
      (r = f < y - 1 && gp(m[f + 1], l)),
      I &&
        ((T = m[f]),
        P &&
          ((T.cp1x = Eg(T.cp1x, l.left, l.right)),
          (T.cp1y = Eg(T.cp1y, l.top, l.bottom))),
        r &&
          ((T.cp2x = Eg(T.cp2x, l.left, l.right)),
          (T.cp2y = Eg(T.cp2y, l.top, l.bottom)))));
}
function LC(m, l, f, y, T) {
  let I, P, r, F;
  if (
    (l.spanGaps && (m = m.filter((B) => !B.skip)),
    l.cubicInterpolationMode === "monotone")
  )
    zC(m, T);
  else {
    let B = y ? m[m.length - 1] : m[0];
    for (I = 0, P = m.length; I < P; ++I)
      ((r = m[I]),
        (F = PC(B, r, m[Math.min(I + 1, P - (y ? 0 : 1)) % P], l.tension)),
        (r.cp1x = F.previous.x),
        (r.cp1y = F.previous.y),
        (r.cp2x = F.next.x),
        (r.cp2y = F.next.y),
        (B = r));
  }
  l.capBezierPoints && kC(m, f);
}
function tv() {
  return typeof window < "u" && typeof document < "u";
}
function iv(m) {
  let l = m.parentNode;
  return (l && l.toString() === "[object ShadowRoot]" && (l = l.host), l);
}
function qg(m, l, f) {
  let y;
  return (
    typeof m == "string"
      ? ((y = parseInt(m, 10)),
        m.indexOf("%") !== -1 && (y = (y / 100) * l.parentNode[f]))
      : (y = m),
    y
  );
}
const Qg = (m) => m.ownerDocument.defaultView.getComputedStyle(m, null);
function OC(m, l) {
  return Qg(m).getPropertyValue(l);
}
const FC = ["top", "right", "bottom", "left"];
function vh(m, l, f) {
  const y = {};
  f = f ? "-" + f : "";
  for (let T = 0; T < 4; T++) {
    const I = FC[T];
    y[I] = parseFloat(m[l + "-" + I + f]) || 0;
  }
  return ((y.width = y.left + y.right), (y.height = y.top + y.bottom), y);
}
const BC = (m, l, f) => (m > 0 || l > 0) && (!f || !f.shadowRoot);
function NC(m, l) {
  const f = m.touches,
    y = f && f.length ? f[0] : m,
    { offsetX: T, offsetY: I } = y;
  let P = !1,
    r,
    F;
  if (BC(T, I, m.target)) ((r = T), (F = I));
  else {
    const B = l.getBoundingClientRect();
    ((r = y.clientX - B.left), (F = y.clientY - B.top), (P = !0));
  }
  return { x: r, y: F, box: P };
}
function fh(m, l) {
  if ("native" in m) return m;
  const { canvas: f, currentDevicePixelRatio: y } = l,
    T = Qg(f),
    I = T.boxSizing === "border-box",
    P = vh(T, "padding"),
    r = vh(T, "border", "width"),
    { x: F, y: B, box: q } = NC(m, f),
    ne = P.left + (q && r.left),
    fe = P.top + (q && r.top);
  let { width: de, height: Ie } = l;
  return (
    I && ((de -= P.width + r.width), (Ie -= P.height + r.height)),
    {
      x: Math.round((((F - ne) / de) * f.width) / y),
      y: Math.round((((B - fe) / Ie) * f.height) / y),
    }
  );
}
function VC(m, l, f) {
  let y, T;
  if (l === void 0 || f === void 0) {
    const I = m && iv(m);
    if (!I) ((l = m.clientWidth), (f = m.clientHeight));
    else {
      const P = I.getBoundingClientRect(),
        r = Qg(I),
        F = vh(r, "border", "width"),
        B = vh(r, "padding");
      ((l = P.width - B.width - F.width),
        (f = P.height - B.height - F.height),
        (y = qg(r.maxWidth, I, "clientWidth")),
        (T = qg(r.maxHeight, I, "clientHeight")));
    }
  }
  return { width: l, height: f, maxWidth: y || Wg, maxHeight: T || Wg };
}
const Ig = (m) => Math.round(m * 10) / 10;
function UC(m, l, f, y) {
  const T = Qg(m),
    I = vh(T, "margin"),
    P = qg(T.maxWidth, m, "clientWidth") || Wg,
    r = qg(T.maxHeight, m, "clientHeight") || Wg,
    F = VC(m, l, f);
  let { width: B, height: q } = F;
  if (T.boxSizing === "content-box") {
    const fe = vh(T, "border", "width"),
      de = vh(T, "padding");
    ((B -= de.width + fe.width), (q -= de.height + fe.height));
  }
  return (
    (B = Math.max(0, B - I.width)),
    (q = Math.max(0, y ? B / y : q - I.height)),
    (B = Ig(Math.min(B, P, F.maxWidth))),
    (q = Ig(Math.min(q, r, F.maxHeight))),
    B && !q && (q = Ig(B / 2)),
    (l !== void 0 || f !== void 0) &&
      y &&
      F.height &&
      q > F.height &&
      ((q = F.height), (B = Ig(Math.floor(q * y)))),
    { width: B, height: q }
  );
}
function zw(m, l, f) {
  const y = l || 1,
    T = Math.floor(m.height * y),
    I = Math.floor(m.width * y);
  ((m.height = Math.floor(m.height)), (m.width = Math.floor(m.width)));
  const P = m.canvas;
  return (
    P.style &&
      (f || (!P.style.height && !P.style.width)) &&
      ((P.style.height = `${m.height}px`), (P.style.width = `${m.width}px`)),
    m.currentDevicePixelRatio !== y || P.height !== T || P.width !== I
      ? ((m.currentDevicePixelRatio = y),
        (P.height = T),
        (P.width = I),
        m.ctx.setTransform(y, 0, 0, y, 0, 0),
        !0)
      : !1
  );
}
const jC = (function () {
  let m = !1;
  try {
    const l = {
      get passive() {
        return ((m = !0), !1);
      },
    };
    tv() &&
      (window.addEventListener("test", null, l),
      window.removeEventListener("test", null, l));
  } catch {}
  return m;
})();
function kw(m, l) {
  const f = OC(m, l),
    y = f && f.match(/^(\d+)(\.\d+)?px$/);
  return y ? +y[1] : void 0;
}
function ph(m, l, f, y) {
  return { x: m.x + f * (l.x - m.x), y: m.y + f * (l.y - m.y) };
}
function GC(m, l, f, y) {
  return {
    x: m.x + f * (l.x - m.x),
    y:
      y === "middle"
        ? f < 0.5
          ? m.y
          : l.y
        : y === "after"
          ? f < 1
            ? m.y
            : l.y
          : f > 0
            ? l.y
            : m.y,
  };
}
function $C(m, l, f, y) {
  const T = { x: m.cp2x, y: m.cp2y },
    I = { x: l.cp1x, y: l.cp1y },
    P = ph(m, T, f),
    r = ph(T, I, f),
    F = ph(I, l, f),
    B = ph(P, r, f),
    q = ph(r, F, f);
  return ph(B, q, f);
}
const HC = function (m, l) {
    return {
      x(f) {
        return m + m + l - f;
      },
      setWidth(f) {
        l = f;
      },
      textAlign(f) {
        return f === "center" ? f : f === "right" ? "left" : "right";
      },
      xPlus(f, y) {
        return f - y;
      },
      leftForLtr(f, y) {
        return f - y;
      },
    };
  },
  WC = function () {
    return {
      x(m) {
        return m;
      },
      setWidth(m) {},
      textAlign(m) {
        return m;
      },
      xPlus(m, l) {
        return m + l;
      },
      leftForLtr(m, l) {
        return m;
      },
    };
  };
function Xu(m, l, f) {
  return m ? HC(l, f) : WC();
}
function h2(m, l) {
  let f, y;
  (l === "ltr" || l === "rtl") &&
    ((f = m.canvas.style),
    (y = [f.getPropertyValue("direction"), f.getPropertyPriority("direction")]),
    f.setProperty("direction", l, "important"),
    (m.prevTextDirection = y));
}
function u2(m, l) {
  l !== void 0 &&
    (delete m.prevTextDirection,
    m.canvas.style.setProperty("direction", l[0], l[1]));
}
function d2(m) {
  return m === "angle"
    ? { between: KT, compare: GM, normalize: Wl }
    : { between: Qf, compare: (l, f) => l - f, normalize: (l) => l };
}
function Lw({ start: m, end: l, count: f, loop: y, style: T }) {
  return {
    start: m % f,
    end: l % f,
    loop: y && (l - m + 1) % f === 0,
    style: T,
  };
}
function qC(m, l, f) {
  const { property: y, start: T, end: I } = f,
    { between: P, normalize: r } = d2(y),
    F = l.length;
  let { start: B, end: q, loop: ne } = m,
    fe,
    de;
  if (ne) {
    for (
      B += F, q += F, fe = 0, de = F;
      fe < de && P(r(l[B % F][y]), T, I);
      ++fe
    )
      (B--, q--);
    ((B %= F), (q %= F));
  }
  return (q < B && (q += F), { start: B, end: q, loop: ne, style: m.style });
}
function ZC(m, l, f) {
  if (!f) return [m];
  const { property: y, start: T, end: I } = f,
    P = l.length,
    { compare: r, between: F, normalize: B } = d2(y),
    { start: q, end: ne, loop: fe, style: de } = qC(m, l, f),
    Ie = [];
  let xe = !1,
    we = null,
    Ae,
    Qe,
    gt;
  const Rt = () => F(T, gt, Ae) && r(T, gt) !== 0,
    Mt = () => r(I, Ae) === 0 || F(I, gt, Ae),
    pt = () => xe || Rt(),
    Re = () => !xe || Mt();
  for (let rt = q, Ot = q; rt <= ne; ++rt)
    ((Qe = l[rt % P]),
      !Qe.skip &&
        ((Ae = B(Qe[y])),
        Ae !== gt &&
          ((xe = F(Ae, T, I)),
          we === null && pt() && (we = r(Ae, T) === 0 ? rt : Ot),
          we !== null &&
            Re() &&
            (Ie.push(Lw({ start: we, end: rt, loop: fe, count: P, style: de })),
            (we = null)),
          (Ot = rt),
          (gt = Ae))));
  return (
    we !== null &&
      Ie.push(Lw({ start: we, end: ne, loop: fe, count: P, style: de })),
    Ie
  );
}
function XC(m, l) {
  const f = [],
    y = m.segments;
  for (let T = 0; T < y.length; T++) {
    const I = ZC(y[T], m.points, l);
    I.length && f.push(...I);
  }
  return f;
}
function YC(m, l, f, y) {
  let T = 0,
    I = l - 1;
  if (f && !y) for (; T < l && !m[T].skip; ) T++;
  for (; T < l && m[T].skip; ) T++;
  for (T %= l, f && (I += T); I > T && m[I % l].skip; ) I--;
  return ((I %= l), { start: T, end: I });
}
function KC(m, l, f, y) {
  const T = m.length,
    I = [];
  let P = l,
    r = m[l],
    F;
  for (F = l + 1; F <= f; ++F) {
    const B = m[F % T];
    (B.skip || B.stop
      ? r.skip ||
        ((y = !1),
        I.push({ start: l % T, end: (F - 1) % T, loop: y }),
        (l = P = B.stop ? F : null))
      : ((P = F), r.skip && (l = F)),
      (r = B));
  }
  return (P !== null && I.push({ start: l % T, end: P % T, loop: y }), I);
}
function JC(m, l) {
  const f = m.points,
    y = m.options.spanGaps,
    T = f.length;
  if (!T) return [];
  const I = !!m._loop,
    { start: P, end: r } = YC(f, T, I, y);
  if (y === !0) return Ow(m, [{ start: P, end: r, loop: I }], f, l);
  const F = r < P ? r + T : r,
    B = !!m._fullLoop && P === 0 && r === T - 1;
  return Ow(m, KC(f, P, F, B), f, l);
}
function Ow(m, l, f, y) {
  return !y || !y.setContext || !f ? l : QC(m, l, f, y);
}
function QC(m, l, f, y) {
  const T = m._chart.getContext(),
    I = Fw(m.options),
    {
      _datasetIndex: P,
      options: { spanGaps: r },
    } = m,
    F = f.length,
    B = [];
  let q = I,
    ne = l[0].start,
    fe = ne;
  function de(Ie, xe, we, Ae) {
    const Qe = r ? -1 : 1;
    if (Ie !== xe) {
      for (Ie += F; f[Ie % F].skip; ) Ie -= Qe;
      for (; f[xe % F].skip; ) xe += Qe;
      Ie % F !== xe % F &&
        (B.push({ start: Ie % F, end: xe % F, loop: we, style: Ae }),
        (q = Ae),
        (ne = xe % F));
    }
  }
  for (const Ie of l) {
    ne = r ? ne : Ie.start;
    let xe = f[ne % F],
      we;
    for (fe = ne + 1; fe <= Ie.end; fe++) {
      const Ae = f[fe % F];
      ((we = Fw(
        y.setContext(
          Th(T, {
            type: "segment",
            p0: xe,
            p1: Ae,
            p0DataIndex: (fe - 1) % F,
            p1DataIndex: fe % F,
            datasetIndex: P,
          }),
        ),
      )),
        eP(we, q) && de(ne, fe - 1, Ie.loop, q),
        (xe = Ae),
        (q = we));
    }
    ne < fe - 1 && de(ne, fe - 1, Ie.loop, q);
  }
  return B;
}
function Fw(m) {
  return {
    backgroundColor: m.backgroundColor,
    borderCapStyle: m.borderCapStyle,
    borderDash: m.borderDash,
    borderDashOffset: m.borderDashOffset,
    borderJoinStyle: m.borderJoinStyle,
    borderWidth: m.borderWidth,
    borderColor: m.borderColor,
  };
}
function eP(m, l) {
  if (!l) return !1;
  const f = [],
    y = function (T, I) {
      return Xx(I) ? (f.includes(I) || f.push(I), f.indexOf(I)) : I;
    };
  return JSON.stringify(m, y) !== JSON.stringify(l, y);
}
function Ag(m, l, f) {
  return m.options.clip ? m[f] : l[f];
}
function tP(m, l) {
  const { xScale: f, yScale: y } = m;
  return f && y
    ? {
        left: Ag(f, l, "left"),
        right: Ag(f, l, "right"),
        top: Ag(y, l, "top"),
        bottom: Ag(y, l, "bottom"),
      }
    : l;
}
function iP(m, l) {
  const f = l._clip;
  if (f.disabled) return !1;
  const y = tP(l, m.chartArea);
  return {
    left: f.left === !1 ? 0 : y.left - (f.left === !0 ? 0 : f.left),
    right: f.right === !1 ? m.width : y.right + (f.right === !0 ? 0 : f.right),
    top: f.top === !1 ? 0 : y.top - (f.top === !0 ? 0 : f.top),
    bottom:
      f.bottom === !1 ? m.height : y.bottom + (f.bottom === !0 ? 0 : f.bottom),
  };
}
/*!
 * Chart.js v4.5.0
 * https://www.chartjs.org
 * (c) 2025 Chart.js Contributors
 * Released under the MIT License
 */ class nP {
  constructor() {
    ((this._request = null),
      (this._charts = new Map()),
      (this._running = !1),
      (this._lastDate = void 0));
  }
  _notify(l, f, y, T) {
    const I = f.listeners[T],
      P = f.duration;
    I.forEach((r) =>
      r({
        chart: l,
        initial: f.initial,
        numSteps: P,
        currentStep: Math.min(y - f.start, P),
      }),
    );
  }
  _refresh() {
    this._request ||
      ((this._running = !0),
      (this._request = QT.call(window, () => {
        (this._update(),
          (this._request = null),
          this._running && this._refresh());
      })));
  }
  _update(l = Date.now()) {
    let f = 0;
    (this._charts.forEach((y, T) => {
      if (!y.running || !y.items.length) return;
      const I = y.items;
      let P = I.length - 1,
        r = !1,
        F;
      for (; P >= 0; --P)
        ((F = I[P]),
          F._active
            ? (F._total > y.duration && (y.duration = F._total),
              F.tick(l),
              (r = !0))
            : ((I[P] = I[I.length - 1]), I.pop()));
      (r && (T.draw(), this._notify(T, y, l, "progress")),
        I.length ||
          ((y.running = !1),
          this._notify(T, y, l, "complete"),
          (y.initial = !1)),
        (f += I.length));
    }),
      (this._lastDate = l),
      f === 0 && (this._running = !1));
  }
  _getAnims(l) {
    const f = this._charts;
    let y = f.get(l);
    return (
      y ||
        ((y = {
          running: !1,
          initial: !0,
          items: [],
          listeners: { complete: [], progress: [] },
        }),
        f.set(l, y)),
      y
    );
  }
  listen(l, f, y) {
    this._getAnims(l).listeners[f].push(y);
  }
  add(l, f) {
    !f || !f.length || this._getAnims(l).items.push(...f);
  }
  has(l) {
    return this._getAnims(l).items.length > 0;
  }
  start(l) {
    const f = this._charts.get(l);
    f &&
      ((f.running = !0),
      (f.start = Date.now()),
      (f.duration = f.items.reduce((y, T) => Math.max(y, T._duration), 0)),
      this._refresh());
  }
  running(l) {
    if (!this._running) return !1;
    const f = this._charts.get(l);
    return !(!f || !f.running || !f.items.length);
  }
  stop(l) {
    const f = this._charts.get(l);
    if (!f || !f.items.length) return;
    const y = f.items;
    let T = y.length - 1;
    for (; T >= 0; --T) y[T].cancel();
    ((f.items = []), this._notify(l, f, Date.now(), "complete"));
  }
  remove(l) {
    return this._charts.delete(l);
  }
}
var Va = new nP();
const Bw = "transparent",
  rP = {
    boolean(m, l, f) {
      return f > 0.5 ? l : m;
    },
    color(m, l, f) {
      const y = Aw(m || Bw),
        T = y.valid && Aw(l || Bw);
      return T && T.valid ? T.mix(y, f).hexString() : l;
    },
    number(m, l, f) {
      return m + (l - m) * f;
    },
  };
class sP {
  constructor(l, f, y, T) {
    const I = f[y];
    T = Sg([l.to, T, I, l.from]);
    const P = Sg([l.from, I, T]);
    ((this._active = !0),
      (this._fn = l.fn || rP[l.type || typeof P]),
      (this._easing = ap[l.easing] || ap.linear),
      (this._start = Math.floor(Date.now() + (l.delay || 0))),
      (this._duration = this._total = Math.floor(l.duration)),
      (this._loop = !!l.loop),
      (this._target = f),
      (this._prop = y),
      (this._from = P),
      (this._to = T),
      (this._promises = void 0));
  }
  active() {
    return this._active;
  }
  update(l, f, y) {
    if (this._active) {
      this._notify(!1);
      const T = this._target[this._prop],
        I = y - this._start,
        P = this._duration - I;
      ((this._start = y),
        (this._duration = Math.floor(Math.max(P, l.duration))),
        (this._total += I),
        (this._loop = !!l.loop),
        (this._to = Sg([l.to, f, T, l.from])),
        (this._from = Sg([l.from, T, f])));
    }
  }
  cancel() {
    this._active &&
      (this.tick(Date.now()), (this._active = !1), this._notify(!1));
  }
  tick(l) {
    const f = l - this._start,
      y = this._duration,
      T = this._prop,
      I = this._from,
      P = this._loop,
      r = this._to;
    let F;
    if (((this._active = I !== r && (P || f < y)), !this._active)) {
      ((this._target[T] = r), this._notify(!0));
      return;
    }
    if (f < 0) {
      this._target[T] = I;
      return;
    }
    ((F = (f / y) % 2),
      (F = P && F > 1 ? 2 - F : F),
      (F = this._easing(Math.min(1, Math.max(0, F)))),
      (this._target[T] = this._fn(I, r, F)));
  }
  wait() {
    const l = this._promises || (this._promises = []);
    return new Promise((f, y) => {
      l.push({ res: f, rej: y });
    });
  }
  _notify(l) {
    const f = l ? "res" : "rej",
      y = this._promises || [];
    for (let T = 0; T < y.length; T++) y[T][f]();
  }
}
class f2 {
  constructor(l, f) {
    ((this._chart = l), (this._properties = new Map()), this.configure(f));
  }
  configure(l) {
    if (!Nn(l)) return;
    const f = Object.keys(gr.animation),
      y = this._properties;
    Object.getOwnPropertyNames(l).forEach((T) => {
      const I = l[T];
      if (!Nn(I)) return;
      const P = {};
      for (const r of f) P[r] = I[r];
      ((Nr(I.properties) && I.properties) || [T]).forEach((r) => {
        (r === T || !y.has(r)) && y.set(r, P);
      });
    });
  }
  _animateOptions(l, f) {
    const y = f.options,
      T = aP(l, y);
    if (!T) return [];
    const I = this._createAnimations(T, y);
    return (
      y.$shared &&
        oP(l.options.$animations, y).then(
          () => {
            l.options = y;
          },
          () => {},
        ),
      I
    );
  }
  _createAnimations(l, f) {
    const y = this._properties,
      T = [],
      I = l.$animations || (l.$animations = {}),
      P = Object.keys(f),
      r = Date.now();
    let F;
    for (F = P.length - 1; F >= 0; --F) {
      const B = P[F];
      if (B.charAt(0) === "$") continue;
      if (B === "options") {
        T.push(...this._animateOptions(l, f));
        continue;
      }
      const q = f[B];
      let ne = I[B];
      const fe = y.get(B);
      if (ne)
        if (fe && ne.active()) {
          ne.update(fe, q, r);
          continue;
        } else ne.cancel();
      if (!fe || !fe.duration) {
        l[B] = q;
        continue;
      }
      ((I[B] = ne = new sP(fe, l, B, q)), T.push(ne));
    }
    return T;
  }
  update(l, f) {
    if (this._properties.size === 0) {
      Object.assign(l, f);
      return;
    }
    const y = this._createAnimations(l, f);
    if (y.length) return (Va.add(this._chart, y), !0);
  }
}
function oP(m, l) {
  const f = [],
    y = Object.keys(l);
  for (let T = 0; T < y.length; T++) {
    const I = m[y[T]];
    I && I.active() && f.push(I.wait());
  }
  return Promise.all(f);
}
function aP(m, l) {
  if (!l) return;
  let f = m.options;
  if (!f) {
    m.options = l;
    return;
  }
  return (
    f.$shared &&
      (m.options = f = Object.assign({}, f, { $shared: !1, $animations: {} })),
    f
  );
}
function Nw(m, l) {
  const f = (m && m.options) || {},
    y = f.reverse,
    T = f.min === void 0 ? l : 0,
    I = f.max === void 0 ? l : 0;
  return { start: y ? I : T, end: y ? T : I };
}
function lP(m, l, f) {
  if (f === !1) return !1;
  const y = Nw(m, f),
    T = Nw(l, f);
  return { top: T.end, right: y.end, bottom: T.start, left: y.start };
}
function cP(m) {
  let l, f, y, T;
  return (
    Nn(m)
      ? ((l = m.top), (f = m.right), (y = m.bottom), (T = m.left))
      : (l = f = y = T = m),
    { top: l, right: f, bottom: y, left: T, disabled: m === !1 }
  );
}
function p2(m, l) {
  const f = [],
    y = m._getSortedDatasetMetas(l);
  let T, I;
  for (T = 0, I = y.length; T < I; ++T) f.push(y[T].index);
  return f;
}
function Vw(m, l, f, y = {}) {
  const T = m.keys,
    I = y.mode === "single";
  let P, r, F, B;
  if (l === null) return;
  let q = !1;
  for (P = 0, r = T.length; P < r; ++P) {
    if (((F = +T[P]), F === f)) {
      if (((q = !0), y.all)) continue;
      break;
    }
    ((B = m.values[F]), Ys(B) && (I || l === 0 || Yu(l) === Yu(B)) && (l += B));
  }
  return !q && !y.all ? 0 : l;
}
function hP(m, l) {
  const { iScale: f, vScale: y } = l,
    T = f.axis === "x" ? "x" : "y",
    I = y.axis === "x" ? "x" : "y",
    P = Object.keys(m),
    r = new Array(P.length);
  let F, B, q;
  for (F = 0, B = P.length; F < B; ++F)
    ((q = P[F]), (r[F] = { [T]: q, [I]: m[q] }));
  return r;
}
function px(m, l) {
  const f = m && m.options.stacked;
  return f || (f === void 0 && l.stack !== void 0);
}
function uP(m, l, f) {
  return `${m.id}.${l.id}.${f.stack || f.type}`;
}
function dP(m) {
  const { min: l, max: f, minDefined: y, maxDefined: T } = m.getUserBounds();
  return {
    min: y ? l : Number.NEGATIVE_INFINITY,
    max: T ? f : Number.POSITIVE_INFINITY,
  };
}
function fP(m, l, f) {
  const y = m[l] || (m[l] = {});
  return y[f] || (y[f] = {});
}
function Uw(m, l, f, y) {
  for (const T of l.getMatchingVisibleMetas(y).reverse()) {
    const I = m[T.index];
    if ((f && I > 0) || (!f && I < 0)) return T.index;
  }
  return null;
}
function jw(m, l) {
  const { chart: f, _cachedMeta: y } = m,
    T = f._stacks || (f._stacks = {}),
    { iScale: I, vScale: P, index: r } = y,
    F = I.axis,
    B = P.axis,
    q = uP(I, P, y),
    ne = l.length;
  let fe;
  for (let de = 0; de < ne; ++de) {
    const Ie = l[de],
      { [F]: xe, [B]: we } = Ie,
      Ae = Ie._stacks || (Ie._stacks = {});
    ((fe = Ae[B] = fP(T, q, xe)),
      (fe[r] = we),
      (fe._top = Uw(fe, P, !0, y.type)),
      (fe._bottom = Uw(fe, P, !1, y.type)));
    const Qe = fe._visualValues || (fe._visualValues = {});
    Qe[r] = we;
  }
}
function mx(m, l) {
  const f = m.scales;
  return Object.keys(f)
    .filter((y) => f[y].axis === l)
    .shift();
}
function pP(m, l) {
  return Th(m, {
    active: !1,
    dataset: void 0,
    datasetIndex: l,
    index: l,
    mode: "default",
    type: "dataset",
  });
}
function mP(m, l, f) {
  return Th(m, {
    active: !1,
    dataIndex: l,
    parsed: void 0,
    raw: void 0,
    element: f,
    index: l,
    mode: "default",
    type: "data",
  });
}
function Hf(m, l) {
  const f = m.controller.index,
    y = m.vScale && m.vScale.axis;
  if (y) {
    l = l || m._parsed;
    for (const T of l) {
      const I = T._stacks;
      if (!I || I[y] === void 0 || I[y][f] === void 0) return;
      (delete I[y][f],
        I[y]._visualValues !== void 0 &&
          I[y]._visualValues[f] !== void 0 &&
          delete I[y]._visualValues[f]);
    }
  }
}
const gx = (m) => m === "reset" || m === "none",
  Gw = (m, l) => (l ? m : Object.assign({}, m)),
  gP = (m, l, f) =>
    m && !l.hidden && l._stacked && { keys: p2(f, !0), values: null };
class hp {
  constructor(l, f) {
    ((this.chart = l),
      (this._ctx = l.ctx),
      (this.index = f),
      (this._cachedDataOpts = {}),
      (this._cachedMeta = this.getMeta()),
      (this._type = this._cachedMeta.type),
      (this.options = void 0),
      (this._parsing = !1),
      (this._data = void 0),
      (this._objectData = void 0),
      (this._sharedOptions = void 0),
      (this._drawStart = void 0),
      (this._drawCount = void 0),
      (this.enableOptionSharing = !1),
      (this.supportsDecimation = !1),
      (this.$context = void 0),
      (this._syncList = []),
      (this.datasetElementType = new.target.datasetElementType),
      (this.dataElementType = new.target.dataElementType),
      this.initialize());
  }
  initialize() {
    const l = this._cachedMeta;
    (this.configure(),
      this.linkScales(),
      (l._stacked = px(l.vScale, l)),
      this.addElements(),
      this.options.fill &&
        !this.chart.isPluginEnabled("filler") &&
        console.warn(
          "Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options",
        ));
  }
  updateIndex(l) {
    (this.index !== l && Hf(this._cachedMeta), (this.index = l));
  }
  linkScales() {
    const l = this.chart,
      f = this._cachedMeta,
      y = this.getDataset(),
      T = (ne, fe, de, Ie) => (ne === "x" ? fe : ne === "r" ? Ie : de),
      I = (f.xAxisID = Dn(y.xAxisID, mx(l, "x"))),
      P = (f.yAxisID = Dn(y.yAxisID, mx(l, "y"))),
      r = (f.rAxisID = Dn(y.rAxisID, mx(l, "r"))),
      F = f.indexAxis,
      B = (f.iAxisID = T(F, I, P, r)),
      q = (f.vAxisID = T(F, P, I, r));
    ((f.xScale = this.getScaleForId(I)),
      (f.yScale = this.getScaleForId(P)),
      (f.rScale = this.getScaleForId(r)),
      (f.iScale = this.getScaleForId(B)),
      (f.vScale = this.getScaleForId(q)));
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(l) {
    return this.chart.scales[l];
  }
  _getOtherScale(l) {
    const f = this._cachedMeta;
    return l === f.iScale ? f.vScale : f.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const l = this._cachedMeta;
    (this._data && Sw(this._data, this), l._stacked && Hf(l));
  }
  _dataCheck() {
    const l = this.getDataset(),
      f = l.data || (l.data = []),
      y = this._data;
    if (Nn(f)) {
      const T = this._cachedMeta;
      this._data = hP(f, T);
    } else if (y !== f) {
      if (y) {
        Sw(y, this);
        const T = this._cachedMeta;
        (Hf(T), (T._parsed = []));
      }
      (f && Object.isExtensible(f) && qM(f, this),
        (this._syncList = []),
        (this._data = f));
    }
  }
  addElements() {
    const l = this._cachedMeta;
    (this._dataCheck(),
      this.datasetElementType && (l.dataset = new this.datasetElementType()));
  }
  buildOrUpdateElements(l) {
    const f = this._cachedMeta,
      y = this.getDataset();
    let T = !1;
    this._dataCheck();
    const I = f._stacked;
    ((f._stacked = px(f.vScale, f)),
      f.stack !== y.stack && ((T = !0), Hf(f), (f.stack = y.stack)),
      this._resyncElements(l),
      (T || I !== f._stacked) &&
        (jw(this, f._parsed), (f._stacked = px(f.vScale, f))));
  }
  configure() {
    const l = this.chart.config,
      f = l.datasetScopeKeys(this._type),
      y = l.getOptionScopes(this.getDataset(), f, !0);
    ((this.options = l.createResolver(y, this.getContext())),
      (this._parsing = this.options.parsing),
      (this._cachedDataOpts = {}));
  }
  parse(l, f) {
    const { _cachedMeta: y, _data: T } = this,
      { iScale: I, _stacked: P } = y,
      r = I.axis;
    let F = l === 0 && f === T.length ? !0 : y._sorted,
      B = l > 0 && y._parsed[l - 1],
      q,
      ne,
      fe;
    if (this._parsing === !1) ((y._parsed = T), (y._sorted = !0), (fe = T));
    else {
      Nr(T[l])
        ? (fe = this.parseArrayData(y, T, l, f))
        : Nn(T[l])
          ? (fe = this.parseObjectData(y, T, l, f))
          : (fe = this.parsePrimitiveData(y, T, l, f));
      const de = () => ne[r] === null || (B && ne[r] < B[r]);
      for (q = 0; q < f; ++q)
        ((y._parsed[q + l] = ne = fe[q]), F && (de() && (F = !1), (B = ne)));
      y._sorted = F;
    }
    P && jw(this, fe);
  }
  parsePrimitiveData(l, f, y, T) {
    const { iScale: I, vScale: P } = l,
      r = I.axis,
      F = P.axis,
      B = I.getLabels(),
      q = I === P,
      ne = new Array(T);
    let fe, de, Ie;
    for (fe = 0, de = T; fe < de; ++fe)
      ((Ie = fe + y),
        (ne[fe] = { [r]: q || I.parse(B[Ie], Ie), [F]: P.parse(f[Ie], Ie) }));
    return ne;
  }
  parseArrayData(l, f, y, T) {
    const { xScale: I, yScale: P } = l,
      r = new Array(T);
    let F, B, q, ne;
    for (F = 0, B = T; F < B; ++F)
      ((q = F + y),
        (ne = f[q]),
        (r[F] = { x: I.parse(ne[0], q), y: P.parse(ne[1], q) }));
    return r;
  }
  parseObjectData(l, f, y, T) {
    const { xScale: I, yScale: P } = l,
      { xAxisKey: r = "x", yAxisKey: F = "y" } = this._parsing,
      B = new Array(T);
    let q, ne, fe, de;
    for (q = 0, ne = T; q < ne; ++q)
      ((fe = q + y),
        (de = f[fe]),
        (B[q] = { x: I.parse($g(de, r), fe), y: P.parse($g(de, F), fe) }));
    return B;
  }
  getParsed(l) {
    return this._cachedMeta._parsed[l];
  }
  getDataElement(l) {
    return this._cachedMeta.data[l];
  }
  applyStack(l, f, y) {
    const T = this.chart,
      I = this._cachedMeta,
      P = f[l.axis],
      r = { keys: p2(T, !0), values: f._stacks[l.axis]._visualValues };
    return Vw(r, P, I.index, { mode: y });
  }
  updateRangeFromParsed(l, f, y, T) {
    const I = y[f.axis];
    let P = I === null ? NaN : I;
    const r = T && y._stacks[f.axis];
    (T && r && ((T.values = r), (P = Vw(T, I, this._cachedMeta.index))),
      (l.min = Math.min(l.min, P)),
      (l.max = Math.max(l.max, P)));
  }
  getMinMax(l, f) {
    const y = this._cachedMeta,
      T = y._parsed,
      I = y._sorted && l === y.iScale,
      P = T.length,
      r = this._getOtherScale(l),
      F = gP(f, y, this.chart),
      B = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY },
      { min: q, max: ne } = dP(r);
    let fe, de;
    function Ie() {
      de = T[fe];
      const xe = de[r.axis];
      return !Ys(de[l.axis]) || q > xe || ne < xe;
    }
    for (
      fe = 0;
      fe < P && !(!Ie() && (this.updateRangeFromParsed(B, l, de, F), I));
      ++fe
    );
    if (I) {
      for (fe = P - 1; fe >= 0; --fe)
        if (!Ie()) {
          this.updateRangeFromParsed(B, l, de, F);
          break;
        }
    }
    return B;
  }
  getAllParsedValues(l) {
    const f = this._cachedMeta._parsed,
      y = [];
    let T, I, P;
    for (T = 0, I = f.length; T < I; ++T)
      ((P = f[T][l.axis]), Ys(P) && y.push(P));
    return y;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(l) {
    const f = this._cachedMeta,
      y = f.iScale,
      T = f.vScale,
      I = this.getParsed(l);
    return {
      label: y ? "" + y.getLabelForValue(I[y.axis]) : "",
      value: T ? "" + T.getLabelForValue(I[T.axis]) : "",
    };
  }
  _update(l) {
    const f = this._cachedMeta;
    (this.update(l || "default"),
      (f._clip = cP(
        Dn(this.options.clip, lP(f.xScale, f.yScale, this.getMaxOverflow())),
      )));
  }
  update(l) {}
  draw() {
    const l = this._ctx,
      f = this.chart,
      y = this._cachedMeta,
      T = y.data || [],
      I = f.chartArea,
      P = [],
      r = this._drawStart || 0,
      F = this._drawCount || T.length - r,
      B = this.options.drawActiveElementsOnTop;
    let q;
    for (y.dataset && y.dataset.draw(l, I, r, F), q = r; q < r + F; ++q) {
      const ne = T[q];
      ne.hidden || (ne.active && B ? P.push(ne) : ne.draw(l, I));
    }
    for (q = 0; q < P.length; ++q) P[q].draw(l, I);
  }
  getStyle(l, f) {
    const y = f ? "active" : "default";
    return l === void 0 && this._cachedMeta.dataset
      ? this.resolveDatasetElementOptions(y)
      : this.resolveDataElementOptions(l || 0, y);
  }
  getContext(l, f, y) {
    const T = this.getDataset();
    let I;
    if (l >= 0 && l < this._cachedMeta.data.length) {
      const P = this._cachedMeta.data[l];
      ((I = P.$context || (P.$context = mP(this.getContext(), l, P))),
        (I.parsed = this.getParsed(l)),
        (I.raw = T.data[l]),
        (I.index = I.dataIndex = l));
    } else
      ((I =
        this.$context ||
        (this.$context = pP(this.chart.getContext(), this.index))),
        (I.dataset = T),
        (I.index = I.datasetIndex = this.index));
    return ((I.active = !!f), (I.mode = y), I);
  }
  resolveDatasetElementOptions(l) {
    return this._resolveElementOptions(this.datasetElementType.id, l);
  }
  resolveDataElementOptions(l, f) {
    return this._resolveElementOptions(this.dataElementType.id, f, l);
  }
  _resolveElementOptions(l, f = "default", y) {
    const T = f === "active",
      I = this._cachedDataOpts,
      P = l + "-" + f,
      r = I[P],
      F = this.enableOptionSharing && Hg(y);
    if (r) return Gw(r, F);
    const B = this.chart.config,
      q = B.datasetElementScopeKeys(this._type, l),
      ne = T ? [`${l}Hover`, "hover", l, ""] : [l, ""],
      fe = B.getOptionScopes(this.getDataset(), q),
      de = Object.keys(gr.elements[l]),
      Ie = () => this.getContext(y, T, f),
      xe = B.resolveNamedOptions(fe, de, Ie, ne);
    return (
      xe.$shared && ((xe.$shared = F), (I[P] = Object.freeze(Gw(xe, F)))),
      xe
    );
  }
  _resolveAnimations(l, f, y) {
    const T = this.chart,
      I = this._cachedDataOpts,
      P = `animation-${f}`,
      r = I[P];
    if (r) return r;
    let F;
    if (T.options.animation !== !1) {
      const q = this.chart.config,
        ne = q.datasetAnimationScopeKeys(this._type, f),
        fe = q.getOptionScopes(this.getDataset(), ne);
      F = q.createResolver(fe, this.getContext(l, y, f));
    }
    const B = new f2(T, F && F.animations);
    return (F && F._cacheable && (I[P] = Object.freeze(B)), B);
  }
  getSharedOptions(l) {
    if (l.$shared)
      return (
        this._sharedOptions || (this._sharedOptions = Object.assign({}, l))
      );
  }
  includeOptions(l, f) {
    return !f || gx(l) || this.chart._animationsDisabled;
  }
  _getSharedOptions(l, f) {
    const y = this.resolveDataElementOptions(l, f),
      T = this._sharedOptions,
      I = this.getSharedOptions(y),
      P = this.includeOptions(f, I) || I !== T;
    return (
      this.updateSharedOptions(I, f, y),
      { sharedOptions: I, includeOptions: P }
    );
  }
  updateElement(l, f, y, T) {
    gx(T) ? Object.assign(l, y) : this._resolveAnimations(f, T).update(l, y);
  }
  updateSharedOptions(l, f, y) {
    l && !gx(f) && this._resolveAnimations(void 0, f).update(l, y);
  }
  _setStyle(l, f, y, T) {
    l.active = T;
    const I = this.getStyle(f, T);
    this._resolveAnimations(f, y, T).update(l, {
      options: (!T && this.getSharedOptions(I)) || I,
    });
  }
  removeHoverStyle(l, f, y) {
    this._setStyle(l, y, "active", !1);
  }
  setHoverStyle(l, f, y) {
    this._setStyle(l, y, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const l = this._cachedMeta.dataset;
    l && this._setStyle(l, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const l = this._cachedMeta.dataset;
    l && this._setStyle(l, void 0, "active", !0);
  }
  _resyncElements(l) {
    const f = this._data,
      y = this._cachedMeta.data;
    for (const [r, F, B] of this._syncList) this[r](F, B);
    this._syncList = [];
    const T = y.length,
      I = f.length,
      P = Math.min(I, T);
    (P && this.parse(0, P),
      I > T
        ? this._insertElements(T, I - T, l)
        : I < T && this._removeElements(I, T - I));
  }
  _insertElements(l, f, y = !0) {
    const T = this._cachedMeta,
      I = T.data,
      P = l + f;
    let r;
    const F = (B) => {
      for (B.length += f, r = B.length - 1; r >= P; r--) B[r] = B[r - f];
    };
    for (F(I), r = l; r < P; ++r) I[r] = new this.dataElementType();
    (this._parsing && F(T._parsed),
      this.parse(l, f),
      y && this.updateElements(I, l, f, "reset"));
  }
  updateElements(l, f, y, T) {}
  _removeElements(l, f) {
    const y = this._cachedMeta;
    if (this._parsing) {
      const T = y._parsed.splice(l, f);
      y._stacked && Hf(y, T);
    }
    y.data.splice(l, f);
  }
  _sync(l) {
    if (this._parsing) this._syncList.push(l);
    else {
      const [f, y, T] = l;
      this[f](y, T);
    }
    this.chart._dataChanges.push([this.index, ...l]);
  }
  _onDataPush() {
    const l = arguments.length;
    this._sync(["_insertElements", this.getDataset().data.length - l, l]);
  }
  _onDataPop() {
    this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
  }
  _onDataShift() {
    this._sync(["_removeElements", 0, 1]);
  }
  _onDataSplice(l, f) {
    f && this._sync(["_removeElements", l, f]);
    const y = arguments.length - 2;
    y && this._sync(["_insertElements", l, y]);
  }
  _onDataUnshift() {
    this._sync(["_insertElements", 0, arguments.length]);
  }
}
(ln(hp, "defaults", {}),
  ln(hp, "datasetElementType", null),
  ln(hp, "dataElementType", null));
class Bg extends hp {
  initialize() {
    ((this.enableOptionSharing = !0),
      (this.supportsDecimation = !0),
      super.initialize());
  }
  update(l) {
    const f = this._cachedMeta,
      { dataset: y, data: T = [], _dataset: I } = f,
      P = this.chart._animationsDisabled;
    let { start: r, count: F } = KM(f, T, P);
    ((this._drawStart = r),
      (this._drawCount = F),
      JM(f) && ((r = 0), (F = T.length)),
      (y._chart = this.chart),
      (y._datasetIndex = this.index),
      (y._decimated = !!I._decimated),
      (y.points = T));
    const B = this.resolveDatasetElementOptions(l);
    (this.options.showLine || (B.borderWidth = 0),
      (B.segment = this.options.segment),
      this.updateElement(y, void 0, { animated: !P, options: B }, l),
      this.updateElements(T, r, F, l));
  }
  updateElements(l, f, y, T) {
    const I = T === "reset",
      { iScale: P, vScale: r, _stacked: F, _dataset: B } = this._cachedMeta,
      { sharedOptions: q, includeOptions: ne } = this._getSharedOptions(f, T),
      fe = P.axis,
      de = r.axis,
      { spanGaps: Ie, segment: xe } = this.options,
      we = mp(Ie) ? Ie : Number.POSITIVE_INFINITY,
      Ae = this.chart._animationsDisabled || I || T === "none",
      Qe = f + y,
      gt = l.length;
    let Rt = f > 0 && this.getParsed(f - 1);
    for (let Mt = 0; Mt < gt; ++Mt) {
      const pt = l[Mt],
        Re = Ae ? pt : {};
      if (Mt < f || Mt >= Qe) {
        Re.skip = !0;
        continue;
      }
      const rt = this.getParsed(Mt),
        Ot = Jn(rt[de]),
        _i = (Re[fe] = P.getPixelForValue(rt[fe], Mt)),
        qt = (Re[de] =
          I || Ot
            ? r.getBasePixel()
            : r.getPixelForValue(F ? this.applyStack(r, rt, F) : rt[de], Mt));
      ((Re.skip = isNaN(_i) || isNaN(qt) || Ot),
        (Re.stop = Mt > 0 && Math.abs(rt[fe] - Rt[fe]) > we),
        xe && ((Re.parsed = rt), (Re.raw = B.data[Mt])),
        ne &&
          (Re.options =
            q || this.resolveDataElementOptions(Mt, pt.active ? "active" : T)),
        Ae || this.updateElement(pt, Mt, Re, T),
        (Rt = rt));
    }
  }
  getMaxOverflow() {
    const l = this._cachedMeta,
      f = l.dataset,
      y = (f.options && f.options.borderWidth) || 0,
      T = l.data || [];
    if (!T.length) return y;
    const I = T[0].size(this.resolveDataElementOptions(0)),
      P = T[T.length - 1].size(this.resolveDataElementOptions(T.length - 1));
    return Math.max(y, I, P) / 2;
  }
  draw() {
    const l = this._cachedMeta;
    (l.dataset.updateControlPoints(this.chart.chartArea, l.iScale.axis),
      super.draw());
  }
}
(ln(Bg, "id", "line"),
  ln(Bg, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: !0,
    spanGaps: !1,
  }),
  ln(Bg, "overrides", {
    scales: { _index_: { type: "category" }, _value_: { type: "linear" } },
  }));
function dh() {
  throw new Error(
    "This method is not implemented: Check that a complete date adapter is provided.",
  );
}
class nv {
  constructor(l) {
    ln(this, "options");
    this.options = l || {};
  }
  static override(l) {
    Object.assign(nv.prototype, l);
  }
  init() {}
  formats() {
    return dh();
  }
  parse() {
    return dh();
  }
  format() {
    return dh();
  }
  add() {
    return dh();
  }
  diff() {
    return dh();
  }
  startOf() {
    return dh();
  }
  endOf() {
    return dh();
  }
}
var _P = { _date: nv };
function yP(m, l, f, y) {
  const { controller: T, data: I, _sorted: P } = m,
    r = T._cachedMeta.iScale,
    F = m.dataset && m.dataset.options ? m.dataset.options.spanGaps : null;
  if (r && l === r.axis && l !== "r" && P && I.length) {
    const B = r._reversePixels ? HM : _h;
    if (y) {
      if (T._sharedOptions) {
        const q = I[0],
          ne = typeof q.getRange == "function" && q.getRange(l);
        if (ne) {
          const fe = B(I, l, f - ne),
            de = B(I, l, f + ne);
          return { lo: fe.lo, hi: de.hi };
        }
      }
    } else {
      const q = B(I, l, f);
      if (F) {
        const { vScale: ne } = T._cachedMeta,
          { _parsed: fe } = m,
          de = fe
            .slice(0, q.lo + 1)
            .reverse()
            .findIndex((xe) => !Jn(xe[ne.axis]));
        q.lo -= Math.max(0, de);
        const Ie = fe.slice(q.hi).findIndex((xe) => !Jn(xe[ne.axis]));
        q.hi += Math.max(0, Ie);
      }
      return q;
    }
  }
  return { lo: 0, hi: I.length - 1 };
}
function e_(m, l, f, y, T) {
  const I = m.getSortedVisibleDatasetMetas(),
    P = f[l];
  for (let r = 0, F = I.length; r < F; ++r) {
    const { index: B, data: q } = I[r],
      { lo: ne, hi: fe } = yP(I[r], l, P, T);
    for (let de = ne; de <= fe; ++de) {
      const Ie = q[de];
      Ie.skip || y(Ie, B, de);
    }
  }
}
function xP(m) {
  const l = m.indexOf("x") !== -1,
    f = m.indexOf("y") !== -1;
  return function (y, T) {
    const I = l ? Math.abs(y.x - T.x) : 0,
      P = f ? Math.abs(y.y - T.y) : 0;
    return Math.sqrt(Math.pow(I, 2) + Math.pow(P, 2));
  };
}
function _x(m, l, f, y, T) {
  const I = [];
  return (
    (!T && !m.isPointInArea(l)) ||
      e_(
        m,
        f,
        l,
        function (r, F, B) {
          (!T && !gp(r, m.chartArea, 0)) ||
            (r.inRange(l.x, l.y, y) &&
              I.push({ element: r, datasetIndex: F, index: B }));
        },
        !0,
      ),
    I
  );
}
function vP(m, l, f, y) {
  let T = [];
  function I(P, r, F) {
    const { startAngle: B, endAngle: q } = P.getProps(
        ["startAngle", "endAngle"],
        y,
      ),
      { angle: ne } = jM(P, { x: l.x, y: l.y });
    KT(ne, B, q) && T.push({ element: P, datasetIndex: r, index: F });
  }
  return (e_(m, f, l, I), T);
}
function bP(m, l, f, y, T, I) {
  let P = [];
  const r = xP(f);
  let F = Number.POSITIVE_INFINITY;
  function B(q, ne, fe) {
    const de = q.inRange(l.x, l.y, T);
    if (y && !de) return;
    const Ie = q.getCenterPoint(T);
    if (!(!!I || m.isPointInArea(Ie)) && !de) return;
    const we = r(l, Ie);
    we < F
      ? ((P = [{ element: q, datasetIndex: ne, index: fe }]), (F = we))
      : we === F && P.push({ element: q, datasetIndex: ne, index: fe });
  }
  return (e_(m, f, l, B), P);
}
function yx(m, l, f, y, T, I) {
  return !I && !m.isPointInArea(l)
    ? []
    : f === "r" && !y
      ? vP(m, l, f, T)
      : bP(m, l, f, y, T, I);
}
function $w(m, l, f, y, T) {
  const I = [],
    P = f === "x" ? "inXRange" : "inYRange";
  let r = !1;
  return (
    e_(m, f, l, (F, B, q) => {
      F[P] &&
        F[P](l[f], T) &&
        (I.push({ element: F, datasetIndex: B, index: q }),
        (r = r || F.inRange(l.x, l.y, T)));
    }),
    y && !r ? [] : I
  );
}
var wP = {
  modes: {
    index(m, l, f, y) {
      const T = fh(l, m),
        I = f.axis || "x",
        P = f.includeInvisible || !1,
        r = f.intersect ? _x(m, T, I, y, P) : yx(m, T, I, !1, y, P),
        F = [];
      return r.length
        ? (m.getSortedVisibleDatasetMetas().forEach((B) => {
            const q = r[0].index,
              ne = B.data[q];
            ne &&
              !ne.skip &&
              F.push({ element: ne, datasetIndex: B.index, index: q });
          }),
          F)
        : [];
    },
    dataset(m, l, f, y) {
      const T = fh(l, m),
        I = f.axis || "xy",
        P = f.includeInvisible || !1;
      let r = f.intersect ? _x(m, T, I, y, P) : yx(m, T, I, !1, y, P);
      if (r.length > 0) {
        const F = r[0].datasetIndex,
          B = m.getDatasetMeta(F).data;
        r = [];
        for (let q = 0; q < B.length; ++q)
          r.push({ element: B[q], datasetIndex: F, index: q });
      }
      return r;
    },
    point(m, l, f, y) {
      const T = fh(l, m),
        I = f.axis || "xy",
        P = f.includeInvisible || !1;
      return _x(m, T, I, y, P);
    },
    nearest(m, l, f, y) {
      const T = fh(l, m),
        I = f.axis || "xy",
        P = f.includeInvisible || !1;
      return yx(m, T, I, f.intersect, y, P);
    },
    x(m, l, f, y) {
      const T = fh(l, m);
      return $w(m, T, "x", f.intersect, y);
    },
    y(m, l, f, y) {
      const T = fh(l, m);
      return $w(m, T, "y", f.intersect, y);
    },
  },
};
const m2 = ["left", "top", "right", "bottom"];
function Wf(m, l) {
  return m.filter((f) => f.pos === l);
}
function Hw(m, l) {
  return m.filter((f) => m2.indexOf(f.pos) === -1 && f.box.axis === l);
}
function qf(m, l) {
  return m.sort((f, y) => {
    const T = l ? y : f,
      I = l ? f : y;
    return T.weight === I.weight ? T.index - I.index : T.weight - I.weight;
  });
}
function TP(m) {
  const l = [];
  let f, y, T, I, P, r;
  for (f = 0, y = (m || []).length; f < y; ++f)
    ((T = m[f]),
      ({
        position: I,
        options: { stack: P, stackWeight: r = 1 },
      } = T),
      l.push({
        index: f,
        box: T,
        pos: I,
        horizontal: T.isHorizontal(),
        weight: T.weight,
        stack: P && I + P,
        stackWeight: r,
      }));
  return l;
}
function SP(m) {
  const l = {};
  for (const f of m) {
    const { stack: y, pos: T, stackWeight: I } = f;
    if (!y || !m2.includes(T)) continue;
    const P = l[y] || (l[y] = { count: 0, placed: 0, weight: 0, size: 0 });
    (P.count++, (P.weight += I));
  }
  return l;
}
function EP(m, l) {
  const f = SP(m),
    { vBoxMaxWidth: y, hBoxMaxHeight: T } = l;
  let I, P, r;
  for (I = 0, P = m.length; I < P; ++I) {
    r = m[I];
    const { fullSize: F } = r.box,
      B = f[r.stack],
      q = B && r.stackWeight / B.weight;
    r.horizontal
      ? ((r.width = q ? q * y : F && l.availableWidth), (r.height = T))
      : ((r.width = y), (r.height = q ? q * T : F && l.availableHeight));
  }
  return f;
}
function IP(m) {
  const l = TP(m),
    f = qf(
      l.filter((B) => B.box.fullSize),
      !0,
    ),
    y = qf(Wf(l, "left"), !0),
    T = qf(Wf(l, "right")),
    I = qf(Wf(l, "top"), !0),
    P = qf(Wf(l, "bottom")),
    r = Hw(l, "x"),
    F = Hw(l, "y");
  return {
    fullSize: f,
    leftAndTop: y.concat(I),
    rightAndBottom: T.concat(F).concat(P).concat(r),
    chartArea: Wf(l, "chartArea"),
    vertical: y.concat(T).concat(F),
    horizontal: I.concat(P).concat(r),
  };
}
function Ww(m, l, f, y) {
  return Math.max(m[f], l[f]) + Math.max(m[y], l[y]);
}
function g2(m, l) {
  ((m.top = Math.max(m.top, l.top)),
    (m.left = Math.max(m.left, l.left)),
    (m.bottom = Math.max(m.bottom, l.bottom)),
    (m.right = Math.max(m.right, l.right)));
}
function AP(m, l, f, y) {
  const { pos: T, box: I } = f,
    P = m.maxPadding;
  if (!Nn(T)) {
    f.size && (m[T] -= f.size);
    const ne = y[f.stack] || { size: 0, count: 1 };
    ((ne.size = Math.max(ne.size, f.horizontal ? I.height : I.width)),
      (f.size = ne.size / ne.count),
      (m[T] += f.size));
  }
  I.getPadding && g2(P, I.getPadding());
  const r = Math.max(0, l.outerWidth - Ww(P, m, "left", "right")),
    F = Math.max(0, l.outerHeight - Ww(P, m, "top", "bottom")),
    B = r !== m.w,
    q = F !== m.h;
  return (
    (m.w = r),
    (m.h = F),
    f.horizontal ? { same: B, other: q } : { same: q, other: B }
  );
}
function MP(m) {
  const l = m.maxPadding;
  function f(y) {
    const T = Math.max(l[y] - m[y], 0);
    return ((m[y] += T), T);
  }
  ((m.y += f("top")), (m.x += f("left")), f("right"), f("bottom"));
}
function CP(m, l) {
  const f = l.maxPadding;
  function y(T) {
    const I = { left: 0, top: 0, right: 0, bottom: 0 };
    return (
      T.forEach((P) => {
        I[P] = Math.max(l[P], f[P]);
      }),
      I
    );
  }
  return y(m ? ["left", "right"] : ["top", "bottom"]);
}
function ep(m, l, f, y) {
  const T = [];
  let I, P, r, F, B, q;
  for (I = 0, P = m.length, B = 0; I < P; ++I) {
    ((r = m[I]),
      (F = r.box),
      F.update(r.width || l.w, r.height || l.h, CP(r.horizontal, l)));
    const { same: ne, other: fe } = AP(l, f, r, y);
    ((B |= ne && T.length), (q = q || fe), F.fullSize || T.push(r));
  }
  return (B && ep(T, l, f, y)) || q;
}
function Mg(m, l, f, y, T) {
  ((m.top = f),
    (m.left = l),
    (m.right = l + y),
    (m.bottom = f + T),
    (m.width = y),
    (m.height = T));
}
function qw(m, l, f, y) {
  const T = f.padding;
  let { x: I, y: P } = l;
  for (const r of m) {
    const F = r.box,
      B = y[r.stack] || { placed: 0, weight: 1 },
      q = r.stackWeight / B.weight || 1;
    if (r.horizontal) {
      const ne = l.w * q,
        fe = B.size || F.height;
      (Hg(B.start) && (P = B.start),
        F.fullSize
          ? Mg(F, T.left, P, f.outerWidth - T.right - T.left, fe)
          : Mg(F, l.left + B.placed, P, ne, fe),
        (B.start = P),
        (B.placed += ne),
        (P = F.bottom));
    } else {
      const ne = l.h * q,
        fe = B.size || F.width;
      (Hg(B.start) && (I = B.start),
        F.fullSize
          ? Mg(F, I, T.top, fe, f.outerHeight - T.bottom - T.top)
          : Mg(F, I, l.top + B.placed, fe, ne),
        (B.start = I),
        (B.placed += ne),
        (I = F.right));
    }
  }
  ((l.x = I), (l.y = P));
}
var Zs = {
  addBox(m, l) {
    (m.boxes || (m.boxes = []),
      (l.fullSize = l.fullSize || !1),
      (l.position = l.position || "top"),
      (l.weight = l.weight || 0),
      (l._layers =
        l._layers ||
        function () {
          return [
            {
              z: 0,
              draw(f) {
                l.draw(f);
              },
            },
          ];
        }),
      m.boxes.push(l));
  },
  removeBox(m, l) {
    const f = m.boxes ? m.boxes.indexOf(l) : -1;
    f !== -1 && m.boxes.splice(f, 1);
  },
  configure(m, l, f) {
    ((l.fullSize = f.fullSize),
      (l.position = f.position),
      (l.weight = f.weight));
  },
  update(m, l, f, y) {
    if (!m) return;
    const T = Ks(m.options.layout.padding),
      I = Math.max(l - T.width, 0),
      P = Math.max(f - T.height, 0),
      r = IP(m.boxes),
      F = r.vertical,
      B = r.horizontal;
    jn(m.boxes, (xe) => {
      typeof xe.beforeLayout == "function" && xe.beforeLayout();
    });
    const q =
        F.reduce(
          (xe, we) =>
            we.box.options && we.box.options.display === !1 ? xe : xe + 1,
          0,
        ) || 1,
      ne = Object.freeze({
        outerWidth: l,
        outerHeight: f,
        padding: T,
        availableWidth: I,
        availableHeight: P,
        vBoxMaxWidth: I / 2 / q,
        hBoxMaxHeight: P / 2,
      }),
      fe = Object.assign({}, T);
    g2(fe, Ks(y));
    const de = Object.assign(
        { maxPadding: fe, w: I, h: P, x: T.left, y: T.top },
        T,
      ),
      Ie = EP(F.concat(B), ne);
    (ep(r.fullSize, de, ne, Ie),
      ep(F, de, ne, Ie),
      ep(B, de, ne, Ie) && ep(F, de, ne, Ie),
      MP(de),
      qw(r.leftAndTop, de, ne, Ie),
      (de.x += de.w),
      (de.y += de.h),
      qw(r.rightAndBottom, de, ne, Ie),
      (m.chartArea = {
        left: de.left,
        top: de.top,
        right: de.left + de.w,
        bottom: de.top + de.h,
        height: de.h,
        width: de.w,
      }),
      jn(r.chartArea, (xe) => {
        const we = xe.box;
        (Object.assign(we, m.chartArea),
          we.update(de.w, de.h, { left: 0, top: 0, right: 0, bottom: 0 }));
      }));
  },
};
class _2 {
  acquireContext(l, f) {}
  releaseContext(l) {
    return !1;
  }
  addEventListener(l, f, y) {}
  removeEventListener(l, f, y) {}
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(l, f, y, T) {
    return (
      (f = Math.max(0, f || l.width)),
      (y = y || l.height),
      { width: f, height: Math.max(0, T ? Math.floor(f / T) : y) }
    );
  }
  isAttached(l) {
    return !0;
  }
  updateConfig(l) {}
}
class PP extends _2 {
  acquireContext(l) {
    return (l && l.getContext && l.getContext("2d")) || null;
  }
  updateConfig(l) {
    l.options.animation = !1;
  }
}
const Ng = "$chartjs",
  DP = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout",
  },
  Zw = (m) => m === null || m === "";
function RP(m, l) {
  const f = m.style,
    y = m.getAttribute("height"),
    T = m.getAttribute("width");
  if (
    ((m[Ng] = {
      initial: {
        height: y,
        width: T,
        style: { display: f.display, height: f.height, width: f.width },
      },
    }),
    (f.display = f.display || "block"),
    (f.boxSizing = f.boxSizing || "border-box"),
    Zw(T))
  ) {
    const I = kw(m, "width");
    I !== void 0 && (m.width = I);
  }
  if (Zw(y))
    if (m.style.height === "") m.height = m.width / (l || 2);
    else {
      const I = kw(m, "height");
      I !== void 0 && (m.height = I);
    }
  return m;
}
const y2 = jC ? { passive: !0 } : !1;
function zP(m, l, f) {
  m && m.addEventListener(l, f, y2);
}
function kP(m, l, f) {
  m && m.canvas && m.canvas.removeEventListener(l, f, y2);
}
function LP(m, l) {
  const f = DP[m.type] || m.type,
    { x: y, y: T } = fh(m, l);
  return {
    type: f,
    chart: l,
    native: m,
    x: y !== void 0 ? y : null,
    y: T !== void 0 ? T : null,
  };
}
function Zg(m, l) {
  for (const f of m) if (f === l || f.contains(l)) return !0;
}
function OP(m, l, f) {
  const y = m.canvas,
    T = new MutationObserver((I) => {
      let P = !1;
      for (const r of I)
        ((P = P || Zg(r.addedNodes, y)), (P = P && !Zg(r.removedNodes, y)));
      P && f();
    });
  return (T.observe(document, { childList: !0, subtree: !0 }), T);
}
function FP(m, l, f) {
  const y = m.canvas,
    T = new MutationObserver((I) => {
      let P = !1;
      for (const r of I)
        ((P = P || Zg(r.removedNodes, y)), (P = P && !Zg(r.addedNodes, y)));
      P && f();
    });
  return (T.observe(document, { childList: !0, subtree: !0 }), T);
}
const yp = new Map();
let Xw = 0;
function x2() {
  const m = window.devicePixelRatio;
  m !== Xw &&
    ((Xw = m),
    yp.forEach((l, f) => {
      f.currentDevicePixelRatio !== m && l();
    }));
}
function BP(m, l) {
  (yp.size || window.addEventListener("resize", x2), yp.set(m, l));
}
function NP(m) {
  (yp.delete(m), yp.size || window.removeEventListener("resize", x2));
}
function VP(m, l, f) {
  const y = m.canvas,
    T = y && iv(y);
  if (!T) return;
  const I = e2((r, F) => {
      const B = T.clientWidth;
      (f(r, F), B < T.clientWidth && f());
    }, window),
    P = new ResizeObserver((r) => {
      const F = r[0],
        B = F.contentRect.width,
        q = F.contentRect.height;
      (B === 0 && q === 0) || I(B, q);
    });
  return (P.observe(T), BP(m, I), P);
}
function xx(m, l, f) {
  (f && f.disconnect(), l === "resize" && NP(m));
}
function UP(m, l, f) {
  const y = m.canvas,
    T = e2((I) => {
      m.ctx !== null && f(LP(I, m));
    }, m);
  return (zP(y, l, T), T);
}
class jP extends _2 {
  acquireContext(l, f) {
    const y = l && l.getContext && l.getContext("2d");
    return y && y.canvas === l ? (RP(l, f), y) : null;
  }
  releaseContext(l) {
    const f = l.canvas;
    if (!f[Ng]) return !1;
    const y = f[Ng].initial;
    ["height", "width"].forEach((I) => {
      const P = y[I];
      Jn(P) ? f.removeAttribute(I) : f.setAttribute(I, P);
    });
    const T = y.style || {};
    return (
      Object.keys(T).forEach((I) => {
        f.style[I] = T[I];
      }),
      (f.width = f.width),
      delete f[Ng],
      !0
    );
  }
  addEventListener(l, f, y) {
    this.removeEventListener(l, f);
    const T = l.$proxies || (l.$proxies = {}),
      P = { attach: OP, detach: FP, resize: VP }[f] || UP;
    T[f] = P(l, f, y);
  }
  removeEventListener(l, f) {
    const y = l.$proxies || (l.$proxies = {}),
      T = y[f];
    if (!T) return;
    ((({ attach: xx, detach: xx, resize: xx })[f] || kP)(l, f, T),
      (y[f] = void 0));
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(l, f, y, T) {
    return UC(l, f, y, T);
  }
  isAttached(l) {
    const f = l && iv(l);
    return !!(f && f.isConnected);
  }
}
function GP(m) {
  return !tv() || (typeof OffscreenCanvas < "u" && m instanceof OffscreenCanvas)
    ? PP
    : jP;
}
class $a {
  constructor() {
    ln(this, "x");
    ln(this, "y");
    ln(this, "active", !1);
    ln(this, "options");
    ln(this, "$animations");
  }
  tooltipPosition(l) {
    const { x: f, y } = this.getProps(["x", "y"], l);
    return { x: f, y };
  }
  hasValue() {
    return mp(this.x) && mp(this.y);
  }
  getProps(l, f) {
    const y = this.$animations;
    if (!f || !y) return this;
    const T = {};
    return (
      l.forEach((I) => {
        T[I] = y[I] && y[I].active() ? y[I]._to : this[I];
      }),
      T
    );
  }
}
(ln($a, "defaults", {}), ln($a, "defaultRoutes"));
function $P(m, l) {
  const f = m.options.ticks,
    y = HP(m),
    T = Math.min(f.maxTicksLimit || y, y),
    I = f.major.enabled ? qP(l) : [],
    P = I.length,
    r = I[0],
    F = I[P - 1],
    B = [];
  if (P > T) return (ZP(l, B, I, P / T), B);
  const q = WP(I, l, T);
  if (P > 0) {
    let ne, fe;
    const de = P > 1 ? Math.round((F - r) / (P - 1)) : null;
    for (Cg(l, B, q, Jn(de) ? 0 : r - de, r), ne = 0, fe = P - 1; ne < fe; ne++)
      Cg(l, B, q, I[ne], I[ne + 1]);
    return (Cg(l, B, q, F, Jn(de) ? l.length : F + de), B);
  }
  return (Cg(l, B, q), B);
}
function HP(m) {
  const l = m.options.offset,
    f = m._tickSize(),
    y = m._length / f + (l ? 0 : 1),
    T = m._maxLength / f;
  return Math.floor(Math.min(y, T));
}
function WP(m, l, f) {
  const y = XP(m),
    T = l.length / f;
  if (!y) return Math.max(T, 1);
  const I = FM(y);
  for (let P = 0, r = I.length - 1; P < r; P++) {
    const F = I[P];
    if (F > T) return F;
  }
  return Math.max(T, 1);
}
function qP(m) {
  const l = [];
  let f, y;
  for (f = 0, y = m.length; f < y; f++) m[f].major && l.push(f);
  return l;
}
function ZP(m, l, f, y) {
  let T = 0,
    I = f[0],
    P;
  for (y = Math.ceil(y), P = 0; P < m.length; P++)
    P === I && (l.push(m[P]), T++, (I = f[T * y]));
}
function Cg(m, l, f, y, T) {
  const I = Dn(y, 0),
    P = Math.min(Dn(T, m.length), m.length);
  let r = 0,
    F,
    B,
    q;
  for (
    f = Math.ceil(f), T && ((F = T - y), (f = F / Math.floor(F / f))), q = I;
    q < 0;

  )
    (r++, (q = Math.round(I + r * f)));
  for (B = Math.max(I, 0); B < P; B++)
    B === q && (l.push(m[B]), r++, (q = Math.round(I + r * f)));
}
function XP(m) {
  const l = m.length;
  let f, y;
  if (l < 2) return !1;
  for (y = m[0], f = 1; f < l; ++f) if (m[f] - m[f - 1] !== y) return !1;
  return y;
}
const YP = (m) => (m === "left" ? "right" : m === "right" ? "left" : m),
  Yw = (m, l, f) => (l === "top" || l === "left" ? m[l] + f : m[l] - f),
  Kw = (m, l) => Math.min(l || m, m);
function Jw(m, l) {
  const f = [],
    y = m.length / l,
    T = m.length;
  let I = 0;
  for (; I < T; I += y) f.push(m[Math.floor(I)]);
  return f;
}
function KP(m, l, f) {
  const y = m.ticks.length,
    T = Math.min(l, y - 1),
    I = m._startPixel,
    P = m._endPixel,
    r = 1e-6;
  let F = m.getPixelForTick(T),
    B;
  if (
    !(
      f &&
      (y === 1
        ? (B = Math.max(F - I, P - F))
        : l === 0
          ? (B = (m.getPixelForTick(1) - F) / 2)
          : (B = (F - m.getPixelForTick(T - 1)) / 2),
      (F += T < l ? B : -B),
      F < I - r || F > P + r)
    )
  )
    return F;
}
function JP(m, l) {
  jn(m, (f) => {
    const y = f.gc,
      T = y.length / 2;
    let I;
    if (T > l) {
      for (I = 0; I < T; ++I) delete f.data[y[I]];
      y.splice(0, T);
    }
  });
}
function Zf(m) {
  return m.drawTicks ? m.tickLength : 0;
}
function Qw(m, l) {
  if (!m.display) return 0;
  const f = rs(m.font, l),
    y = Ks(m.padding);
  return (Nr(m.text) ? m.text.length : 1) * f.lineHeight + y.height;
}
function QP(m, l) {
  return Th(m, { scale: l, type: "scale" });
}
function eD(m, l, f) {
  return Th(m, { tick: f, index: l, type: "tick" });
}
function tD(m, l, f) {
  let y = Zx(m);
  return (((f && l !== "right") || (!f && l === "right")) && (y = YP(y)), y);
}
function iD(m, l, f, y) {
  const { top: T, left: I, bottom: P, right: r, chart: F } = m,
    { chartArea: B, scales: q } = F;
  let ne = 0,
    fe,
    de,
    Ie;
  const xe = P - T,
    we = r - I;
  if (m.isHorizontal()) {
    if (((de = ns(y, I, r)), Nn(f))) {
      const Ae = Object.keys(f)[0],
        Qe = f[Ae];
      Ie = q[Ae].getPixelForValue(Qe) + xe - l;
    } else
      f === "center"
        ? (Ie = (B.bottom + B.top) / 2 + xe - l)
        : (Ie = Yw(m, f, l));
    fe = r - I;
  } else {
    if (Nn(f)) {
      const Ae = Object.keys(f)[0],
        Qe = f[Ae];
      de = q[Ae].getPixelForValue(Qe) - we + l;
    } else
      f === "center"
        ? (de = (B.left + B.right) / 2 - we + l)
        : (de = Yw(m, f, l));
    ((Ie = ns(y, P, T)), (ne = f === "left" ? -wo : wo));
  }
  return { titleX: de, titleY: Ie, maxWidth: fe, rotation: ne };
}
class Qu extends $a {
  constructor(l) {
    (super(),
      (this.id = l.id),
      (this.type = l.type),
      (this.options = void 0),
      (this.ctx = l.ctx),
      (this.chart = l.chart),
      (this.top = void 0),
      (this.bottom = void 0),
      (this.left = void 0),
      (this.right = void 0),
      (this.width = void 0),
      (this.height = void 0),
      (this._margins = { left: 0, right: 0, top: 0, bottom: 0 }),
      (this.maxWidth = void 0),
      (this.maxHeight = void 0),
      (this.paddingTop = void 0),
      (this.paddingBottom = void 0),
      (this.paddingLeft = void 0),
      (this.paddingRight = void 0),
      (this.axis = void 0),
      (this.labelRotation = void 0),
      (this.min = void 0),
      (this.max = void 0),
      (this._range = void 0),
      (this.ticks = []),
      (this._gridLineItems = null),
      (this._labelItems = null),
      (this._labelSizes = null),
      (this._length = 0),
      (this._maxLength = 0),
      (this._longestTextCache = {}),
      (this._startPixel = void 0),
      (this._endPixel = void 0),
      (this._reversePixels = !1),
      (this._userMax = void 0),
      (this._userMin = void 0),
      (this._suggestedMax = void 0),
      (this._suggestedMin = void 0),
      (this._ticksLength = 0),
      (this._borderValue = 0),
      (this._cache = {}),
      (this._dataLimitsCached = !1),
      (this.$context = void 0));
  }
  init(l) {
    ((this.options = l.setContext(this.getContext())),
      (this.axis = l.axis),
      (this._userMin = this.parse(l.min)),
      (this._userMax = this.parse(l.max)),
      (this._suggestedMin = this.parse(l.suggestedMin)),
      (this._suggestedMax = this.parse(l.suggestedMax)));
  }
  parse(l, f) {
    return l;
  }
  getUserBounds() {
    let { _userMin: l, _userMax: f, _suggestedMin: y, _suggestedMax: T } = this;
    return (
      (l = ea(l, Number.POSITIVE_INFINITY)),
      (f = ea(f, Number.NEGATIVE_INFINITY)),
      (y = ea(y, Number.POSITIVE_INFINITY)),
      (T = ea(T, Number.NEGATIVE_INFINITY)),
      { min: ea(l, y), max: ea(f, T), minDefined: Ys(l), maxDefined: Ys(f) }
    );
  }
  getMinMax(l) {
    let { min: f, max: y, minDefined: T, maxDefined: I } = this.getUserBounds(),
      P;
    if (T && I) return { min: f, max: y };
    const r = this.getMatchingVisibleMetas();
    for (let F = 0, B = r.length; F < B; ++F)
      ((P = r[F].controller.getMinMax(this, l)),
        T || (f = Math.min(f, P.min)),
        I || (y = Math.max(y, P.max)));
    return (
      (f = I && f > y ? y : f),
      (y = T && f > y ? f : y),
      { min: ea(f, ea(y, f)), max: ea(y, ea(f, y)) }
    );
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0,
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const l = this.chart.data;
    return (
      this.options.labels ||
      (this.isHorizontal() ? l.xLabels : l.yLabels) ||
      l.labels ||
      []
    );
  }
  getLabelItems(l = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(l));
  }
  beforeLayout() {
    ((this._cache = {}), (this._dataLimitsCached = !1));
  }
  beforeUpdate() {
    er(this.options.beforeUpdate, [this]);
  }
  update(l, f, y) {
    const { beginAtZero: T, grace: I, ticks: P } = this.options,
      r = P.sampleSize;
    (this.beforeUpdate(),
      (this.maxWidth = l),
      (this.maxHeight = f),
      (this._margins = y =
        Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, y)),
      (this.ticks = null),
      (this._labelSizes = null),
      (this._gridLineItems = null),
      (this._labelItems = null),
      this.beforeSetDimensions(),
      this.setDimensions(),
      this.afterSetDimensions(),
      (this._maxLength = this.isHorizontal()
        ? this.width + y.left + y.right
        : this.height + y.top + y.bottom),
      this._dataLimitsCached ||
        (this.beforeDataLimits(),
        this.determineDataLimits(),
        this.afterDataLimits(),
        (this._range = xC(this, I, T)),
        (this._dataLimitsCached = !0)),
      this.beforeBuildTicks(),
      (this.ticks = this.buildTicks() || []),
      this.afterBuildTicks());
    const F = r < this.ticks.length;
    (this._convertTicksToLabels(F ? Jw(this.ticks, r) : this.ticks),
      this.configure(),
      this.beforeCalculateLabelRotation(),
      this.calculateLabelRotation(),
      this.afterCalculateLabelRotation(),
      P.display &&
        (P.autoSkip || P.source === "auto") &&
        ((this.ticks = $P(this, this.ticks)),
        (this._labelSizes = null),
        this.afterAutoSkip()),
      F && this._convertTicksToLabels(this.ticks),
      this.beforeFit(),
      this.fit(),
      this.afterFit(),
      this.afterUpdate());
  }
  configure() {
    let l = this.options.reverse,
      f,
      y;
    (this.isHorizontal()
      ? ((f = this.left), (y = this.right))
      : ((f = this.top), (y = this.bottom), (l = !l)),
      (this._startPixel = f),
      (this._endPixel = y),
      (this._reversePixels = l),
      (this._length = y - f),
      (this._alignToPixels = this.options.alignToPixels));
  }
  afterUpdate() {
    er(this.options.afterUpdate, [this]);
  }
  beforeSetDimensions() {
    er(this.options.beforeSetDimensions, [this]);
  }
  setDimensions() {
    (this.isHorizontal()
      ? ((this.width = this.maxWidth),
        (this.left = 0),
        (this.right = this.width))
      : ((this.height = this.maxHeight),
        (this.top = 0),
        (this.bottom = this.height)),
      (this.paddingLeft = 0),
      (this.paddingTop = 0),
      (this.paddingRight = 0),
      (this.paddingBottom = 0));
  }
  afterSetDimensions() {
    er(this.options.afterSetDimensions, [this]);
  }
  _callHooks(l) {
    (this.chart.notifyPlugins(l, this.getContext()),
      er(this.options[l], [this]));
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {}
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    er(this.options.beforeTickToLabelConversion, [this]);
  }
  generateTickLabels(l) {
    const f = this.options.ticks;
    let y, T, I;
    for (y = 0, T = l.length; y < T; y++)
      ((I = l[y]), (I.label = er(f.callback, [I.value, y, l], this)));
  }
  afterTickToLabelConversion() {
    er(this.options.afterTickToLabelConversion, [this]);
  }
  beforeCalculateLabelRotation() {
    er(this.options.beforeCalculateLabelRotation, [this]);
  }
  calculateLabelRotation() {
    const l = this.options,
      f = l.ticks,
      y = Kw(this.ticks.length, l.ticks.maxTicksLimit),
      T = f.minRotation || 0,
      I = f.maxRotation;
    let P = T,
      r,
      F,
      B;
    if (
      !this._isVisible() ||
      !f.display ||
      T >= I ||
      y <= 1 ||
      !this.isHorizontal()
    ) {
      this.labelRotation = T;
      return;
    }
    const q = this._getLabelSizes(),
      ne = q.widest.width,
      fe = q.highest.height,
      de = qs(this.chart.width - ne, 0, this.maxWidth);
    ((r = l.offset ? this.maxWidth / y : de / (y - 1)),
      ne + 6 > r &&
        ((r = de / (y - (l.offset ? 0.5 : 1))),
        (F =
          this.maxHeight -
          Zf(l.grid) -
          f.padding -
          Qw(l.title, this.chart.options.font)),
        (B = Math.sqrt(ne * ne + fe * fe)),
        (P = UM(
          Math.min(
            Math.asin(qs((q.highest.height + 6) / r, -1, 1)),
            Math.asin(qs(F / B, -1, 1)) - Math.asin(qs(fe / B, -1, 1)),
          ),
        )),
        (P = Math.max(T, Math.min(I, P)))),
      (this.labelRotation = P));
  }
  afterCalculateLabelRotation() {
    er(this.options.afterCalculateLabelRotation, [this]);
  }
  afterAutoSkip() {}
  beforeFit() {
    er(this.options.beforeFit, [this]);
  }
  fit() {
    const l = { width: 0, height: 0 },
      {
        chart: f,
        options: { ticks: y, title: T, grid: I },
      } = this,
      P = this._isVisible(),
      r = this.isHorizontal();
    if (P) {
      const F = Qw(T, f.options.font);
      if (
        (r
          ? ((l.width = this.maxWidth), (l.height = Zf(I) + F))
          : ((l.height = this.maxHeight), (l.width = Zf(I) + F)),
        y.display && this.ticks.length)
      ) {
        const {
            first: B,
            last: q,
            widest: ne,
            highest: fe,
          } = this._getLabelSizes(),
          de = y.padding * 2,
          Ie = gh(this.labelRotation),
          xe = Math.cos(Ie),
          we = Math.sin(Ie);
        if (r) {
          const Ae = y.mirror ? 0 : we * ne.width + xe * fe.height;
          l.height = Math.min(this.maxHeight, l.height + Ae + de);
        } else {
          const Ae = y.mirror ? 0 : xe * ne.width + we * fe.height;
          l.width = Math.min(this.maxWidth, l.width + Ae + de);
        }
        this._calculatePadding(B, q, we, xe);
      }
    }
    (this._handleMargins(),
      r
        ? ((this.width = this._length =
            f.width - this._margins.left - this._margins.right),
          (this.height = l.height))
        : ((this.width = l.width),
          (this.height = this._length =
            f.height - this._margins.top - this._margins.bottom)));
  }
  _calculatePadding(l, f, y, T) {
    const {
        ticks: { align: I, padding: P },
        position: r,
      } = this.options,
      F = this.labelRotation !== 0,
      B = r !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const q = this.getPixelForTick(0) - this.left,
        ne = this.right - this.getPixelForTick(this.ticks.length - 1);
      let fe = 0,
        de = 0;
      (F
        ? B
          ? ((fe = T * l.width), (de = y * f.height))
          : ((fe = y * l.height), (de = T * f.width))
        : I === "start"
          ? (de = f.width)
          : I === "end"
            ? (fe = l.width)
            : I !== "inner" && ((fe = l.width / 2), (de = f.width / 2)),
        (this.paddingLeft = Math.max(
          ((fe - q + P) * this.width) / (this.width - q),
          0,
        )),
        (this.paddingRight = Math.max(
          ((de - ne + P) * this.width) / (this.width - ne),
          0,
        )));
    } else {
      let q = f.height / 2,
        ne = l.height / 2;
      (I === "start"
        ? ((q = 0), (ne = l.height))
        : I === "end" && ((q = f.height), (ne = 0)),
        (this.paddingTop = q + P),
        (this.paddingBottom = ne + P));
    }
  }
  _handleMargins() {
    this._margins &&
      ((this._margins.left = Math.max(this.paddingLeft, this._margins.left)),
      (this._margins.top = Math.max(this.paddingTop, this._margins.top)),
      (this._margins.right = Math.max(this.paddingRight, this._margins.right)),
      (this._margins.bottom = Math.max(
        this.paddingBottom,
        this._margins.bottom,
      )));
  }
  afterFit() {
    er(this.options.afterFit, [this]);
  }
  isHorizontal() {
    const { axis: l, position: f } = this.options;
    return f === "top" || f === "bottom" || l === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(l) {
    (this.beforeTickToLabelConversion(), this.generateTickLabels(l));
    let f, y;
    for (f = 0, y = l.length; f < y; f++)
      Jn(l[f].label) && (l.splice(f, 1), y--, f--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let l = this._labelSizes;
    if (!l) {
      const f = this.options.ticks.sampleSize;
      let y = this.ticks;
      (f < y.length && (y = Jw(y, f)),
        (this._labelSizes = l =
          this._computeLabelSizes(
            y,
            y.length,
            this.options.ticks.maxTicksLimit,
          )));
    }
    return l;
  }
  _computeLabelSizes(l, f, y) {
    const { ctx: T, _longestTextCache: I } = this,
      P = [],
      r = [],
      F = Math.floor(f / Kw(f, y));
    let B = 0,
      q = 0,
      ne,
      fe,
      de,
      Ie,
      xe,
      we,
      Ae,
      Qe,
      gt,
      Rt,
      Mt;
    for (ne = 0; ne < f; ne += F) {
      if (
        ((Ie = l[ne].label),
        (xe = this._resolveTickFontOptions(ne)),
        (T.font = we = xe.string),
        (Ae = I[we] = I[we] || { data: {}, gc: [] }),
        (Qe = xe.lineHeight),
        (gt = Rt = 0),
        !Jn(Ie) && !Nr(Ie))
      )
        ((gt = Cw(T, Ae.data, Ae.gc, gt, Ie)), (Rt = Qe));
      else if (Nr(Ie))
        for (fe = 0, de = Ie.length; fe < de; ++fe)
          ((Mt = Ie[fe]),
            !Jn(Mt) &&
              !Nr(Mt) &&
              ((gt = Cw(T, Ae.data, Ae.gc, gt, Mt)), (Rt += Qe)));
      (P.push(gt), r.push(Rt), (B = Math.max(gt, B)), (q = Math.max(Rt, q)));
    }
    JP(I, f);
    const pt = P.indexOf(B),
      Re = r.indexOf(q),
      rt = (Ot) => ({ width: P[Ot] || 0, height: r[Ot] || 0 });
    return {
      first: rt(0),
      last: rt(f - 1),
      widest: rt(pt),
      highest: rt(Re),
      widths: P,
      heights: r,
    };
  }
  getLabelForValue(l) {
    return l;
  }
  getPixelForValue(l, f) {
    return NaN;
  }
  getValueForPixel(l) {}
  getPixelForTick(l) {
    const f = this.ticks;
    return l < 0 || l > f.length - 1 ? null : this.getPixelForValue(f[l].value);
  }
  getPixelForDecimal(l) {
    this._reversePixels && (l = 1 - l);
    const f = this._startPixel + l * this._length;
    return $M(this._alignToPixels ? uh(this.chart, f, 0) : f);
  }
  getDecimalForPixel(l) {
    const f = (l - this._startPixel) / this._length;
    return this._reversePixels ? 1 - f : f;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: l, max: f } = this;
    return l < 0 && f < 0 ? f : l > 0 && f > 0 ? l : 0;
  }
  getContext(l) {
    const f = this.ticks || [];
    if (l >= 0 && l < f.length) {
      const y = f[l];
      return y.$context || (y.$context = eD(this.getContext(), l, y));
    }
    return this.$context || (this.$context = QP(this.chart.getContext(), this));
  }
  _tickSize() {
    const l = this.options.ticks,
      f = gh(this.labelRotation),
      y = Math.abs(Math.cos(f)),
      T = Math.abs(Math.sin(f)),
      I = this._getLabelSizes(),
      P = l.autoSkipPadding || 0,
      r = I ? I.widest.width + P : 0,
      F = I ? I.highest.height + P : 0;
    return this.isHorizontal()
      ? F * y > r * T
        ? r / y
        : F / T
      : F * T < r * y
        ? F / y
        : r / T;
  }
  _isVisible() {
    const l = this.options.display;
    return l !== "auto" ? !!l : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(l) {
    const f = this.axis,
      y = this.chart,
      T = this.options,
      { grid: I, position: P, border: r } = T,
      F = I.offset,
      B = this.isHorizontal(),
      ne = this.ticks.length + (F ? 1 : 0),
      fe = Zf(I),
      de = [],
      Ie = r.setContext(this.getContext()),
      xe = Ie.display ? Ie.width : 0,
      we = xe / 2,
      Ae = function (Ii) {
        return uh(y, Ii, xe);
      };
    let Qe, gt, Rt, Mt, pt, Re, rt, Ot, _i, qt, pi, Ri;
    if (P === "top")
      ((Qe = Ae(this.bottom)),
        (Re = this.bottom - fe),
        (Ot = Qe - we),
        (qt = Ae(l.top) + we),
        (Ri = l.bottom));
    else if (P === "bottom")
      ((Qe = Ae(this.top)),
        (qt = l.top),
        (Ri = Ae(l.bottom) - we),
        (Re = Qe + we),
        (Ot = this.top + fe));
    else if (P === "left")
      ((Qe = Ae(this.right)),
        (pt = this.right - fe),
        (rt = Qe - we),
        (_i = Ae(l.left) + we),
        (pi = l.right));
    else if (P === "right")
      ((Qe = Ae(this.left)),
        (_i = l.left),
        (pi = Ae(l.right) - we),
        (pt = Qe + we),
        (rt = this.left + fe));
    else if (f === "x") {
      if (P === "center") Qe = Ae((l.top + l.bottom) / 2 + 0.5);
      else if (Nn(P)) {
        const Ii = Object.keys(P)[0],
          Ln = P[Ii];
        Qe = Ae(this.chart.scales[Ii].getPixelForValue(Ln));
      }
      ((qt = l.top), (Ri = l.bottom), (Re = Qe + we), (Ot = Re + fe));
    } else if (f === "y") {
      if (P === "center") Qe = Ae((l.left + l.right) / 2);
      else if (Nn(P)) {
        const Ii = Object.keys(P)[0],
          Ln = P[Ii];
        Qe = Ae(this.chart.scales[Ii].getPixelForValue(Ln));
      }
      ((pt = Qe - we), (rt = pt - fe), (_i = l.left), (pi = l.right));
    }
    const wi = Dn(T.ticks.maxTicksLimit, ne),
      ei = Math.max(1, Math.ceil(ne / wi));
    for (gt = 0; gt < ne; gt += ei) {
      const Ii = this.getContext(gt),
        Ln = I.setContext(Ii),
        ir = r.setContext(Ii),
        or = Ln.lineWidth,
        Vi = Ln.color,
        _r = ir.dash || [],
        yr = ir.dashOffset,
        fs = Ln.tickWidth,
        qr = Ln.tickColor,
        tn = Ln.tickBorderDash || [],
        wn = Ln.tickBorderDashOffset;
      ((Rt = KP(this, gt, F)),
        Rt !== void 0 &&
          ((Mt = uh(y, Rt, or)),
          B ? (pt = rt = _i = pi = Mt) : (Re = Ot = qt = Ri = Mt),
          de.push({
            tx1: pt,
            ty1: Re,
            tx2: rt,
            ty2: Ot,
            x1: _i,
            y1: qt,
            x2: pi,
            y2: Ri,
            width: or,
            color: Vi,
            borderDash: _r,
            borderDashOffset: yr,
            tickWidth: fs,
            tickColor: qr,
            tickBorderDash: tn,
            tickBorderDashOffset: wn,
          })));
    }
    return ((this._ticksLength = ne), (this._borderValue = Qe), de);
  }
  _computeLabelItems(l) {
    const f = this.axis,
      y = this.options,
      { position: T, ticks: I } = y,
      P = this.isHorizontal(),
      r = this.ticks,
      { align: F, crossAlign: B, padding: q, mirror: ne } = I,
      fe = Zf(y.grid),
      de = fe + q,
      Ie = ne ? -q : de,
      xe = -gh(this.labelRotation),
      we = [];
    let Ae,
      Qe,
      gt,
      Rt,
      Mt,
      pt,
      Re,
      rt,
      Ot,
      _i,
      qt,
      pi,
      Ri = "middle";
    if (T === "top")
      ((pt = this.bottom - Ie), (Re = this._getXAxisLabelAlignment()));
    else if (T === "bottom")
      ((pt = this.top + Ie), (Re = this._getXAxisLabelAlignment()));
    else if (T === "left") {
      const ei = this._getYAxisLabelAlignment(fe);
      ((Re = ei.textAlign), (Mt = ei.x));
    } else if (T === "right") {
      const ei = this._getYAxisLabelAlignment(fe);
      ((Re = ei.textAlign), (Mt = ei.x));
    } else if (f === "x") {
      if (T === "center") pt = (l.top + l.bottom) / 2 + de;
      else if (Nn(T)) {
        const ei = Object.keys(T)[0],
          Ii = T[ei];
        pt = this.chart.scales[ei].getPixelForValue(Ii) + de;
      }
      Re = this._getXAxisLabelAlignment();
    } else if (f === "y") {
      if (T === "center") Mt = (l.left + l.right) / 2 - de;
      else if (Nn(T)) {
        const ei = Object.keys(T)[0],
          Ii = T[ei];
        Mt = this.chart.scales[ei].getPixelForValue(Ii);
      }
      Re = this._getYAxisLabelAlignment(fe).textAlign;
    }
    f === "y" &&
      (F === "start" ? (Ri = "top") : F === "end" && (Ri = "bottom"));
    const wi = this._getLabelSizes();
    for (Ae = 0, Qe = r.length; Ae < Qe; ++Ae) {
      ((gt = r[Ae]), (Rt = gt.label));
      const ei = I.setContext(this.getContext(Ae));
      ((rt = this.getPixelForTick(Ae) + I.labelOffset),
        (Ot = this._resolveTickFontOptions(Ae)),
        (_i = Ot.lineHeight),
        (qt = Nr(Rt) ? Rt.length : 1));
      const Ii = qt / 2,
        Ln = ei.color,
        ir = ei.textStrokeColor,
        or = ei.textStrokeWidth;
      let Vi = Re;
      P
        ? ((Mt = rt),
          Re === "inner" &&
            (Ae === Qe - 1
              ? (Vi = this.options.reverse ? "left" : "right")
              : Ae === 0
                ? (Vi = this.options.reverse ? "right" : "left")
                : (Vi = "center")),
          T === "top"
            ? B === "near" || xe !== 0
              ? (pi = -qt * _i + _i / 2)
              : B === "center"
                ? (pi = -wi.highest.height / 2 - Ii * _i + _i)
                : (pi = -wi.highest.height + _i / 2)
            : B === "near" || xe !== 0
              ? (pi = _i / 2)
              : B === "center"
                ? (pi = wi.highest.height / 2 - Ii * _i)
                : (pi = wi.highest.height - qt * _i),
          ne && (pi *= -1),
          xe !== 0 && !ei.showLabelBackdrop && (Mt += (_i / 2) * Math.sin(xe)))
        : ((pt = rt), (pi = ((1 - qt) * _i) / 2));
      let _r;
      if (ei.showLabelBackdrop) {
        const yr = Ks(ei.backdropPadding),
          fs = wi.heights[Ae],
          qr = wi.widths[Ae];
        let tn = pi - yr.top,
          wn = 0 - yr.left;
        switch (Ri) {
          case "middle":
            tn -= fs / 2;
            break;
          case "bottom":
            tn -= fs;
            break;
        }
        switch (Re) {
          case "center":
            wn -= qr / 2;
            break;
          case "right":
            wn -= qr;
            break;
          case "inner":
            Ae === Qe - 1 ? (wn -= qr) : Ae > 0 && (wn -= qr / 2);
            break;
        }
        _r = {
          left: wn,
          top: tn,
          width: qr + yr.width,
          height: fs + yr.height,
          color: ei.backdropColor,
        };
      }
      we.push({
        label: Rt,
        font: Ot,
        textOffset: pi,
        options: {
          rotation: xe,
          color: Ln,
          strokeColor: ir,
          strokeWidth: or,
          textAlign: Vi,
          textBaseline: Ri,
          translation: [Mt, pt],
          backdrop: _r,
        },
      });
    }
    return we;
  }
  _getXAxisLabelAlignment() {
    const { position: l, ticks: f } = this.options;
    if (-gh(this.labelRotation)) return l === "top" ? "left" : "right";
    let T = "center";
    return (
      f.align === "start"
        ? (T = "left")
        : f.align === "end"
          ? (T = "right")
          : f.align === "inner" && (T = "inner"),
      T
    );
  }
  _getYAxisLabelAlignment(l) {
    const {
        position: f,
        ticks: { crossAlign: y, mirror: T, padding: I },
      } = this.options,
      P = this._getLabelSizes(),
      r = l + I,
      F = P.widest.width;
    let B, q;
    return (
      f === "left"
        ? T
          ? ((q = this.right + I),
            y === "near"
              ? (B = "left")
              : y === "center"
                ? ((B = "center"), (q += F / 2))
                : ((B = "right"), (q += F)))
          : ((q = this.right - r),
            y === "near"
              ? (B = "right")
              : y === "center"
                ? ((B = "center"), (q -= F / 2))
                : ((B = "left"), (q = this.left)))
        : f === "right"
          ? T
            ? ((q = this.left + I),
              y === "near"
                ? (B = "right")
                : y === "center"
                  ? ((B = "center"), (q -= F / 2))
                  : ((B = "left"), (q -= F)))
            : ((q = this.left + r),
              y === "near"
                ? (B = "left")
                : y === "center"
                  ? ((B = "center"), (q += F / 2))
                  : ((B = "right"), (q = this.right)))
          : (B = "right"),
      { textAlign: B, x: q }
    );
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) return;
    const l = this.chart,
      f = this.options.position;
    if (f === "left" || f === "right")
      return { top: 0, left: this.left, bottom: l.height, right: this.right };
    if (f === "top" || f === "bottom")
      return { top: this.top, left: 0, bottom: this.bottom, right: l.width };
  }
  drawBackground() {
    const {
      ctx: l,
      options: { backgroundColor: f },
      left: y,
      top: T,
      width: I,
      height: P,
    } = this;
    f && (l.save(), (l.fillStyle = f), l.fillRect(y, T, I, P), l.restore());
  }
  getLineWidthForValue(l) {
    const f = this.options.grid;
    if (!this._isVisible() || !f.display) return 0;
    const T = this.ticks.findIndex((I) => I.value === l);
    return T >= 0 ? f.setContext(this.getContext(T)).lineWidth : 0;
  }
  drawGrid(l) {
    const f = this.options.grid,
      y = this.ctx,
      T =
        this._gridLineItems ||
        (this._gridLineItems = this._computeGridLineItems(l));
    let I, P;
    const r = (F, B, q) => {
      !q.width ||
        !q.color ||
        (y.save(),
        (y.lineWidth = q.width),
        (y.strokeStyle = q.color),
        y.setLineDash(q.borderDash || []),
        (y.lineDashOffset = q.borderDashOffset),
        y.beginPath(),
        y.moveTo(F.x, F.y),
        y.lineTo(B.x, B.y),
        y.stroke(),
        y.restore());
    };
    if (f.display)
      for (I = 0, P = T.length; I < P; ++I) {
        const F = T[I];
        (f.drawOnChartArea && r({ x: F.x1, y: F.y1 }, { x: F.x2, y: F.y2 }, F),
          f.drawTicks &&
            r(
              { x: F.tx1, y: F.ty1 },
              { x: F.tx2, y: F.ty2 },
              {
                color: F.tickColor,
                width: F.tickWidth,
                borderDash: F.tickBorderDash,
                borderDashOffset: F.tickBorderDashOffset,
              },
            ));
      }
  }
  drawBorder() {
    const {
        chart: l,
        ctx: f,
        options: { border: y, grid: T },
      } = this,
      I = y.setContext(this.getContext()),
      P = y.display ? I.width : 0;
    if (!P) return;
    const r = T.setContext(this.getContext(0)).lineWidth,
      F = this._borderValue;
    let B, q, ne, fe;
    (this.isHorizontal()
      ? ((B = uh(l, this.left, P) - P / 2),
        (q = uh(l, this.right, r) + r / 2),
        (ne = fe = F))
      : ((ne = uh(l, this.top, P) - P / 2),
        (fe = uh(l, this.bottom, r) + r / 2),
        (B = q = F)),
      f.save(),
      (f.lineWidth = I.width),
      (f.strokeStyle = I.color),
      f.beginPath(),
      f.moveTo(B, ne),
      f.lineTo(q, fe),
      f.stroke(),
      f.restore());
  }
  drawLabels(l) {
    if (!this.options.ticks.display) return;
    const y = this.ctx,
      T = this._computeLabelArea();
    T && Yx(y, T);
    const I = this.getLabelItems(l);
    for (const P of I) {
      const r = P.options,
        F = P.font,
        B = P.label,
        q = P.textOffset;
      _p(y, B, 0, q, F, r);
    }
    T && Kx(y);
  }
  drawTitle() {
    const {
      ctx: l,
      options: { position: f, title: y, reverse: T },
    } = this;
    if (!y.display) return;
    const I = rs(y.font),
      P = Ks(y.padding),
      r = y.align;
    let F = I.lineHeight / 2;
    f === "bottom" || f === "center" || Nn(f)
      ? ((F += P.bottom),
        Nr(y.text) && (F += I.lineHeight * (y.text.length - 1)))
      : (F += P.top);
    const {
      titleX: B,
      titleY: q,
      maxWidth: ne,
      rotation: fe,
    } = iD(this, F, f, r);
    _p(l, y.text, 0, 0, I, {
      color: y.color,
      maxWidth: ne,
      rotation: fe,
      textAlign: tD(r, f, T),
      textBaseline: "middle",
      translation: [B, q],
    });
  }
  draw(l) {
    this._isVisible() &&
      (this.drawBackground(),
      this.drawGrid(l),
      this.drawBorder(),
      this.drawTitle(),
      this.drawLabels(l));
  }
  _layers() {
    const l = this.options,
      f = (l.ticks && l.ticks.z) || 0,
      y = Dn(l.grid && l.grid.z, -1),
      T = Dn(l.border && l.border.z, 0);
    return !this._isVisible() || this.draw !== Qu.prototype.draw
      ? [
          {
            z: f,
            draw: (I) => {
              this.draw(I);
            },
          },
        ]
      : [
          {
            z: y,
            draw: (I) => {
              (this.drawBackground(), this.drawGrid(I), this.drawTitle());
            },
          },
          {
            z: T,
            draw: () => {
              this.drawBorder();
            },
          },
          {
            z: f,
            draw: (I) => {
              this.drawLabels(I);
            },
          },
        ];
  }
  getMatchingVisibleMetas(l) {
    const f = this.chart.getSortedVisibleDatasetMetas(),
      y = this.axis + "AxisID",
      T = [];
    let I, P;
    for (I = 0, P = f.length; I < P; ++I) {
      const r = f[I];
      r[y] === this.id && (!l || r.type === l) && T.push(r);
    }
    return T;
  }
  _resolveTickFontOptions(l) {
    const f = this.options.ticks.setContext(this.getContext(l));
    return rs(f.font);
  }
  _maxDigits() {
    const l = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / l;
  }
}
class Pg {
  constructor(l, f, y) {
    ((this.type = l),
      (this.scope = f),
      (this.override = y),
      (this.items = Object.create(null)));
  }
  isForType(l) {
    return Object.prototype.isPrototypeOf.call(
      this.type.prototype,
      l.prototype,
    );
  }
  register(l) {
    const f = Object.getPrototypeOf(l);
    let y;
    sD(f) && (y = this.register(f));
    const T = this.items,
      I = l.id,
      P = this.scope + "." + I;
    if (!I) throw new Error("class does not have id: " + l);
    return (
      I in T ||
        ((T[I] = l),
        nD(l, P, y),
        this.override && gr.override(l.id, l.overrides)),
      P
    );
  }
  get(l) {
    return this.items[l];
  }
  unregister(l) {
    const f = this.items,
      y = l.id,
      T = this.scope;
    (y in f && delete f[y],
      T && y in gr[T] && (delete gr[T][y], this.override && delete wh[y]));
  }
}
function nD(m, l, f) {
  const y = pp(Object.create(null), [
    f ? gr.get(f) : {},
    gr.get(l),
    m.defaults,
  ]);
  (gr.set(l, y),
    m.defaultRoutes && rD(l, m.defaultRoutes),
    m.descriptors && gr.describe(l, m.descriptors));
}
function rD(m, l) {
  Object.keys(l).forEach((f) => {
    const y = f.split("."),
      T = y.pop(),
      I = [m].concat(y).join("."),
      P = l[f].split("."),
      r = P.pop(),
      F = P.join(".");
    gr.route(I, T, F, r);
  });
}
function sD(m) {
  return "id" in m && "defaults" in m;
}
class oD {
  constructor() {
    ((this.controllers = new Pg(hp, "datasets", !0)),
      (this.elements = new Pg($a, "elements")),
      (this.plugins = new Pg(Object, "plugins")),
      (this.scales = new Pg(Qu, "scales")),
      (this._typedRegistries = [this.controllers, this.scales, this.elements]));
  }
  add(...l) {
    this._each("register", l);
  }
  remove(...l) {
    this._each("unregister", l);
  }
  addControllers(...l) {
    this._each("register", l, this.controllers);
  }
  addElements(...l) {
    this._each("register", l, this.elements);
  }
  addPlugins(...l) {
    this._each("register", l, this.plugins);
  }
  addScales(...l) {
    this._each("register", l, this.scales);
  }
  getController(l) {
    return this._get(l, this.controllers, "controller");
  }
  getElement(l) {
    return this._get(l, this.elements, "element");
  }
  getPlugin(l) {
    return this._get(l, this.plugins, "plugin");
  }
  getScale(l) {
    return this._get(l, this.scales, "scale");
  }
  removeControllers(...l) {
    this._each("unregister", l, this.controllers);
  }
  removeElements(...l) {
    this._each("unregister", l, this.elements);
  }
  removePlugins(...l) {
    this._each("unregister", l, this.plugins);
  }
  removeScales(...l) {
    this._each("unregister", l, this.scales);
  }
  _each(l, f, y) {
    [...f].forEach((T) => {
      const I = y || this._getRegistryForType(T);
      y || I.isForType(T) || (I === this.plugins && T.id)
        ? this._exec(l, I, T)
        : jn(T, (P) => {
            const r = y || this._getRegistryForType(P);
            this._exec(l, r, P);
          });
    });
  }
  _exec(l, f, y) {
    const T = Wx(l);
    (er(y["before" + T], [], y), f[l](y), er(y["after" + T], [], y));
  }
  _getRegistryForType(l) {
    for (let f = 0; f < this._typedRegistries.length; f++) {
      const y = this._typedRegistries[f];
      if (y.isForType(l)) return y;
    }
    return this.plugins;
  }
  _get(l, f, y) {
    const T = f.get(l);
    if (T === void 0)
      throw new Error('"' + l + '" is not a registered ' + y + ".");
    return T;
  }
}
var ia = new oD();
class aD {
  constructor() {
    this._init = [];
  }
  notify(l, f, y, T) {
    f === "beforeInit" &&
      ((this._init = this._createDescriptors(l, !0)),
      this._notify(this._init, l, "install"));
    const I = T ? this._descriptors(l).filter(T) : this._descriptors(l),
      P = this._notify(I, l, f, y);
    return (
      f === "afterDestroy" &&
        (this._notify(I, l, "stop"), this._notify(this._init, l, "uninstall")),
      P
    );
  }
  _notify(l, f, y, T) {
    T = T || {};
    for (const I of l) {
      const P = I.plugin,
        r = P[y],
        F = [f, T, I.options];
      if (er(r, F, P) === !1 && T.cancelable) return !1;
    }
    return !0;
  }
  invalidate() {
    Jn(this._cache) || ((this._oldCache = this._cache), (this._cache = void 0));
  }
  _descriptors(l) {
    if (this._cache) return this._cache;
    const f = (this._cache = this._createDescriptors(l));
    return (this._notifyStateChanges(l), f);
  }
  _createDescriptors(l, f) {
    const y = l && l.config,
      T = Dn(y.options && y.options.plugins, {}),
      I = lD(y);
    return T === !1 && !f ? [] : hD(l, I, T, f);
  }
  _notifyStateChanges(l) {
    const f = this._oldCache || [],
      y = this._cache,
      T = (I, P) =>
        I.filter((r) => !P.some((F) => r.plugin.id === F.plugin.id));
    (this._notify(T(f, y), l, "stop"), this._notify(T(y, f), l, "start"));
  }
}
function lD(m) {
  const l = {},
    f = [],
    y = Object.keys(ia.plugins.items);
  for (let I = 0; I < y.length; I++) f.push(ia.getPlugin(y[I]));
  const T = m.plugins || [];
  for (let I = 0; I < T.length; I++) {
    const P = T[I];
    f.indexOf(P) === -1 && (f.push(P), (l[P.id] = !0));
  }
  return { plugins: f, localIds: l };
}
function cD(m, l) {
  return !l && m === !1 ? null : m === !0 ? {} : m;
}
function hD(m, { plugins: l, localIds: f }, y, T) {
  const I = [],
    P = m.getContext();
  for (const r of l) {
    const F = r.id,
      B = cD(y[F], T);
    B !== null &&
      I.push({
        plugin: r,
        options: uD(m.config, { plugin: r, local: f[F] }, B, P),
      });
  }
  return I;
}
function uD(m, { plugin: l, local: f }, y, T) {
  const I = m.pluginScopeKeys(l),
    P = m.getOptionScopes(y, I);
  return (
    f && l.defaults && P.push(l.defaults),
    m.createResolver(P, T, [""], { scriptable: !1, indexable: !1, allKeys: !0 })
  );
}
function Px(m, l) {
  const f = gr.datasets[m] || {};
  return (
    ((l.datasets || {})[m] || {}).indexAxis || l.indexAxis || f.indexAxis || "x"
  );
}
function dD(m, l) {
  let f = m;
  return (
    m === "_index_" ? (f = l) : m === "_value_" && (f = l === "x" ? "y" : "x"),
    f
  );
}
function fD(m, l) {
  return m === l ? "_index_" : "_value_";
}
function eT(m) {
  if (m === "x" || m === "y" || m === "r") return m;
}
function pD(m) {
  if (m === "top" || m === "bottom") return "x";
  if (m === "left" || m === "right") return "y";
}
function Dx(m, ...l) {
  if (eT(m)) return m;
  for (const f of l) {
    const y =
      f.axis || pD(f.position) || (m.length > 1 && eT(m[0].toLowerCase()));
    if (y) return y;
  }
  throw new Error(
    `Cannot determine type of '${m}' axis. Please provide 'axis' or 'position' option.`,
  );
}
function tT(m, l, f) {
  if (f[l + "AxisID"] === m) return { axis: l };
}
function mD(m, l) {
  if (l.data && l.data.datasets) {
    const f = l.data.datasets.filter((y) => y.xAxisID === m || y.yAxisID === m);
    if (f.length) return tT(m, "x", f[0]) || tT(m, "y", f[0]);
  }
  return {};
}
function gD(m, l) {
  const f = wh[m.type] || { scales: {} },
    y = l.scales || {},
    T = Px(m.type, l),
    I = Object.create(null);
  return (
    Object.keys(y).forEach((P) => {
      const r = y[P];
      if (!Nn(r))
        return console.error(`Invalid scale configuration for scale: ${P}`);
      if (r._proxy)
        return console.warn(
          `Ignoring resolver passed as options for scale: ${P}`,
        );
      const F = Dx(P, r, mD(P, m), gr.scales[r.type]),
        B = fD(F, T),
        q = f.scales || {};
      I[P] = sp(Object.create(null), [{ axis: F }, r, q[F], q[B]]);
    }),
    m.data.datasets.forEach((P) => {
      const r = P.type || m.type,
        F = P.indexAxis || Px(r, l),
        q = (wh[r] || {}).scales || {};
      Object.keys(q).forEach((ne) => {
        const fe = dD(ne, F),
          de = P[fe + "AxisID"] || fe;
        ((I[de] = I[de] || Object.create(null)),
          sp(I[de], [{ axis: fe }, y[de], q[ne]]));
      });
    }),
    Object.keys(I).forEach((P) => {
      const r = I[P];
      sp(r, [gr.scales[r.type], gr.scale]);
    }),
    I
  );
}
function v2(m) {
  const l = m.options || (m.options = {});
  ((l.plugins = Dn(l.plugins, {})), (l.scales = gD(m, l)));
}
function b2(m) {
  return (
    (m = m || {}),
    (m.datasets = m.datasets || []),
    (m.labels = m.labels || []),
    m
  );
}
function _D(m) {
  return ((m = m || {}), (m.data = b2(m.data)), v2(m), m);
}
const iT = new Map(),
  w2 = new Set();
function Dg(m, l) {
  let f = iT.get(m);
  return (f || ((f = l()), iT.set(m, f), w2.add(f)), f);
}
const Xf = (m, l, f) => {
  const y = $g(l, f);
  y !== void 0 && m.add(y);
};
class yD {
  constructor(l) {
    ((this._config = _D(l)),
      (this._scopeCache = new Map()),
      (this._resolverCache = new Map()));
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(l) {
    this._config.type = l;
  }
  get data() {
    return this._config.data;
  }
  set data(l) {
    this._config.data = b2(l);
  }
  get options() {
    return this._config.options;
  }
  set options(l) {
    this._config.options = l;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const l = this._config;
    (this.clearCache(), v2(l));
  }
  clearCache() {
    (this._scopeCache.clear(), this._resolverCache.clear());
  }
  datasetScopeKeys(l) {
    return Dg(l, () => [[`datasets.${l}`, ""]]);
  }
  datasetAnimationScopeKeys(l, f) {
    return Dg(`${l}.transition.${f}`, () => [
      [`datasets.${l}.transitions.${f}`, `transitions.${f}`],
      [`datasets.${l}`, ""],
    ]);
  }
  datasetElementScopeKeys(l, f) {
    return Dg(`${l}-${f}`, () => [
      [`datasets.${l}.elements.${f}`, `datasets.${l}`, `elements.${f}`, ""],
    ]);
  }
  pluginScopeKeys(l) {
    const f = l.id,
      y = this.type;
    return Dg(`${y}-plugin-${f}`, () => [
      [`plugins.${f}`, ...(l.additionalOptionScopes || [])],
    ]);
  }
  _cachedScopes(l, f) {
    const y = this._scopeCache;
    let T = y.get(l);
    return ((!T || f) && ((T = new Map()), y.set(l, T)), T);
  }
  getOptionScopes(l, f, y) {
    const { options: T, type: I } = this,
      P = this._cachedScopes(l, y),
      r = P.get(f);
    if (r) return r;
    const F = new Set();
    f.forEach((q) => {
      (l && (F.add(l), q.forEach((ne) => Xf(F, l, ne))),
        q.forEach((ne) => Xf(F, T, ne)),
        q.forEach((ne) => Xf(F, wh[I] || {}, ne)),
        q.forEach((ne) => Xf(F, gr, ne)),
        q.forEach((ne) => Xf(F, Ax, ne)));
    });
    const B = Array.from(F);
    return (
      B.length === 0 && B.push(Object.create(null)),
      w2.has(f) && P.set(f, B),
      B
    );
  }
  chartOptionScopes() {
    const { options: l, type: f } = this;
    return [l, wh[f] || {}, gr.datasets[f] || {}, { type: f }, gr, Ax];
  }
  resolveNamedOptions(l, f, y, T = [""]) {
    const I = { $shared: !0 },
      { resolver: P, subPrefixes: r } = nT(this._resolverCache, l, T);
    let F = P;
    if (vD(P, f)) {
      ((I.$shared = !1), (y = Kl(y) ? y() : y));
      const B = this.createResolver(l, y, r);
      F = Ku(P, y, B);
    }
    for (const B of f) I[B] = F[B];
    return I;
  }
  createResolver(l, f, y = [""], T) {
    const { resolver: I } = nT(this._resolverCache, l, y);
    return Nn(f) ? Ku(I, f, void 0, T) : I;
  }
}
function nT(m, l, f) {
  let y = m.get(l);
  y || ((y = new Map()), m.set(l, y));
  const T = f.join();
  let I = y.get(T);
  return (
    I ||
      ((I = {
        resolver: Jx(l, f),
        subPrefixes: f.filter((r) => !r.toLowerCase().includes("hover")),
      }),
      y.set(T, I)),
    I
  );
}
const xD = (m) => Nn(m) && Object.getOwnPropertyNames(m).some((l) => Kl(m[l]));
function vD(m, l) {
  const { isScriptable: f, isIndexable: y } = s2(m);
  for (const T of l) {
    const I = f(T),
      P = y(T),
      r = (P || I) && m[T];
    if ((I && (Kl(r) || xD(r))) || (P && Nr(r))) return !0;
  }
  return !1;
}
var bD = "4.5.0";
const wD = ["top", "bottom", "left", "right", "chartArea"];
function rT(m, l) {
  return m === "top" || m === "bottom" || (wD.indexOf(m) === -1 && l === "x");
}
function sT(m, l) {
  return function (f, y) {
    return f[m] === y[m] ? f[l] - y[l] : f[m] - y[m];
  };
}
function oT(m) {
  const l = m.chart,
    f = l.options.animation;
  (l.notifyPlugins("afterRender"), er(f && f.onComplete, [m], l));
}
function TD(m) {
  const l = m.chart,
    f = l.options.animation;
  er(f && f.onProgress, [m], l);
}
function T2(m) {
  return (
    tv() && typeof m == "string"
      ? (m = document.getElementById(m))
      : m && m.length && (m = m[0]),
    m && m.canvas && (m = m.canvas),
    m
  );
}
const Vg = {},
  aT = (m) => {
    const l = T2(m);
    return Object.values(Vg)
      .filter((f) => f.canvas === l)
      .pop();
  };
function SD(m, l, f) {
  const y = Object.keys(m);
  for (const T of y) {
    const I = +T;
    if (I >= l) {
      const P = m[T];
      (delete m[T], (f > 0 || I > l) && (m[I + f] = P));
    }
  }
}
function ED(m, l, f, y) {
  return !f || m.type === "mouseout" ? null : y ? l : m;
}
var Hl;
let t_ =
  ((Hl = class {
    static register(...l) {
      (ia.add(...l), lT());
    }
    static unregister(...l) {
      (ia.remove(...l), lT());
    }
    constructor(l, f) {
      const y = (this.config = new yD(f)),
        T = T2(l),
        I = aT(T);
      if (I)
        throw new Error(
          "Canvas is already in use. Chart with ID '" +
            I.id +
            "' must be destroyed before the canvas with ID '" +
            I.canvas.id +
            "' can be reused.",
        );
      const P = y.createResolver(y.chartOptionScopes(), this.getContext());
      ((this.platform = new (y.platform || GP(T))()),
        this.platform.updateConfig(y));
      const r = this.platform.acquireContext(T, P.aspectRatio),
        F = r && r.canvas,
        B = F && F.height,
        q = F && F.width;
      if (
        ((this.id = MM()),
        (this.ctx = r),
        (this.canvas = F),
        (this.width = q),
        (this.height = B),
        (this._options = P),
        (this._aspectRatio = this.aspectRatio),
        (this._layers = []),
        (this._metasets = []),
        (this._stacks = void 0),
        (this.boxes = []),
        (this.currentDevicePixelRatio = void 0),
        (this.chartArea = void 0),
        (this._active = []),
        (this._lastEvent = void 0),
        (this._listeners = {}),
        (this._responsiveListeners = void 0),
        (this._sortedMetasets = []),
        (this.scales = {}),
        (this._plugins = new aD()),
        (this.$proxies = {}),
        (this._hiddenIndices = {}),
        (this.attached = !1),
        (this._animationsDisabled = void 0),
        (this.$context = void 0),
        (this._doResize = XM((ne) => this.update(ne), P.resizeDelay || 0)),
        (this._dataChanges = []),
        (Vg[this.id] = this),
        !r || !F)
      ) {
        console.error(
          "Failed to create chart: can't acquire context from the given item",
        );
        return;
      }
      (Va.listen(this, "complete", oT),
        Va.listen(this, "progress", TD),
        this._initialize(),
        this.attached && this.update());
    }
    get aspectRatio() {
      const {
        options: { aspectRatio: l, maintainAspectRatio: f },
        width: y,
        height: T,
        _aspectRatio: I,
      } = this;
      return Jn(l) ? (f && I ? I : T ? y / T : null) : l;
    }
    get data() {
      return this.config.data;
    }
    set data(l) {
      this.config.data = l;
    }
    get options() {
      return this._options;
    }
    set options(l) {
      this.config.options = l;
    }
    get registry() {
      return ia;
    }
    _initialize() {
      return (
        this.notifyPlugins("beforeInit"),
        this.options.responsive
          ? this.resize()
          : zw(this, this.options.devicePixelRatio),
        this.bindEvents(),
        this.notifyPlugins("afterInit"),
        this
      );
    }
    clear() {
      return (Pw(this.canvas, this.ctx), this);
    }
    stop() {
      return (Va.stop(this), this);
    }
    resize(l, f) {
      Va.running(this)
        ? (this._resizeBeforeDraw = { width: l, height: f })
        : this._resize(l, f);
    }
    _resize(l, f) {
      const y = this.options,
        T = this.canvas,
        I = y.maintainAspectRatio && this.aspectRatio,
        P = this.platform.getMaximumSize(T, l, f, I),
        r = y.devicePixelRatio || this.platform.getDevicePixelRatio(),
        F = this.width ? "resize" : "attach";
      ((this.width = P.width),
        (this.height = P.height),
        (this._aspectRatio = this.aspectRatio),
        zw(this, r, !0) &&
          (this.notifyPlugins("resize", { size: P }),
          er(y.onResize, [this, P], this),
          this.attached && this._doResize(F) && this.render()));
    }
    ensureScalesHaveIDs() {
      const f = this.options.scales || {};
      jn(f, (y, T) => {
        y.id = T;
      });
    }
    buildOrUpdateScales() {
      const l = this.options,
        f = l.scales,
        y = this.scales,
        T = Object.keys(y).reduce((P, r) => ((P[r] = !1), P), {});
      let I = [];
      (f &&
        (I = I.concat(
          Object.keys(f).map((P) => {
            const r = f[P],
              F = Dx(P, r),
              B = F === "r",
              q = F === "x";
            return {
              options: r,
              dposition: B ? "chartArea" : q ? "bottom" : "left",
              dtype: B ? "radialLinear" : q ? "category" : "linear",
            };
          }),
        )),
        jn(I, (P) => {
          const r = P.options,
            F = r.id,
            B = Dx(F, r),
            q = Dn(r.type, P.dtype);
          ((r.position === void 0 || rT(r.position, B) !== rT(P.dposition)) &&
            (r.position = P.dposition),
            (T[F] = !0));
          let ne = null;
          if (F in y && y[F].type === q) ne = y[F];
          else {
            const fe = ia.getScale(q);
            ((ne = new fe({ id: F, type: q, ctx: this.ctx, chart: this })),
              (y[ne.id] = ne));
          }
          ne.init(r, l);
        }),
        jn(T, (P, r) => {
          P || delete y[r];
        }),
        jn(y, (P) => {
          (Zs.configure(this, P, P.options), Zs.addBox(this, P));
        }));
    }
    _updateMetasets() {
      const l = this._metasets,
        f = this.data.datasets.length,
        y = l.length;
      if ((l.sort((T, I) => T.index - I.index), y > f)) {
        for (let T = f; T < y; ++T) this._destroyDatasetMeta(T);
        l.splice(f, y - f);
      }
      this._sortedMetasets = l.slice(0).sort(sT("order", "index"));
    }
    _removeUnreferencedMetasets() {
      const {
        _metasets: l,
        data: { datasets: f },
      } = this;
      (l.length > f.length && delete this._stacks,
        l.forEach((y, T) => {
          f.filter((I) => I === y._dataset).length === 0 &&
            this._destroyDatasetMeta(T);
        }));
    }
    buildOrUpdateControllers() {
      const l = [],
        f = this.data.datasets;
      let y, T;
      for (
        this._removeUnreferencedMetasets(), y = 0, T = f.length;
        y < T;
        y++
      ) {
        const I = f[y];
        let P = this.getDatasetMeta(y);
        const r = I.type || this.config.type;
        if (
          (P.type &&
            P.type !== r &&
            (this._destroyDatasetMeta(y), (P = this.getDatasetMeta(y))),
          (P.type = r),
          (P.indexAxis = I.indexAxis || Px(r, this.options)),
          (P.order = I.order || 0),
          (P.index = y),
          (P.label = "" + I.label),
          (P.visible = this.isDatasetVisible(y)),
          P.controller)
        )
          (P.controller.updateIndex(y), P.controller.linkScales());
        else {
          const F = ia.getController(r),
            { datasetElementType: B, dataElementType: q } = gr.datasets[r];
          (Object.assign(F, {
            dataElementType: ia.getElement(q),
            datasetElementType: B && ia.getElement(B),
          }),
            (P.controller = new F(this, y)),
            l.push(P.controller));
        }
      }
      return (this._updateMetasets(), l);
    }
    _resetElements() {
      jn(
        this.data.datasets,
        (l, f) => {
          this.getDatasetMeta(f).controller.reset();
        },
        this,
      );
    }
    reset() {
      (this._resetElements(), this.notifyPlugins("reset"));
    }
    update(l) {
      const f = this.config;
      f.update();
      const y = (this._options = f.createResolver(
          f.chartOptionScopes(),
          this.getContext(),
        )),
        T = (this._animationsDisabled = !y.animation);
      if (
        (this._updateScales(),
        this._checkEventBindings(),
        this._updateHiddenIndices(),
        this._plugins.invalidate(),
        this.notifyPlugins("beforeUpdate", { mode: l, cancelable: !0 }) === !1)
      )
        return;
      const I = this.buildOrUpdateControllers();
      this.notifyPlugins("beforeElementsUpdate");
      let P = 0;
      for (let B = 0, q = this.data.datasets.length; B < q; B++) {
        const { controller: ne } = this.getDatasetMeta(B),
          fe = !T && I.indexOf(ne) === -1;
        (ne.buildOrUpdateElements(fe), (P = Math.max(+ne.getMaxOverflow(), P)));
      }
      ((P = this._minPadding = y.layout.autoPadding ? P : 0),
        this._updateLayout(P),
        T ||
          jn(I, (B) => {
            B.reset();
          }),
        this._updateDatasets(l),
        this.notifyPlugins("afterUpdate", { mode: l }),
        this._layers.sort(sT("z", "_idx")));
      const { _active: r, _lastEvent: F } = this;
      (F
        ? this._eventHandler(F, !0)
        : r.length && this._updateHoverStyles(r, r, !0),
        this.render());
    }
    _updateScales() {
      (jn(this.scales, (l) => {
        Zs.removeBox(this, l);
      }),
        this.ensureScalesHaveIDs(),
        this.buildOrUpdateScales());
    }
    _checkEventBindings() {
      const l = this.options,
        f = new Set(Object.keys(this._listeners)),
        y = new Set(l.events);
      (!vw(f, y) || !!this._responsiveListeners !== l.responsive) &&
        (this.unbindEvents(), this.bindEvents());
    }
    _updateHiddenIndices() {
      const { _hiddenIndices: l } = this,
        f = this._getUniformDataChanges() || [];
      for (const { method: y, start: T, count: I } of f) {
        const P = y === "_removeElements" ? -I : I;
        SD(l, T, P);
      }
    }
    _getUniformDataChanges() {
      const l = this._dataChanges;
      if (!l || !l.length) return;
      this._dataChanges = [];
      const f = this.data.datasets.length,
        y = (I) =>
          new Set(
            l
              .filter((P) => P[0] === I)
              .map((P, r) => r + "," + P.splice(1).join(",")),
          ),
        T = y(0);
      for (let I = 1; I < f; I++) if (!vw(T, y(I))) return;
      return Array.from(T)
        .map((I) => I.split(","))
        .map((I) => ({ method: I[1], start: +I[2], count: +I[3] }));
    }
    _updateLayout(l) {
      if (this.notifyPlugins("beforeLayout", { cancelable: !0 }) === !1) return;
      Zs.update(this, this.width, this.height, l);
      const f = this.chartArea,
        y = f.width <= 0 || f.height <= 0;
      ((this._layers = []),
        jn(
          this.boxes,
          (T) => {
            (y && T.position === "chartArea") ||
              (T.configure && T.configure(), this._layers.push(...T._layers()));
          },
          this,
        ),
        this._layers.forEach((T, I) => {
          T._idx = I;
        }),
        this.notifyPlugins("afterLayout"));
    }
    _updateDatasets(l) {
      if (
        this.notifyPlugins("beforeDatasetsUpdate", {
          mode: l,
          cancelable: !0,
        }) !== !1
      ) {
        for (let f = 0, y = this.data.datasets.length; f < y; ++f)
          this.getDatasetMeta(f).controller.configure();
        for (let f = 0, y = this.data.datasets.length; f < y; ++f)
          this._updateDataset(f, Kl(l) ? l({ datasetIndex: f }) : l);
        this.notifyPlugins("afterDatasetsUpdate", { mode: l });
      }
    }
    _updateDataset(l, f) {
      const y = this.getDatasetMeta(l),
        T = { meta: y, index: l, mode: f, cancelable: !0 };
      this.notifyPlugins("beforeDatasetUpdate", T) !== !1 &&
        (y.controller._update(f),
        (T.cancelable = !1),
        this.notifyPlugins("afterDatasetUpdate", T));
    }
    render() {
      this.notifyPlugins("beforeRender", { cancelable: !0 }) !== !1 &&
        (Va.has(this)
          ? this.attached && !Va.running(this) && Va.start(this)
          : (this.draw(), oT({ chart: this })));
    }
    draw() {
      let l;
      if (this._resizeBeforeDraw) {
        const { width: y, height: T } = this._resizeBeforeDraw;
        ((this._resizeBeforeDraw = null), this._resize(y, T));
      }
      if (
        (this.clear(),
        this.width <= 0 ||
          this.height <= 0 ||
          this.notifyPlugins("beforeDraw", { cancelable: !0 }) === !1)
      )
        return;
      const f = this._layers;
      for (l = 0; l < f.length && f[l].z <= 0; ++l) f[l].draw(this.chartArea);
      for (this._drawDatasets(); l < f.length; ++l) f[l].draw(this.chartArea);
      this.notifyPlugins("afterDraw");
    }
    _getSortedDatasetMetas(l) {
      const f = this._sortedMetasets,
        y = [];
      let T, I;
      for (T = 0, I = f.length; T < I; ++T) {
        const P = f[T];
        (!l || P.visible) && y.push(P);
      }
      return y;
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(!0);
    }
    _drawDatasets() {
      if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: !0 }) === !1)
        return;
      const l = this.getSortedVisibleDatasetMetas();
      for (let f = l.length - 1; f >= 0; --f) this._drawDataset(l[f]);
      this.notifyPlugins("afterDatasetsDraw");
    }
    _drawDataset(l) {
      const f = this.ctx,
        y = { meta: l, index: l.index, cancelable: !0 },
        T = iP(this, l);
      this.notifyPlugins("beforeDatasetDraw", y) !== !1 &&
        (T && Yx(f, T),
        l.controller.draw(),
        T && Kx(f),
        (y.cancelable = !1),
        this.notifyPlugins("afterDatasetDraw", y));
    }
    isPointInArea(l) {
      return gp(l, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(l, f, y, T) {
      const I = wP.modes[f];
      return typeof I == "function" ? I(this, l, y, T) : [];
    }
    getDatasetMeta(l) {
      const f = this.data.datasets[l],
        y = this._metasets;
      let T = y.filter((I) => I && I._dataset === f).pop();
      return (
        T ||
          ((T = {
            type: null,
            data: [],
            dataset: null,
            controller: null,
            hidden: null,
            xAxisID: null,
            yAxisID: null,
            order: (f && f.order) || 0,
            index: l,
            _dataset: f,
            _parsed: [],
            _sorted: !1,
          }),
          y.push(T)),
        T
      );
    }
    getContext() {
      return (
        this.$context ||
        (this.$context = Th(null, { chart: this, type: "chart" }))
      );
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(l) {
      const f = this.data.datasets[l];
      if (!f) return !1;
      const y = this.getDatasetMeta(l);
      return typeof y.hidden == "boolean" ? !y.hidden : !f.hidden;
    }
    setDatasetVisibility(l, f) {
      const y = this.getDatasetMeta(l);
      y.hidden = !f;
    }
    toggleDataVisibility(l) {
      this._hiddenIndices[l] = !this._hiddenIndices[l];
    }
    getDataVisibility(l) {
      return !this._hiddenIndices[l];
    }
    _updateVisibility(l, f, y) {
      const T = y ? "show" : "hide",
        I = this.getDatasetMeta(l),
        P = I.controller._resolveAnimations(void 0, T);
      Hg(f)
        ? ((I.data[f].hidden = !y), this.update())
        : (this.setDatasetVisibility(l, y),
          P.update(I, { visible: y }),
          this.update((r) => (r.datasetIndex === l ? T : void 0)));
    }
    hide(l, f) {
      this._updateVisibility(l, f, !1);
    }
    show(l, f) {
      this._updateVisibility(l, f, !0);
    }
    _destroyDatasetMeta(l) {
      const f = this._metasets[l];
      (f && f.controller && f.controller._destroy(), delete this._metasets[l]);
    }
    _stop() {
      let l, f;
      for (
        this.stop(), Va.remove(this), l = 0, f = this.data.datasets.length;
        l < f;
        ++l
      )
        this._destroyDatasetMeta(l);
    }
    destroy() {
      this.notifyPlugins("beforeDestroy");
      const { canvas: l, ctx: f } = this;
      (this._stop(),
        this.config.clearCache(),
        l &&
          (this.unbindEvents(),
          Pw(l, f),
          this.platform.releaseContext(f),
          (this.canvas = null),
          (this.ctx = null)),
        delete Vg[this.id],
        this.notifyPlugins("afterDestroy"));
    }
    toBase64Image(...l) {
      return this.canvas.toDataURL(...l);
    }
    bindEvents() {
      (this.bindUserEvents(),
        this.options.responsive
          ? this.bindResponsiveEvents()
          : (this.attached = !0));
    }
    bindUserEvents() {
      const l = this._listeners,
        f = this.platform,
        y = (I, P) => {
          (f.addEventListener(this, I, P), (l[I] = P));
        },
        T = (I, P, r) => {
          ((I.offsetX = P), (I.offsetY = r), this._eventHandler(I));
        };
      jn(this.options.events, (I) => y(I, T));
    }
    bindResponsiveEvents() {
      this._responsiveListeners || (this._responsiveListeners = {});
      const l = this._responsiveListeners,
        f = this.platform,
        y = (F, B) => {
          (f.addEventListener(this, F, B), (l[F] = B));
        },
        T = (F, B) => {
          l[F] && (f.removeEventListener(this, F, B), delete l[F]);
        },
        I = (F, B) => {
          this.canvas && this.resize(F, B);
        };
      let P;
      const r = () => {
        (T("attach", r),
          (this.attached = !0),
          this.resize(),
          y("resize", I),
          y("detach", P));
      };
      ((P = () => {
        ((this.attached = !1),
          T("resize", I),
          this._stop(),
          this._resize(0, 0),
          y("attach", r));
      }),
        f.isAttached(this.canvas) ? r() : P());
    }
    unbindEvents() {
      (jn(this._listeners, (l, f) => {
        this.platform.removeEventListener(this, f, l);
      }),
        (this._listeners = {}),
        jn(this._responsiveListeners, (l, f) => {
          this.platform.removeEventListener(this, f, l);
        }),
        (this._responsiveListeners = void 0));
    }
    updateHoverStyle(l, f, y) {
      const T = y ? "set" : "remove";
      let I, P, r, F;
      for (
        f === "dataset" &&
          ((I = this.getDatasetMeta(l[0].datasetIndex)),
          I.controller["_" + T + "DatasetHoverStyle"]()),
          r = 0,
          F = l.length;
        r < F;
        ++r
      ) {
        P = l[r];
        const B = P && this.getDatasetMeta(P.datasetIndex).controller;
        B && B[T + "HoverStyle"](P.element, P.datasetIndex, P.index);
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(l) {
      const f = this._active || [],
        y = l.map(({ datasetIndex: I, index: P }) => {
          const r = this.getDatasetMeta(I);
          if (!r) throw new Error("No dataset found at index " + I);
          return { datasetIndex: I, element: r.data[P], index: P };
        });
      !jg(y, f) &&
        ((this._active = y),
        (this._lastEvent = null),
        this._updateHoverStyles(y, f));
    }
    notifyPlugins(l, f, y) {
      return this._plugins.notify(this, l, f, y);
    }
    isPluginEnabled(l) {
      return this._plugins._cache.filter((f) => f.plugin.id === l).length === 1;
    }
    _updateHoverStyles(l, f, y) {
      const T = this.options.hover,
        I = (F, B) =>
          F.filter(
            (q) =>
              !B.some(
                (ne) =>
                  q.datasetIndex === ne.datasetIndex && q.index === ne.index,
              ),
          ),
        P = I(f, l),
        r = y ? l : I(l, f);
      (P.length && this.updateHoverStyle(P, T.mode, !1),
        r.length && T.mode && this.updateHoverStyle(r, T.mode, !0));
    }
    _eventHandler(l, f) {
      const y = {
          event: l,
          replay: f,
          cancelable: !0,
          inChartArea: this.isPointInArea(l),
        },
        T = (P) =>
          (P.options.events || this.options.events).includes(l.native.type);
      if (this.notifyPlugins("beforeEvent", y, T) === !1) return;
      const I = this._handleEvent(l, f, y.inChartArea);
      return (
        (y.cancelable = !1),
        this.notifyPlugins("afterEvent", y, T),
        (I || y.changed) && this.render(),
        this
      );
    }
    _handleEvent(l, f, y) {
      const { _active: T = [], options: I } = this,
        P = f,
        r = this._getActiveElements(l, T, y, P),
        F = kM(l),
        B = ED(l, this._lastEvent, y, F);
      y &&
        ((this._lastEvent = null),
        er(I.onHover, [l, r, this], this),
        F && er(I.onClick, [l, r, this], this));
      const q = !jg(r, T);
      return (
        (q || f) && ((this._active = r), this._updateHoverStyles(r, T, f)),
        (this._lastEvent = B),
        q
      );
    }
    _getActiveElements(l, f, y, T) {
      if (l.type === "mouseout") return [];
      if (!y) return f;
      const I = this.options.hover;
      return this.getElementsAtEventForMode(l, I.mode, I, T);
    }
  }),
  ln(Hl, "defaults", gr),
  ln(Hl, "instances", Vg),
  ln(Hl, "overrides", wh),
  ln(Hl, "registry", ia),
  ln(Hl, "version", bD),
  ln(Hl, "getChart", aT),
  Hl);
function lT() {
  return jn(t_.instances, (m) => m._plugins.invalidate());
}
function S2(m, l, f = l) {
  ((m.lineCap = Dn(f.borderCapStyle, l.borderCapStyle)),
    m.setLineDash(Dn(f.borderDash, l.borderDash)),
    (m.lineDashOffset = Dn(f.borderDashOffset, l.borderDashOffset)),
    (m.lineJoin = Dn(f.borderJoinStyle, l.borderJoinStyle)),
    (m.lineWidth = Dn(f.borderWidth, l.borderWidth)),
    (m.strokeStyle = Dn(f.borderColor, l.borderColor)));
}
function ID(m, l, f) {
  m.lineTo(f.x, f.y);
}
function AD(m) {
  return m.stepped
    ? cC
    : m.tension || m.cubicInterpolationMode === "monotone"
      ? hC
      : ID;
}
function E2(m, l, f = {}) {
  const y = m.length,
    { start: T = 0, end: I = y - 1 } = f,
    { start: P, end: r } = l,
    F = Math.max(T, P),
    B = Math.min(I, r),
    q = (T < P && I < P) || (T > r && I > r);
  return {
    count: y,
    start: F,
    loop: l.loop,
    ilen: B < F && !q ? y + B - F : B - F,
  };
}
function MD(m, l, f, y) {
  const { points: T, options: I } = l,
    { count: P, start: r, loop: F, ilen: B } = E2(T, f, y),
    q = AD(I);
  let { move: ne = !0, reverse: fe } = y || {},
    de,
    Ie,
    xe;
  for (de = 0; de <= B; ++de)
    ((Ie = T[(r + (fe ? B - de : de)) % P]),
      !Ie.skip &&
        (ne ? (m.moveTo(Ie.x, Ie.y), (ne = !1)) : q(m, xe, Ie, fe, I.stepped),
        (xe = Ie)));
  return (
    F && ((Ie = T[(r + (fe ? B : 0)) % P]), q(m, xe, Ie, fe, I.stepped)),
    !!F
  );
}
function CD(m, l, f, y) {
  const T = l.points,
    { count: I, start: P, ilen: r } = E2(T, f, y),
    { move: F = !0, reverse: B } = y || {};
  let q = 0,
    ne = 0,
    fe,
    de,
    Ie,
    xe,
    we,
    Ae;
  const Qe = (Rt) => (P + (B ? r - Rt : Rt)) % I,
    gt = () => {
      xe !== we && (m.lineTo(q, we), m.lineTo(q, xe), m.lineTo(q, Ae));
    };
  for (F && ((de = T[Qe(0)]), m.moveTo(de.x, de.y)), fe = 0; fe <= r; ++fe) {
    if (((de = T[Qe(fe)]), de.skip)) continue;
    const Rt = de.x,
      Mt = de.y,
      pt = Rt | 0;
    (pt === Ie
      ? (Mt < xe ? (xe = Mt) : Mt > we && (we = Mt), (q = (ne * q + Rt) / ++ne))
      : (gt(), m.lineTo(Rt, Mt), (Ie = pt), (ne = 0), (xe = we = Mt)),
      (Ae = Mt));
  }
  gt();
}
function Rx(m) {
  const l = m.options,
    f = l.borderDash && l.borderDash.length;
  return !m._decimated &&
    !m._loop &&
    !l.tension &&
    l.cubicInterpolationMode !== "monotone" &&
    !l.stepped &&
    !f
    ? CD
    : MD;
}
function PD(m) {
  return m.stepped
    ? GC
    : m.tension || m.cubicInterpolationMode === "monotone"
      ? $C
      : ph;
}
function DD(m, l, f, y) {
  let T = l._path;
  (T || ((T = l._path = new Path2D()), l.path(T, f, y) && T.closePath()),
    S2(m, l.options),
    m.stroke(T));
}
function RD(m, l, f, y) {
  const { segments: T, options: I } = l,
    P = Rx(l);
  for (const r of T)
    (S2(m, I, r.style),
      m.beginPath(),
      P(m, l, r, { start: f, end: f + y - 1 }) && m.closePath(),
      m.stroke());
}
const zD = typeof Path2D == "function";
function kD(m, l, f, y) {
  zD && !l.options.segment ? DD(m, l, f, y) : RD(m, l, f, y);
}
class tp extends $a {
  constructor(l) {
    (super(),
      (this.animated = !0),
      (this.options = void 0),
      (this._chart = void 0),
      (this._loop = void 0),
      (this._fullLoop = void 0),
      (this._path = void 0),
      (this._points = void 0),
      (this._segments = void 0),
      (this._decimated = !1),
      (this._pointsUpdated = !1),
      (this._datasetIndex = void 0),
      l && Object.assign(this, l));
  }
  updateControlPoints(l, f) {
    const y = this.options;
    if (
      (y.tension || y.cubicInterpolationMode === "monotone") &&
      !y.stepped &&
      !this._pointsUpdated
    ) {
      const T = y.spanGaps ? this._loop : this._fullLoop;
      (LC(this._points, y, l, T, f), (this._pointsUpdated = !0));
    }
  }
  set points(l) {
    ((this._points = l),
      delete this._segments,
      delete this._path,
      (this._pointsUpdated = !1));
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = JC(this, this.options.segment));
  }
  first() {
    const l = this.segments,
      f = this.points;
    return l.length && f[l[0].start];
  }
  last() {
    const l = this.segments,
      f = this.points,
      y = l.length;
    return y && f[l[y - 1].end];
  }
  interpolate(l, f) {
    const y = this.options,
      T = l[f],
      I = this.points,
      P = XC(this, { property: f, start: T, end: T });
    if (!P.length) return;
    const r = [],
      F = PD(y);
    let B, q;
    for (B = 0, q = P.length; B < q; ++B) {
      const { start: ne, end: fe } = P[B],
        de = I[ne],
        Ie = I[fe];
      if (de === Ie) {
        r.push(de);
        continue;
      }
      const xe = Math.abs((T - de[f]) / (Ie[f] - de[f])),
        we = F(de, Ie, xe, y.stepped);
      ((we[f] = l[f]), r.push(we));
    }
    return r.length === 1 ? r[0] : r;
  }
  pathSegment(l, f, y) {
    return Rx(this)(l, this, f, y);
  }
  path(l, f, y) {
    const T = this.segments,
      I = Rx(this);
    let P = this._loop;
    ((f = f || 0), (y = y || this.points.length - f));
    for (const r of T) P &= I(l, this, r, { start: f, end: f + y - 1 });
    return !!P;
  }
  draw(l, f, y, T) {
    const I = this.options || {};
    ((this.points || []).length &&
      I.borderWidth &&
      (l.save(), kD(l, this, y, T), l.restore()),
      this.animated && ((this._pointsUpdated = !1), (this._path = void 0)));
  }
}
(ln(tp, "id", "line"),
  ln(tp, "defaults", {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: !0,
    cubicInterpolationMode: "default",
    fill: !1,
    spanGaps: !1,
    stepped: !1,
    tension: 0,
  }),
  ln(tp, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor",
  }),
  ln(tp, "descriptors", {
    _scriptable: !0,
    _indexable: (l) => l !== "borderDash" && l !== "fill",
  }));
function cT(m, l, f, y) {
  const T = m.options,
    { [f]: I } = m.getProps([f], y);
  return Math.abs(l - I) < T.radius + T.hitRadius;
}
class Ug extends $a {
  constructor(f) {
    super();
    ln(this, "parsed");
    ln(this, "skip");
    ln(this, "stop");
    ((this.options = void 0),
      (this.parsed = void 0),
      (this.skip = void 0),
      (this.stop = void 0),
      f && Object.assign(this, f));
  }
  inRange(f, y, T) {
    const I = this.options,
      { x: P, y: r } = this.getProps(["x", "y"], T);
    return (
      Math.pow(f - P, 2) + Math.pow(y - r, 2) <
      Math.pow(I.hitRadius + I.radius, 2)
    );
  }
  inXRange(f, y) {
    return cT(this, f, "x", y);
  }
  inYRange(f, y) {
    return cT(this, f, "y", y);
  }
  getCenterPoint(f) {
    const { x: y, y: T } = this.getProps(["x", "y"], f);
    return { x: y, y: T };
  }
  size(f) {
    f = f || this.options || {};
    let y = f.radius || 0;
    y = Math.max(y, (y && f.hoverRadius) || 0);
    const T = (y && f.borderWidth) || 0;
    return (y + T) * 2;
  }
  draw(f, y) {
    const T = this.options;
    this.skip ||
      T.radius < 0.1 ||
      !gp(this, y, this.size(T) / 2) ||
      ((f.strokeStyle = T.borderColor),
      (f.lineWidth = T.borderWidth),
      (f.fillStyle = T.backgroundColor),
      Mx(f, T, this.x, this.y));
  }
  getRange() {
    const f = this.options || {};
    return f.radius + f.hitRadius;
  }
}
(ln(Ug, "id", "point"),
  ln(Ug, "defaults", {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0,
  }),
  ln(Ug, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor",
  }));
const hT = (m, l) => {
    let { boxHeight: f = l, boxWidth: y = l } = m;
    return (
      m.usePointStyle &&
        ((f = Math.min(f, l)), (y = m.pointStyleWidth || Math.min(y, l))),
      { boxWidth: y, boxHeight: f, itemHeight: Math.max(l, f) }
    );
  },
  LD = (m, l) =>
    m !== null &&
    l !== null &&
    m.datasetIndex === l.datasetIndex &&
    m.index === l.index;
class uT extends $a {
  constructor(l) {
    (super(),
      (this._added = !1),
      (this.legendHitBoxes = []),
      (this._hoveredItem = null),
      (this.doughnutMode = !1),
      (this.chart = l.chart),
      (this.options = l.options),
      (this.ctx = l.ctx),
      (this.legendItems = void 0),
      (this.columnSizes = void 0),
      (this.lineWidths = void 0),
      (this.maxHeight = void 0),
      (this.maxWidth = void 0),
      (this.top = void 0),
      (this.bottom = void 0),
      (this.left = void 0),
      (this.right = void 0),
      (this.height = void 0),
      (this.width = void 0),
      (this._margins = void 0),
      (this.position = void 0),
      (this.weight = void 0),
      (this.fullSize = void 0));
  }
  update(l, f, y) {
    ((this.maxWidth = l),
      (this.maxHeight = f),
      (this._margins = y),
      this.setDimensions(),
      this.buildLabels(),
      this.fit());
  }
  setDimensions() {
    this.isHorizontal()
      ? ((this.width = this.maxWidth),
        (this.left = this._margins.left),
        (this.right = this.width))
      : ((this.height = this.maxHeight),
        (this.top = this._margins.top),
        (this.bottom = this.height));
  }
  buildLabels() {
    const l = this.options.labels || {};
    let f = er(l.generateLabels, [this.chart], this) || [];
    (l.filter && (f = f.filter((y) => l.filter(y, this.chart.data))),
      l.sort && (f = f.sort((y, T) => l.sort(y, T, this.chart.data))),
      this.options.reverse && f.reverse(),
      (this.legendItems = f));
  }
  fit() {
    const { options: l, ctx: f } = this;
    if (!l.display) {
      this.width = this.height = 0;
      return;
    }
    const y = l.labels,
      T = rs(y.font),
      I = T.size,
      P = this._computeTitleHeight(),
      { boxWidth: r, itemHeight: F } = hT(y, I);
    let B, q;
    ((f.font = T.string),
      this.isHorizontal()
        ? ((B = this.maxWidth), (q = this._fitRows(P, I, r, F) + 10))
        : ((q = this.maxHeight), (B = this._fitCols(P, T, r, F) + 10)),
      (this.width = Math.min(B, l.maxWidth || this.maxWidth)),
      (this.height = Math.min(q, l.maxHeight || this.maxHeight)));
  }
  _fitRows(l, f, y, T) {
    const {
        ctx: I,
        maxWidth: P,
        options: {
          labels: { padding: r },
        },
      } = this,
      F = (this.legendHitBoxes = []),
      B = (this.lineWidths = [0]),
      q = T + r;
    let ne = l;
    ((I.textAlign = "left"), (I.textBaseline = "middle"));
    let fe = -1,
      de = -q;
    return (
      this.legendItems.forEach((Ie, xe) => {
        const we = y + f / 2 + I.measureText(Ie.text).width;
        ((xe === 0 || B[B.length - 1] + we + 2 * r > P) &&
          ((ne += q), (B[B.length - (xe > 0 ? 0 : 1)] = 0), (de += q), fe++),
          (F[xe] = { left: 0, top: de, row: fe, width: we, height: T }),
          (B[B.length - 1] += we + r));
      }),
      ne
    );
  }
  _fitCols(l, f, y, T) {
    const {
        ctx: I,
        maxHeight: P,
        options: {
          labels: { padding: r },
        },
      } = this,
      F = (this.legendHitBoxes = []),
      B = (this.columnSizes = []),
      q = P - l;
    let ne = r,
      fe = 0,
      de = 0,
      Ie = 0,
      xe = 0;
    return (
      this.legendItems.forEach((we, Ae) => {
        const { itemWidth: Qe, itemHeight: gt } = OD(y, f, I, we, T);
        (Ae > 0 &&
          de + gt + 2 * r > q &&
          ((ne += fe + r),
          B.push({ width: fe, height: de }),
          (Ie += fe + r),
          xe++,
          (fe = de = 0)),
          (F[Ae] = { left: Ie, top: de, col: xe, width: Qe, height: gt }),
          (fe = Math.max(fe, Qe)),
          (de += gt + r));
      }),
      (ne += fe),
      B.push({ width: fe, height: de }),
      ne
    );
  }
  adjustHitBoxes() {
    if (!this.options.display) return;
    const l = this._computeTitleHeight(),
      {
        legendHitBoxes: f,
        options: {
          align: y,
          labels: { padding: T },
          rtl: I,
        },
      } = this,
      P = Xu(I, this.left, this.width);
    if (this.isHorizontal()) {
      let r = 0,
        F = ns(y, this.left + T, this.right - this.lineWidths[r]);
      for (const B of f)
        (r !== B.row &&
          ((r = B.row),
          (F = ns(y, this.left + T, this.right - this.lineWidths[r]))),
          (B.top += this.top + l + T),
          (B.left = P.leftForLtr(P.x(F), B.width)),
          (F += B.width + T));
    } else {
      let r = 0,
        F = ns(y, this.top + l + T, this.bottom - this.columnSizes[r].height);
      for (const B of f)
        (B.col !== r &&
          ((r = B.col),
          (F = ns(
            y,
            this.top + l + T,
            this.bottom - this.columnSizes[r].height,
          ))),
          (B.top = F),
          (B.left += this.left + T),
          (B.left = P.leftForLtr(P.x(B.left), B.width)),
          (F += B.height + T));
    }
  }
  isHorizontal() {
    return (
      this.options.position === "top" || this.options.position === "bottom"
    );
  }
  draw() {
    if (this.options.display) {
      const l = this.ctx;
      (Yx(l, this), this._draw(), Kx(l));
    }
  }
  _draw() {
    const { options: l, columnSizes: f, lineWidths: y, ctx: T } = this,
      { align: I, labels: P } = l,
      r = gr.color,
      F = Xu(l.rtl, this.left, this.width),
      B = rs(P.font),
      { padding: q } = P,
      ne = B.size,
      fe = ne / 2;
    let de;
    (this.drawTitle(),
      (T.textAlign = F.textAlign("left")),
      (T.textBaseline = "middle"),
      (T.lineWidth = 0.5),
      (T.font = B.string));
    const { boxWidth: Ie, boxHeight: xe, itemHeight: we } = hT(P, ne),
      Ae = function (pt, Re, rt) {
        if (isNaN(Ie) || Ie <= 0 || isNaN(xe) || xe < 0) return;
        T.save();
        const Ot = Dn(rt.lineWidth, 1);
        if (
          ((T.fillStyle = Dn(rt.fillStyle, r)),
          (T.lineCap = Dn(rt.lineCap, "butt")),
          (T.lineDashOffset = Dn(rt.lineDashOffset, 0)),
          (T.lineJoin = Dn(rt.lineJoin, "miter")),
          (T.lineWidth = Ot),
          (T.strokeStyle = Dn(rt.strokeStyle, r)),
          T.setLineDash(Dn(rt.lineDash, [])),
          P.usePointStyle)
        ) {
          const _i = {
              radius: (xe * Math.SQRT2) / 2,
              pointStyle: rt.pointStyle,
              rotation: rt.rotation,
              borderWidth: Ot,
            },
            qt = F.xPlus(pt, Ie / 2),
            pi = Re + fe;
          n2(T, _i, qt, pi, P.pointStyleWidth && Ie);
        } else {
          const _i = Re + Math.max((ne - xe) / 2, 0),
            qt = F.leftForLtr(pt, Ie),
            pi = cp(rt.borderRadius);
          (T.beginPath(),
            Object.values(pi).some((Ri) => Ri !== 0)
              ? Cx(T, { x: qt, y: _i, w: Ie, h: xe, radius: pi })
              : T.rect(qt, _i, Ie, xe),
            T.fill(),
            Ot !== 0 && T.stroke());
        }
        T.restore();
      },
      Qe = function (pt, Re, rt) {
        _p(T, rt.text, pt, Re + we / 2, B, {
          strikethrough: rt.hidden,
          textAlign: F.textAlign(rt.textAlign),
        });
      },
      gt = this.isHorizontal(),
      Rt = this._computeTitleHeight();
    (gt
      ? (de = {
          x: ns(I, this.left + q, this.right - y[0]),
          y: this.top + q + Rt,
          line: 0,
        })
      : (de = {
          x: this.left + q,
          y: ns(I, this.top + Rt + q, this.bottom - f[0].height),
          line: 0,
        }),
      h2(this.ctx, l.textDirection));
    const Mt = we + q;
    (this.legendItems.forEach((pt, Re) => {
      ((T.strokeStyle = pt.fontColor), (T.fillStyle = pt.fontColor));
      const rt = T.measureText(pt.text).width,
        Ot = F.textAlign(pt.textAlign || (pt.textAlign = P.textAlign)),
        _i = Ie + fe + rt;
      let qt = de.x,
        pi = de.y;
      (F.setWidth(this.width),
        gt
          ? Re > 0 &&
            qt + _i + q > this.right &&
            ((pi = de.y += Mt),
            de.line++,
            (qt = de.x = ns(I, this.left + q, this.right - y[de.line])))
          : Re > 0 &&
            pi + Mt > this.bottom &&
            ((qt = de.x = qt + f[de.line].width + q),
            de.line++,
            (pi = de.y =
              ns(I, this.top + Rt + q, this.bottom - f[de.line].height))));
      const Ri = F.x(qt);
      if (
        (Ae(Ri, pi, pt),
        (qt = YM(Ot, qt + Ie + fe, gt ? qt + _i : this.right, l.rtl)),
        Qe(F.x(qt), pi, pt),
        gt)
      )
        de.x += _i + q;
      else if (typeof pt.text != "string") {
        const wi = B.lineHeight;
        de.y += I2(pt, wi) + q;
      } else de.y += Mt;
    }),
      u2(this.ctx, l.textDirection));
  }
  drawTitle() {
    const l = this.options,
      f = l.title,
      y = rs(f.font),
      T = Ks(f.padding);
    if (!f.display) return;
    const I = Xu(l.rtl, this.left, this.width),
      P = this.ctx,
      r = f.position,
      F = y.size / 2,
      B = T.top + F;
    let q,
      ne = this.left,
      fe = this.width;
    if (this.isHorizontal())
      ((fe = Math.max(...this.lineWidths)),
        (q = this.top + B),
        (ne = ns(l.align, ne, this.right - fe)));
    else {
      const Ie = this.columnSizes.reduce(
        (xe, we) => Math.max(xe, we.height),
        0,
      );
      q =
        B +
        ns(
          l.align,
          this.top,
          this.bottom - Ie - l.labels.padding - this._computeTitleHeight(),
        );
    }
    const de = ns(r, ne, ne + fe);
    ((P.textAlign = I.textAlign(Zx(r))),
      (P.textBaseline = "middle"),
      (P.strokeStyle = f.color),
      (P.fillStyle = f.color),
      (P.font = y.string),
      _p(P, f.text, de, q, y));
  }
  _computeTitleHeight() {
    const l = this.options.title,
      f = rs(l.font),
      y = Ks(l.padding);
    return l.display ? f.lineHeight + y.height : 0;
  }
  _getLegendItemAt(l, f) {
    let y, T, I;
    if (Qf(l, this.left, this.right) && Qf(f, this.top, this.bottom)) {
      for (I = this.legendHitBoxes, y = 0; y < I.length; ++y)
        if (
          ((T = I[y]),
          Qf(l, T.left, T.left + T.width) && Qf(f, T.top, T.top + T.height))
        )
          return this.legendItems[y];
    }
    return null;
  }
  handleEvent(l) {
    const f = this.options;
    if (!ND(l.type, f)) return;
    const y = this._getLegendItemAt(l.x, l.y);
    if (l.type === "mousemove" || l.type === "mouseout") {
      const T = this._hoveredItem,
        I = LD(T, y);
      (T && !I && er(f.onLeave, [l, T, this], this),
        (this._hoveredItem = y),
        y && !I && er(f.onHover, [l, y, this], this));
    } else y && er(f.onClick, [l, y, this], this);
  }
}
function OD(m, l, f, y, T) {
  const I = FD(y, m, l, f),
    P = BD(T, y, l.lineHeight);
  return { itemWidth: I, itemHeight: P };
}
function FD(m, l, f, y) {
  let T = m.text;
  return (
    T &&
      typeof T != "string" &&
      (T = T.reduce((I, P) => (I.length > P.length ? I : P))),
    l + f.size / 2 + y.measureText(T).width
  );
}
function BD(m, l, f) {
  let y = m;
  return (typeof l.text != "string" && (y = I2(l, f)), y);
}
function I2(m, l) {
  const f = m.text ? m.text.length : 0;
  return l * f;
}
function ND(m, l) {
  return !!(
    ((m === "mousemove" || m === "mouseout") && (l.onHover || l.onLeave)) ||
    (l.onClick && (m === "click" || m === "mouseup"))
  );
}
var VD = {
  id: "legend",
  _element: uT,
  start(m, l, f) {
    const y = (m.legend = new uT({ ctx: m.ctx, options: f, chart: m }));
    (Zs.configure(m, y, f), Zs.addBox(m, y));
  },
  stop(m) {
    (Zs.removeBox(m, m.legend), delete m.legend);
  },
  beforeUpdate(m, l, f) {
    const y = m.legend;
    (Zs.configure(m, y, f), (y.options = f));
  },
  afterUpdate(m) {
    const l = m.legend;
    (l.buildLabels(), l.adjustHitBoxes());
  },
  afterEvent(m, l) {
    l.replay || m.legend.handleEvent(l.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(m, l, f) {
      const y = l.datasetIndex,
        T = f.chart;
      T.isDatasetVisible(y)
        ? (T.hide(y), (l.hidden = !0))
        : (T.show(y), (l.hidden = !1));
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (m) => m.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(m) {
        const l = m.data.datasets,
          {
            labels: {
              usePointStyle: f,
              pointStyle: y,
              textAlign: T,
              color: I,
              useBorderRadius: P,
              borderRadius: r,
            },
          } = m.legend.options;
        return m._getSortedDatasetMetas().map((F) => {
          const B = F.controller.getStyle(f ? 0 : void 0),
            q = Ks(B.borderWidth);
          return {
            text: l[F.index].label,
            fillStyle: B.backgroundColor,
            fontColor: I,
            hidden: !F.visible,
            lineCap: B.borderCapStyle,
            lineDash: B.borderDash,
            lineDashOffset: B.borderDashOffset,
            lineJoin: B.borderJoinStyle,
            lineWidth: (q.width + q.height) / 4,
            strokeStyle: B.borderColor,
            pointStyle: y || B.pointStyle,
            rotation: B.rotation,
            textAlign: T || B.textAlign,
            borderRadius: P && (r || B.borderRadius),
            datasetIndex: F.index,
          };
        }, this);
      },
    },
    title: {
      color: (m) => m.chart.options.color,
      display: !1,
      position: "center",
      text: "",
    },
  },
  descriptors: {
    _scriptable: (m) => !m.startsWith("on"),
    labels: {
      _scriptable: (m) => !["generateLabels", "filter", "sort"].includes(m),
    },
  },
};
class A2 extends $a {
  constructor(l) {
    (super(),
      (this.chart = l.chart),
      (this.options = l.options),
      (this.ctx = l.ctx),
      (this._padding = void 0),
      (this.top = void 0),
      (this.bottom = void 0),
      (this.left = void 0),
      (this.right = void 0),
      (this.width = void 0),
      (this.height = void 0),
      (this.position = void 0),
      (this.weight = void 0),
      (this.fullSize = void 0));
  }
  update(l, f) {
    const y = this.options;
    if (((this.left = 0), (this.top = 0), !y.display)) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    ((this.width = this.right = l), (this.height = this.bottom = f));
    const T = Nr(y.text) ? y.text.length : 1;
    this._padding = Ks(y.padding);
    const I = T * rs(y.font).lineHeight + this._padding.height;
    this.isHorizontal() ? (this.height = I) : (this.width = I);
  }
  isHorizontal() {
    const l = this.options.position;
    return l === "top" || l === "bottom";
  }
  _drawArgs(l) {
    const { top: f, left: y, bottom: T, right: I, options: P } = this,
      r = P.align;
    let F = 0,
      B,
      q,
      ne;
    return (
      this.isHorizontal()
        ? ((q = ns(r, y, I)), (ne = f + l), (B = I - y))
        : (P.position === "left"
            ? ((q = y + l), (ne = ns(r, T, f)), (F = Vr * -0.5))
            : ((q = I - l), (ne = ns(r, f, T)), (F = Vr * 0.5)),
          (B = T - f)),
      { titleX: q, titleY: ne, maxWidth: B, rotation: F }
    );
  }
  draw() {
    const l = this.ctx,
      f = this.options;
    if (!f.display) return;
    const y = rs(f.font),
      I = y.lineHeight / 2 + this._padding.top,
      { titleX: P, titleY: r, maxWidth: F, rotation: B } = this._drawArgs(I);
    _p(l, f.text, 0, 0, y, {
      color: f.color,
      maxWidth: F,
      rotation: B,
      textAlign: Zx(f.align),
      textBaseline: "middle",
      translation: [P, r],
    });
  }
}
function UD(m, l) {
  const f = new A2({ ctx: m.ctx, options: l, chart: m });
  (Zs.configure(m, f, l), Zs.addBox(m, f), (m.titleBlock = f));
}
var jD = {
  id: "title",
  _element: A2,
  start(m, l, f) {
    UD(m, f);
  },
  stop(m) {
    const l = m.titleBlock;
    (Zs.removeBox(m, l), delete m.titleBlock);
  },
  beforeUpdate(m, l, f) {
    const y = m.titleBlock;
    (Zs.configure(m, y, f), (y.options = f));
  },
  defaults: {
    align: "center",
    display: !1,
    font: { weight: "bold" },
    fullSize: !0,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3,
  },
  defaultRoutes: { color: "color" },
  descriptors: { _scriptable: !0, _indexable: !1 },
};
const ip = {
  average(m) {
    if (!m.length) return !1;
    let l,
      f,
      y = new Set(),
      T = 0,
      I = 0;
    for (l = 0, f = m.length; l < f; ++l) {
      const r = m[l].element;
      if (r && r.hasValue()) {
        const F = r.tooltipPosition();
        (y.add(F.x), (T += F.y), ++I);
      }
    }
    return I === 0 || y.size === 0
      ? !1
      : { x: [...y].reduce((r, F) => r + F) / y.size, y: T / I };
  },
  nearest(m, l) {
    if (!m.length) return !1;
    let f = l.x,
      y = l.y,
      T = Number.POSITIVE_INFINITY,
      I,
      P,
      r;
    for (I = 0, P = m.length; I < P; ++I) {
      const F = m[I].element;
      if (F && F.hasValue()) {
        const B = F.getCenterPoint(),
          q = Ix(l, B);
        q < T && ((T = q), (r = F));
      }
    }
    if (r) {
      const F = r.tooltipPosition();
      ((f = F.x), (y = F.y));
    }
    return { x: f, y };
  },
};
function ta(m, l) {
  return (l && (Nr(l) ? Array.prototype.push.apply(m, l) : m.push(l)), m);
}
function Ua(m) {
  return (typeof m == "string" || m instanceof String) &&
    m.indexOf(`
`) > -1
    ? m.split(`
`)
    : m;
}
function GD(m, l) {
  const { element: f, datasetIndex: y, index: T } = l,
    I = m.getDatasetMeta(y).controller,
    { label: P, value: r } = I.getLabelAndValue(T);
  return {
    chart: m,
    label: P,
    parsed: I.getParsed(T),
    raw: m.data.datasets[y].data[T],
    formattedValue: r,
    dataset: I.getDataset(),
    dataIndex: T,
    datasetIndex: y,
    element: f,
  };
}
function dT(m, l) {
  const f = m.chart.ctx,
    { body: y, footer: T, title: I } = m,
    { boxWidth: P, boxHeight: r } = l,
    F = rs(l.bodyFont),
    B = rs(l.titleFont),
    q = rs(l.footerFont),
    ne = I.length,
    fe = T.length,
    de = y.length,
    Ie = Ks(l.padding);
  let xe = Ie.height,
    we = 0,
    Ae = y.reduce(
      (Rt, Mt) => Rt + Mt.before.length + Mt.lines.length + Mt.after.length,
      0,
    );
  if (
    ((Ae += m.beforeBody.length + m.afterBody.length),
    ne &&
      (xe +=
        ne * B.lineHeight + (ne - 1) * l.titleSpacing + l.titleMarginBottom),
    Ae)
  ) {
    const Rt = l.displayColors ? Math.max(r, F.lineHeight) : F.lineHeight;
    xe += de * Rt + (Ae - de) * F.lineHeight + (Ae - 1) * l.bodySpacing;
  }
  fe &&
    (xe += l.footerMarginTop + fe * q.lineHeight + (fe - 1) * l.footerSpacing);
  let Qe = 0;
  const gt = function (Rt) {
    we = Math.max(we, f.measureText(Rt).width + Qe);
  };
  return (
    f.save(),
    (f.font = B.string),
    jn(m.title, gt),
    (f.font = F.string),
    jn(m.beforeBody.concat(m.afterBody), gt),
    (Qe = l.displayColors ? P + 2 + l.boxPadding : 0),
    jn(y, (Rt) => {
      (jn(Rt.before, gt), jn(Rt.lines, gt), jn(Rt.after, gt));
    }),
    (Qe = 0),
    (f.font = q.string),
    jn(m.footer, gt),
    f.restore(),
    (we += Ie.width),
    { width: we, height: xe }
  );
}
function $D(m, l) {
  const { y: f, height: y } = l;
  return f < y / 2 ? "top" : f > m.height - y / 2 ? "bottom" : "center";
}
function HD(m, l, f, y) {
  const { x: T, width: I } = y,
    P = f.caretSize + f.caretPadding;
  if ((m === "left" && T + I + P > l.width) || (m === "right" && T - I - P < 0))
    return !0;
}
function WD(m, l, f, y) {
  const { x: T, width: I } = f,
    {
      width: P,
      chartArea: { left: r, right: F },
    } = m;
  let B = "center";
  return (
    y === "center"
      ? (B = T <= (r + F) / 2 ? "left" : "right")
      : T <= I / 2
        ? (B = "left")
        : T >= P - I / 2 && (B = "right"),
    HD(B, m, l, f) && (B = "center"),
    B
  );
}
function fT(m, l, f) {
  const y = f.yAlign || l.yAlign || $D(m, f);
  return { xAlign: f.xAlign || l.xAlign || WD(m, l, f, y), yAlign: y };
}
function qD(m, l) {
  let { x: f, width: y } = m;
  return (l === "right" ? (f -= y) : l === "center" && (f -= y / 2), f);
}
function ZD(m, l, f) {
  let { y, height: T } = m;
  return (
    l === "top" ? (y += f) : l === "bottom" ? (y -= T + f) : (y -= T / 2),
    y
  );
}
function pT(m, l, f, y) {
  const { caretSize: T, caretPadding: I, cornerRadius: P } = m,
    { xAlign: r, yAlign: F } = f,
    B = T + I,
    { topLeft: q, topRight: ne, bottomLeft: fe, bottomRight: de } = cp(P);
  let Ie = qD(l, r);
  const xe = ZD(l, F, B);
  return (
    F === "center"
      ? r === "left"
        ? (Ie += B)
        : r === "right" && (Ie -= B)
      : r === "left"
        ? (Ie -= Math.max(q, fe) + T)
        : r === "right" && (Ie += Math.max(ne, de) + T),
    { x: qs(Ie, 0, y.width - l.width), y: qs(xe, 0, y.height - l.height) }
  );
}
function Rg(m, l, f) {
  const y = Ks(f.padding);
  return l === "center"
    ? m.x + m.width / 2
    : l === "right"
      ? m.x + m.width - y.right
      : m.x + y.left;
}
function mT(m) {
  return ta([], Ua(m));
}
function XD(m, l, f) {
  return Th(m, { tooltip: l, tooltipItems: f, type: "tooltip" });
}
function gT(m, l) {
  const f = l && l.dataset && l.dataset.tooltip && l.dataset.tooltip.callbacks;
  return f ? m.override(f) : m;
}
const M2 = {
  beforeTitle: Ba,
  title(m) {
    if (m.length > 0) {
      const l = m[0],
        f = l.chart.data.labels,
        y = f ? f.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return l.dataset.label || "";
      if (l.label) return l.label;
      if (y > 0 && l.dataIndex < y) return f[l.dataIndex];
    }
    return "";
  },
  afterTitle: Ba,
  beforeBody: Ba,
  beforeLabel: Ba,
  label(m) {
    if (this && this.options && this.options.mode === "dataset")
      return m.label + ": " + m.formattedValue || m.formattedValue;
    let l = m.dataset.label || "";
    l && (l += ": ");
    const f = m.formattedValue;
    return (Jn(f) || (l += f), l);
  },
  labelColor(m) {
    const f = m.chart
      .getDatasetMeta(m.datasetIndex)
      .controller.getStyle(m.dataIndex);
    return {
      borderColor: f.borderColor,
      backgroundColor: f.backgroundColor,
      borderWidth: f.borderWidth,
      borderDash: f.borderDash,
      borderDashOffset: f.borderDashOffset,
      borderRadius: 0,
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(m) {
    const f = m.chart
      .getDatasetMeta(m.datasetIndex)
      .controller.getStyle(m.dataIndex);
    return { pointStyle: f.pointStyle, rotation: f.rotation };
  },
  afterLabel: Ba,
  afterBody: Ba,
  beforeFooter: Ba,
  footer: Ba,
  afterFooter: Ba,
};
function Ss(m, l, f, y) {
  const T = m[l].call(f, y);
  return typeof T > "u" ? M2[l].call(f, y) : T;
}
class zx extends $a {
  constructor(l) {
    (super(),
      (this.opacity = 0),
      (this._active = []),
      (this._eventPosition = void 0),
      (this._size = void 0),
      (this._cachedAnimations = void 0),
      (this._tooltipItems = []),
      (this.$animations = void 0),
      (this.$context = void 0),
      (this.chart = l.chart),
      (this.options = l.options),
      (this.dataPoints = void 0),
      (this.title = void 0),
      (this.beforeBody = void 0),
      (this.body = void 0),
      (this.afterBody = void 0),
      (this.footer = void 0),
      (this.xAlign = void 0),
      (this.yAlign = void 0),
      (this.x = void 0),
      (this.y = void 0),
      (this.height = void 0),
      (this.width = void 0),
      (this.caretX = void 0),
      (this.caretY = void 0),
      (this.labelColors = void 0),
      (this.labelPointStyles = void 0),
      (this.labelTextColors = void 0));
  }
  initialize(l) {
    ((this.options = l),
      (this._cachedAnimations = void 0),
      (this.$context = void 0));
  }
  _resolveAnimations() {
    const l = this._cachedAnimations;
    if (l) return l;
    const f = this.chart,
      y = this.options.setContext(this.getContext()),
      T = y.enabled && f.options.animation && y.animations,
      I = new f2(this.chart, T);
    return (T._cacheable && (this._cachedAnimations = Object.freeze(I)), I);
  }
  getContext() {
    return (
      this.$context ||
      (this.$context = XD(this.chart.getContext(), this, this._tooltipItems))
    );
  }
  getTitle(l, f) {
    const { callbacks: y } = f,
      T = Ss(y, "beforeTitle", this, l),
      I = Ss(y, "title", this, l),
      P = Ss(y, "afterTitle", this, l);
    let r = [];
    return ((r = ta(r, Ua(T))), (r = ta(r, Ua(I))), (r = ta(r, Ua(P))), r);
  }
  getBeforeBody(l, f) {
    return mT(Ss(f.callbacks, "beforeBody", this, l));
  }
  getBody(l, f) {
    const { callbacks: y } = f,
      T = [];
    return (
      jn(l, (I) => {
        const P = { before: [], lines: [], after: [] },
          r = gT(y, I);
        (ta(P.before, Ua(Ss(r, "beforeLabel", this, I))),
          ta(P.lines, Ss(r, "label", this, I)),
          ta(P.after, Ua(Ss(r, "afterLabel", this, I))),
          T.push(P));
      }),
      T
    );
  }
  getAfterBody(l, f) {
    return mT(Ss(f.callbacks, "afterBody", this, l));
  }
  getFooter(l, f) {
    const { callbacks: y } = f,
      T = Ss(y, "beforeFooter", this, l),
      I = Ss(y, "footer", this, l),
      P = Ss(y, "afterFooter", this, l);
    let r = [];
    return ((r = ta(r, Ua(T))), (r = ta(r, Ua(I))), (r = ta(r, Ua(P))), r);
  }
  _createItems(l) {
    const f = this._active,
      y = this.chart.data,
      T = [],
      I = [],
      P = [];
    let r = [],
      F,
      B;
    for (F = 0, B = f.length; F < B; ++F) r.push(GD(this.chart, f[F]));
    return (
      l.filter && (r = r.filter((q, ne, fe) => l.filter(q, ne, fe, y))),
      l.itemSort && (r = r.sort((q, ne) => l.itemSort(q, ne, y))),
      jn(r, (q) => {
        const ne = gT(l.callbacks, q);
        (T.push(Ss(ne, "labelColor", this, q)),
          I.push(Ss(ne, "labelPointStyle", this, q)),
          P.push(Ss(ne, "labelTextColor", this, q)));
      }),
      (this.labelColors = T),
      (this.labelPointStyles = I),
      (this.labelTextColors = P),
      (this.dataPoints = r),
      r
    );
  }
  update(l, f) {
    const y = this.options.setContext(this.getContext()),
      T = this._active;
    let I,
      P = [];
    if (!T.length) this.opacity !== 0 && (I = { opacity: 0 });
    else {
      const r = ip[y.position].call(this, T, this._eventPosition);
      ((P = this._createItems(y)),
        (this.title = this.getTitle(P, y)),
        (this.beforeBody = this.getBeforeBody(P, y)),
        (this.body = this.getBody(P, y)),
        (this.afterBody = this.getAfterBody(P, y)),
        (this.footer = this.getFooter(P, y)));
      const F = (this._size = dT(this, y)),
        B = Object.assign({}, r, F),
        q = fT(this.chart, y, B),
        ne = pT(y, B, q, this.chart);
      ((this.xAlign = q.xAlign),
        (this.yAlign = q.yAlign),
        (I = {
          opacity: 1,
          x: ne.x,
          y: ne.y,
          width: F.width,
          height: F.height,
          caretX: r.x,
          caretY: r.y,
        }));
    }
    ((this._tooltipItems = P),
      (this.$context = void 0),
      I && this._resolveAnimations().update(this, I),
      l &&
        y.external &&
        y.external.call(this, { chart: this.chart, tooltip: this, replay: f }));
  }
  drawCaret(l, f, y, T) {
    const I = this.getCaretPosition(l, y, T);
    (f.lineTo(I.x1, I.y1), f.lineTo(I.x2, I.y2), f.lineTo(I.x3, I.y3));
  }
  getCaretPosition(l, f, y) {
    const { xAlign: T, yAlign: I } = this,
      { caretSize: P, cornerRadius: r } = y,
      { topLeft: F, topRight: B, bottomLeft: q, bottomRight: ne } = cp(r),
      { x: fe, y: de } = l,
      { width: Ie, height: xe } = f;
    let we, Ae, Qe, gt, Rt, Mt;
    return (
      I === "center"
        ? ((Rt = de + xe / 2),
          T === "left"
            ? ((we = fe), (Ae = we - P), (gt = Rt + P), (Mt = Rt - P))
            : ((we = fe + Ie), (Ae = we + P), (gt = Rt - P), (Mt = Rt + P)),
          (Qe = we))
        : (T === "left"
            ? (Ae = fe + Math.max(F, q) + P)
            : T === "right"
              ? (Ae = fe + Ie - Math.max(B, ne) - P)
              : (Ae = this.caretX),
          I === "top"
            ? ((gt = de), (Rt = gt - P), (we = Ae - P), (Qe = Ae + P))
            : ((gt = de + xe), (Rt = gt + P), (we = Ae + P), (Qe = Ae - P)),
          (Mt = gt)),
      { x1: we, x2: Ae, x3: Qe, y1: gt, y2: Rt, y3: Mt }
    );
  }
  drawTitle(l, f, y) {
    const T = this.title,
      I = T.length;
    let P, r, F;
    if (I) {
      const B = Xu(y.rtl, this.x, this.width);
      for (
        l.x = Rg(this, y.titleAlign, y),
          f.textAlign = B.textAlign(y.titleAlign),
          f.textBaseline = "middle",
          P = rs(y.titleFont),
          r = y.titleSpacing,
          f.fillStyle = y.titleColor,
          f.font = P.string,
          F = 0;
        F < I;
        ++F
      )
        (f.fillText(T[F], B.x(l.x), l.y + P.lineHeight / 2),
          (l.y += P.lineHeight + r),
          F + 1 === I && (l.y += y.titleMarginBottom - r));
    }
  }
  _drawColorBox(l, f, y, T, I) {
    const P = this.labelColors[y],
      r = this.labelPointStyles[y],
      { boxHeight: F, boxWidth: B } = I,
      q = rs(I.bodyFont),
      ne = Rg(this, "left", I),
      fe = T.x(ne),
      de = F < q.lineHeight ? (q.lineHeight - F) / 2 : 0,
      Ie = f.y + de;
    if (I.usePointStyle) {
      const xe = {
          radius: Math.min(B, F) / 2,
          pointStyle: r.pointStyle,
          rotation: r.rotation,
          borderWidth: 1,
        },
        we = T.leftForLtr(fe, B) + B / 2,
        Ae = Ie + F / 2;
      ((l.strokeStyle = I.multiKeyBackground),
        (l.fillStyle = I.multiKeyBackground),
        Mx(l, xe, we, Ae),
        (l.strokeStyle = P.borderColor),
        (l.fillStyle = P.backgroundColor),
        Mx(l, xe, we, Ae));
    } else {
      ((l.lineWidth = Nn(P.borderWidth)
        ? Math.max(...Object.values(P.borderWidth))
        : P.borderWidth || 1),
        (l.strokeStyle = P.borderColor),
        l.setLineDash(P.borderDash || []),
        (l.lineDashOffset = P.borderDashOffset || 0));
      const xe = T.leftForLtr(fe, B),
        we = T.leftForLtr(T.xPlus(fe, 1), B - 2),
        Ae = cp(P.borderRadius);
      Object.values(Ae).some((Qe) => Qe !== 0)
        ? (l.beginPath(),
          (l.fillStyle = I.multiKeyBackground),
          Cx(l, { x: xe, y: Ie, w: B, h: F, radius: Ae }),
          l.fill(),
          l.stroke(),
          (l.fillStyle = P.backgroundColor),
          l.beginPath(),
          Cx(l, { x: we, y: Ie + 1, w: B - 2, h: F - 2, radius: Ae }),
          l.fill())
        : ((l.fillStyle = I.multiKeyBackground),
          l.fillRect(xe, Ie, B, F),
          l.strokeRect(xe, Ie, B, F),
          (l.fillStyle = P.backgroundColor),
          l.fillRect(we, Ie + 1, B - 2, F - 2));
    }
    l.fillStyle = this.labelTextColors[y];
  }
  drawBody(l, f, y) {
    const { body: T } = this,
      {
        bodySpacing: I,
        bodyAlign: P,
        displayColors: r,
        boxHeight: F,
        boxWidth: B,
        boxPadding: q,
      } = y,
      ne = rs(y.bodyFont);
    let fe = ne.lineHeight,
      de = 0;
    const Ie = Xu(y.rtl, this.x, this.width),
      xe = function (rt) {
        (f.fillText(rt, Ie.x(l.x + de), l.y + fe / 2), (l.y += fe + I));
      },
      we = Ie.textAlign(P);
    let Ae, Qe, gt, Rt, Mt, pt, Re;
    for (
      f.textAlign = P,
        f.textBaseline = "middle",
        f.font = ne.string,
        l.x = Rg(this, we, y),
        f.fillStyle = y.bodyColor,
        jn(this.beforeBody, xe),
        de = r && we !== "right" ? (P === "center" ? B / 2 + q : B + 2 + q) : 0,
        Rt = 0,
        pt = T.length;
      Rt < pt;
      ++Rt
    ) {
      for (
        Ae = T[Rt],
          Qe = this.labelTextColors[Rt],
          f.fillStyle = Qe,
          jn(Ae.before, xe),
          gt = Ae.lines,
          r &&
            gt.length &&
            (this._drawColorBox(f, l, Rt, Ie, y),
            (fe = Math.max(ne.lineHeight, F))),
          Mt = 0,
          Re = gt.length;
        Mt < Re;
        ++Mt
      )
        (xe(gt[Mt]), (fe = ne.lineHeight));
      jn(Ae.after, xe);
    }
    ((de = 0), (fe = ne.lineHeight), jn(this.afterBody, xe), (l.y -= I));
  }
  drawFooter(l, f, y) {
    const T = this.footer,
      I = T.length;
    let P, r;
    if (I) {
      const F = Xu(y.rtl, this.x, this.width);
      for (
        l.x = Rg(this, y.footerAlign, y),
          l.y += y.footerMarginTop,
          f.textAlign = F.textAlign(y.footerAlign),
          f.textBaseline = "middle",
          P = rs(y.footerFont),
          f.fillStyle = y.footerColor,
          f.font = P.string,
          r = 0;
        r < I;
        ++r
      )
        (f.fillText(T[r], F.x(l.x), l.y + P.lineHeight / 2),
          (l.y += P.lineHeight + y.footerSpacing));
    }
  }
  drawBackground(l, f, y, T) {
    const { xAlign: I, yAlign: P } = this,
      { x: r, y: F } = l,
      { width: B, height: q } = y,
      {
        topLeft: ne,
        topRight: fe,
        bottomLeft: de,
        bottomRight: Ie,
      } = cp(T.cornerRadius);
    ((f.fillStyle = T.backgroundColor),
      (f.strokeStyle = T.borderColor),
      (f.lineWidth = T.borderWidth),
      f.beginPath(),
      f.moveTo(r + ne, F),
      P === "top" && this.drawCaret(l, f, y, T),
      f.lineTo(r + B - fe, F),
      f.quadraticCurveTo(r + B, F, r + B, F + fe),
      P === "center" && I === "right" && this.drawCaret(l, f, y, T),
      f.lineTo(r + B, F + q - Ie),
      f.quadraticCurveTo(r + B, F + q, r + B - Ie, F + q),
      P === "bottom" && this.drawCaret(l, f, y, T),
      f.lineTo(r + de, F + q),
      f.quadraticCurveTo(r, F + q, r, F + q - de),
      P === "center" && I === "left" && this.drawCaret(l, f, y, T),
      f.lineTo(r, F + ne),
      f.quadraticCurveTo(r, F, r + ne, F),
      f.closePath(),
      f.fill(),
      T.borderWidth > 0 && f.stroke());
  }
  _updateAnimationTarget(l) {
    const f = this.chart,
      y = this.$animations,
      T = y && y.x,
      I = y && y.y;
    if (T || I) {
      const P = ip[l.position].call(this, this._active, this._eventPosition);
      if (!P) return;
      const r = (this._size = dT(this, l)),
        F = Object.assign({}, P, this._size),
        B = fT(f, l, F),
        q = pT(l, F, B, f);
      (T._to !== q.x || I._to !== q.y) &&
        ((this.xAlign = B.xAlign),
        (this.yAlign = B.yAlign),
        (this.width = r.width),
        (this.height = r.height),
        (this.caretX = P.x),
        (this.caretY = P.y),
        this._resolveAnimations().update(this, q));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(l) {
    const f = this.options.setContext(this.getContext());
    let y = this.opacity;
    if (!y) return;
    this._updateAnimationTarget(f);
    const T = { width: this.width, height: this.height },
      I = { x: this.x, y: this.y };
    y = Math.abs(y) < 0.001 ? 0 : y;
    const P = Ks(f.padding),
      r =
        this.title.length ||
        this.beforeBody.length ||
        this.body.length ||
        this.afterBody.length ||
        this.footer.length;
    f.enabled &&
      r &&
      (l.save(),
      (l.globalAlpha = y),
      this.drawBackground(I, l, T, f),
      h2(l, f.textDirection),
      (I.y += P.top),
      this.drawTitle(I, l, f),
      this.drawBody(I, l, f),
      this.drawFooter(I, l, f),
      u2(l, f.textDirection),
      l.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(l, f) {
    const y = this._active,
      T = l.map(({ datasetIndex: r, index: F }) => {
        const B = this.chart.getDatasetMeta(r);
        if (!B) throw new Error("Cannot find a dataset at index " + r);
        return { datasetIndex: r, element: B.data[F], index: F };
      }),
      I = !jg(y, T),
      P = this._positionChanged(T, f);
    (I || P) &&
      ((this._active = T),
      (this._eventPosition = f),
      (this._ignoreReplayEvents = !0),
      this.update(!0));
  }
  handleEvent(l, f, y = !0) {
    if (f && this._ignoreReplayEvents) return !1;
    this._ignoreReplayEvents = !1;
    const T = this.options,
      I = this._active || [],
      P = this._getActiveElements(l, I, f, y),
      r = this._positionChanged(P, l),
      F = f || !jg(P, I) || r;
    return (
      F &&
        ((this._active = P),
        (T.enabled || T.external) &&
          ((this._eventPosition = { x: l.x, y: l.y }), this.update(!0, f))),
      F
    );
  }
  _getActiveElements(l, f, y, T) {
    const I = this.options;
    if (l.type === "mouseout") return [];
    if (!T)
      return f.filter(
        (r) =>
          this.chart.data.datasets[r.datasetIndex] &&
          this.chart
            .getDatasetMeta(r.datasetIndex)
            .controller.getParsed(r.index) !== void 0,
      );
    const P = this.chart.getElementsAtEventForMode(l, I.mode, I, y);
    return (I.reverse && P.reverse(), P);
  }
  _positionChanged(l, f) {
    const { caretX: y, caretY: T, options: I } = this,
      P = ip[I.position].call(this, l, f);
    return P !== !1 && (y !== P.x || T !== P.y);
  }
}
ln(zx, "positioners", ip);
var YD = {
  id: "tooltip",
  _element: zx,
  positioners: ip,
  afterInit(m, l, f) {
    f && (m.tooltip = new zx({ chart: m, options: f }));
  },
  beforeUpdate(m, l, f) {
    m.tooltip && m.tooltip.initialize(f);
  },
  reset(m, l, f) {
    m.tooltip && m.tooltip.initialize(f);
  },
  afterDraw(m) {
    const l = m.tooltip;
    if (l && l._willRender()) {
      const f = { tooltip: l };
      if (m.notifyPlugins("beforeTooltipDraw", { ...f, cancelable: !0 }) === !1)
        return;
      (l.draw(m.ctx), m.notifyPlugins("afterTooltipDraw", f));
    }
  },
  afterEvent(m, l) {
    if (m.tooltip) {
      const f = l.replay;
      m.tooltip.handleEvent(l.event, f, l.inChartArea) && (l.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: { weight: "bold" },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: { weight: "bold" },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (m, l) => l.bodyFont.size,
    boxWidth: (m, l) => l.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: { duration: 400, easing: "easeOutQuart" },
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "width", "height", "caretX", "caretY"],
      },
      opacity: { easing: "linear", duration: 200 },
    },
    callbacks: M2,
  },
  defaultRoutes: { bodyFont: "font", footerFont: "font", titleFont: "font" },
  descriptors: {
    _scriptable: (m) => m !== "filter" && m !== "itemSort" && m !== "external",
    _indexable: !1,
    callbacks: { _scriptable: !1, _indexable: !1 },
    animation: { _fallback: !1 },
    animations: { _fallback: "animation" },
  },
  additionalOptionScopes: ["interaction"],
};
const KD = (m, l, f, y) => (
  typeof l == "string"
    ? ((f = m.push(l) - 1), y.unshift({ index: f, label: l }))
    : isNaN(l) && (f = null),
  f
);
function JD(m, l, f, y) {
  const T = m.indexOf(l);
  if (T === -1) return KD(m, l, f, y);
  const I = m.lastIndexOf(l);
  return T !== I ? f : T;
}
const QD = (m, l) => (m === null ? null : qs(Math.round(m), 0, l));
function _T(m) {
  const l = this.getLabels();
  return m >= 0 && m < l.length ? l[m] : m;
}
class kx extends Qu {
  constructor(l) {
    (super(l),
      (this._startValue = void 0),
      (this._valueRange = 0),
      (this._addedLabels = []));
  }
  init(l) {
    const f = this._addedLabels;
    if (f.length) {
      const y = this.getLabels();
      for (const { index: T, label: I } of f) y[T] === I && y.splice(T, 1);
      this._addedLabels = [];
    }
    super.init(l);
  }
  parse(l, f) {
    if (Jn(l)) return null;
    const y = this.getLabels();
    return (
      (f =
        isFinite(f) && y[f] === l ? f : JD(y, l, Dn(f, l), this._addedLabels)),
      QD(f, y.length - 1)
    );
  }
  determineDataLimits() {
    const { minDefined: l, maxDefined: f } = this.getUserBounds();
    let { min: y, max: T } = this.getMinMax(!0);
    (this.options.bounds === "ticks" &&
      (l || (y = 0), f || (T = this.getLabels().length - 1)),
      (this.min = y),
      (this.max = T));
  }
  buildTicks() {
    const l = this.min,
      f = this.max,
      y = this.options.offset,
      T = [];
    let I = this.getLabels();
    ((I = l === 0 && f === I.length - 1 ? I : I.slice(l, f + 1)),
      (this._valueRange = Math.max(I.length - (y ? 0 : 1), 1)),
      (this._startValue = this.min - (y ? 0.5 : 0)));
    for (let P = l; P <= f; P++) T.push({ value: P });
    return T;
  }
  getLabelForValue(l) {
    return _T.call(this, l);
  }
  configure() {
    (super.configure(),
      this.isHorizontal() || (this._reversePixels = !this._reversePixels));
  }
  getPixelForValue(l) {
    return (
      typeof l != "number" && (l = this.parse(l)),
      l === null
        ? NaN
        : this.getPixelForDecimal((l - this._startValue) / this._valueRange)
    );
  }
  getPixelForTick(l) {
    const f = this.ticks;
    return l < 0 || l > f.length - 1 ? null : this.getPixelForValue(f[l].value);
  }
  getValueForPixel(l) {
    return Math.round(
      this._startValue + this.getDecimalForPixel(l) * this._valueRange,
    );
  }
  getBasePixel() {
    return this.bottom;
  }
}
(ln(kx, "id", "category"), ln(kx, "defaults", { ticks: { callback: _T } }));
function eR(m, l) {
  const f = [],
    {
      bounds: T,
      step: I,
      min: P,
      max: r,
      precision: F,
      count: B,
      maxTicks: q,
      maxDigits: ne,
      includeBounds: fe,
    } = m,
    de = I || 1,
    Ie = q - 1,
    { min: xe, max: we } = l,
    Ae = !Jn(P),
    Qe = !Jn(r),
    gt = !Jn(B),
    Rt = (we - xe) / (ne + 1);
  let Mt = ww((we - xe) / Ie / de) * de,
    pt,
    Re,
    rt,
    Ot;
  if (Mt < 1e-14 && !Ae && !Qe) return [{ value: xe }, { value: we }];
  ((Ot = Math.ceil(we / Mt) - Math.floor(xe / Mt)),
    Ot > Ie && (Mt = ww((Ot * Mt) / Ie / de) * de),
    Jn(F) || ((pt = Math.pow(10, F)), (Mt = Math.ceil(Mt * pt) / pt)),
    T === "ticks"
      ? ((Re = Math.floor(xe / Mt) * Mt), (rt = Math.ceil(we / Mt) * Mt))
      : ((Re = xe), (rt = we)),
    Ae && Qe && I && NM((r - P) / I, Mt / 1e3)
      ? ((Ot = Math.round(Math.min((r - P) / Mt, q))),
        (Mt = (r - P) / Ot),
        (Re = P),
        (rt = r))
      : gt
        ? ((Re = Ae ? P : Re),
          (rt = Qe ? r : rt),
          (Ot = B - 1),
          (Mt = (rt - Re) / Ot))
        : ((Ot = (rt - Re) / Mt),
          op(Ot, Math.round(Ot), Mt / 1e3)
            ? (Ot = Math.round(Ot))
            : (Ot = Math.ceil(Ot))));
  const _i = Math.max(Tw(Mt), Tw(Re));
  ((pt = Math.pow(10, Jn(F) ? _i : F)),
    (Re = Math.round(Re * pt) / pt),
    (rt = Math.round(rt * pt) / pt));
  let qt = 0;
  for (
    Ae &&
    (fe && Re !== P
      ? (f.push({ value: P }),
        Re < P && qt++,
        op(Math.round((Re + qt * Mt) * pt) / pt, P, yT(P, Rt, m)) && qt++)
      : Re < P && qt++);
    qt < Ot;
    ++qt
  ) {
    const pi = Math.round((Re + qt * Mt) * pt) / pt;
    if (Qe && pi > r) break;
    f.push({ value: pi });
  }
  return (
    Qe && fe && rt !== r
      ? f.length && op(f[f.length - 1].value, r, yT(r, Rt, m))
        ? (f[f.length - 1].value = r)
        : f.push({ value: r })
      : (!Qe || rt === r) && f.push({ value: rt }),
    f
  );
}
function yT(m, l, { horizontal: f, minRotation: y }) {
  const T = gh(y),
    I = (f ? Math.sin(T) : Math.cos(T)) || 0.001,
    P = 0.75 * l * ("" + m).length;
  return Math.min(l / I, P);
}
class tR extends Qu {
  constructor(l) {
    (super(l),
      (this.start = void 0),
      (this.end = void 0),
      (this._startValue = void 0),
      (this._endValue = void 0),
      (this._valueRange = 0));
  }
  parse(l, f) {
    return Jn(l) ||
      ((typeof l == "number" || l instanceof Number) && !isFinite(+l))
      ? null
      : +l;
  }
  handleTickRangeOptions() {
    const { beginAtZero: l } = this.options,
      { minDefined: f, maxDefined: y } = this.getUserBounds();
    let { min: T, max: I } = this;
    const P = (F) => (T = f ? T : F),
      r = (F) => (I = y ? I : F);
    if (l) {
      const F = Yu(T),
        B = Yu(I);
      F < 0 && B < 0 ? r(0) : F > 0 && B > 0 && P(0);
    }
    if (T === I) {
      let F = I === 0 ? 1 : Math.abs(I * 0.05);
      (r(I + F), l || P(T - F));
    }
    ((this.min = T), (this.max = I));
  }
  getTickLimit() {
    const l = this.options.ticks;
    let { maxTicksLimit: f, stepSize: y } = l,
      T;
    return (
      y
        ? ((T = Math.ceil(this.max / y) - Math.floor(this.min / y) + 1),
          T > 1e3 &&
            (console.warn(
              `scales.${this.id}.ticks.stepSize: ${y} would result generating up to ${T} ticks. Limiting to 1000.`,
            ),
            (T = 1e3)))
        : ((T = this.computeTickLimit()), (f = f || 11)),
      f && (T = Math.min(f, T)),
      T
    );
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const l = this.options,
      f = l.ticks;
    let y = this.getTickLimit();
    y = Math.max(2, y);
    const T = {
        maxTicks: y,
        bounds: l.bounds,
        min: l.min,
        max: l.max,
        precision: f.precision,
        step: f.stepSize,
        count: f.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: f.minRotation || 0,
        includeBounds: f.includeBounds !== !1,
      },
      I = this._range || this,
      P = eR(T, I);
    return (
      l.bounds === "ticks" && VM(P, this, "value"),
      l.reverse
        ? (P.reverse(), (this.start = this.max), (this.end = this.min))
        : ((this.start = this.min), (this.end = this.max)),
      P
    );
  }
  configure() {
    const l = this.ticks;
    let f = this.min,
      y = this.max;
    if ((super.configure(), this.options.offset && l.length)) {
      const T = (y - f) / Math.max(l.length - 1, 1) / 2;
      ((f -= T), (y += T));
    }
    ((this._startValue = f), (this._endValue = y), (this._valueRange = y - f));
  }
  getLabelForValue(l) {
    return t2(l, this.chart.options.locale, this.options.ticks.format);
  }
}
class Lx extends tR {
  determineDataLimits() {
    const { min: l, max: f } = this.getMinMax(!0);
    ((this.min = Ys(l) ? l : 0),
      (this.max = Ys(f) ? f : 1),
      this.handleTickRangeOptions());
  }
  computeTickLimit() {
    const l = this.isHorizontal(),
      f = l ? this.width : this.height,
      y = gh(this.options.ticks.minRotation),
      T = (l ? Math.sin(y) : Math.cos(y)) || 0.001,
      I = this._resolveTickFontOptions(0);
    return Math.ceil(f / Math.min(40, I.lineHeight / T));
  }
  getPixelForValue(l) {
    return l === null
      ? NaN
      : this.getPixelForDecimal((l - this._startValue) / this._valueRange);
  }
  getValueForPixel(l) {
    return this._startValue + this.getDecimalForPixel(l) * this._valueRange;
  }
}
(ln(Lx, "id", "linear"),
  ln(Lx, "defaults", { ticks: { callback: i2.formatters.numeric } }));
const i_ = {
    millisecond: { common: !0, size: 1, steps: 1e3 },
    second: { common: !0, size: 1e3, steps: 60 },
    minute: { common: !0, size: 6e4, steps: 60 },
    hour: { common: !0, size: 36e5, steps: 24 },
    day: { common: !0, size: 864e5, steps: 30 },
    week: { common: !1, size: 6048e5, steps: 4 },
    month: { common: !0, size: 2628e6, steps: 12 },
    quarter: { common: !1, size: 7884e6, steps: 4 },
    year: { common: !0, size: 3154e7 },
  },
  Es = Object.keys(i_);
function xT(m, l) {
  return m - l;
}
function vT(m, l) {
  if (Jn(l)) return null;
  const f = m._adapter,
    { parser: y, round: T, isoWeekday: I } = m._parseOpts;
  let P = l;
  return (
    typeof y == "function" && (P = y(P)),
    Ys(P) || (P = typeof y == "string" ? f.parse(P, y) : f.parse(P)),
    P === null
      ? null
      : (T &&
          (P =
            T === "week" && (mp(I) || I === !0)
              ? f.startOf(P, "isoWeek", I)
              : f.startOf(P, T)),
        +P)
  );
}
function bT(m, l, f, y) {
  const T = Es.length;
  for (let I = Es.indexOf(m); I < T - 1; ++I) {
    const P = i_[Es[I]],
      r = P.steps ? P.steps : Number.MAX_SAFE_INTEGER;
    if (P.common && Math.ceil((f - l) / (r * P.size)) <= y) return Es[I];
  }
  return Es[T - 1];
}
function iR(m, l, f, y, T) {
  for (let I = Es.length - 1; I >= Es.indexOf(f); I--) {
    const P = Es[I];
    if (i_[P].common && m._adapter.diff(T, y, P) >= l - 1) return P;
  }
  return Es[f ? Es.indexOf(f) : 0];
}
function nR(m) {
  for (let l = Es.indexOf(m) + 1, f = Es.length; l < f; ++l)
    if (i_[Es[l]].common) return Es[l];
}
function wT(m, l, f) {
  if (!f) m[l] = !0;
  else if (f.length) {
    const { lo: y, hi: T } = qx(f, l),
      I = f[y] >= l ? f[y] : f[T];
    m[I] = !0;
  }
}
function rR(m, l, f, y) {
  const T = m._adapter,
    I = +T.startOf(l[0].value, y),
    P = l[l.length - 1].value;
  let r, F;
  for (r = I; r <= P; r = +T.add(r, 1, y))
    ((F = f[r]), F >= 0 && (l[F].major = !0));
  return l;
}
function TT(m, l, f) {
  const y = [],
    T = {},
    I = l.length;
  let P, r;
  for (P = 0; P < I; ++P)
    ((r = l[P]), (T[r] = P), y.push({ value: r, major: !1 }));
  return I === 0 || !f ? y : rR(m, y, T, f);
}
class Xg extends Qu {
  constructor(l) {
    (super(l),
      (this._cache = { data: [], labels: [], all: [] }),
      (this._unit = "day"),
      (this._majorUnit = void 0),
      (this._offsets = {}),
      (this._normalized = !1),
      (this._parseOpts = void 0));
  }
  init(l, f = {}) {
    const y = l.time || (l.time = {}),
      T = (this._adapter = new _P._date(l.adapters.date));
    (T.init(f),
      sp(y.displayFormats, T.formats()),
      (this._parseOpts = {
        parser: y.parser,
        round: y.round,
        isoWeekday: y.isoWeekday,
      }),
      super.init(l),
      (this._normalized = f.normalized));
  }
  parse(l, f) {
    return l === void 0 ? null : vT(this, l);
  }
  beforeLayout() {
    (super.beforeLayout(), (this._cache = { data: [], labels: [], all: [] }));
  }
  determineDataLimits() {
    const l = this.options,
      f = this._adapter,
      y = l.time.unit || "day";
    let { min: T, max: I, minDefined: P, maxDefined: r } = this.getUserBounds();
    function F(B) {
      (!P && !isNaN(B.min) && (T = Math.min(T, B.min)),
        !r && !isNaN(B.max) && (I = Math.max(I, B.max)));
    }
    ((!P || !r) &&
      (F(this._getLabelBounds()),
      (l.bounds !== "ticks" || l.ticks.source !== "labels") &&
        F(this.getMinMax(!1))),
      (T = Ys(T) && !isNaN(T) ? T : +f.startOf(Date.now(), y)),
      (I = Ys(I) && !isNaN(I) ? I : +f.endOf(Date.now(), y) + 1),
      (this.min = Math.min(T, I - 1)),
      (this.max = Math.max(T + 1, I)));
  }
  _getLabelBounds() {
    const l = this.getLabelTimestamps();
    let f = Number.POSITIVE_INFINITY,
      y = Number.NEGATIVE_INFINITY;
    return (
      l.length && ((f = l[0]), (y = l[l.length - 1])),
      { min: f, max: y }
    );
  }
  buildTicks() {
    const l = this.options,
      f = l.time,
      y = l.ticks,
      T = y.source === "labels" ? this.getLabelTimestamps() : this._generate();
    l.bounds === "ticks" &&
      T.length &&
      ((this.min = this._userMin || T[0]),
      (this.max = this._userMax || T[T.length - 1]));
    const I = this.min,
      P = this.max,
      r = WM(T, I, P);
    return (
      (this._unit =
        f.unit ||
        (y.autoSkip
          ? bT(f.minUnit, this.min, this.max, this._getLabelCapacity(I))
          : iR(this, r.length, f.minUnit, this.min, this.max))),
      (this._majorUnit =
        !y.major.enabled || this._unit === "year" ? void 0 : nR(this._unit)),
      this.initOffsets(T),
      l.reverse && r.reverse(),
      TT(this, r, this._majorUnit)
    );
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip &&
      this.initOffsets(this.ticks.map((l) => +l.value));
  }
  initOffsets(l = []) {
    let f = 0,
      y = 0,
      T,
      I;
    this.options.offset &&
      l.length &&
      ((T = this.getDecimalForValue(l[0])),
      l.length === 1
        ? (f = 1 - T)
        : (f = (this.getDecimalForValue(l[1]) - T) / 2),
      (I = this.getDecimalForValue(l[l.length - 1])),
      l.length === 1
        ? (y = I)
        : (y = (I - this.getDecimalForValue(l[l.length - 2])) / 2));
    const P = l.length < 3 ? 0.5 : 0.25;
    ((f = qs(f, 0, P)),
      (y = qs(y, 0, P)),
      (this._offsets = { start: f, end: y, factor: 1 / (f + 1 + y) }));
  }
  _generate() {
    const l = this._adapter,
      f = this.min,
      y = this.max,
      T = this.options,
      I = T.time,
      P = I.unit || bT(I.minUnit, f, y, this._getLabelCapacity(f)),
      r = Dn(T.ticks.stepSize, 1),
      F = P === "week" ? I.isoWeekday : !1,
      B = mp(F) || F === !0,
      q = {};
    let ne = f,
      fe,
      de;
    if (
      (B && (ne = +l.startOf(ne, "isoWeek", F)),
      (ne = +l.startOf(ne, B ? "day" : P)),
      l.diff(y, f, P) > 1e5 * r)
    )
      throw new Error(
        f + " and " + y + " are too far apart with stepSize of " + r + " " + P,
      );
    const Ie = T.ticks.source === "data" && this.getDataTimestamps();
    for (fe = ne, de = 0; fe < y; fe = +l.add(fe, r, P), de++) wT(q, fe, Ie);
    return (
      (fe === y || T.bounds === "ticks" || de === 1) && wT(q, fe, Ie),
      Object.keys(q)
        .sort(xT)
        .map((xe) => +xe)
    );
  }
  getLabelForValue(l) {
    const f = this._adapter,
      y = this.options.time;
    return y.tooltipFormat
      ? f.format(l, y.tooltipFormat)
      : f.format(l, y.displayFormats.datetime);
  }
  format(l, f) {
    const T = this.options.time.displayFormats,
      I = this._unit,
      P = f || T[I];
    return this._adapter.format(l, P);
  }
  _tickFormatFunction(l, f, y, T) {
    const I = this.options,
      P = I.ticks.callback;
    if (P) return er(P, [l, f, y], this);
    const r = I.time.displayFormats,
      F = this._unit,
      B = this._majorUnit,
      q = F && r[F],
      ne = B && r[B],
      fe = y[f],
      de = B && ne && fe && fe.major;
    return this._adapter.format(l, T || (de ? ne : q));
  }
  generateTickLabels(l) {
    let f, y, T;
    for (f = 0, y = l.length; f < y; ++f)
      ((T = l[f]), (T.label = this._tickFormatFunction(T.value, f, l)));
  }
  getDecimalForValue(l) {
    return l === null ? NaN : (l - this.min) / (this.max - this.min);
  }
  getPixelForValue(l) {
    const f = this._offsets,
      y = this.getDecimalForValue(l);
    return this.getPixelForDecimal((f.start + y) * f.factor);
  }
  getValueForPixel(l) {
    const f = this._offsets,
      y = this.getDecimalForPixel(l) / f.factor - f.end;
    return this.min + y * (this.max - this.min);
  }
  _getLabelSize(l) {
    const f = this.options.ticks,
      y = this.ctx.measureText(l).width,
      T = gh(this.isHorizontal() ? f.maxRotation : f.minRotation),
      I = Math.cos(T),
      P = Math.sin(T),
      r = this._resolveTickFontOptions(0).size;
    return { w: y * I + r * P, h: y * P + r * I };
  }
  _getLabelCapacity(l) {
    const f = this.options.time,
      y = f.displayFormats,
      T = y[f.unit] || y.millisecond,
      I = this._tickFormatFunction(l, 0, TT(this, [l], this._majorUnit), T),
      P = this._getLabelSize(I),
      r =
        Math.floor(this.isHorizontal() ? this.width / P.w : this.height / P.h) -
        1;
    return r > 0 ? r : 1;
  }
  getDataTimestamps() {
    let l = this._cache.data || [],
      f,
      y;
    if (l.length) return l;
    const T = this.getMatchingVisibleMetas();
    if (this._normalized && T.length)
      return (this._cache.data = T[0].controller.getAllParsedValues(this));
    for (f = 0, y = T.length; f < y; ++f)
      l = l.concat(T[f].controller.getAllParsedValues(this));
    return (this._cache.data = this.normalize(l));
  }
  getLabelTimestamps() {
    const l = this._cache.labels || [];
    let f, y;
    if (l.length) return l;
    const T = this.getLabels();
    for (f = 0, y = T.length; f < y; ++f) l.push(vT(this, T[f]));
    return (this._cache.labels = this._normalized ? l : this.normalize(l));
  }
  normalize(l) {
    return ZM(l.sort(xT));
  }
}
(ln(Xg, "id", "time"),
  ln(Xg, "defaults", {
    bounds: "data",
    adapters: {},
    time: {
      parser: !1,
      unit: !1,
      round: !1,
      isoWeekday: !1,
      minUnit: "millisecond",
      displayFormats: {},
    },
    ticks: { source: "auto", callback: !1, major: { enabled: !1 } },
  }));
function zg(m, l, f) {
  let y = 0,
    T = m.length - 1,
    I,
    P,
    r,
    F;
  f
    ? (l >= m[y].pos && l <= m[T].pos && ({ lo: y, hi: T } = _h(m, "pos", l)),
      ({ pos: I, time: r } = m[y]),
      ({ pos: P, time: F } = m[T]))
    : (l >= m[y].time &&
        l <= m[T].time &&
        ({ lo: y, hi: T } = _h(m, "time", l)),
      ({ time: I, pos: r } = m[y]),
      ({ time: P, pos: F } = m[T]));
  const B = P - I;
  return B ? r + ((F - r) * (l - I)) / B : r;
}
class ST extends Xg {
  constructor(l) {
    (super(l),
      (this._table = []),
      (this._minPos = void 0),
      (this._tableRange = void 0));
  }
  initOffsets() {
    const l = this._getTimestampsForTable(),
      f = (this._table = this.buildLookupTable(l));
    ((this._minPos = zg(f, this.min)),
      (this._tableRange = zg(f, this.max) - this._minPos),
      super.initOffsets(l));
  }
  buildLookupTable(l) {
    const { min: f, max: y } = this,
      T = [],
      I = [];
    let P, r, F, B, q;
    for (P = 0, r = l.length; P < r; ++P)
      ((B = l[P]), B >= f && B <= y && T.push(B));
    if (T.length < 2)
      return [
        { time: f, pos: 0 },
        { time: y, pos: 1 },
      ];
    for (P = 0, r = T.length; P < r; ++P)
      ((q = T[P + 1]),
        (F = T[P - 1]),
        (B = T[P]),
        Math.round((q + F) / 2) !== B && I.push({ time: B, pos: P / (r - 1) }));
    return I;
  }
  _generate() {
    const l = this.min,
      f = this.max;
    let y = super.getDataTimestamps();
    return (
      (!y.includes(l) || !y.length) && y.splice(0, 0, l),
      (!y.includes(f) || y.length === 1) && y.push(f),
      y.sort((T, I) => T - I)
    );
  }
  _getTimestampsForTable() {
    let l = this._cache.all || [];
    if (l.length) return l;
    const f = this.getDataTimestamps(),
      y = this.getLabelTimestamps();
    return (
      f.length && y.length
        ? (l = this.normalize(f.concat(y)))
        : (l = f.length ? f : y),
      (l = this._cache.all = l),
      l
    );
  }
  getDecimalForValue(l) {
    return (zg(this._table, l) - this._minPos) / this._tableRange;
  }
  getValueForPixel(l) {
    const f = this._offsets,
      y = this.getDecimalForPixel(l) / f.factor - f.end;
    return zg(this._table, y * this._tableRange + this._minPos, !0);
  }
}
(ln(ST, "id", "timeseries"), ln(ST, "defaults", Xg.defaults));
const C2 = {
    data: { type: Object, required: !0 },
    options: { type: Object, default: () => ({}) },
    plugins: { type: Array, default: () => [] },
    datasetIdKey: { type: String, default: "label" },
    updateMode: { type: String, default: void 0 },
  },
  sR = { ariaLabel: { type: String }, ariaDescribedby: { type: String } },
  oR = {
    type: { type: String, required: !0 },
    destroyDelay: { type: Number, default: 0 },
    ...C2,
    ...sR,
  },
  aR =
    bA[0] === "2"
      ? (m, l) => Object.assign(m, { attrs: l })
      : (m, l) => Object.assign(m, l);
function Hu(m) {
  return NT(m) ? Tx(m) : m;
}
function lR(m) {
  let l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : m;
  return NT(l) ? new Proxy(m, {}) : m;
}
function cR(m, l) {
  const f = m.options;
  f && l && Object.assign(f, l);
}
function P2(m, l) {
  m.labels = l;
}
function D2(m, l, f) {
  const y = [];
  m.datasets = l.map((T) => {
    const I = m.datasets.find((P) => P[f] === T[f]);
    return !I || !T.data || y.includes(I)
      ? { ...T }
      : (y.push(I), Object.assign(I, T), I);
  });
}
function hR(m, l) {
  const f = { labels: [], datasets: [] };
  return (P2(f, m.labels), D2(f, m.datasets, l), f);
}
const uR = aa({
  props: oR,
  setup(m, l) {
    let { expose: f, slots: y } = l;
    const T = $n(null),
      I = Fx(null);
    f({ chart: I });
    const P = () => {
        if (!T.value) return;
        const {
            type: B,
            data: q,
            options: ne,
            plugins: fe,
            datasetIdKey: de,
          } = m,
          Ie = hR(q, de),
          xe = lR(Ie, q);
        I.value = new t_(T.value, {
          type: B,
          data: xe,
          options: { ...ne },
          plugins: fe,
        });
      },
      r = () => {
        const B = Tx(I.value);
        B &&
          (m.destroyDelay > 0
            ? setTimeout(() => {
                (B.destroy(), (I.value = null));
              }, m.destroyDelay)
            : (B.destroy(), (I.value = null)));
      },
      F = (B) => {
        B.update(m.updateMode);
      };
    return (
      bh(P),
      BT(r),
      Yl(
        [() => m.options, () => m.data],
        (B, q) => {
          let [ne, fe] = B,
            [de, Ie] = q;
          const xe = Tx(I.value);
          if (!xe) return;
          let we = !1;
          if (ne) {
            const Ae = Hu(ne),
              Qe = Hu(de);
            Ae && Ae !== Qe && (cR(xe, Ae), (we = !0));
          }
          if (fe) {
            const Ae = Hu(fe.labels),
              Qe = Hu(Ie.labels),
              gt = Hu(fe.datasets),
              Rt = Hu(Ie.datasets);
            (Ae !== Qe && (P2(xe.config.data, Ae), (we = !0)),
              gt &&
                gt !== Rt &&
                (D2(xe.config.data, gt, m.datasetIdKey), (we = !0)));
          }
          we &&
            Sx(() => {
              F(xe);
            });
        },
        { deep: !0 },
      ),
      () =>
        dp(
          "canvas",
          {
            role: "img",
            ariaLabel: m.ariaLabel,
            ariaDescribedby: m.ariaDescribedby,
            ref: T,
          },
          [dp("p", {}, [y.default ? y.default() : ""])],
        )
    );
  },
});
function dR(m, l) {
  return (
    t_.register(l),
    aa({
      props: C2,
      setup(f, y) {
        let { expose: T } = y;
        const I = Fx(null),
          P = (r) => {
            I.value = r == null ? void 0 : r.chart;
          };
        return (
          T({ chart: I }),
          () => dp(uR, aR({ ref: P }, { type: m, ...f }))
        );
      },
    })
  );
}
const fR = dR("line", Bg),
  pR = { class: "mt-4" },
  mR = { class: "text-2xl font-semibold mb-2" },
  gR = { class: "mb-2" },
  _R = aa({
    __name: "AlertsChart",
    props: { alertsStatistics: {}, calculateHectares: { type: Boolean } },
    setup(m) {
      t_.register(jD, YD, VD, tp, Ug, kx, Lx);
      const { t: l } = wA(),
        f = m,
        y = us(() => {
          const T = f.calculateHectares,
            I = f.alertsStatistics.hectaresPerMonth !== null,
            P =
              T && I
                ? f.alertsStatistics.hectaresPerMonth
                : f.alertsStatistics.alertsPerMonth,
            r = l(T && I ? "hectaresPerMonth" : "numberOfAlerts");
          return {
            labels: Object.keys(P),
            datasets: [
              {
                backgroundColor: "rgba(0, 0, 0, 0)",
                borderColor: "#f87979",
                data: Object.values(P),
                fill: !1,
                label: r,
                pointBackgroundColor: "#f87979",
              },
            ],
          };
        });
      return (T, I) => (
        Xi(),
        pn("div", pR, [
          ci("h3", mR, An(T.$t("alertsLast12Months")), 1),
          ci("div", gR, [Lt(sr(fR), { data: sr(y) }, null, 8, ["data"])]),
        ])
      );
    },
  }),
  yR = { class: "space-y-4" },
  xR = { class: "rounded-lg border bg-card text-card-foreground shadow-sm" },
  vR = { class: "p-6 space-y-4" },
  bR = ["src"],
  wR = {
    key: 1,
    src: "https://placehold.co/200x100/cccccc/666666?text=Logo",
    alt: "Logo placeholder",
    class: "w-auto mx-auto mb-4 max-h-25",
  },
  TR = { class: "text-2xl font-semibold tracking-tight" },
  SR = { key: 0, class: "text-muted-foreground" },
  ER = { class: "space-y-2 text-sm text-muted-foreground" },
  IR = { class: "italic" },
  AR = { class: "text-red-500 font-medium" },
  MR = { class: "text-orange-500 font-medium" },
  CR = { class: "italic inline-flex items-center whitespace-nowrap" },
  PR = ["src"],
  DR = {
    key: 1,
    src: "https://placehold.co/16x16/ff0000/ffffff?text=!",
    alt: "Warning icon placeholder",
    class: "w-4 h-4 inline-block -mt-0.5 ml-0.5",
  },
  RR = { class: "italic" },
  zR = { class: "space-y-2" },
  kR = { key: 0, class: "flex items-center gap-2" },
  LR = { class: "font-medium text-sm" },
  OR = { class: "text-sm text-muted-foreground" },
  FR = { key: 1, class: "flex items-center gap-2" },
  BR = { class: "font-medium text-sm" },
  NR = { class: "text-sm text-muted-foreground" },
  VR = { class: "flex items-center gap-2" },
  UR = { class: "font-medium text-sm" },
  jR = { class: "text-sm text-muted-foreground" },
  GR = { class: "flex items-center gap-2" },
  $R = { class: "font-medium text-sm" },
  HR = { class: "text-sm text-muted-foreground" },
  WR = { class: "flex items-center gap-2" },
  qR = { class: "font-medium text-sm" },
  ZR = { class: "text-sm text-muted-foreground" },
  XR = { class: "flex items-center gap-2" },
  YR = { class: "font-medium text-sm" },
  KR = { class: "text-sm text-muted-foreground" },
  JR = { key: 2, class: "flex items-center gap-2" },
  QR = { class: "font-medium text-sm" },
  ez = { class: "text-sm text-muted-foreground" },
  tz = {
    key: 0,
    class: "rounded-lg border bg-card text-card-foreground shadow-sm",
  },
  iz = { class: "p-6" },
  nz = { key: 0, class: "mt-4" },
  rz = {
    key: 1,
    class: "rounded-lg border bg-card text-card-foreground shadow-sm",
  },
  sz = { class: "p-6" },
  oz = aa({
    __name: "AlertsIntroPanel",
    props: {
      alertsStatistics: {},
      calculateHectares: { type: Boolean },
      dateOptions: {},
      dataForAlertsIntroPanel: {},
      logoUrl: {},
      showSlider: { type: Boolean },
    },
    emits: ["dateRangeChanged"],
    setup(m, { emit: l }) {
      const f = m,
        y = l;
      return (T, I) => {
        var B, q;
        const P = UT,
          r = sM,
          F = _R;
        return (
          Xi(),
          pn("div", yR, [
            ci("div", xR, [
              ci("div", vR, [
                f.logoUrl
                  ? (Xi(),
                    rp(
                      P,
                      {
                        key: 0,
                        src: f.logoUrl,
                        class: "w-auto mx-auto mb-4 max-h-25",
                        alt: "Logo",
                        preset: "logo",
                        loading: "eager",
                        custom: !0,
                      },
                      {
                        default: mh(
                          ({ src: ne, isLoaded: fe, imgAttrs: de }) => [
                            fe
                              ? (Xi(),
                                pn(
                                  "img",
                                  Ws({ key: 0 }, de, {
                                    src: ne,
                                    class: "w-auto mx-auto mb-4 max-h-25",
                                  }),
                                  null,
                                  16,
                                  bR,
                                ))
                              : (Xi(), pn("img", wR)),
                          ],
                        ),
                        _: 1,
                      },
                      8,
                      ["src"],
                    ))
                  : Fr("", !0),
                ci("h2", TR, [
                  na(An(T.$t("changeDetectionAlerts")), 1),
                  f.alertsStatistics.territory
                    ? (Xi(),
                      pn(
                        "span",
                        SR,
                        ": " + An(f.alertsStatistics.territory),
                        1,
                      ))
                    : Fr("", !0),
                ]),
                ci("div", ER, [
                  ci("p", IR, [
                    na(An(T.$t("mostRecentAlertsShownIn")) + " ", 1),
                    ci("span", AR, An(T.$t("red")), 1),
                    na(", " + An(T.$t("andPreviousAlertsShownIn")) + " ", 1),
                    ci("span", MR, An(T.$t("orange")), 1),
                    I[1] || (I[1] = na(". ")),
                  ]),
                  ci("p", CR, [
                    na(
                      An(T.$t("ifYouAreZoomedOutAlertsWillBeShownAsA")) + " ",
                      1,
                    ),
                    Lt(
                      P,
                      {
                        src: "@/assets/icons/warning_red.png",
                        alt: "Warning icon",
                        class: "w-4 h-4 inline-block -mt-0.5 ml-0.5",
                        preset: "icon",
                        loading: "eager",
                        custom: !0,
                      },
                      {
                        default: mh(
                          ({ src: ne, isLoaded: fe, imgAttrs: de }) => [
                            fe
                              ? (Xi(),
                                pn(
                                  "img",
                                  Ws({ key: 0 }, de, {
                                    src: ne,
                                    class:
                                      "w-4 h-4 inline-block -mt-0.5 ml-0.5",
                                  }),
                                  null,
                                  16,
                                  PR,
                                ))
                              : (Xi(), pn("img", DR)),
                          ],
                        ),
                        _: 1,
                      },
                    ),
                    I[2] || (I[2] = na(". ")),
                  ]),
                  ci("p", RR, An(T.$t("clickOnAlertsForMoreInfo")) + ".", 1),
                ]),
                ci("div", zR, [
                  (B = f.alertsStatistics.typeOfAlerts) != null && B.length
                    ? (Xi(),
                      pn("div", kR, [
                        ci("span", LR, An(T.$t("typeOfAlerts")) + ":", 1),
                        ci(
                          "span",
                          OR,
                          An(f.alertsStatistics.typeOfAlerts.join(", ")),
                          1,
                        ),
                      ]))
                    : Fr("", !0),
                  (q = f.alertsStatistics.dataProviders) != null && q.length
                    ? (Xi(),
                      pn("div", FR, [
                        ci("span", BR, An(T.$t("dataProviders")) + ":", 1),
                        ci(
                          "span",
                          NR,
                          An(f.alertsStatistics.dataProviders.join(", ")),
                          1,
                        ),
                      ]))
                    : Fr("", !0),
                  ci("div", VR, [
                    ci("span", UR, An(T.$t("alertDetectionRange")) + ":", 1),
                    ci(
                      "span",
                      jR,
                      An(f.alertsStatistics.alertDetectionRange),
                      1,
                    ),
                  ]),
                  ci("div", GR, [
                    ci("span", $R, An(T.$t("recentAlertsDate")) + ":", 1),
                    ci("span", HR, An(f.alertsStatistics.recentAlertsDate), 1),
                  ]),
                  ci("div", WR, [
                    ci("span", qR, An(T.$t("recentAlertsNumber")) + ":", 1),
                    ci(
                      "span",
                      ZR,
                      An(f.alertsStatistics.recentAlertsNumber),
                      1,
                    ),
                  ]),
                  ci("div", XR, [
                    ci("span", YR, An(T.$t("alertsTotal")) + ":", 1),
                    ci("span", KR, An(f.alertsStatistics.alertsTotal), 1),
                  ]),
                  f.calculateHectares && f.alertsStatistics.hectaresTotal
                    ? (Xi(),
                      pn("div", JR, [
                        ci("span", QR, An(T.$t("hectaresTotal")) + ":", 1),
                        ci("span", ez, An(f.alertsStatistics.hectaresTotal), 1),
                      ]))
                    : Fr("", !0),
                ]),
              ]),
            ]),
            f.showSlider
              ? (Xi(),
                pn("div", tz, [
                  ci("div", iz, [
                    Lt(
                      r,
                      {
                        "date-options": f.dateOptions,
                        onDateRangeChanged:
                          I[0] || (I[0] = (ne) => y("dateRangeChanged", ne)),
                      },
                      null,
                      8,
                      ["date-options"],
                    ),
                    f.dataForAlertsIntroPanel
                      ? (Xi(),
                        pn("div", nz, [
                          Lt(
                            GT,
                            { "data-for-download": f.dataForAlertsIntroPanel },
                            null,
                            8,
                            ["data-for-download"],
                          ),
                        ]))
                      : Fr("", !0),
                  ]),
                ]))
              : Fr("", !0),
            f.alertsStatistics
              ? (Xi(),
                pn("div", rz, [
                  ci("div", sz, [
                    Lt(
                      F,
                      {
                        "alerts-statistics": f.alertsStatistics,
                        "calculate-hectares": f.calculateHectares,
                      },
                      null,
                      8,
                      ["alerts-statistics", "calculate-hectares"],
                    ),
                  ]),
                ]))
              : Fr("", !0),
          ])
        );
      };
    },
  }),
  az = { class: "relative h-full" },
  lz = { key: 0, class: "scroll-indicator" },
  cz = { class: "p-4 sidebar-content" },
  hz = aa({
    __name: "ViewSidebar",
    props: {
      alertsStatistics: {},
      allowedFileExtensions: {},
      calculateHectares: { type: Boolean },
      dateOptions: {},
      downloadAlert: { type: Boolean },
      feature: {},
      filePaths: {},
      isAlert: { type: Boolean },
      isMapeo: { type: Boolean },
      isAlertsDashboard: { type: Boolean },
      localAlertsData: {},
      logoUrl: {},
      mediaBasePath: {},
      mediaBasePathAlerts: {},
      showIntroPanel: { type: Boolean },
      showSidebar: { type: Boolean },
      showSlider: { type: Boolean },
    },
    emits: ["close", "date-range-changed", "update:showSidebar"],
    setup(m, { emit: l }) {
      const f = m,
        y = $n(!1),
        T = us(() => {
          if (!f.feature) return {};
          const { latitude: F, longitude: B, ...q } = f.feature;
          return q;
        }),
        I = us(() => {
          if (f.localAlertsData && "mostRecentAlerts" in f.localAlertsData)
            return f.localAlertsData;
        }),
        P = l,
        r = () => {
          const F = document.querySelector(".sidebar");
          F && (y.value = F.scrollHeight > F.offsetHeight);
        };
      return (
        Yl(
          () => f.feature,
          () => {
            Sx(() => {
              r();
            });
          },
        ),
        Yl(
          () => f.showSidebar,
          (F) => {
            F &&
              Sx(() => {
                r();
              });
          },
        ),
        bh(() => {
          (r(), window.addEventListener("resize", r));
        }),
        TA(() => {
          window.removeEventListener("resize", r);
        }),
        (F, B) => (
          Xi(),
          pn(
            "div",
            {
              class: ra([
                "fixed top-0 left-0 h-full w-[400px] bg-white shadow-lg transform transition-transform duration-300 ease-in-out overflow-y-auto z-50 sidebar",
                {
                  "translate-x-0": F.showSidebar,
                  "-translate-x-full": !F.showSidebar,
                },
              ]),
            },
            [
              ci("div", az, [
                sr(y)
                  ? (Xi(),
                    pn("div", lz, [
                      Lt(sr(zA), {
                        class: "w-6 h-6 text-gray-600 animate-bounce",
                      }),
                    ]))
                  : Fr("", !0),
                ci(
                  "button",
                  {
                    class:
                      "absolute top-4 right-4 p-2.5 bg-white/80 backdrop-blur-sm hover:bg-gray-100 rounded-full transition-all duration-200 ease-in-out shadow-sm hover:shadow-md active:scale-95 focus:outline-none focus:ring-2 focus:ring-gray-200 focus:ring-offset-2",
                    onClick: B[0] || (B[0] = (q) => P("close")),
                  },
                  [
                    B[2] ||
                      (B[2] = ci("span", { class: "sr-only" }, "Close", -1)),
                    Lt(sr(kA), { class: "w-5 h-5 text-gray-600" }),
                  ],
                ),
                ci("div", cz, [
                  F.showIntroPanel && F.alertsStatistics
                    ? (Xi(),
                      rp(
                        oz,
                        {
                          key: 0,
                          "calculate-hectares": F.calculateHectares,
                          "date-options": F.dateOptions,
                          "data-for-alerts-intro-panel": sr(I),
                          "logo-url": F.logoUrl,
                          "show-slider": F.showSlider,
                          "alerts-statistics": F.alertsStatistics,
                          onDateRangeChanged:
                            B[1] || (B[1] = (q) => P("date-range-changed", q)),
                        },
                        null,
                        8,
                        [
                          "calculate-hectares",
                          "date-options",
                          "data-for-alerts-intro-panel",
                          "logo-url",
                          "show-slider",
                          "alerts-statistics",
                        ],
                      ))
                    : Fr("", !0),
                  F.feature
                    ? (Xi(),
                      rp(
                        CA,
                        {
                          key: 1,
                          "allowed-file-extensions": F.allowedFileExtensions,
                          feature: sr(T),
                          "file-paths": F.filePaths,
                          "is-alert": F.isAlert,
                          "is-mapeo": F.isMapeo,
                          "is-alerts-dashboard": F.isAlertsDashboard,
                          "media-base-path": F.mediaBasePath,
                          "media-base-path-alerts": F.mediaBasePathAlerts,
                        },
                        null,
                        8,
                        [
                          "allowed-file-extensions",
                          "feature",
                          "file-paths",
                          "is-alert",
                          "is-mapeo",
                          "is-alerts-dashboard",
                          "media-base-path",
                          "media-base-path-alerts",
                        ],
                      ))
                    : Fr("", !0),
                  F.downloadAlert
                    ? (Xi(),
                      rp(
                        GT,
                        { key: 2, "data-for-download": F.localAlertsData },
                        null,
                        8,
                        ["data-for-download"],
                      ))
                    : Fr("", !0),
                ]),
              ]),
            ],
            2,
          )
        )
      );
    },
  }),
  uL = Bx(hz, [["__scopeId", "data-v-e79ec3f4"]]),
  uz = { class: "map-legend feature p-4 rounded-lg shadow-lg" },
  dz = { class: "text-2xl font-semibold mb-2" },
  fz = ["id", "onUpdate:modelValue", "checked", "onChange"],
  pz = ["for"],
  mz = aa({
    __name: "MapLegend",
    props: { mapLegendContent: {} },
    emits: ["toggle-layer-visibility"],
    setup(m, { emit: l }) {
      const f = m,
        y = l,
        T = $n();
      bh(() => {
        T.value = f.mapLegendContent.map((r) => ({ ...r, visible: !0 }));
      });
      const I = (r) => {
          y("toggle-layer-visibility", r);
        },
        P = (r) => `${r.type}-box`;
      return (
        Yl(
          () => f.mapLegendContent,
          (r) => {
            T.value = r.map((F) => ({ ...F, visible: !0 }));
          },
        ),
        (r, F) => (
          Xi(),
          pn("div", uz, [
            ci("h2", dz, An(r.$t("mapLegend")), 1),
            (Xi(!0),
            pn(
              Yf,
              null,
              Og(
                sr(T),
                (B) => (
                  Xi(),
                  pn("div", { key: B.id, class: "legend-item" }, [
                    Kf(
                      ci(
                        "input",
                        {
                          id: B.id,
                          "onUpdate:modelValue": (q) => (B.visible = q),
                          class: "mr-2",
                          type: "checkbox",
                          checked: B.visible,
                          onChange: (q) => I(B),
                        },
                        null,
                        40,
                        fz,
                      ),
                      [[SA, B.visible]],
                    ),
                    ci(
                      "label",
                      { for: B.id },
                      [
                        ci(
                          "div",
                          {
                            class: ra(["color-box", P(B)]),
                            style: sa({ backgroundColor: B.color }),
                          },
                          null,
                          6,
                        ),
                        ci(
                          "span",
                          null,
                          An(
                            B.name === "Mapeo data"
                              ? r.$t("mapeoData")
                              : B.name === "Most recent alerts"
                                ? r.$t("mostRecentAlerts")
                                : B.name === "Previous alerts"
                                  ? r.$t("previousAlerts")
                                  : B.name,
                          ),
                          1,
                        ),
                      ],
                      8,
                      pz,
                    ),
                  ])
                ),
              ),
              128,
            )),
          ])
        )
      );
    },
  }),
  dL = Bx(mz, [["__scopeId", "data-v-17be5996"]]);
function R2(m) {
  return (
    m instanceof Date || Object.prototype.toString.call(m) === "[object Date]"
  );
}
function n_(m) {
  return R2(m)
    ? new Date(m.getTime())
    : m == null
      ? new Date(NaN)
      : new Date(m);
}
function gz(m) {
  return R2(m) && !isNaN(m.getTime());
}
function z2(m) {
  var l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!(l >= 0 && l <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6");
  var f = n_(m),
    y = f.getDay(),
    T = (y + 7 - l) % 7;
  return (f.setDate(f.getDate() - T), f.setHours(0, 0, 0, 0), f);
}
function k2(m) {
  var l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    f = l.firstDayOfWeek,
    y = f === void 0 ? 0 : f,
    T = l.firstWeekContainsDate,
    I = T === void 0 ? 1 : T;
  if (!(I >= 1 && I <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7");
  for (
    var P = n_(m), r = P.getFullYear(), F = new Date(0), B = r + 1;
    B >= r - 1 &&
    (F.setFullYear(B, 0, I),
    F.setHours(0, 0, 0, 0),
    (F = z2(F, y)),
    !(P.getTime() >= F.getTime()));
    B--
  );
  return F;
}
function rv(m) {
  var l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    f = l.firstDayOfWeek,
    y = f === void 0 ? 0 : f,
    T = l.firstWeekContainsDate,
    I = T === void 0 ? 1 : T,
    P = n_(m),
    r = z2(P, y),
    F = k2(P, { firstDayOfWeek: y, firstWeekContainsDate: I }),
    B = r.getTime() - F.getTime();
  return Math.round(B / (7 * 24 * 3600 * 1e3)) + 1;
}
var sv = {
    months: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December",
    ],
    monthsShort: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
    ],
    weekdays: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
    ],
    weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    weekdaysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    firstDayOfWeek: 0,
    firstWeekContainsDate: 1,
  },
  _z =
    /\[([^\]]+)]|YYYY|YY?|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|Z{1,2}|S{1,3}|w{1,2}|x|X|a|A/g;
function Os(m) {
  for (
    var l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2,
      f = "".concat(Math.abs(m)),
      y = m < 0 ? "-" : "";
    f.length < l;

  )
    f = "0".concat(f);
  return y + f;
}
function ET(m) {
  return Math.round(m.getTimezoneOffset() / 15) * 15;
}
function IT(m) {
  var l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "",
    f = m > 0 ? "-" : "+",
    y = Math.abs(m),
    T = Math.floor(y / 60),
    I = y % 60;
  return f + Os(T, 2) + l + Os(I, 2);
}
var AT = function (l, f, y) {
    var T = l < 12 ? "AM" : "PM";
    return y ? T.toLocaleLowerCase() : T;
  },
  up = {
    Y: function (l) {
      var f = l.getFullYear();
      return f <= 9999 ? "".concat(f) : "+".concat(f);
    },
    YY: function (l) {
      return Os(l.getFullYear(), 4).substr(2);
    },
    YYYY: function (l) {
      return Os(l.getFullYear(), 4);
    },
    M: function (l) {
      return l.getMonth() + 1;
    },
    MM: function (l) {
      return Os(l.getMonth() + 1, 2);
    },
    MMM: function (l, f) {
      return f.monthsShort[l.getMonth()];
    },
    MMMM: function (l, f) {
      return f.months[l.getMonth()];
    },
    D: function (l) {
      return l.getDate();
    },
    DD: function (l) {
      return Os(l.getDate(), 2);
    },
    H: function (l) {
      return l.getHours();
    },
    HH: function (l) {
      return Os(l.getHours(), 2);
    },
    h: function (l) {
      var f = l.getHours();
      return f === 0 ? 12 : f > 12 ? f % 12 : f;
    },
    hh: function () {
      var l = up.h.apply(up, arguments);
      return Os(l, 2);
    },
    m: function (l) {
      return l.getMinutes();
    },
    mm: function (l) {
      return Os(l.getMinutes(), 2);
    },
    s: function (l) {
      return l.getSeconds();
    },
    ss: function (l) {
      return Os(l.getSeconds(), 2);
    },
    S: function (l) {
      return Math.floor(l.getMilliseconds() / 100);
    },
    SS: function (l) {
      return Os(Math.floor(l.getMilliseconds() / 10), 2);
    },
    SSS: function (l) {
      return Os(l.getMilliseconds(), 3);
    },
    d: function (l) {
      return l.getDay();
    },
    dd: function (l, f) {
      return f.weekdaysMin[l.getDay()];
    },
    ddd: function (l, f) {
      return f.weekdaysShort[l.getDay()];
    },
    dddd: function (l, f) {
      return f.weekdays[l.getDay()];
    },
    A: function (l, f) {
      var y = f.meridiem || AT;
      return y(l.getHours(), l.getMinutes(), !1);
    },
    a: function (l, f) {
      var y = f.meridiem || AT;
      return y(l.getHours(), l.getMinutes(), !0);
    },
    Z: function (l) {
      return IT(ET(l), ":");
    },
    ZZ: function (l) {
      return IT(ET(l));
    },
    X: function (l) {
      return Math.floor(l.getTime() / 1e3);
    },
    x: function (l) {
      return l.getTime();
    },
    w: function (l, f) {
      return rv(l, {
        firstDayOfWeek: f.firstDayOfWeek,
        firstWeekContainsDate: f.firstWeekContainsDate,
      });
    },
    ww: function (l, f) {
      return Os(up.w(l, f), 2);
    },
  };
function ov(m, l) {
  var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
    y = l ? String(l) : "YYYY-MM-DDTHH:mm:ss.SSSZ",
    T = n_(m);
  if (!gz(T)) return "Invalid Date";
  var I = f.locale || sv;
  return y.replace(_z, function (P, r) {
    return r || (typeof up[P] == "function" ? "".concat(up[P](T, I)) : P);
  });
}
function MT(m) {
  return vz(m) || xz(m) || yz();
}
function yz() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
function xz(m) {
  if (
    Symbol.iterator in Object(m) ||
    Object.prototype.toString.call(m) === "[object Arguments]"
  )
    return Array.from(m);
}
function vz(m) {
  if (Array.isArray(m)) {
    for (var l = 0, f = new Array(m.length); l < m.length; l++) f[l] = m[l];
    return f;
  }
}
function CT(m, l) {
  var f = Object.keys(m);
  if (Object.getOwnPropertySymbols) {
    var y = Object.getOwnPropertySymbols(m);
    (l &&
      (y = y.filter(function (T) {
        return Object.getOwnPropertyDescriptor(m, T).enumerable;
      })),
      f.push.apply(f, y));
  }
  return f;
}
function bz(m) {
  for (var l = 1; l < arguments.length; l++) {
    var f = arguments[l] != null ? arguments[l] : {};
    l % 2
      ? CT(f, !0).forEach(function (y) {
          Ql(m, y, f[y]);
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(m, Object.getOwnPropertyDescriptors(f))
        : CT(f).forEach(function (y) {
            Object.defineProperty(m, y, Object.getOwnPropertyDescriptor(f, y));
          });
  }
  return m;
}
function wz(m, l) {
  return Ez(m) || Sz(m, l) || Tz();
}
function Tz() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function Sz(m, l) {
  if (
    Symbol.iterator in Object(m) ||
    Object.prototype.toString.call(m) === "[object Arguments]"
  ) {
    var f = [],
      y = !0,
      T = !1,
      I = void 0;
    try {
      for (
        var P = m[Symbol.iterator](), r;
        !(y = (r = P.next()).done) && (f.push(r.value), !(l && f.length === l));
        y = !0
      );
    } catch (F) {
      ((T = !0), (I = F));
    } finally {
      try {
        !y && P.return != null && P.return();
      } finally {
        if (T) throw I;
      }
    }
    return f;
  }
}
function Ez(m) {
  if (Array.isArray(m)) return m;
}
function Ql(m, l, f) {
  return (
    l in m
      ? Object.defineProperty(m, l, {
          value: f,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (m[l] = f),
    m
  );
}
var Iz =
    /(\[[^\[]*\])|(MM?M?M?|Do|DD?|ddd?d?|w[o|w]?|YYYY|YY|a|A|hh?|HH?|mm?|ss?|S{1,3}|x|X|ZZ?|.)/g,
  L2 = /\d/,
  ec = /\d\d/,
  Az = /\d{3}/,
  Mz = /\d{4}/,
  ed = /\d\d?/,
  Cz = /[+-]\d\d:?\d\d/,
  O2 = /[+-]?\d+/,
  Pz = /[+-]?\d+(\.\d{1,3})?/,
  av = "year",
  r_ = "month",
  F2 = "day",
  B2 = "hour",
  N2 = "minute",
  V2 = "second",
  lv = "millisecond",
  U2 = {},
  Hn = function (l, f, y) {
    var T = Array.isArray(l) ? l : [l],
      I;
    (typeof y == "string"
      ? (I = function (r) {
          var F = parseInt(r, 10);
          return Ql({}, y, F);
        })
      : (I = y),
      T.forEach(function (P) {
        U2[P] = [f, I];
      }));
  },
  Dz = function (l) {
    return l.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
  },
  bp = function (l) {
    return function (f) {
      var y = f[l];
      if (!Array.isArray(y))
        throw new Error("Locale[".concat(l, "] need an array"));
      return new RegExp(y.map(Dz).join("|"));
    };
  },
  wp = function (l, f) {
    return function (y, T) {
      var I = T[l];
      if (!Array.isArray(I))
        throw new Error("Locale[".concat(l, "] need an array"));
      var P = I.indexOf(y);
      if (P < 0) throw new Error("Invalid Word");
      return Ql({}, f, P);
    };
  };
Hn("Y", O2, av);
Hn("YY", ec, function (m) {
  var l = new Date().getFullYear(),
    f = Math.floor(l / 100),
    y = parseInt(m, 10);
  return ((y = (y > 68 ? f - 1 : f) * 100 + y), Ql({}, av, y));
});
Hn("YYYY", Mz, av);
Hn("M", ed, function (m) {
  return Ql({}, r_, parseInt(m, 10) - 1);
});
Hn("MM", ec, function (m) {
  return Ql({}, r_, parseInt(m, 10) - 1);
});
Hn("MMM", bp("monthsShort"), wp("monthsShort", r_));
Hn("MMMM", bp("months"), wp("months", r_));
Hn("D", ed, F2);
Hn("DD", ec, F2);
Hn(["H", "h"], ed, B2);
Hn(["HH", "hh"], ec, B2);
Hn("m", ed, N2);
Hn("mm", ec, N2);
Hn("s", ed, V2);
Hn("ss", ec, V2);
Hn("S", L2, function (m) {
  return Ql({}, lv, parseInt(m, 10) * 100);
});
Hn("SS", ec, function (m) {
  return Ql({}, lv, parseInt(m, 10) * 10);
});
Hn("SSS", Az, lv);
function Rz(m) {
  return m.meridiemParse || /[ap]\.?m?\.?/i;
}
function zz(m) {
  return "".concat(m).toLowerCase().charAt(0) === "p";
}
Hn(["A", "a"], Rz, function (m, l) {
  var f = typeof l.isPM == "function" ? l.isPM(m) : zz(m);
  return { isPM: f };
});
function kz(m) {
  var l = m.match(/([+-]|\d\d)/g) || ["-", "0", "0"],
    f = wz(l, 3),
    y = f[0],
    T = f[1],
    I = f[2],
    P = parseInt(T, 10) * 60 + parseInt(I, 10);
  return P === 0 ? 0 : y === "+" ? -P : +P;
}
Hn(["Z", "ZZ"], Cz, function (m) {
  return { offset: kz(m) };
});
Hn("x", O2, function (m) {
  return { date: new Date(parseInt(m, 10)) };
});
Hn("X", Pz, function (m) {
  return { date: new Date(parseFloat(m) * 1e3) };
});
Hn("d", L2, "weekday");
Hn("dd", bp("weekdaysMin"), wp("weekdaysMin", "weekday"));
Hn("ddd", bp("weekdaysShort"), wp("weekdaysShort", "weekday"));
Hn("dddd", bp("weekdays"), wp("weekdays", "weekday"));
Hn("w", ed, "week");
Hn("ww", ec, "week");
function Lz(m, l) {
  if (m !== void 0 && l !== void 0) {
    if (l) {
      if (m < 12) return m + 12;
    } else if (m === 12) return 0;
  }
  return m;
}
function Oz(m) {
  for (
    var l =
        arguments.length > 1 && arguments[1] !== void 0
          ? arguments[1]
          : new Date(),
      f = [0, 0, 1, 0, 0, 0, 0],
      y = [
        l.getFullYear(),
        l.getMonth(),
        l.getDate(),
        l.getHours(),
        l.getMinutes(),
        l.getSeconds(),
        l.getMilliseconds(),
      ],
      T = !0,
      I = 0;
    I < 7;
    I++
  )
    m[I] === void 0 ? (f[I] = T ? y[I] : f[I]) : ((f[I] = m[I]), (T = !1));
  return f;
}
function Fz(m, l, f, y, T, I, P) {
  var r;
  return (
    m < 100 && m >= 0
      ? ((r = new Date(m + 400, l, f, y, T, I, P)),
        isFinite(r.getFullYear()) && r.setFullYear(m))
      : (r = new Date(m, l, f, y, T, I, P)),
    r
  );
}
function Bz() {
  for (var m, l = arguments.length, f = new Array(l), y = 0; y < l; y++)
    f[y] = arguments[y];
  var T = f[0];
  return (
    T < 100 && T >= 0
      ? ((f[0] += 400),
        (m = new Date(Date.UTC.apply(Date, f))),
        isFinite(m.getUTCFullYear()) && m.setUTCFullYear(T))
      : (m = new Date(Date.UTC.apply(Date, f))),
    m
  );
}
function Nz(m, l, f) {
  var y = l.match(Iz);
  if (!y) throw new Error();
  for (var T = y.length, I = {}, P = 0; P < T; P += 1) {
    var r = y[P],
      F = U2[r];
    if (F) {
      var q = typeof F[0] == "function" ? F[0](f) : F[0],
        ne = F[1],
        fe = (q.exec(m) || [])[0],
        de = ne(fe, f);
      ((I = bz({}, I, {}, de)), (m = m.replace(fe, "")));
    } else {
      var B = r.replace(/^\[|\]$/g, "");
      if (m.indexOf(B) === 0) m = m.substr(B.length);
      else throw new Error("not match");
    }
  }
  return I;
}
function Vz(m, l) {
  var f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  try {
    var y = f.locale,
      T = y === void 0 ? sv : y,
      I = f.backupDate,
      P = I === void 0 ? new Date() : I,
      r = Nz(m, l, T),
      F = r.year,
      B = r.month,
      q = r.day,
      ne = r.hour,
      fe = r.minute,
      de = r.second,
      Ie = r.millisecond,
      xe = r.isPM,
      we = r.date,
      Ae = r.offset,
      Qe = r.weekday,
      gt = r.week;
    if (we) return we;
    var Rt = [F, B, q, ne, fe, de, Ie];
    if (
      ((Rt[3] = Lz(Rt[3], xe)), gt !== void 0 && B === void 0 && q === void 0)
    ) {
      var Mt = k2(F === void 0 ? P : new Date(F, 3), {
        firstDayOfWeek: T.firstDayOfWeek,
        firstWeekContainsDate: T.firstWeekContainsDate,
      });
      return new Date(Mt.getTime() + (gt - 1) * 7 * 24 * 3600 * 1e3);
    }
    var pt,
      Re = Oz(Rt, P);
    return (
      Ae !== void 0
        ? ((Re[6] += Ae * 60 * 1e3), (pt = Bz.apply(void 0, MT(Re))))
        : (pt = Fz.apply(void 0, MT(Re))),
      Qe !== void 0 && pt.getDay() !== Qe ? new Date(NaN) : pt
    );
  } catch {
    return new Date(NaN);
  }
}
var Uz = Object.defineProperty,
  jz = Object.defineProperties,
  Gz = Object.getOwnPropertyDescriptors,
  Yg = Object.getOwnPropertySymbols,
  j2 = Object.prototype.hasOwnProperty,
  G2 = Object.prototype.propertyIsEnumerable,
  PT = (m, l, f) =>
    l in m
      ? Uz(m, l, { enumerable: !0, configurable: !0, writable: !0, value: f })
      : (m[l] = f),
  Br = (m, l) => {
    for (var f in l || (l = {})) j2.call(l, f) && PT(m, f, l[f]);
    if (Yg) for (var f of Yg(l)) G2.call(l, f) && PT(m, f, l[f]);
    return m;
  },
  Js = (m, l) => jz(m, Gz(l)),
  $z = (m, l) => {
    var f = {};
    for (var y in m) j2.call(m, y) && l.indexOf(y) < 0 && (f[y] = m[y]);
    if (m != null && Yg)
      for (var y of Yg(m)) l.indexOf(y) < 0 && G2.call(m, y) && (f[y] = m[y]);
    return f;
  };
const Hz = {
  formatLocale: sv,
  yearFormat: "YYYY",
  monthFormat: "MMM",
  monthBeforeYear: !0,
};
let np = "en";
const qu = {};
qu[np] = Hz;
function $2(m, l, f = !1) {
  if (typeof m != "string") return qu[np];
  let y = np;
  return (
    qu[m] && (y = m),
    l && ((qu[m] = l), (y = m)),
    f || (np = y),
    qu[m] || qu[np]
  );
}
function Ox(m) {
  return $2(m, void 0, !0);
}
function cv(m, l) {
  if (!Array.isArray(m)) return [];
  const f = [],
    y = m.length;
  let T = 0;
  for (l = l || y; T < y; ) f.push(m.slice(T, (T += l)));
  return f;
}
function DT(m) {
  return Array.isArray(m) ? m[m.length - 1] : void 0;
}
function Zl(m) {
  return Object.prototype.toString.call(m) === "[object Object]";
}
function Ga(m, l) {
  const f = {};
  return (
    Zl(m) &&
      (Array.isArray(l) || (l = [l]),
      l.forEach((y) => {
        Object.prototype.hasOwnProperty.call(m, y) && (f[y] = m[y]);
      })),
    f
  );
}
function H2(m, l) {
  if (!Zl(m)) return {};
  let f = m;
  return (
    Zl(l) &&
      Object.keys(l).forEach((y) => {
        let T = l[y];
        const I = m[y];
        (Zl(T) && Zl(I) && (T = H2(I, T)), (f = Js(Br({}, f), { [y]: T })));
      }),
    f
  );
}
function vx(m) {
  const l = parseInt(String(m), 10);
  return l < 10 ? `0${l}` : `${l}`;
}
function Wz(m) {
  const l = /-(\w)/g;
  return m.replace(l, (f, y) => (y ? y.toUpperCase() : ""));
}
const W2 = "datepicker_locale",
  q2 = "datepicker_prefixClass",
  Z2 = "datepicker_getWeek";
function hv() {
  return Nx(W2, Fx(Ox()));
}
function qz(m) {
  const l = us(() => (Zl(m.value) ? H2(Ox(), m.value) : Ox(m.value)));
  return (Vx(W2, l), l);
}
function Zz(m) {
  Vx(q2, m);
}
function ds() {
  return Nx(q2, "mx");
}
function Xz(m) {
  Vx(Z2, m);
}
function Yz() {
  return Nx(Z2, rv);
}
function Kz(m) {
  const l = m.style.display,
    f = m.style.visibility;
  ((m.style.display = "block"), (m.style.visibility = "hidden"));
  const y = window.getComputedStyle(m),
    T =
      m.offsetWidth + parseInt(y.marginLeft, 10) + parseInt(y.marginRight, 10),
    I =
      m.offsetHeight + parseInt(y.marginTop, 10) + parseInt(y.marginBottom, 10);
  return (
    (m.style.display = l),
    (m.style.visibility = f),
    { width: T, height: I }
  );
}
function Jz(m, l, f, y) {
  let T = 0,
    I = 0,
    P = 0,
    r = 0;
  const F = m.getBoundingClientRect(),
    B = document.documentElement.clientWidth,
    q = document.documentElement.clientHeight;
  return (
    y && ((P = window.pageXOffset + F.left), (r = window.pageYOffset + F.top)),
    B - F.left < l && F.right < l
      ? (T = P - F.left + 1)
      : F.left + F.width / 2 <= B / 2
        ? (T = P)
        : (T = P + F.width - l),
    F.top <= f && q - F.bottom <= f
      ? (I = r + q - F.top - f)
      : F.top + F.height / 2 <= q / 2
        ? (I = r + F.height)
        : (I = r - f),
    { left: `${T}px`, top: `${I}px` }
  );
}
function uv(m, l = document.body) {
  if (!m || m === l) return null;
  const f = (I, P) => getComputedStyle(I, null).getPropertyValue(P);
  return /(auto|scroll)/.test(
    f(m, "overflow") + f(m, "overflow-y") + f(m, "overflow-x"),
  )
    ? m
    : uv(m.parentElement, l);
}
let kg;
function Qz() {
  if (typeof window > "u") return 0;
  if (kg !== void 0) return kg;
  const m = document.createElement("div");
  ((m.style.visibility = "hidden"),
    (m.style.overflow = "scroll"),
    (m.style.width = "100px"),
    (m.style.position = "absolute"),
    (m.style.top = "-9999px"),
    document.body.appendChild(m));
  const l = document.createElement("div");
  return (
    (l.style.width = "100%"),
    m.appendChild(l),
    (kg = m.offsetWidth - l.offsetWidth),
    m.parentNode.removeChild(m),
    kg
  );
}
const RT = "ontouchend" in document ? "touchstart" : "mousedown";
function ek(m) {
  let l = !1;
  return function (...y) {
    l ||
      ((l = !0),
      requestAnimationFrame(() => {
        ((l = !1), m.apply(this, y));
      }));
  };
}
function Wa(m, l) {
  return { setup: m, name: m.name, props: l };
}
function qa(m, l) {
  return new Proxy(m, {
    get(y, T) {
      const I = y[T];
      return I !== void 0 ? I : l[T];
    },
  });
}
const tc = () => (m) => m,
  tk = (m, l) => {
    const f = {};
    for (const y in m)
      if (Object.prototype.hasOwnProperty.call(m, y)) {
        const T = Wz(y);
        let I = m[y];
        (l.indexOf(T) !== -1 && I === "" && (I = !0), (f[T] = I));
      }
    return f;
  };
function ik(m, { slots: l }) {
  const f = qa(m, { appendToBody: !0 }),
    y = ds(),
    T = $n(null),
    I = $n({ left: "", top: "" }),
    P = () => {
      if (!f.visible || !T.value) return;
      const F = f.getRelativeElement();
      if (!F) return;
      const { width: B, height: q } = Kz(T.value);
      I.value = Jz(F, B, q, f.appendToBody);
    };
  (Xs(P, { flush: "post" }),
    Xs(
      (F) => {
        const B = f.getRelativeElement();
        if (!B) return;
        const q = uv(B) || window,
          ne = ek(P);
        (q.addEventListener("scroll", ne),
          window.addEventListener("resize", ne),
          F(() => {
            (q.removeEventListener("scroll", ne),
              window.removeEventListener("resize", ne));
          }));
      },
      { flush: "post" },
    ));
  const r = (F) => {
    if (!f.visible) return;
    const B = F.target,
      q = T.value,
      ne = f.getRelativeElement();
    q && !q.contains(B) && ne && !ne.contains(B) && f.onClickOutside(F);
  };
  return (
    Xs((F) => {
      (document.addEventListener(RT, r),
        F(() => {
          document.removeEventListener(RT, r);
        }));
    }),
    () =>
      Lt(
        AA,
        { to: "body", disabled: !f.appendToBody },
        {
          default: () => [
            Lt(
              MA,
              { name: `${y}-zoom-in-down` },
              {
                default: () => {
                  var F;
                  return [
                    f.visible &&
                      Lt(
                        "div",
                        {
                          ref: T,
                          class: `${y}-datepicker-main ${y}-datepicker-popup ${f.className}`,
                          style: [
                            Br({ position: "absolute" }, I.value),
                            f.style || {},
                          ],
                        },
                        [(F = l.default) == null ? void 0 : F.call(l)],
                      ),
                  ];
                },
              },
            ),
          ],
        },
      )
  );
}
const nk = tc()([
  "style",
  "className",
  "visible",
  "appendToBody",
  "onClickOutside",
  "getRelativeElement",
]);
var rk = Wa(ik, nk);
const sk = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    width: "1em",
    height: "1em",
  },
  ok = ci(
    "path",
    {
      d: "M940.218 107.055H730.764v-60.51H665.6v60.51H363.055v-60.51H297.89v60.51H83.78c-18.617 0-32.581 13.963-32.581 32.581v805.237c0 18.618 13.964 32.582 32.582 32.582h861.09c18.619 0 32.583-13.964 32.583-32.582V139.636c-4.655-18.618-18.619-32.581-37.237-32.581zm-642.327 65.163v60.51h65.164v-60.51h307.2v60.51h65.163v-60.51h176.873v204.8H116.364v-204.8H297.89zM116.364 912.291V442.18H912.29v470.11H116.364z",
    },
    null,
    -1,
  ),
  ak = [ok];
function X2(m, l) {
  return (Xi(), pn("svg", sk, ak));
}
const lk = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    width: "1em",
    height: "1em",
  },
  ck = ci(
    "path",
    {
      d: "M810.005 274.005 572.011 512l237.994 237.995-60.01 60.01L512 572.011 274.005 810.005l-60.01-60.01L451.989 512 213.995 274.005l60.01-60.01L512 451.989l237.995-237.994z",
    },
    null,
    -1,
  ),
  hk = [ck];
function uk(m, l) {
  return (Xi(), pn("svg", lk, hk));
}
const dk = {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: "1em",
    height: "1em",
  },
  fk = ci("path", { d: "M0 0h24v24H0z", fill: "none" }, null, -1),
  pk = ci(
    "path",
    {
      d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z",
    },
    null,
    -1,
  ),
  mk = ci("path", { d: "M12.5 7H11v6l5.25 3.15.75-1.23-4.5-2.67z" }, null, -1),
  gk = [fk, pk, mk];
function _k(m, l) {
  return (Xi(), pn("svg", dk, gk));
}
function yh(m, l = 0, f = 1, y = 0, T = 0, I = 0, P = 0) {
  const r = new Date(m, l, f, y, T, I, P);
  return (m < 100 && m >= 0 && r.setFullYear(m), r);
}
function Ha(m) {
  return m instanceof Date && !isNaN(m.getTime());
}
function xh(m) {
  return Array.isArray(m) && m.length === 2 && m.every(Ha) && m[0] <= m[1];
}
function yk(m) {
  return Array.isArray(m) && m.every(Ha);
}
function s_(...m) {
  if (m[0] !== void 0 && m[0] !== null) {
    const f = new Date(m[0]);
    if (Ha(f)) return f;
  }
  const l = m.slice(1);
  return l.length ? s_(...l) : new Date();
}
function xk(m) {
  const l = new Date(m);
  return (l.setMonth(0, 1), l.setHours(0, 0, 0, 0), l);
}
function zT(m) {
  const l = new Date(m);
  return (l.setDate(1), l.setHours(0, 0, 0, 0), l);
}
function Jl(m) {
  const l = new Date(m);
  return (l.setHours(0, 0, 0, 0), l);
}
function vk({ firstDayOfWeek: m, year: l, month: f }) {
  const y = [],
    T = yh(l, f, 0),
    I = T.getDate(),
    P = I - ((T.getDay() + 7 - m) % 7);
  for (let q = P; q <= I; q++) y.push(yh(l, f, q - I));
  T.setMonth(f + 1, 0);
  const r = T.getDate();
  for (let q = 1; q <= r; q++) y.push(yh(l, f, q));
  const F = I - P + 1,
    B = 6 * 7 - F - r;
  for (let q = 1; q <= B; q++) y.push(yh(l, f, r + q));
  return y;
}
function Kg(m, l) {
  const f = new Date(m),
    y = typeof l == "function" ? l(f.getMonth()) : Number(l),
    T = f.getFullYear(),
    I = yh(T, y + 1, 0).getDate(),
    P = f.getDate();
  return (f.setMonth(y, Math.min(P, I)), f);
}
function Zu(m, l) {
  const f = new Date(m),
    y = typeof l == "function" ? l(f.getFullYear()) : l;
  return (f.setFullYear(y), f);
}
function bk(m, l) {
  const f = new Date(l),
    y = new Date(m),
    T = f.getFullYear() - y.getFullYear(),
    I = f.getMonth() - y.getMonth();
  return T * 12 + I;
}
function Jg(m, l) {
  const f = new Date(m),
    y = new Date(l);
  return (f.setHours(y.getHours(), y.getMinutes(), y.getSeconds()), f);
}
function wk(m, { slots: l }) {
  const f = qa(m, {
      editable: !0,
      disabled: !1,
      clearable: !0,
      range: !1,
      multiple: !1,
    }),
    y = ds(),
    T = $n(null),
    I = us(() => f.separator || (f.range ? " ~ " : ",")),
    P = (de) => (f.range ? xh(de) : f.multiple ? yk(de) : Ha(de)),
    r = (de) =>
      Array.isArray(de)
        ? de.some((Ie) => f.disabledDate(Ie))
        : f.disabledDate(de),
    F = us(() =>
      T.value !== null
        ? T.value
        : typeof f.renderInputText == "function"
          ? f.renderInputText(f.value)
          : P(f.value)
            ? Array.isArray(f.value)
              ? f.value.map((de) => f.formatDate(de)).join(I.value)
              : f.formatDate(f.value)
            : "",
    ),
    B = (de) => {
      var Ie;
      (de && de.stopPropagation(),
        f.onChange(f.range ? [null, null] : null),
        (Ie = f.onClear) == null || Ie.call(f));
    },
    q = () => {
      var de;
      if (!f.editable || T.value === null) return;
      const Ie = T.value.trim();
      if (((T.value = null), Ie === "")) {
        B();
        return;
      }
      let xe;
      if (f.range) {
        let we = Ie.split(I.value);
        (we.length !== 2 && (we = Ie.split(I.value.trim())),
          (xe = we.map((Ae) => f.parseDate(Ae.trim()))));
      } else
        f.multiple
          ? (xe = Ie.split(I.value).map((we) => f.parseDate(we.trim())))
          : (xe = f.parseDate(Ie));
      P(xe) && !r(xe)
        ? f.onChange(xe)
        : (de = f.onInputError) == null || de.call(f, Ie);
    },
    ne = (de) => {
      T.value = typeof de == "string" ? de : de.target.value;
    },
    fe = (de) => {
      const { keyCode: Ie } = de;
      Ie === 9 ? f.onBlur() : Ie === 13 && q();
    };
  return () => {
    var de, Ie, xe;
    const we = !f.disabled && f.clearable && F.value,
      Ae = Js(
        Br(
          {
            name: "date",
            type: "text",
            autocomplete: "off",
            value: F.value,
            class: f.inputClass || `${y}-input`,
            readonly: !f.editable,
            disabled: f.disabled,
            placeholder: f.placeholder,
          },
          f.inputAttr,
        ),
        { onFocus: f.onFocus, onKeydown: fe, onInput: ne, onChange: q },
      );
    return Lt("div", { class: `${y}-input-wrapper`, onClick: f.onClick }, [
      ((de = l.input) == null ? void 0 : de.call(l, Ae)) ||
        Lt("input", Ae, null),
      we
        ? Lt("i", { class: `${y}-icon-clear`, onClick: B }, [
            ((Ie = l["icon-clear"]) == null ? void 0 : Ie.call(l)) ||
              Lt(uk, null, null),
          ])
        : null,
      Lt("i", { class: `${y}-icon-calendar` }, [
        ((xe = l["icon-calendar"]) == null ? void 0 : xe.call(l)) ||
          Lt(X2, null, null),
      ]),
    ]);
  };
}
const dv = tc()([
    "placeholder",
    "editable",
    "disabled",
    "clearable",
    "inputClass",
    "inputAttr",
    "range",
    "multiple",
    "separator",
    "renderInputText",
    "onInputError",
    "onClear",
  ]),
  Tk = tc()([
    "value",
    "formatDate",
    "parseDate",
    "disabledDate",
    "onChange",
    "onFocus",
    "onBlur",
    "onClick",
    ...dv,
  ]);
var Sk = Wa(wk, Tk);
function Ek(m, { slots: l }) {
  var f;
  const y = qa(m, {
    prefixClass: "mx",
    valueType: "date",
    format: "YYYY-MM-DD",
    type: "date",
    disabledDate: () => !1,
    disabledTime: () => !1,
    confirmText: "OK",
  });
  (Zz(y.prefixClass),
    Xz(((f = y.formatter) == null ? void 0 : f.getWeek) || rv));
  const T = qz(EA(m, "lang")),
    I = $n(),
    P = () => I.value,
    r = $n(!1),
    F = us(
      () => !y.disabled && (typeof y.open == "boolean" ? y.open : r.value),
    ),
    B = () => {
      var pt, Re;
      y.disabled ||
        F.value ||
        ((r.value = !0),
        (pt = y["onUpdate:open"]) == null || pt.call(y, !0),
        (Re = y.onOpen) == null || Re.call(y));
    },
    q = () => {
      var pt, Re;
      F.value &&
        ((r.value = !1),
        (pt = y["onUpdate:open"]) == null || pt.call(y, !1),
        (Re = y.onClose) == null || Re.call(y));
    },
    ne = (pt, Re) => (
      (Re = Re || y.format),
      Zl(y.formatter) && typeof y.formatter.stringify == "function"
        ? y.formatter.stringify(pt, Re)
        : ov(pt, Re, { locale: T.value.formatLocale })
    ),
    fe = (pt, Re) => {
      if (
        ((Re = Re || y.format),
        Zl(y.formatter) && typeof y.formatter.parse == "function")
      )
        return y.formatter.parse(pt, Re);
      const rt = new Date();
      return Vz(pt, Re, { locale: T.value.formatLocale, backupDate: rt });
    },
    de = (pt) => {
      switch (y.valueType) {
        case "date":
          return pt instanceof Date ? new Date(pt.getTime()) : new Date(NaN);
        case "timestamp":
          return typeof pt == "number" ? new Date(pt) : new Date(NaN);
        case "format":
          return typeof pt == "string" ? fe(pt) : new Date(NaN);
        default:
          return typeof pt == "string" ? fe(pt, y.valueType) : new Date(NaN);
      }
    },
    Ie = (pt) => {
      if (!Ha(pt)) return null;
      switch (y.valueType) {
        case "date":
          return pt;
        case "timestamp":
          return pt.getTime();
        case "format":
          return ne(pt);
        default:
          return ne(pt, y.valueType);
      }
    },
    xe = us(() => {
      const pt = y.value;
      return y.range
        ? (Array.isArray(pt) ? pt.slice(0, 2) : [null, null]).map(de)
        : y.multiple
          ? (Array.isArray(pt) ? pt : []).map(de)
          : de(pt);
    }),
    we = (pt, Re, rt = !0) => {
      var Ot, _i;
      const qt = Array.isArray(pt) ? pt.map(Ie) : Ie(pt);
      return (
        (Ot = y["onUpdate:value"]) == null || Ot.call(y, qt),
        (_i = y.onChange) == null || _i.call(y, qt, Re),
        rt && q(),
        qt
      );
    },
    Ae = $n(new Date());
  Xs(() => {
    F.value && (Ae.value = xe.value);
  });
  const Qe = (pt, Re) => {
      y.confirm
        ? (Ae.value = pt)
        : we(pt, Re, !y.multiple && (Re === y.type || Re === "time"));
    },
    gt = () => {
      var pt;
      const Re = we(Ae.value);
      (pt = y.onConfirm) == null || pt.call(y, Re);
    },
    Rt = (pt) => y.disabledDate(pt) || y.disabledTime(pt),
    Mt = (pt) => {
      var Re;
      const { prefixClass: rt } = y;
      return Lt("div", { class: `${rt}-datepicker-sidebar` }, [
        (Re = l.sidebar) == null ? void 0 : Re.call(l, pt),
        (y.shortcuts || []).map((Ot, _i) =>
          Lt(
            "button",
            {
              key: _i,
              "data-index": _i,
              type: "button",
              class: `${rt}-btn ${rt}-btn-text ${rt}-btn-shortcut`,
              onClick: () => {
                var qt;
                const pi = (qt = Ot.onClick) == null ? void 0 : qt.call(Ot);
                pi && we(pi);
              },
            },
            [Ot.text],
          ),
        ),
      ]);
    };
  return () => {
    var pt, Re;
    const {
        prefixClass: rt,
        disabled: Ot,
        confirm: _i,
        range: qt,
        popupClass: pi,
        popupStyle: Ri,
        appendToBody: wi,
      } = y,
      ei = { value: Ae.value, "onUpdate:value": Qe, emit: we },
      Ii =
        l.header &&
        Lt("div", { class: `${rt}-datepicker-header` }, [l.header(ei)]),
      Ln =
        (l.footer || _i) &&
        Lt("div", { class: `${rt}-datepicker-footer` }, [
          (pt = l.footer) == null ? void 0 : pt.call(l, ei),
          _i &&
            Lt(
              "button",
              {
                type: "button",
                class: `${rt}-btn ${rt}-datepicker-btn-confirm`,
                onClick: gt,
              },
              [y.confirmText],
            ),
        ]),
      ir = (Re = l.content) == null ? void 0 : Re.call(l, ei),
      or = (l.sidebar || y.shortcuts) && Mt(ei);
    return Lt(
      "div",
      {
        ref: I,
        class: {
          [`${rt}-datepicker`]: !0,
          [`${rt}-datepicker-range`]: qt,
          disabled: Ot,
        },
      },
      [
        Lt(
          Sk,
          Js(Br({}, Ga(y, dv)), {
            value: xe.value,
            formatDate: ne,
            parseDate: fe,
            disabledDate: Rt,
            onChange: we,
            onClick: B,
            onFocus: B,
            onBlur: q,
          }),
          Ga(l, ["icon-calendar", "icon-clear", "input"]),
        ),
        Lt(
          rk,
          {
            className: pi,
            style: Ri,
            visible: F.value,
            appendToBody: wi,
            getRelativeElement: P,
            onClickOutside: q,
          },
          {
            default: () => [
              or,
              Lt("div", { class: `${rt}-datepicker-content` }, [Ii, ir, Ln]),
            ],
          },
        ),
      ],
    );
  };
}
const Ik = tc()([
    "value",
    "valueType",
    "type",
    "format",
    "formatter",
    "lang",
    "prefixClass",
    "appendToBody",
    "open",
    "popupClass",
    "popupStyle",
    "confirm",
    "confirmText",
    "shortcuts",
    "disabledDate",
    "disabledTime",
    "onOpen",
    "onClose",
    "onConfirm",
    "onChange",
    "onUpdate:open",
    "onUpdate:value",
  ]),
  Ak = [...Ik, ...dv];
var kT = Wa(Ek, Ak);
function Lg(m) {
  var l = m,
    { value: f } = l,
    y = $z(l, ["value"]);
  const T = ds();
  return Lt(
    "button",
    Js(Br({}, y), {
      type: "button",
      class: `${T}-btn ${T}-btn-text ${T}-btn-icon-${f}`,
    }),
    [Lt("i", { class: `${T}-icon-${f}` }, null)],
  );
}
function fv({ type: m, calendar: l, onUpdateCalendar: f }, { slots: y }) {
  var T;
  const I = ds(),
    P = () => {
      f(Kg(l, (fe) => fe - 1));
    },
    r = () => {
      f(Kg(l, (fe) => fe + 1));
    },
    F = () => {
      f(Zu(l, (fe) => fe - 1));
    },
    B = () => {
      f(Zu(l, (fe) => fe + 1));
    },
    q = () => {
      f(Zu(l, (fe) => fe - 10));
    },
    ne = () => {
      f(Zu(l, (fe) => fe + 10));
    };
  return Lt("div", { class: `${I}-calendar-header` }, [
    Lt(Lg, { value: "double-left", onClick: m === "year" ? q : F }, null),
    m === "date" && Lt(Lg, { value: "left", onClick: P }, null),
    Lt(Lg, { value: "double-right", onClick: m === "year" ? ne : B }, null),
    m === "date" && Lt(Lg, { value: "right", onClick: r }, null),
    Lt("span", { class: `${I}-calendar-header-label` }, [
      (T = y.default) == null ? void 0 : T.call(y),
    ]),
  ]);
}
function Mk({
  calendar: m,
  isWeekMode: l,
  showWeekNumber: f,
  titleFormat: y,
  getWeekActive: T,
  getCellClasses: I,
  onSelect: P,
  onUpdatePanel: r,
  onUpdateCalendar: F,
  onDateMouseEnter: B,
  onDateMouseLeave: q,
}) {
  const ne = ds(),
    fe = Yz(),
    de = hv().value,
    {
      yearFormat: Ie,
      monthBeforeYear: xe,
      monthFormat: we = "MMM",
      formatLocale: Ae,
    } = de,
    Qe = Ae.firstDayOfWeek || 0;
  let gt = de.days || Ae.weekdaysMin;
  gt = gt.concat(gt).slice(Qe, Qe + 7);
  const Rt = m.getFullYear(),
    Mt = m.getMonth(),
    pt = cv(vk({ firstDayOfWeek: Qe, year: Rt, month: Mt }), 7),
    Re = (ei, Ii) => ov(ei, Ii, { locale: de.formatLocale }),
    rt = (ei) => {
      r(ei);
    },
    Ot = (ei) => {
      const Ii = ei.getAttribute("data-index"),
        [Ln, ir] = Ii.split(",").map((Vi) => parseInt(Vi, 10)),
        or = pt[Ln][ir];
      return new Date(or);
    },
    _i = (ei) => {
      P(Ot(ei.currentTarget));
    },
    qt = (ei) => {
      B && B(Ot(ei.currentTarget));
    },
    pi = (ei) => {
      q && q(Ot(ei.currentTarget));
    },
    Ri = Lt(
      "button",
      {
        type: "button",
        class: `${ne}-btn ${ne}-btn-text ${ne}-btn-current-year`,
        onClick: () => rt("year"),
      },
      [Re(m, Ie)],
    ),
    wi = Lt(
      "button",
      {
        type: "button",
        class: `${ne}-btn ${ne}-btn-text ${ne}-btn-current-month`,
        onClick: () => rt("month"),
      },
      [Re(m, we)],
    );
  return (
    (f = typeof f == "boolean" ? f : l),
    Lt(
      "div",
      {
        class: [
          `${ne}-calendar ${ne}-calendar-panel-date`,
          { [`${ne}-calendar-week-mode`]: l },
        ],
      },
      [
        Lt(
          fv,
          { type: "date", calendar: m, onUpdateCalendar: F },
          { default: () => [xe ? [wi, Ri] : [Ri, wi]] },
        ),
        Lt("div", { class: `${ne}-calendar-content` }, [
          Lt("table", { class: `${ne}-table ${ne}-table-date` }, [
            Lt("thead", null, [
              Lt("tr", null, [
                f && Lt("th", { class: `${ne}-week-number-header` }, null),
                gt.map((ei) => Lt("th", { key: ei }, [ei])),
              ]),
            ]),
            Lt("tbody", null, [
              pt.map((ei, Ii) =>
                Lt(
                  "tr",
                  {
                    key: Ii,
                    class: [`${ne}-date-row`, { [`${ne}-active-week`]: T(ei) }],
                  },
                  [
                    f &&
                      Lt(
                        "td",
                        {
                          class: `${ne}-week-number`,
                          "data-index": `${Ii},0`,
                          onClick: _i,
                        },
                        [Lt("div", null, [fe(ei[0])])],
                      ),
                    ei.map((Ln, ir) =>
                      Lt(
                        "td",
                        {
                          key: ir,
                          class: ["cell", I(Ln)],
                          title: Re(Ln, y),
                          "data-index": `${Ii},${ir}`,
                          onClick: _i,
                          onMouseenter: qt,
                          onMouseleave: pi,
                        },
                        [Lt("div", null, [Ln.getDate()])],
                      ),
                    ),
                  ],
                ),
              ),
            ]),
          ]),
        ]),
      ],
    )
  );
}
function Ck({
  calendar: m,
  getCellClasses: l,
  onSelect: f,
  onUpdateCalendar: y,
  onUpdatePanel: T,
}) {
  const I = ds(),
    P = hv().value,
    r = P.months || P.formatLocale.monthsShort,
    F = (q) => yh(m.getFullYear(), q),
    B = (q) => {
      const fe = q.currentTarget.getAttribute("data-month");
      f(F(parseInt(fe, 10)));
    };
  return Lt("div", { class: `${I}-calendar ${I}-calendar-panel-month` }, [
    Lt(
      fv,
      { type: "month", calendar: m, onUpdateCalendar: y },
      {
        default: () => [
          Lt(
            "button",
            {
              type: "button",
              class: `${I}-btn ${I}-btn-text ${I}-btn-current-year`,
              onClick: () => T("year"),
            },
            [m.getFullYear()],
          ),
        ],
      },
    ),
    Lt("div", { class: `${I}-calendar-content` }, [
      Lt("table", { class: `${I}-table ${I}-table-month` }, [
        cv(r, 3).map((q, ne) =>
          Lt("tr", { key: ne }, [
            q.map((fe, de) => {
              const Ie = ne * 3 + de;
              return Lt(
                "td",
                {
                  key: de,
                  class: ["cell", l(F(Ie))],
                  "data-month": Ie,
                  onClick: B,
                },
                [Lt("div", null, [fe])],
              );
            }),
          ]),
        ),
      ]),
    ]),
  ]);
}
const Pk = (m) => {
  const l = Math.floor(m.getFullYear() / 10) * 10,
    f = [];
  for (let y = 0; y < 10; y++) f.push(l + y);
  return cv(f, 2);
};
function Dk({
  calendar: m,
  getCellClasses: l = () => [],
  getYearPanel: f = Pk,
  onSelect: y,
  onUpdateCalendar: T,
}) {
  const I = ds(),
    P = (ne) => yh(ne, 0),
    r = (ne) => {
      const de = ne.currentTarget.getAttribute("data-year");
      y(P(parseInt(de, 10)));
    },
    F = f(new Date(m)),
    B = F[0][0],
    q = DT(DT(F));
  return Lt("div", { class: `${I}-calendar ${I}-calendar-panel-year` }, [
    Lt(
      fv,
      { type: "year", calendar: m, onUpdateCalendar: T },
      {
        default: () => [
          Lt("span", null, [B]),
          Lt("span", { class: `${I}-calendar-decade-separator` }, null),
          Lt("span", null, [q]),
        ],
      },
    ),
    Lt("div", { class: `${I}-calendar-content` }, [
      Lt("table", { class: `${I}-table ${I}-table-year` }, [
        F.map((ne, fe) =>
          Lt("tr", { key: fe }, [
            ne.map((de, Ie) =>
              Lt(
                "td",
                {
                  key: Ie,
                  class: ["cell", l(P(de))],
                  "data-year": de,
                  onClick: r,
                },
                [Lt("div", null, [de])],
              ),
            ),
          ]),
        ),
      ]),
    ]),
  ]);
}
function Rk(m) {
  const l = qa(m, {
      defaultValue: Jl(new Date()),
      type: "date",
      disabledDate: () => !1,
      getClasses: () => [],
      titleFormat: "YYYY-MM-DD",
    }),
    f = us(() =>
      (Array.isArray(l.value) ? l.value : [l.value])
        .filter(Ha)
        .map((Qe) =>
          l.type === "year" ? xk(Qe) : l.type === "month" ? zT(Qe) : Jl(Qe),
        ),
    ),
    y = $n(new Date());
  Xs(() => {
    let Ae = l.calendar;
    if (!Ha(Ae)) {
      const { length: Qe } = f.value;
      Ae = s_(Qe > 0 ? f.value[Qe - 1] : l.defaultValue);
    }
    y.value = zT(Ae);
  });
  const T = (Ae) => {
      var Qe;
      ((y.value = Ae), (Qe = l.onCalendarChange) == null || Qe.call(l, Ae));
    },
    I = $n("date");
  Xs(() => {
    const Ae = ["date", "month", "year"],
      Qe = Math.max(Ae.indexOf(l.type), Ae.indexOf(l.defaultPanel));
    I.value = Qe !== -1 ? Ae[Qe] : "date";
  });
  const P = (Ae) => {
      var Qe;
      const gt = I.value;
      ((I.value = Ae), (Qe = l.onPanelChange) == null || Qe.call(l, Ae, gt));
    },
    r = (Ae) => l.disabledDate(new Date(Ae), f.value),
    F = (Ae, Qe) => {
      var gt, Rt, Mt;
      if (!r(Ae))
        if (((gt = l.onPick) == null || gt.call(l, Ae), l.multiple === !0)) {
          const pt = f.value.filter((Re) => Re.getTime() !== Ae.getTime());
          (pt.length === f.value.length && pt.push(Ae),
            (Rt = l["onUpdate:value"]) == null || Rt.call(l, pt, Qe));
        } else (Mt = l["onUpdate:value"]) == null || Mt.call(l, Ae, Qe);
    },
    B = (Ae) => {
      F(Ae, l.type === "week" ? "week" : "date");
    },
    q = (Ae) => {
      if (l.type === "year") F(Ae, "year");
      else if ((T(Ae), P("month"), l.partialUpdate && f.value.length === 1)) {
        const Qe = Zu(f.value[0], Ae.getFullYear());
        F(Qe, "year");
      }
    },
    ne = (Ae) => {
      if (l.type === "month") F(Ae, "month");
      else if ((T(Ae), P("date"), l.partialUpdate && f.value.length === 1)) {
        const Qe = Kg(Zu(f.value[0], Ae.getFullYear()), Ae.getMonth());
        F(Qe, "month");
      }
    },
    fe = (Ae, Qe = []) => (
      r(Ae)
        ? Qe.push("disabled")
        : f.value.some((gt) => gt.getTime() === Ae.getTime()) &&
          Qe.push("active"),
      Qe.concat(l.getClasses(Ae, f.value, Qe.join(" ")))
    ),
    de = (Ae) => {
      const Qe = Ae.getMonth() !== y.value.getMonth(),
        gt = [];
      return (
        Ae.getTime() === new Date().setHours(0, 0, 0, 0) && gt.push("today"),
        Qe && gt.push("not-current-month"),
        fe(Ae, gt)
      );
    },
    Ie = (Ae) =>
      l.type !== "month"
        ? y.value.getMonth() === Ae.getMonth()
          ? "active"
          : ""
        : fe(Ae),
    xe = (Ae) =>
      l.type !== "year"
        ? y.value.getFullYear() === Ae.getFullYear()
          ? "active"
          : ""
        : fe(Ae),
    we = (Ae) => {
      if (l.type !== "week") return !1;
      const Qe = Ae[0].getTime(),
        gt = Ae[6].getTime();
      return f.value.some((Rt) => {
        const Mt = Rt.getTime();
        return Mt >= Qe && Mt <= gt;
      });
    };
  return () =>
    I.value === "year"
      ? Lt(
          Dk,
          {
            calendar: y.value,
            getCellClasses: xe,
            getYearPanel: l.getYearPanel,
            onSelect: q,
            onUpdateCalendar: T,
          },
          null,
        )
      : I.value === "month"
        ? Lt(
            Ck,
            {
              calendar: y.value,
              getCellClasses: Ie,
              onSelect: ne,
              onUpdatePanel: P,
              onUpdateCalendar: T,
            },
            null,
          )
        : Lt(
            Mk,
            {
              isWeekMode: l.type === "week",
              showWeekNumber: l.showWeekNumber,
              titleFormat: l.titleFormat,
              calendar: y.value,
              getCellClasses: de,
              getWeekActive: we,
              onSelect: B,
              onUpdatePanel: P,
              onUpdateCalendar: T,
              onDateMouseEnter: l.onDateMouseEnter,
              onDateMouseLeave: l.onDateMouseLeave,
            },
            null,
          );
}
const o_ = tc()([
  "type",
  "value",
  "defaultValue",
  "defaultPanel",
  "disabledDate",
  "getClasses",
  "calendar",
  "multiple",
  "partialUpdate",
  "showWeekNumber",
  "titleFormat",
  "getYearPanel",
  "onDateMouseEnter",
  "onDateMouseLeave",
  "onCalendarChange",
  "onPanelChange",
  "onUpdate:value",
  "onPick",
]);
var a_ = Wa(Rk, o_);
const LT = (m, l) => {
  const f = m.getTime();
  let [y, T] = l.map((I) => I.getTime());
  return (y > T && ([y, T] = [T, y]), f > y && f < T);
};
function zk(m) {
  const l = qa(m, { defaultValue: new Date(), type: "date" }),
    f = ds(),
    y = us(() => {
      let we = Array.isArray(l.defaultValue)
        ? l.defaultValue
        : [l.defaultValue, l.defaultValue];
      return (
        (we = we.map((Ae) => Jl(Ae))),
        xh(we) ? we : [new Date(), new Date()].map((Ae) => Jl(Ae))
      );
    }),
    T = $n([new Date(NaN), new Date(NaN)]);
  Xs(() => {
    xh(l.value) && (T.value = l.value);
  });
  const I = (we, Ae) => {
      var Qe;
      const [gt, Rt] = T.value;
      Ha(gt) && !Ha(Rt)
        ? (gt.getTime() > we.getTime()
            ? (T.value = [we, gt])
            : (T.value = [gt, we]),
          (Qe = l["onUpdate:value"]) == null || Qe.call(l, T.value, Ae))
        : (T.value = [we, new Date(NaN)]);
    },
    P = $n([new Date(), new Date()]),
    r = us(() => (xh(l.calendar) ? l.calendar : P.value)),
    F = us(() =>
      l.type === "year" ? 10 * 12 : l.type === "month" ? 1 * 12 : 1,
    ),
    B = (we, Ae) => {
      var Qe;
      const gt = bk(we[0], we[1]),
        Rt = F.value - gt;
      if (Rt > 0) {
        const Mt = Ae === 1 ? 0 : 1;
        we[Mt] = Kg(we[Mt], (pt) => pt + (Mt === 0 ? -Rt : Rt));
      }
      ((P.value = we), (Qe = l.onCalendarChange) == null || Qe.call(l, we, Ae));
    },
    q = (we) => {
      B([we, r.value[1]], 0);
    },
    ne = (we) => {
      B([r.value[0], we], 1);
    };
  Xs(() => {
    const we = xh(l.value) ? l.value : y.value;
    B(we.slice(0, 2));
  });
  const fe = $n(null),
    de = (we) => (fe.value = we),
    Ie = () => (fe.value = null),
    xe = (we, Ae, Qe) => {
      const gt = l.getClasses ? l.getClasses(we, Ae, Qe) : [],
        Rt = Array.isArray(gt) ? gt : [gt];
      return /disabled|active/.test(Qe)
        ? Rt
        : (Ae.length === 2 && LT(we, Ae) && Rt.push("in-range"),
          Ae.length === 1 && fe.value && LT(we, [Ae[0], fe.value])
            ? Rt.concat("hover-in-range")
            : Rt);
    };
  return () => {
    const we = r.value.map((Ae, Qe) => {
      const gt = Js(Br({}, l), {
        calendar: Ae,
        value: T.value,
        defaultValue: y.value[Qe],
        getClasses: xe,
        partialUpdate: !1,
        multiple: !1,
        "onUpdate:value": I,
        onCalendarChange: Qe === 0 ? q : ne,
        onDateMouseLeave: Ie,
        onDateMouseEnter: de,
      });
      return Lt(a_, gt, null);
    });
    return Lt("div", { class: `${f}-calendar-range` }, [we]);
  };
}
const pv = o_;
var mv = Wa(zk, pv);
const Y2 = aa({
  setup(m, { slots: l }) {
    const f = ds(),
      y = $n(),
      T = $n(""),
      I = $n("");
    bh(() => {
      if (!y.value) return;
      const Ie = y.value,
        xe = (Ie.clientHeight * 100) / Ie.scrollHeight;
      T.value = xe < 100 ? `${xe}%` : "";
    });
    const r = Qz(),
      F = (Ie) => {
        const xe = Ie.currentTarget,
          { scrollHeight: we, scrollTop: Ae } = xe;
        I.value = `${(Ae * 100) / we}%`;
      };
    let B = !1,
      q = 0;
    const ne = (Ie) => {
        Ie.stopImmediatePropagation();
        const xe = Ie.currentTarget,
          { offsetTop: we } = xe;
        ((B = !0), (q = Ie.clientY - we));
      },
      fe = (Ie) => {
        if (!B || !y.value) return;
        const { clientY: xe } = Ie,
          { scrollHeight: we, clientHeight: Ae } = y.value,
          gt = ((xe - q) * we) / Ae;
        y.value.scrollTop = gt;
      },
      de = () => {
        B = !1;
      };
    return (
      bh(() => {
        (document.addEventListener("mousemove", fe),
          document.addEventListener("mouseup", de));
      }),
      BT(() => {
        (document.addEventListener("mousemove", fe),
          document.addEventListener("mouseup", de));
      }),
      () => {
        var Ie;
        return Lt(
          "div",
          {
            class: `${f}-scrollbar`,
            style: { position: "relative", overflow: "hidden" },
          },
          [
            Lt(
              "div",
              {
                ref: y,
                class: `${f}-scrollbar-wrap`,
                style: { marginRight: `-${r}px` },
                onScroll: F,
              },
              [(Ie = l.default) == null ? void 0 : Ie.call(l)],
            ),
            Lt("div", { class: `${f}-scrollbar-track` }, [
              Lt(
                "div",
                {
                  class: `${f}-scrollbar-thumb`,
                  style: { height: T.value, top: I.value },
                  onMousedown: ne,
                },
                null,
              ),
            ]),
          ],
        );
      }
    );
  },
});
function kk({ options: m, getClasses: l, onSelect: f }) {
  const y = ds(),
    T = (I) => {
      const P = I.target,
        r = I.currentTarget;
      if (P.tagName.toUpperCase() !== "LI") return;
      const F = r.getAttribute("data-type"),
        B = parseInt(r.getAttribute("data-index"), 10),
        q = parseInt(P.getAttribute("data-index"), 10),
        ne = m[B].list[q].value;
      f(ne, F);
    };
  return Lt("div", { class: `${y}-time-columns` }, [
    m.map((I, P) =>
      Lt(
        Y2,
        { key: I.type, class: `${y}-time-column` },
        {
          default: () => [
            Lt(
              "ul",
              {
                class: `${y}-time-list`,
                "data-index": P,
                "data-type": I.type,
                onClick: T,
              },
              [
                I.list.map((r, F) =>
                  Lt(
                    "li",
                    {
                      key: r.text,
                      "data-index": F,
                      class: [`${y}-time-item`, l(r.value, I.type)],
                    },
                    [r.text],
                  ),
                ),
              ],
            ),
          ],
        },
      ),
    ),
  ]);
}
function Lk(m) {
  return (
    typeof m == "function" ||
    (Object.prototype.toString.call(m) === "[object Object]" && !IA(m))
  );
}
function Ok(m) {
  let l;
  const f = ds();
  return Lt(
    Y2,
    null,
    Lk(
      (l = m.options.map((y) =>
        Lt(
          "div",
          {
            key: y.text,
            class: [`${f}-time-option`, m.getClasses(y.value, "time")],
            onClick: () => m.onSelect(y.value, "time"),
          },
          [y.text],
        ),
      )),
    )
      ? l
      : { default: () => [l] },
  );
}
function bx({ length: m, step: l = 1, options: f }) {
  if (Array.isArray(f)) return f.filter((T) => T >= 0 && T < m);
  l <= 0 && (l = 1);
  const y = [];
  for (let T = 0; T < m; T += l) y.push(T);
  return y;
}
function Fk(m, l) {
  let { showHour: f, showMinute: y, showSecond: T, use12h: I } = l;
  const P = l.format || "HH:mm:ss";
  ((f = typeof f == "boolean" ? f : /[HhKk]/.test(P)),
    (y = typeof y == "boolean" ? y : /m/.test(P)),
    (T = typeof T == "boolean" ? T : /s/.test(P)),
    (I = typeof I == "boolean" ? I : /a/i.test(P)));
  const r = [],
    F = I && m.getHours() >= 12;
  return (
    f &&
      r.push({
        type: "hour",
        list: bx({
          length: I ? 12 : 24,
          step: l.hourStep,
          options: l.hourOptions,
        }).map((B) => {
          const q = B === 0 && I ? "12" : vx(B),
            ne = new Date(m);
          return (ne.setHours(F ? B + 12 : B), { value: ne, text: q });
        }),
      }),
    y &&
      r.push({
        type: "minute",
        list: bx({
          length: 60,
          step: l.minuteStep,
          options: l.minuteOptions,
        }).map((B) => {
          const q = new Date(m);
          return (q.setMinutes(B), { value: q, text: vx(B) });
        }),
      }),
    T &&
      r.push({
        type: "second",
        list: bx({
          length: 60,
          step: l.secondStep,
          options: l.secondOptions,
        }).map((B) => {
          const q = new Date(m);
          return (q.setSeconds(B), { value: q, text: vx(B) });
        }),
      }),
    I &&
      r.push({
        type: "ampm",
        list: ["AM", "PM"].map((B, q) => {
          const ne = new Date(m);
          return (
            ne.setHours((ne.getHours() % 12) + q * 12),
            { text: B, value: ne }
          );
        }),
      }),
    r
  );
}
function wx(m = "") {
  const l = m.split(":");
  if (l.length >= 2) {
    const f = parseInt(l[0], 10),
      y = parseInt(l[1], 10);
    return { hours: f, minutes: y };
  }
  return null;
}
function Bk({ date: m, option: l, format: f, formatDate: y }) {
  const T = [];
  if (typeof l == "function") return l() || [];
  const I = wx(l.start),
    P = wx(l.end),
    r = wx(l.step),
    F = l.format || f;
  if (I && P && r) {
    const B = I.minutes + I.hours * 60,
      q = P.minutes + P.hours * 60,
      ne = r.minutes + r.hours * 60,
      fe = Math.floor((q - B) / ne);
    for (let de = 0; de <= fe; de++) {
      const Ie = B + de * ne,
        xe = Math.floor(Ie / 60),
        we = Ie % 60,
        Ae = new Date(m);
      (Ae.setHours(xe, we, 0), T.push({ value: Ae, text: y(Ae, F) }));
    }
  }
  return T;
}
const K2 = (m, l, f = 0) => {
  if (f <= 0) {
    requestAnimationFrame(() => {
      m.scrollTop = l;
    });
    return;
  }
  const T = ((l - m.scrollTop) / f) * 10;
  requestAnimationFrame(() => {
    const I = m.scrollTop + T;
    if (I >= l) {
      m.scrollTop = l;
      return;
    }
    ((m.scrollTop = I), K2(m, l, f - 10));
  });
};
function Nk(m) {
  const l = qa(m, {
      defaultValue: Jl(new Date()),
      format: "HH:mm:ss",
      timeTitleFormat: "YYYY-MM-DD",
      disabledTime: () => !1,
      scrollDuration: 100,
    }),
    f = ds(),
    y = hv(),
    T = (xe, we) => ov(xe, we, { locale: y.value.formatLocale }),
    I = $n(new Date());
  Xs(() => {
    I.value = s_(l.value, l.defaultValue);
  });
  const P = (xe) =>
      Array.isArray(xe)
        ? xe.every((we) => l.disabledTime(new Date(we)))
        : l.disabledTime(new Date(xe)),
    r = (xe) => {
      const we = new Date(xe);
      return P([
        we.getTime(),
        we.setMinutes(0, 0, 0),
        we.setMinutes(59, 59, 999),
      ]);
    },
    F = (xe) => {
      const we = new Date(xe);
      return P([we.getTime(), we.setSeconds(0, 0), we.setSeconds(59, 999)]);
    },
    B = (xe) => {
      const we = new Date(xe),
        Ae = we.getHours() < 12 ? 0 : 12,
        Qe = Ae + 11;
      return P([
        we.getTime(),
        we.setHours(Ae, 0, 0, 0),
        we.setHours(Qe, 59, 59, 999),
      ]);
    },
    q = (xe, we) =>
      we === "hour"
        ? r(xe)
        : we === "minute"
          ? F(xe)
          : we === "ampm"
            ? B(xe)
            : P(xe),
    ne = (xe, we) => {
      var Ae;
      if (!q(xe, we)) {
        const Qe = new Date(xe);
        ((I.value = Qe),
          P(Qe) || (Ae = l["onUpdate:value"]) == null || Ae.call(l, Qe, we));
      }
    },
    fe = (xe, we) =>
      q(xe, we)
        ? "disabled"
        : xe.getTime() === I.value.getTime()
          ? "active"
          : "",
    de = $n(),
    Ie = (xe) => {
      if (!de.value) return;
      const we = de.value.querySelectorAll(".active");
      for (let Ae = 0; Ae < we.length; Ae++) {
        const Qe = we[Ae],
          gt = uv(Qe, de.value);
        if (gt) {
          const Rt = Qe.offsetTop;
          K2(gt, Rt, xe);
        }
      }
    };
  return (
    bh(() => Ie(0)),
    Yl(I, () => Ie(l.scrollDuration), { flush: "post" }),
    () => {
      let xe;
      return (
        l.timePickerOptions
          ? (xe = Lt(
              Ok,
              {
                onSelect: ne,
                getClasses: fe,
                options: Bk({
                  date: I.value,
                  format: l.format,
                  option: l.timePickerOptions,
                  formatDate: T,
                }),
              },
              null,
            ))
          : (xe = Lt(
              kk,
              { options: Fk(I.value, l), onSelect: ne, getClasses: fe },
              null,
            )),
        Lt("div", { class: `${f}-time`, ref: de }, [
          l.showTimeHeader &&
            Lt("div", { class: `${f}-time-header` }, [
              Lt(
                "button",
                {
                  type: "button",
                  class: `${f}-btn ${f}-btn-text ${f}-time-header-title`,
                  onClick: l.onClickTitle,
                },
                [T(I.value, l.timeTitleFormat)],
              ),
            ]),
          Lt("div", { class: `${f}-time-content` }, [xe]),
        ])
      );
    }
  );
}
const l_ = tc()([
  "value",
  "defaultValue",
  "format",
  "timeTitleFormat",
  "showTimeHeader",
  "disabledTime",
  "timePickerOptions",
  "hourOptions",
  "minuteOptions",
  "secondOptions",
  "hourStep",
  "minuteStep",
  "secondStep",
  "showHour",
  "showMinute",
  "showSecond",
  "use12h",
  "scrollDuration",
  "onClickTitle",
  "onUpdate:value",
]);
var xp = Wa(Nk, l_);
function Vk(m) {
  const l = qa(m, { defaultValue: Jl(new Date()), disabledTime: () => !1 }),
    f = ds(),
    y = $n([new Date(NaN), new Date(NaN)]);
  Xs(() => {
    xh(l.value)
      ? (y.value = l.value)
      : (y.value = [new Date(NaN), new Date(NaN)]);
  });
  const T = (B, q) => {
      var ne;
      (ne = l["onUpdate:value"]) == null ||
        ne.call(l, y.value, B === "time" ? "time-range" : B, q);
    },
    I = (B, q) => {
      ((y.value[0] = B),
        y.value[1].getTime() >= B.getTime() || (y.value[1] = B),
        T(q, 0));
    },
    P = (B, q) => {
      ((y.value[1] = B),
        y.value[0].getTime() <= B.getTime() || (y.value[0] = B),
        T(q, 1));
    },
    r = (B) => l.disabledTime(B, 0),
    F = (B) => B.getTime() < y.value[0].getTime() || l.disabledTime(B, 1);
  return () => {
    const B = Array.isArray(l.defaultValue)
      ? l.defaultValue
      : [l.defaultValue, l.defaultValue];
    return Lt("div", { class: `${f}-time-range` }, [
      Lt(
        xp,
        Js(Br({}, l), {
          "onUpdate:value": I,
          value: y.value[0],
          defaultValue: B[0],
          disabledTime: r,
        }),
        null,
      ),
      Lt(
        xp,
        Js(Br({}, l), {
          "onUpdate:value": P,
          value: y.value[1],
          defaultValue: B[1],
          disabledTime: F,
        }),
        null,
      ),
    ]);
  };
}
const gv = l_;
var _v = Wa(Vk, gv);
function J2(m) {
  const l = $n(!1),
    f = () => {
      var I;
      ((l.value = !1), (I = m.onShowTimePanelChange) == null || I.call(m, !1));
    },
    y = () => {
      var I;
      ((l.value = !0), (I = m.onShowTimePanelChange) == null || I.call(m, !0));
    };
  return {
    timeVisible: us(() =>
      typeof m.showTimePanel == "boolean" ? m.showTimePanel : l.value,
    ),
    openTimePanel: y,
    closeTimePanel: f,
  };
}
function Uk(m) {
  const l = qa(m, { disabledTime: () => !1, defaultValue: Jl(new Date()) }),
    f = $n(l.value);
  Xs(() => {
    f.value = l.value;
  });
  const { openTimePanel: y, closeTimePanel: T, timeVisible: I } = J2(l),
    P = (r, F) => {
      var B;
      F === "date" && y();
      let q = Jg(r, s_(l.value, l.defaultValue));
      if (
        l.disabledTime(new Date(q)) &&
        ((q = Jg(r, l.defaultValue)), l.disabledTime(new Date(q)))
      ) {
        f.value = q;
        return;
      }
      (B = l["onUpdate:value"]) == null || B.call(l, q, F);
    };
  return () => {
    const r = ds(),
      F = Js(Br({}, Ga(l, o_)), {
        multiple: !1,
        type: "date",
        value: f.value,
        "onUpdate:value": P,
      }),
      B = Js(Br({}, Ga(l, l_)), {
        showTimeHeader: !0,
        value: f.value,
        "onUpdate:value": l["onUpdate:value"],
        onClickTitle: T,
      });
    return Lt("div", { class: `${r}-date-time` }, [
      Lt(a_, F, null),
      I.value && Lt(xp, B, null),
    ]);
  };
}
const Q2 = tc()(["showTimePanel", "onShowTimePanelChange"]),
  jk = [...Q2, ...o_, ...l_];
var eS = Wa(Uk, jk);
function Gk(m) {
  const l = qa(m, { defaultValue: Jl(new Date()), disabledTime: () => !1 }),
    f = $n(l.value);
  Xs(() => {
    f.value = l.value;
  });
  const { openTimePanel: y, closeTimePanel: T, timeVisible: I } = J2(l),
    P = (r, F) => {
      var B;
      F === "date" && y();
      const q = Array.isArray(l.defaultValue)
        ? l.defaultValue
        : [l.defaultValue, l.defaultValue];
      let ne = r.map((fe, de) => {
        const Ie = xh(l.value) ? l.value[de] : q[de];
        return Jg(fe, Ie);
      });
      if (
        (ne[1].getTime() < ne[0].getTime() && (ne = [ne[0], ne[0]]),
        ne.some(l.disabledTime) &&
          ((ne = r.map((fe, de) => Jg(fe, q[de]))), ne.some(l.disabledTime)))
      ) {
        f.value = ne;
        return;
      }
      (B = l["onUpdate:value"]) == null || B.call(l, ne, F);
    };
  return () => {
    const r = ds(),
      F = Js(Br({}, Ga(l, pv)), {
        type: "date",
        value: f.value,
        "onUpdate:value": P,
      }),
      B = Js(Br({}, Ga(l, gv)), {
        showTimeHeader: !0,
        value: f.value,
        "onUpdate:value": l["onUpdate:value"],
        onClickTitle: T,
      });
    return Lt("div", { class: `${r}-date-time-range` }, [
      Lt(mv, F, null),
      I.value && Lt(_v, B, null),
    ]);
  };
}
const $k = [...Q2, ...gv, ...pv];
var tS = Wa(Gk, $k);
const Hk = tc()([
    "range",
    "open",
    "appendToBody",
    "clearable",
    "confirm",
    "disabled",
    "editable",
    "multiple",
    "partialUpdate",
    "showHour",
    "showMinute",
    "showSecond",
    "showTimeHeader",
    "showTimePanel",
    "showWeekNumber",
    "use12h",
  ]),
  OT = {
    date: "YYYY-MM-DD",
    datetime: "YYYY-MM-DD HH:mm:ss",
    year: "YYYY",
    month: "YYYY-MM",
    time: "HH:mm:ss",
    week: "w",
  };
function iS(m, { slots: l }) {
  const f = m.type || "date",
    y = m.format || OT[f] || OT.date,
    T = Js(Br({}, tk(m, Hk)), { type: f, format: y });
  return Lt(
    kT,
    Ga(T, kT.props),
    Br(
      {
        content: (I) => {
          if (T.range) {
            const P = f === "time" ? _v : f === "datetime" ? tS : mv;
            return dp(P, Ga(Br(Br({}, T), I), P.props));
          } else {
            const P = f === "time" ? xp : f === "datetime" ? eS : a_;
            return dp(P, Ga(Br(Br({}, T), I), P.props));
          }
        },
        "icon-calendar": () =>
          f === "time" ? Lt(_k, null, null) : Lt(X2, null, null),
      },
      l,
    ),
  );
}
const Wk = {
  locale: $2,
  install: (m) => {
    m.component("DatePicker", iS);
  },
};
var qk = Object.assign(iS, Wk, {
  Calendar: a_,
  CalendarRange: mv,
  TimePanel: xp,
  TimeRange: _v,
  DateTime: eS,
  DateTimeRange: tS,
});
const Zk = ["src"],
  Xk = {
    key: 1,
    src: "https://placehold.co/30x30/cccccc/666666?text=",
    alt: "Map icon placeholder",
  },
  Yk = { class: "basemap-window-content" },
  Kk = { class: "font-semibold mb-2" },
  Jk = ["value"],
  Qk = { key: 0 },
  eL = ["value"],
  tL = { key: 1 },
  iL = "2020_01",
  nL = aa({
    __name: "BasemapSelector",
    props: {
      hasRulerControl: Boolean,
      mapboxStyle: String,
      planetApiKey: String,
    },
    emits: ["basemapSelected"],
    setup(m, { emit: l }) {
      const f = m,
        y = l,
        T = us(() => (f.hasRulerControl ? "187px" : "147px")),
        I = $n(!1),
        P = $n({ id: "custom", style: f.mapboxStyle }),
        r = () => {
          I.value = !I.value;
        },
        F = us(() => {
          const de = new Date();
          de.getDate() <= 15
            ? de.setMonth(de.getMonth() - 2)
            : de.setMonth(de.getMonth() - 1);
          const Ie = de.getFullYear(),
            xe = de.getMonth() + 1,
            we = xe < 10 ? `0${xe}` : xe;
          return `${Ie}_${we}`;
        }),
        B = $n(F.value),
        q = (de) => {
          const Ie = de.getFullYear(),
            xe = de.getMonth() + 1,
            we = `${Ie}_${xe < 10 ? "0" + xe : xe}`;
          return we < iL || we > F.value;
        };
      (Yl(P, (de, Ie) => {
        de.id === "planet" && de !== Ie && (B.value = F.value);
      }),
        Yl(B, (de, Ie) => {
          P.value.id === "planet" && ne();
        }));
      const ne = () => {
          P.value.id === "planet" && ((P.value.monthYear = B.value), fe());
        },
        fe = () => {
          y("basemapSelected", P.value);
        };
      return (de, Ie) => {
        const xe = UT;
        return (
          Xi(),
          pn("div", null, [
            ci(
              "div",
              {
                class: ra(["basemap-toggle rounded shadow", { active: sr(I) }]),
                style: sa({ top: sr(T) }),
                onClick: r,
              },
              [
                Lt(
                  xe,
                  {
                    src: "/map.svg",
                    alt: "Map Icon",
                    preset: "icon",
                    loading: "eager",
                    custom: !0,
                  },
                  {
                    default: mh(({ src: we, isLoaded: Ae, imgAttrs: Qe }) => [
                      Ae
                        ? (Xi(),
                          pn(
                            "img",
                            Ws({ key: 0 }, Qe, { src: we }),
                            null,
                            16,
                            Zk,
                          ))
                        : (Xi(), pn("img", Xk)),
                    ]),
                    _: 1,
                  },
                ),
              ],
              6,
            ),
            sr(I)
              ? (Xi(),
                pn(
                  "div",
                  {
                    key: 0,
                    class: "basemap-window rounded shadow",
                    style: sa({ top: sr(T) }),
                  },
                  [
                    ci("div", Yk, [
                      ci("h3", Kk, An(de.$t("selectBasemap")), 1),
                      ci("label", null, [
                        Kf(
                          ci(
                            "input",
                            {
                              "onUpdate:modelValue":
                                Ie[0] ||
                                (Ie[0] = (we) =>
                                  Wu(P) ? (P.value = we) : null),
                              type: "radio",
                              value: { id: "custom", style: m.mapboxStyle },
                              name: "basemap",
                              onChange: fe,
                            },
                            null,
                            40,
                            Jk,
                          ),
                          [[xg, sr(P)]],
                        ),
                        na(" " + An(de.$t("yourMapboxStyleDefault")), 1),
                      ]),
                      ci("label", null, [
                        Kf(
                          ci(
                            "input",
                            {
                              "onUpdate:modelValue":
                                Ie[1] ||
                                (Ie[1] = (we) =>
                                  Wu(P) ? (P.value = we) : null),
                              type: "radio",
                              value: {
                                id: "satellite-streets",
                                style:
                                  "mapbox://styles/mapbox/satellite-streets-v12",
                              },
                              name: "basemap",
                              onChange: fe,
                            },
                            null,
                            544,
                          ),
                          [[xg, sr(P)]],
                        ),
                        na(" " + An(de.$t("mapboxSatelliteUpTo2019")), 1),
                      ]),
                      ci("label", null, [
                        Kf(
                          ci(
                            "input",
                            {
                              "onUpdate:modelValue":
                                Ie[2] ||
                                (Ie[2] = (we) =>
                                  Wu(P) ? (P.value = we) : null),
                              type: "radio",
                              value: {
                                id: "streets",
                                style: "mapbox://styles/mapbox/streets-v12",
                              },
                              name: "basemap",
                              onChange: fe,
                            },
                            null,
                            544,
                          ),
                          [[xg, sr(P)]],
                        ),
                        na(" " + An(de.$t("mapboxStreets")), 1),
                      ]),
                      m.planetApiKey
                        ? (Xi(),
                          pn("label", Qk, [
                            Kf(
                              ci(
                                "input",
                                {
                                  "onUpdate:modelValue":
                                    Ie[3] ||
                                    (Ie[3] = (we) =>
                                      Wu(P) ? (P.value = we) : null),
                                  type: "radio",
                                  value: { id: "planet", monthYear: sr(B) },
                                  name: "basemap",
                                  onChange: fe,
                                },
                                null,
                                40,
                                eL,
                              ),
                              [[xg, sr(P)]],
                            ),
                            Ie[5] ||
                              (Ie[5] = na(
                                " PlanetScope Monthly Select Basemaps ",
                              )),
                          ]))
                        : Fr("", !0),
                      sr(P).id === "planet"
                        ? (Xi(),
                          pn("label", tL, [
                            Lt(
                              sr(qk),
                              {
                                value: sr(B),
                                "onUpdate:value":
                                  Ie[4] ||
                                  (Ie[4] = (we) =>
                                    Wu(B) ? (B.value = we) : null),
                                format: "YYYY_MM",
                                "value-type": "YYYY_MM",
                                type: "month",
                                "default-value": sr(F),
                                "disabled-date": q,
                                clearable: !1,
                                onSelected: ne,
                              },
                              null,
                              8,
                              ["value", "default-value"],
                            ),
                          ]))
                        : Fr("", !0),
                    ]),
                  ],
                  4,
                ))
              : Fr("", !0),
          ])
        );
      };
    },
  }),
  fL = Bx(nL, [["__scopeId", "data-v-3fc23d02"]]);
export { fL as B, dL as M, uL as V, cL as m };
